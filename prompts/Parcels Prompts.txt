===============================================================================================================
My Next js front project structure:
===============================================================================================================
App Folder :
-----------------------------------------------------------------------
--++--> app/[locale]/(protected)/dashboard/page.tsx
--++--> app/[locale]/(protected)/profile/page.tsx
--++--> app/[locale]/(protected)/roles/page.tsx
-----------------------------------------------------------------------
--++--> app/[locale]/(protected)/users/page.tsx =======>
-----------------------------------------------------------------------
"use client";
import React from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Icon } from "@/components/ui/icon";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Badge } from "@/components/ui/badge";
import { Link } from "@/i18n/routing";
import UsersTable from "@/components/users/users-table";
import { useAuthStore } from "@/lib/stores/auth/auth.store";
import { ProtectedRoute } from "@/components/route/protected-route";
import { USER_PERMISSIONS } from "@/lib/constants/auth";
const UsersPageContent = () => {
  const { hasPermission, user, hasAnyPermission } = useAuthStore();

  // Check individual permissions
  const canViewUsers = hasPermission(USER_PERMISSIONS.READ_USERS);
  const canCreateUsers = hasPermission(USER_PERMISSIONS.CREATE_USER);
  const canUpdateUsers = hasPermission(USER_PERMISSIONS.UPDATE_USER);
  const canDeleteUsers = hasPermission(USER_PERMISSIONS.DELETE_USER);
  const canManageRoles = hasPermission(USER_PERMISSIONS.MANAGE_USER_ROLES);
  const canViewAnalytics = hasPermission(USER_PERMISSIONS.READ_USER_ANALYTICS);

  // Check if user has any user management permissions
  const hasAnyUserPermissions = hasAnyPermission([
    USER_PERMISSIONS.READ_USERS,
    USER_PERMISSIONS.CREATE_USER,
    USER_PERMISSIONS.UPDATE_USER,
    USER_PERMISSIONS.DELETE_USER,
    USER_PERMISSIONS.MANAGE_USER_ROLES,
    USER_PERMISSIONS.READ_USER_ANALYTICS,
  ]);

  // Define permission-based features
  const availableFeatures = [
    {
      id: "view",
      label: "View Users",
      enabled: canViewUsers,
      icon: "heroicons:eye",
      description: "Browse and search users",
    },
    {
      id: "create",
      label: "Create Users",
      enabled: canCreateUsers,
      icon: "heroicons:plus",
      description: "Add new users to the system",
    },
    {
      id: "update",
      label: "Edit Users",
      enabled: canUpdateUsers,
      icon: "heroicons:pencil",
      description: "Modify user information",
    },
    {
      id: "delete",
      label: "Delete Users",
      enabled: canDeleteUsers,
      icon: "heroicons:trash",
      description: "Remove users from the system",
    },
    {
      id: "roles",
      label: "Manage Roles",
      enabled: canManageRoles,
      icon: "heroicons:shield-check",
      description: "Assign and modify user roles",
    },
    {
      id: "analytics",
      label: "View Analytics",
      enabled: canViewAnalytics,
      icon: "heroicons:chart-bar",
      description: "Access user analytics and reports",
    },
  ];

  const enabledFeatures = availableFeatures.filter(
    (feature) => feature.enabled
  );
  const disabledFeatures = availableFeatures.filter(
    (feature) => !feature.enabled
  );

  // Show error if user has no permissions at all
  if (!hasAnyUserPermissions) {
    return (
      <div className="space-y-6">
        <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
          <div>
            <h1 className="text-2xl font-bold text-default-900">
              Users Management
            </h1>
            <p className="text-default-600">
              Manage your users, roles, and permissions
            </p>
          </div>
        </div>

        <Alert color="destructive">
          <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
          <AlertDescription>
            <div className="space-y-2">
              <div className="font-medium">Access Denied</div>
              <div>
                You don't have permission to access user management features.
                Please contact your administrator to request access.
              </div>
              <div className="text-sm">
                <strong>Your user type:</strong> {user?.userType || "Unknown"}
              </div>
            </div>
          </AlertDescription>
        </Alert>

        {/* Contact Support Card */}
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Icon icon="heroicons:question-mark-circle" className="w-5 h-5" />
              Need Access?
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <p className="text-sm text-muted-foreground">
              If you believe you should have access to user management features,
              please contact your system administrator or support team.
            </p>
            <div className="flex gap-2">
              <Button variant="outline" size="md">
                <Icon
                  icon="heroicons:chat-bubble-left-right"
                  className="w-4 h-4 mr-2"
                />
                Contact Support
              </Button>
              <Link href="/dashboard">
                <Button variant="outline" size="md">
                  <Icon icon="heroicons:home" className="w-4 h-4 mr-2" />
                  Return to Dashboard
                </Button>
              </Link>
            </div>
          </CardContent>
        </Card>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
        <div>
          <h1 className="text-2xl font-bold text-default-900">
            Users Management
          </h1>
          <p className="text-default-600">
            Manage your users, roles, and permissions
          </p>
        </div>

        <div className="flex items-center gap-2">
          {canViewAnalytics && (
            <Link href="/users/analytics">
              <Button variant="outline" size="md">
                <Icon icon="heroicons:chart-bar" className="w-4 h-4 mr-2" />
                Analytics
              </Button>
            </Link>
          )}

          {canCreateUsers && (
            <Link href="/users/create">
              <Button>
                <Icon icon="heroicons:plus" className="w-4 h-4 mr-2" />
                Create User
              </Button>
            </Link>
          )}
        </div>
      </div>

      {/* Permissions Overview */}
      {process.env.NODE_ENV === "development" && (
        <Alert color="info" variant="soft">
          <Icon icon="heroicons:information-circle" className="h-4 w-4" />
          <AlertDescription>
            <div className="space-y-2">
              <div className="font-medium">
                Development Info - Your Permissions
              </div>
              <div className="flex flex-wrap gap-1">
                {enabledFeatures.map((feature) => (
                  <Badge key={feature.id} color="info" className="text-xs">
                    <Icon icon={feature.icon} className="w-3 h-3 mr-1" />
                    {feature.label}
                  </Badge>
                ))}
                {disabledFeatures.map((feature) => (
                  <Badge
                    key={feature.id}
                    color="secondary"
                    className="text-xs opacity-50"
                  >
                    <Icon icon={feature.icon} className="w-3 h-3 mr-1" />
                    {feature.label}
                  </Badge>
                ))}
              </div>
            </div>
          </AlertDescription>
        </Alert>
      )}

      {/* Limited Access Warning */}
      {hasAnyUserPermissions &&
        (!canViewUsers || enabledFeatures.length < 3) && (
          <Alert color="warning" variant="soft">
            <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
            <AlertDescription>
              <div className="space-y-1">
                <div className="font-medium">Limited Access</div>
                <div className="text-sm">
                  You have restricted access to user management features. Some
                  actions may not be available.
                </div>
                <div className="text-xs mt-2">
                  <strong>Available:</strong>{" "}
                  {enabledFeatures.map((f) => f.label).join(", ")}
                </div>
              </div>
            </AlertDescription>
          </Alert>
        )}

      {/* Users Table */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center justify-between">
            <span>All Users</span>
            {canViewUsers && (
              <Badge color="secondary" className="text-xs">
                <Icon icon="heroicons:eye" className="w-3 h-3 mr-1" />
                View Access
              </Badge>
            )}
          </CardTitle>
        </CardHeader>
        <CardContent className="p-0">
          {canViewUsers ? (
            <UsersTable />
          ) : (
            <div className="p-8 text-center">
              <div className="space-y-4">
                <Icon
                  icon="heroicons:lock-closed"
                  className="w-12 h-12 text-muted-foreground mx-auto"
                />
                <div>
                  <h3 className="font-medium text-default-900">
                    No View Permission
                  </h3>
                  <p className="text-sm text-muted-foreground mt-1">
                    You don't have permission to view the users list.
                  </p>
                </div>
                {canCreateUsers && (
                  <div>
                    <p className="text-xs text-muted-foreground mb-3">
                      You can still create new users:
                    </p>
                    <Link href="/users/create">
                      <Button size="md">
                        <Icon icon="heroicons:plus" className="w-4 h-4 mr-2" />
                        Create User
                      </Button>
                    </Link>
                  </div>
                )}
              </div>
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
};
// Main component wrapped with ProtectedRoute
const UsersPage = () => {
  return (
    <ProtectedRoute
      requiredPermissions={[USER_PERMISSIONS.READ_USERS]}
      requiredAccessLevel="LIMITED"
      allowedAccountStatuses={["ACTIVE"]}
    >
      <UsersPageContent />
    </ProtectedRoute>
  );
};
export default UsersPage;
-----------------------------------------------------------------------
--++--> app/[locale]/(protected)/users/[id]/page.tsx =======>
-----------------------------------------------------------------------
"use client";
import React, { useState, useEffect } from "react";
import { useRouter, useParams } from "next/navigation";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Icon } from "@/components/ui/icon";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Alert, AlertDescription } from "@/components/ui/alert";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Link } from "@/i18n/routing";
import { ProtectedRoute } from "@/components/route/protected-route";
import { USER_TYPES, PERMISSIONS } from "@/lib/constants/auth";
import { usersApiClient } from "@/lib/api/clients/auth/users.client";
import { useAuthStore } from "@/lib/stores/auth/auth.store";
import { toast } from "sonner";
// Status configurations
const userTypeConfig = {
  ADMIN: {
    label: "Admin",
    color: "destructive" as const,
    icon: "heroicons:shield-check",
  },
  MANAGER: {
    label: "Manager",
    color: "warning" as const,
    icon: "heroicons:user-group",
  },
  SUPPORT: {
    label: "Support",
    color: "info" as const,
    icon: "heroicons:chat-bubble-left-right",
  },
  SELLER: {
    label: "Seller",
    color: "success" as const,
    icon: "heroicons:currency-dollar",
  },
  LIVREUR: {
    label: "Delivery",
    color: "secondary" as const,
    icon: "heroicons:truck",
  },
  CUSTOMER: {
    label: "Customer",
    color: "primary" as const,
    icon: "heroicons:user",
  },
  BUYER: {
    label: "Buyer",
    color: "success" as const,
    icon: "heroicons:shopping-cart",
  },
  VENDOR: {
    label: "Vendor",
    color: "warning" as const,
    icon: "heroicons:building-storefront",
  },
  WAREHOUSE: {
    label: "Warehouse",
    color: "secondary" as const,
    icon: "heroicons:building-office-2",
  },
  DISPATCHER: {
    label: "Dispatcher",
    color: "info" as const,
    icon: "heroicons:map",
  },
};
const accountStatusConfig = {
  PENDING: {
    label: "Pending Approval",
    color: "warning" as const,
    icon: "heroicons:clock",
    description: "Awaiting admin approval",
  },
  INACTIVE: {
    label: "Inactive",
    color: "secondary" as const,
    icon: "heroicons:pause",
    description: "Account is inactive",
  },
  PENDING_VALIDATION: {
    label: "Pending Validation",
    color: "info" as const,
    icon: "heroicons:document-check",
    description: "Profile awaiting validation",
  },
  ACTIVE: {
    label: "Active",
    color: "success" as const,
    icon: "heroicons:check-circle",
    description: "Account is active",
  },
  REJECTED: {
    label: "Rejected",
    color: "destructive" as const,
    icon: "heroicons:x-circle",
    description: "Account was rejected",
  },
  SUSPENDED: {
    label: "Suspended",
    color: "destructive" as const,
    icon: "heroicons:no-symbol",
    description: "Account is suspended",
  },
};
const validationStatusConfig = {
  PENDING: {
    label: "Pending",
    color: "warning" as const,
    icon: "heroicons:clock",
  },
  VALIDATED: {
    label: "Validated",
    color: "success" as const,
    icon: "heroicons:shield-check",
  },
  REJECTED: {
    label: "Rejected",
    color: "destructive" as const,
    icon: "heroicons:shield-exclamation",
  },
};
const formatDate = (dateString: string) => {
  const date = new Date(dateString);
  return date.toLocaleDateString("en-US", {
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: "2-digit",
    minute: "2-digit",
  });
};
const UserDetailsPage = () => {
  const router = useRouter();
  const params = useParams();
  const userId = params?.id as string;
  const { hasPermission } = useAuthStore();

  const [loading, setLoading] = useState(true);
  const [user, setUser] = useState<any>(null);
  const [userActivity, setUserActivity] = useState<any[]>([]);
  const [permissions, setPermissions] = useState<any>(null);
  const [actionLoading, setActionLoading] = useState(false);
  const [deleteDialog, setDeleteDialog] = useState(false);

  const canUpdateUsers = hasPermission(PERMISSIONS.UPDATE_USER);
  const canDeleteUsers = hasPermission(PERMISSIONS.DELETE_USER);
  const canApproveUsers = hasPermission("users:approve");
  const canValidateUsers = hasPermission("users:validate");

  // Fetch user data
  useEffect(() => {
    const fetchUserData = async () => {
      if (!userId) return;

      try {
        setLoading(true);

        // Fetch user details
        const userResult = await usersApiClient.getUserById(userId);
        if (userResult.success) {
          setUser(userResult.data);
        } else {
          toast.error("Failed to fetch user data");
          router.push("/users");
          return;
        }

        // Fetch user permissions (no conditional check needed since this is admin-only)
        try {
          const permissionsResult = await usersApiClient.getUserPermissions(
            userId
          );
          if (permissionsResult.success) {
            setPermissions(permissionsResult.data);
          }
        } catch (error) {
          console.error("Error fetching permissions:", error);
        }

        // Fetch user activity (no conditional check needed since this is admin-only)
        try {
          const activityResult: any = await usersApiClient.getUserActivity(
            userId,
            10
          );
          if (activityResult.success) {
            setUserActivity(activityResult.data);
          }
        } catch (error) {
          console.error("Error fetching activity:", error);
        }
      } catch (error) {
        console.error("Error fetching user data:", error);
        toast.error("An error occurred while fetching user data");
        router.push("/users");
      } finally {
        setLoading(false);
      }
    };

    fetchUserData();
  }, [userId, router]);

  // Handle user actions
  const handleApproveRegistration = async () => {
    setActionLoading(true);
    try {
      const result = await usersApiClient.approveRegistration(userId, {
        approve: true,
        message: "Your registration has been approved!",
      });
      if (result.success) {
        setUser(result.data);
        toast.success("Registration approved successfully");
      } else {
        toast.error(result.error?.message || "Failed to approve registration");
      }
    } catch (error) {
      toast.error("An error occurred");
    } finally {
      setActionLoading(false);
    }
  };

  const handleValidateProfile = async () => {
    setActionLoading(true);
    try {
      const result = await usersApiClient.validateProfile(userId, {
        action: "VALIDATE",
        notes: "Profile validated successfully",
      });
      if (result.success) {
        setUser(result.data);
        toast.success("Profile validated successfully");
      } else {
        toast.error(result.error?.message || "Failed to validate profile");
      }
    } catch (error) {
      toast.error("An error occurred");
    } finally {
      setActionLoading(false);
    }
  };

  const handleSuspendUser = async () => {
    setActionLoading(true);
    try {
      const result = await usersApiClient.suspendUser(userId);
      if (result.success) {
        setUser(result.data);
        toast.success("User suspended successfully");
      } else {
        toast.error(result.error?.message || "Failed to suspend user");
      }
    } catch (error) {
      toast.error("An error occurred");
    } finally {
      setActionLoading(false);
    }
  };

  const handleReactivateUser = async () => {
    setActionLoading(true);
    try {
      const result = await usersApiClient.reactivateUser(userId);
      if (result.success) {
        setUser(result.data);
        toast.success("User reactivated successfully");
      } else {
        toast.error(result.error?.message || "Failed to reactivate user");
      }
    } catch (error) {
      toast.error("An error occurred");
    } finally {
      setActionLoading(false);
    }
  };

  const handleDeleteUser = async () => {
    try {
      const result = await usersApiClient.deleteUser(userId);
      if (result.success) {
        toast.success("User deleted successfully");
        router.push("/users");
      } else {
        toast.error(result.error?.message || "Failed to delete user");
      }
    } catch (error) {
      toast.error("An error occurred");
    } finally {
      setDeleteDialog(false);
    }
  };

  if (loading) {
    return (
      <ProtectedRoute
        requiredUserTypes={[USER_TYPES.ADMIN]}
        requiredPermissions={[PERMISSIONS.READ_USERS]}
        requiredAccessLevel="FULL"
      >
        <div className="container mx-auto py-6">
          <Card>
            <CardContent className="p-8">
              <div className="flex items-center justify-center space-x-2">
                <Icon
                  icon="heroicons:arrow-path"
                  className="w-5 h-5 animate-spin"
                />
                <span>Loading user details...</span>
              </div>
            </CardContent>
          </Card>
        </div>
      </ProtectedRoute>
    );
  }

  if (!user) {
    return (
      <ProtectedRoute
        requiredUserTypes={[USER_TYPES.ADMIN]}
        requiredPermissions={[PERMISSIONS.READ_USERS]}
        requiredAccessLevel="FULL"
      >
        <div className="container mx-auto py-8">
          <Alert color="destructive">
            <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
            <AlertDescription>
              User not found or has been deleted.
            </AlertDescription>
          </Alert>
        </div>
      </ProtectedRoute>
    );
  }

  const userTypeInfo =
    userTypeConfig[user.userType as keyof typeof userTypeConfig];
  const accountStatusInfo =
    accountStatusConfig[user.accountStatus as keyof typeof accountStatusConfig];
  const validationStatusInfo =
    validationStatusConfig[
      user.validationStatus as keyof typeof validationStatusConfig
    ];

  return (
    <ProtectedRoute
      requiredUserTypes={[USER_TYPES.ADMIN]}
      requiredPermissions={[PERMISSIONS.READ_USERS]}
      requiredAccessLevel="FULL"
    >
      <div className="container mx-auto py-6 space-y-6">
        {/* Header */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-4">
            <Avatar size="xl">
              <AvatarImage
                src={user.profile?.profilePhoto || user.avatar}
                alt={user.name}
              />
              <AvatarFallback className="text-lg">
                {user.name
                  ?.split(" ")
                  .map((n: string) => n[0])
                  .join("")
                  .toUpperCase() || "U"}
              </AvatarFallback>
            </Avatar>
            <div>
              <div className="flex items-center gap-2">
                <h1 className="text-3xl font-bold text-default-900">
                  {user.name}
                </h1>
                {user.validationStatus === "VALIDATED" && (
                  <TooltipProvider>
                    <Tooltip>
                      <TooltipTrigger>
                        <Icon
                          icon="heroicons:shield-check"
                          className="w-6 h-6 text-blue-500"
                        />
                      </TooltipTrigger>
                      <TooltipContent>
                        <p>Verified Profile</p>
                      </TooltipContent>
                    </Tooltip>
                  </TooltipProvider>
                )}
              </div>
              <p className="text-lg text-default-600">{user.email}</p>
              <div className="flex items-center gap-2 mt-2">
                <Badge color={userTypeInfo?.color}>
                  <Icon icon={userTypeInfo?.icon} className="w-3 h-3 mr-1" />
                  {userTypeInfo?.label}
                </Badge>
                <Badge color={accountStatusInfo?.color}>
                  <Icon
                    icon={accountStatusInfo?.icon}
                    className="w-3 h-3 mr-1"
                  />
                  {accountStatusInfo?.label}
                </Badge>
                <Badge color={validationStatusInfo?.color}>
                  <Icon
                    icon={validationStatusInfo?.icon}
                    className="w-3 h-3 mr-1"
                  />
                  {validationStatusInfo?.label}
                </Badge>
              </div>
            </div>
          </div>

          <div className="flex items-center gap-2">
            {/* Admin Actions Dropdown */}
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button disabled={actionLoading}>
                  <Icon
                    icon="heroicons:ellipsis-horizontal"
                    className="w-4 h-4 mr-2"
                  />
                  Admin Actions
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end">
                {canUpdateUsers && (
                  <DropdownMenuItem asChild>
                    <Link href={`/users/${userId}/edit`}>
                      <Icon
                        icon="heroicons:pencil-square"
                        className="mr-2 h-4 w-4"
                      />
                      Edit User
                    </Link>
                  </DropdownMenuItem>
                )}

                {/* Admin-specific actions */}
                {canApproveUsers && user.accountStatus === "PENDING" && (
                  <>
                    <DropdownMenuSeparator />
                    <DropdownMenuItem onClick={handleApproveRegistration}>
                      <Icon
                        icon="heroicons:check"
                        className="mr-2 h-4 w-4 text-green-600"
                      />
                      Approve Registration
                    </DropdownMenuItem>
                  </>
                )}

                {canValidateUsers &&
                  user.accountStatus === "PENDING_VALIDATION" && (
                    <>
                      <DropdownMenuSeparator />
                      <DropdownMenuItem onClick={handleValidateProfile}>
                        <Icon
                          icon="heroicons:shield-check"
                          className="mr-2 h-4 w-4 text-blue-600"
                        />
                        Validate Profile
                      </DropdownMenuItem>
                    </>
                  )}

                {canUpdateUsers && (
                  <>
                    <DropdownMenuSeparator />
                    {user.accountStatus === "SUSPENDED" ? (
                      <DropdownMenuItem onClick={handleReactivateUser}>
                        <Icon
                          icon="heroicons:play"
                          className="mr-2 h-4 w-4 text-green-600"
                        />
                        Reactivate User
                      </DropdownMenuItem>
                    ) : (
                      user.accountStatus === "ACTIVE" && (
                        <DropdownMenuItem onClick={handleSuspendUser}>
                          <Icon
                            icon="heroicons:pause"
                            className="mr-2 h-4 w-4 text-orange-600"
                          />
                          Suspend User
                        </DropdownMenuItem>
                      )
                    )}
                  </>
                )}

                {canDeleteUsers && (
                  <>
                    <DropdownMenuSeparator />
                    <DropdownMenuItem
                      className="text-red-600 focus:text-red-600"
                      onClick={() => setDeleteDialog(true)}
                    >
                      <Icon icon="heroicons:trash" className="mr-2 h-4 w-4" />
                      Delete User
                    </DropdownMenuItem>
                  </>
                )}
              </DropdownMenuContent>
            </DropdownMenu>

            <Link href="/users">
              <Button variant="outline">
                <Icon icon="heroicons:arrow-left" className="w-4 h-4 mr-2" />
                Back to Users
              </Button>
            </Link>
          </div>
        </div>

        {/* Status Alert */}
        {user.accountStatus !== "ACTIVE" && (
          <Alert color={accountStatusInfo?.color} variant="soft">
            <Icon icon={accountStatusInfo?.icon} className="h-4 w-4" />
            <AlertDescription>
              <strong>{accountStatusInfo?.label}:</strong>{" "}
              {accountStatusInfo?.description}
              {user.validationNotes && (
                <span className="block mt-1 text-sm">
                  {user.validationNotes}
                </span>
              )}
            </AlertDescription>
          </Alert>
        )}

        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          {/* Main Content */}
          <div className="lg:col-span-2 space-y-6">
            {/* Personal Information */}
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:user" className="w-5 h-5" />
                  Personal Information
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <h4 className="font-medium text-default-900">Full Name</h4>
                    <p className="text-default-600">
                      {user.name || "Not provided"}
                    </p>
                  </div>
                  <div>
                    <h4 className="font-medium text-default-900">Email</h4>
                    <p className="text-default-600">{user.email}</p>
                  </div>
                  <div>
                    <h4 className="font-medium text-default-900">Phone</h4>
                    <p className="text-default-600">
                      {user.phone || "Not provided"}
                    </p>
                  </div>
                  <div>
                    <h4 className="font-medium text-default-900">City</h4>
                    <p className="text-default-600">
                      {user.city || "Not provided"}
                    </p>
                  </div>
                  {user.profile?.address && (
                    <div className="md:col-span-2">
                      <h4 className="font-medium text-default-900">Address</h4>
                      <p className="text-default-600">{user.profile.address}</p>
                    </div>
                  )}
                  {user.profile?.cin && (
                    <div>
                      <h4 className="font-medium text-default-900">CIN</h4>
                      <p className="text-default-600">{user.profile.cin}</p>
                    </div>
                  )}
                  {user.profile?.department && (
                    <div>
                      <h4 className="font-medium text-default-900">
                        Department
                      </h4>
                      <p className="text-default-600">
                        {user.profile.department}
                      </p>
                    </div>
                  )}
                </div>

                {user.profile?.notes && (
                  <div>
                    <h4 className="font-medium text-default-900">Notes</h4>
                    <p className="text-default-600">{user.profile.notes}</p>
                  </div>
                )}
              </CardContent>
            </Card>

            {/* Role & Permissions */}
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:identification" className="w-5 h-5" />
                  Role & Permissions
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <h4 className="font-medium text-default-900">User Type</h4>
                    <div className="flex items-center gap-2 mt-1">
                      <Badge color={userTypeInfo?.color}>
                        <Icon
                          icon={userTypeInfo?.icon}
                          className="w-3 h-3 mr-1"
                        />
                        {userTypeInfo?.label}
                      </Badge>
                    </div>
                  </div>
                  <div>
                    <h4 className="font-medium text-default-900">Role</h4>
                    <p className="text-default-600">
                      {user.role?.name || "No role assigned"}
                    </p>
                    {user.role?.description && (
                      <p className="text-sm text-default-500">
                        {user.role.description}
                      </p>
                    )}
                  </div>
                </div>

                {permissions && permissions.permissions && (
                  <div>
                    <h4 className="font-medium text-default-900 mb-2">
                      Permissions
                    </h4>
                    <div className="flex flex-wrap gap-1">
                      {permissions.permissions.map((permission: string) => (
                        <Badge key={permission} className="outline text-xs">
                          {permission}
                        </Badge>
                      ))}
                    </div>
                  </div>
                )}
              </CardContent>
            </Card>

            {/* Activity Log */}
            {userActivity.length > 0 && (
              <Card>
                <CardHeader>
                  <CardTitle className="flex items-center gap-2">
                    <Icon icon="heroicons:clock" className="w-5 h-5" />
                    Recent Activity
                  </CardTitle>
                </CardHeader>
                <CardContent>
                  <div className="space-y-3">
                    {userActivity.map((activity) => (
                      <div
                        key={activity.id}
                        className="flex items-start gap-3 p-3 bg-default-50 rounded-lg"
                      >
                        <div className="w-2 h-2 bg-primary rounded-full mt-2"></div>
                        <div className="flex-1">
                          <p className="text-sm font-medium">
                            {activity.action}
                          </p>
                          <p className="text-xs text-default-500">
                            {formatDate(activity.timestamp)} by{" "}
                            {activity.performedBy?.name}
                          </p>
                          {activity.details && (
                            <p className="text-xs text-default-600 mt-1">
                              {activity.details}
                            </p>
                          )}
                        </div>
                      </div>
                    ))}
                  </div>
                </CardContent>
              </Card>
            )}
          </div>

          {/* Sidebar */}
          <div className="space-y-6">
            {/* Account Status */}
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon
                    icon="heroicons:information-circle"
                    className="w-5 h-5"
                  />
                  Account Status
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div>
                  <h4 className="font-medium text-default-900">
                    Account Status
                  </h4>
                  <div className="flex items-center gap-2 mt-1">
                    <Badge color={accountStatusInfo?.color}>
                      <Icon
                        icon={accountStatusInfo?.icon}
                        className="w-3 h-3 mr-1"
                      />
                      {accountStatusInfo?.label}
                    </Badge>
                  </div>
                </div>

                <div>
                  <h4 className="font-medium text-default-900">
                    Validation Status
                  </h4>
                  <div className="flex items-center gap-2 mt-1">
                    <Badge color={validationStatusInfo?.color}>
                      <Icon
                        icon={validationStatusInfo?.icon}
                        className="w-3 h-3 mr-1"
                      />
                      {validationStatusInfo?.label}
                    </Badge>
                  </div>
                </div>

                <div>
                  <h4 className="font-medium text-default-900">
                    Profile Completion
                  </h4>
                  <div className="flex items-center gap-2 mt-1">
                    <Badge
                      color={user.profileCompleted ? "success" : "warning"}
                    >
                      {user.profileCompleted ? "Complete" : "Incomplete"}
                    </Badge>
                  </div>
                </div>

                <div>
                  <h4 className="font-medium text-default-900">
                    Access Status
                  </h4>
                  <div className="flex items-center gap-2 mt-1">
                    <Badge color={user.isActive ? "success" : "destructive"}>
                      {user.isActive ? "Active" : "Inactive"}
                    </Badge>
                  </div>
                </div>
              </CardContent>
            </Card>

            {/* Account Timeline */}
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:calendar" className="w-5 h-5" />
                  Account Timeline
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div>
                  <h4 className="font-medium text-default-900">Created</h4>
                  <p className="text-sm text-default-600">
                    {formatDate(user.createdAt)}
                  </p>
                  {user.createdBy && (
                    <p className="text-xs text-default-500">
                      by {user.createdBy.name}
                    </p>
                  )}
                </div>

                <div>
                  <h4 className="font-medium text-default-900">Last Updated</h4>
                  <p className="text-sm text-default-600">
                    {formatDate(user.updatedAt)}
                  </p>
                </div>

                {user.validatedAt && (
                  <div>
                    <h4 className="font-medium text-default-900">Validated</h4>
                    <p className="text-sm text-default-600">
                      {formatDate(user.validatedAt)}
                    </p>
                    {user.validatedBy && (
                      <p className="text-xs text-default-500">
                        by {user.validatedBy.name}
                      </p>
                    )}
                  </div>
                )}

                {user.lastLogin && (
                  <div>
                    <h4 className="font-medium text-default-900">Last Login</h4>
                    <p className="text-sm text-default-600">
                      {formatDate(user.lastLogin)}
                    </p>
                  </div>
                )}
              </CardContent>
            </Card>

            {/* Tenant Information */}
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:building-office" className="w-5 h-5" />
                  Organization
                </CardTitle>
              </CardHeader>
              <CardContent>
                <div>
                  <h4 className="font-medium text-default-900">
                    {user.tenant?.name}
                  </h4>
                  <p className="text-sm text-default-500">
                    {user.tenant?.slug}
                  </p>
                </div>
              </CardContent>
            </Card>
          </div>
        </div>

        {/* Delete Confirmation Dialog */}
        <AlertDialog open={deleteDialog} onOpenChange={setDeleteDialog}>
          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>Delete User</AlertDialogTitle>
              <AlertDialogDescription>
                Are you sure you want to delete <strong>{user.name}</strong>?
                This action cannot be undone and will permanently remove all
                user data.
              </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
              <AlertDialogCancel>Cancel</AlertDialogCancel>
              <AlertDialogAction
                onClick={handleDeleteUser}
                className="bg-red-600 text-white hover:bg-red-700"
              >
                Delete User
              </AlertDialogAction>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>
      </div>
    </ProtectedRoute>
  );
};
export default UserDetailsPage;
-----------------------------------------------------------------------
--++--> app/[locale]/(protected)/users/[id]/edit/page.tsx =======>
-----------------------------------------------------------------------
"use client";
import React, { useState, useEffect } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { useRouter, useParams } from "next/navigation";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";
import { Badge } from "@/components/ui/badge";
import { Icon } from "@/components/ui/icon";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Alert, AlertDescription } from "@/components/ui/alert";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Link } from "@/i18n/routing";
import { ProtectedRoute } from "@/components/route/protected-route";
import { USER_TYPES, PERMISSIONS } from "@/lib/constants/auth";
import { usersApiClient } from "@/lib/api/clients/auth/users.client";
import { useAuthStore } from "@/lib/stores/auth/auth.store";
import { toast } from "sonner";
import { cn } from "@/lib/utils/ui.utils";
// Form schema for updating user
const updateUserSchema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters"),
  email: z.string().email("Please enter a valid email address"),
  userType: z.enum([
    "ADMIN",
    "MANAGER",
    "SUPPORT",
    "SELLER",
    "LIVREUR",
    "CUSTOMER",
    "BUYER",
    "VENDOR",
    "WAREHOUSE",
    "DISPATCHER",
  ]),
  phone: z.string().optional(),
  city: z.string().optional(),
  roleId: z.string().optional(),
  profile: z
    .object({
      department: z.string().optional(),
      notes: z.string().optional(),
      address: z.string().optional(),
      cin: z.string().optional(),
    })
    .optional(),
  accountStatus: z
    .enum([
      "PENDING",
      "INACTIVE",
      "PENDING_VALIDATION",
      "ACTIVE",
      "REJECTED",
      "SUSPENDED",
    ])
    .optional(),
  validationStatus: z.enum(["PENDING", "VALIDATED", "REJECTED"]).optional(),
  isActive: z.boolean().default(true),
});
type UpdateUserFormData = z.infer<typeof updateUserSchema>;
// User type configurations
const userTypeConfig = {
  ADMIN: {
    label: "Admin",
    color: "destructive" as const,
    icon: "heroicons:shield-check",
  },
  MANAGER: {
    label: "Manager",
    color: "warning" as const,
    icon: "heroicons:user-group",
  },
  SUPPORT: {
    label: "Support",
    color: "info" as const,
    icon: "heroicons:chat-bubble-left-right",
  },
  SELLER: {
    label: "Seller",
    color: "success" as const,
    icon: "heroicons:currency-dollar",
  },
  LIVREUR: {
    label: "Delivery",
    color: "secondary" as const,
    icon: "heroicons:truck",
  },
  CUSTOMER: {
    label: "Customer",
    color: "primary" as const,
    icon: "heroicons:user",
  },
  BUYER: {
    label: "Buyer",
    color: "success" as const,
    icon: "heroicons:shopping-cart",
  },
  VENDOR: {
    label: "Vendor",
    color: "warning" as const,
    icon: "heroicons:building-storefront",
  },
  WAREHOUSE: {
    label: "Warehouse",
    color: "secondary" as const,
    icon: "heroicons:building-office-2",
  },
  DISPATCHER: {
    label: "Dispatcher",
    color: "info" as const,
    icon: "heroicons:map",
  },
};
// Status configurations
const accountStatusConfig = {
  PENDING: {
    label: "Pending Approval",
    color: "warning" as const,
    icon: "heroicons:clock",
  },
  INACTIVE: {
    label: "Inactive",
    color: "secondary" as const,
    icon: "heroicons:pause",
  },
  PENDING_VALIDATION: {
    label: "Pending Validation",
    color: "info" as const,
    icon: "heroicons:document-check",
  },
  ACTIVE: {
    label: "Active",
    color: "success" as const,
    icon: "heroicons:check-circle",
  },
  REJECTED: {
    label: "Rejected",
    color: "destructive" as const,
    icon: "heroicons:x-circle",
  },
  SUSPENDED: {
    label: "Suspended",
    color: "destructive" as const,
    icon: "heroicons:no-symbol",
  },
};
const validationStatusConfig = {
  PENDING: {
    label: "Pending",
    color: "warning" as const,
    icon: "heroicons:clock",
  },
  VALIDATED: {
    label: "Validated",
    color: "success" as const,
    icon: "heroicons:shield-check",
  },
  REJECTED: {
    label: "Rejected",
    color: "destructive" as const,
    icon: "heroicons:shield-exclamation",
  },
};
const UpdateUserPage = () => {
  const router = useRouter();
  const params = useParams();
  const userId = params?.id as string;
  const { hasPermission } = useAuthStore();

  const [loading, setLoading] = useState(false);
  const [fetchLoading, setFetchLoading] = useState(true);
  const [user, setUser] = useState<any>(null);
  const [roles, setRoles] = useState<
    Array<{
      id: string;
      name: string;
      description?: string;
      userTypes: string[];
    }>
  >([]);
  const [showPasswordDialog, setShowPasswordDialog] = useState(false);
  const [passwordForm, setPasswordForm] = useState({
    currentPassword: "",
    newPassword: "",
    confirmPassword: "",
  });
  const [passwordLoading, setPasswordLoading] = useState(false);

  // Simplified permission checks (ProtectedRoute handles main access control)
  const canChangePassword = hasPermission("users:change_password");

  const {
    register,
    handleSubmit,
    watch,
    setValue,
    formState: { errors, isDirty },
    reset,
  } = useForm<UpdateUserFormData>({
    resolver: zodResolver(updateUserSchema),
  });

  const watchedUserType = watch("userType");

  // Fetch user data
  useEffect(() => {
    const fetchUser = async () => {
      if (!userId) return;

      try {
        setFetchLoading(true);
        const result = await usersApiClient.getUserById(userId);

        if (result.success) {
          const userData: any = result.data;
          setUser(userData);

          // Populate form with user data
          reset({
            name: userData.name || "",
            email: userData.email || "",
            userType: userData.userType,
            phone: userData.phone || "",
            city: userData.city || "",
            roleId: userData.role?.id || "",
            accountStatus: userData.accountStatus,
            validationStatus: userData.validationStatus,
            isActive: userData.isActive,
            profile: {
              department: userData.profile?.department || "",
              notes: userData.profile?.notes || "",
              address: userData.profile?.address || "",
              cin: userData.profile?.cin || "",
            },
          });
        } else {
          toast.error("Failed to fetch user data");
          router.push("/users");
        }
      } catch (error) {
        console.error("Error fetching user:", error);
        toast.error("An error occurred while fetching user data");
        router.push("/users");
      } finally {
        setFetchLoading(false);
      }
    };

    fetchUser();
  }, [userId, reset, router]);

  // Fetch available roles
  useEffect(() => {
    const fetchRoles = async () => {
      try {
        // Mock data - replace with actual API call
        setRoles([
          {
            id: "1",
            name: "System Admin",
            description: "Full system access",
            userTypes: ["ADMIN"],
          },
          {
            id: "2",
            name: "Operations Manager",
            description: "Operations oversight",
            userTypes: ["MANAGER"],
          },
          {
            id: "3",
            name: "Sales Representative",
            description: "Sales operations",
            userTypes: ["SELLER"],
          },
          {
            id: "4",
            name: "Support Agent",
            description: "Customer support",
            userTypes: ["SUPPORT"],
          },
          {
            id: "5",
            name: "Delivery Driver",
            description: "Package delivery",
            userTypes: ["LIVREUR"],
          },
          {
            id: "6",
            name: "Standard Customer",
            description: "Customer access",
            userTypes: ["CUSTOMER"],
          },
          {
            id: "7",
            name: "Procurement Officer",
            description: "Purchasing operations",
            userTypes: ["BUYER"],
          },
          {
            id: "8",
            name: "Vendor Account",
            description: "Vendor portal access",
            userTypes: ["VENDOR"],
          },
          {
            id: "9",
            name: "Warehouse Staff",
            description: "Inventory management",
            userTypes: ["WAREHOUSE"],
          },
          {
            id: "10",
            name: "Logistics Coordinator",
            description: "Dispatch operations",
            userTypes: ["DISPATCHER"],
          },
        ]);
      } catch (error) {
        console.error("Failed to fetch roles:", error);
      }
    };

    fetchRoles();
  }, []);

  // Filter roles based on selected user type
  const availableRoles = roles.filter((role) =>
    watchedUserType ? role.userTypes.includes(watchedUserType) : true
  );

  const onSubmit = async (data: UpdateUserFormData) => {
    setLoading(true);
    try {
      const result = await usersApiClient.updateUser(userId, data);

      if (result.success) {
        toast.success("User updated successfully");
        setUser(result.data);
        // Update form with new data to reset dirty state
        reset(data);
      } else {
        toast.error(result.error?.message || "Failed to update user");
      }
    } catch (error) {
      console.error("Error updating user:", error);
      toast.error("An unexpected error occurred");
    } finally {
      setLoading(false);
    }
  };

  const handlePasswordChange = async () => {
    if (!canChangePassword) {
      toast.error("You don't have permission to change passwords");
      return;
    }

    if (!passwordForm.currentPassword || !passwordForm.newPassword) {
      toast.error("Please fill in all password fields");
      return;
    }

    if (passwordForm.newPassword !== passwordForm.confirmPassword) {
      toast.error("New passwords don't match");
      return;
    }

    if (passwordForm.newPassword.length < 6) {
      toast.error("Password must be at least 6 characters");
      return;
    }

    setPasswordLoading(true);
    try {
      const result = await usersApiClient.changeUserPassword(userId, {
        currentPassword: passwordForm.currentPassword,
        newPassword: passwordForm.newPassword,
      });

      if (result.success) {
        toast.success("Password changed successfully");
        setShowPasswordDialog(false);
        setPasswordForm({
          currentPassword: "",
          newPassword: "",
          confirmPassword: "",
        });
      } else {
        toast.error(result.error?.message || "Failed to change password");
      }
    } catch (error) {
      console.error("Error changing password:", error);
      toast.error("An unexpected error occurred");
    } finally {
      setPasswordLoading(false);
    }
  };

  const handleFormSubmit = () => {
    handleSubmit(onSubmit)();
  };

  if (fetchLoading) {
    return (
      <ProtectedRoute
        requiredUserTypes={[USER_TYPES.ADMIN]}
        requiredPermissions={[PERMISSIONS.UPDATE_USER]}
        requiredAccessLevel="FULL"
      >
        <div className="container mx-auto py-6">
          <Card>
            <CardContent className="p-8">
              <div className="flex items-center justify-center space-x-2">
                <Icon
                  icon="heroicons:arrow-path"
                  className="w-5 h-5 animate-spin"
                />
                <span>Loading user data...</span>
              </div>
            </CardContent>
          </Card>
        </div>
      </ProtectedRoute>
    );
  }

  if (!user) {
    return (
      <ProtectedRoute
        requiredUserTypes={[USER_TYPES.ADMIN]}
        requiredPermissions={[PERMISSIONS.UPDATE_USER]}
        requiredAccessLevel="FULL"
      >
        <div className="container mx-auto py-8">
          <Alert color="destructive">
            <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
            <AlertDescription>
              User not found or has been deleted.
            </AlertDescription>
          </Alert>
        </div>
      </ProtectedRoute>
    );
  }

  return (
    <ProtectedRoute
      requiredUserTypes={[USER_TYPES.ADMIN]}
      requiredPermissions={[PERMISSIONS.UPDATE_USER]}
      requiredAccessLevel="FULL"
    >
      <div className="container mx-auto py-6 space-y-6">
        {/* Header */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-4">
            <Avatar size="lg">
              <AvatarImage
                src={user.profile?.profilePhoto || user.avatar}
                alt={user.name}
              />
              <AvatarFallback>
                {user.name
                  ?.split(" ")
                  .map((n: string) => n[0])
                  .join("")
                  .toUpperCase() || "U"}
              </AvatarFallback>
            </Avatar>
            <div>
              <h1 className="text-2xl font-bold text-default-900">
                Edit User - Admin Panel
              </h1>
              <p className="text-default-600">
                {user.name}  {user.email}
              </p>
              <div className="flex items-center gap-2 mt-1">
                <Badge
                  color={
                    userTypeConfig[user.userType as keyof typeof userTypeConfig]
                      ?.color
                  }
                >
                  {
                    userTypeConfig[user.userType as keyof typeof userTypeConfig]
                      ?.label
                  }
                </Badge>
                <Badge
                  color={
                    accountStatusConfig[
                      user.accountStatus as keyof typeof accountStatusConfig
                    ]?.color
                  }
                >
                  {
                    accountStatusConfig[
                      user.accountStatus as keyof typeof accountStatusConfig
                    ]?.label
                  }
                </Badge>
                {user.validationStatus === "VALIDATED" && (
                  <Badge color="success">
                    <Icon
                      icon="heroicons:shield-check"
                      className="w-3 h-3 mr-1"
                    />
                    Validated
                  </Badge>
                )}
              </div>
            </div>
          </div>
          <div className="flex items-center gap-2">
            <Link href={`/users/${userId}`}>
              <Button variant="outline">
                <Icon icon="heroicons:eye" className="w-4 h-4 mr-2" />
                View Profile
              </Button>
            </Link>
            <Link href="/users">
              <Button variant="outline">
                <Icon icon="heroicons:arrow-left" className="w-4 h-4 mr-2" />
                Back to Users
              </Button>
            </Link>
          </div>
        </div>

        {/* Admin Notice */}
        <Alert color="info" variant="soft">
          <Icon icon="heroicons:shield-check" className="h-4 w-4" />
          <AlertDescription>
            <strong>Admin Mode:</strong> You are editing user information with
            administrator privileges. All changes will be logged and auditable.
          </AlertDescription>
        </Alert>

        {/* Unsaved Changes Warning */}
        {isDirty && (
          <Alert color="warning" variant="soft">
            <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
            <AlertDescription>
              You have unsaved changes. Don't forget to save your updates.
            </AlertDescription>
          </Alert>
        )}

        <div className="space-y-6">
          <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
            {/* Main Information */}
            <div className="lg:col-span-2 space-y-6">
              <Card>
                <CardHeader>
                  <CardTitle className="flex items-center gap-2">
                    <Icon icon="heroicons:user" className="w-5 h-5" />
                    Basic Information
                  </CardTitle>
                </CardHeader>
                <CardContent className="space-y-4">
                  {/* Name */}
                  <div className="space-y-2">
                    <Label
                      htmlFor="name"
                      className={cn("", { "text-destructive": errors.name })}
                    >
                      Full Name *
                    </Label>
                    <Input
                      id="name"
                      {...register("name")}
                      placeholder="Enter full name"
                      className={cn("", {
                        "border-destructive focus:border-destructive":
                          errors.name,
                      })}
                    />
                    {errors.name && (
                      <p className="text-xs text-destructive">
                        {errors.name.message}
                      </p>
                    )}
                  </div>

                  {/* Email */}
                  <div className="space-y-2">
                    <Label
                      htmlFor="email"
                      className={cn("", { "text-destructive": errors.email })}
                    >
                      Email Address *
                    </Label>
                    <Input
                      id="email"
                      type="email"
                      {...register("email")}
                      placeholder="user@example.com"
                      className={cn("", {
                        "border-destructive focus:border-destructive":
                          errors.email,
                      })}
                    />
                    {errors.email && (
                      <p className="text-xs text-destructive">
                        {errors.email.message}
                      </p>
                    )}
                  </div>

                  {/* Phone and City */}
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div className="space-y-2">
                      <Label htmlFor="phone">Phone Number</Label>
                      <Input
                        id="phone"
                        {...register("phone")}
                        placeholder="+1 (555) 123-4567"
                      />
                    </div>
                    <div className="space-y-2">
                      <Label htmlFor="city">City</Label>
                      <Input
                        id="city"
                        {...register("city")}
                        placeholder="Enter city"
                      />
                    </div>
                  </div>

                  {/* Address and CIN */}
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div className="space-y-2">
                      <Label htmlFor="address">Address</Label>
                      <Input
                        id="address"
                        {...register("profile.address")}
                        placeholder="Full address"
                      />
                    </div>
                    <div className="space-y-2">
                      <Label htmlFor="cin">CIN</Label>
                      <Input
                        id="cin"
                        {...register("profile.cin")}
                        placeholder="National ID"
                      />
                    </div>
                  </div>
                </CardContent>
              </Card>

              {/* User Type and Role */}
              <Card>
                <CardHeader>
                  <CardTitle className="flex items-center gap-2">
                    <Icon icon="heroicons:identification" className="w-5 h-5" />
                    User Type & Role
                  </CardTitle>
                </CardHeader>
                <CardContent className="space-y-4">
                  {/* User Type */}
                  <div className="space-y-2">
                    <Label>User Type *</Label>
                    <Select
                      value={watchedUserType}
                      onValueChange={(value) =>
                        setValue("userType", value as any, {
                          shouldDirty: true,
                        })
                      }
                    >
                      <SelectTrigger>
                        <SelectValue placeholder="Select user type" />
                      </SelectTrigger>
                      <SelectContent>
                        {Object.entries(userTypeConfig).map(([key, config]) => (
                          <SelectItem key={key} value={key}>
                            <div className="flex items-center gap-3">
                              <Icon icon={config.icon} className="w-4 h-4" />
                              <div className="font-medium">{config.label}</div>
                            </div>
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>

                  {/* Role Selection */}
                  {watchedUserType && (
                    <div className="space-y-2">
                      <Label>Role</Label>
                      <Select
                        onValueChange={(value) =>
                          setValue("roleId", value, { shouldDirty: true })
                        }
                      >
                        <SelectTrigger>
                          <SelectValue placeholder="Select role" />
                        </SelectTrigger>
                        <SelectContent>
                          {availableRoles.map((role) => (
                            <SelectItem key={role.id} value={role.id}>
                              <div>
                                <div className="font-medium">{role.name}</div>
                                {role.description && (
                                  <div className="text-xs text-muted-foreground">
                                    {role.description}
                                  </div>
                                )}
                              </div>
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                    </div>
                  )}
                </CardContent>
              </Card>

              {/* Status Management - Now always visible since this is admin-only */}
              <Card>
                <CardHeader>
                  <CardTitle className="flex items-center gap-2">
                    <Icon icon="heroicons:cog-6-tooth" className="w-5 h-5" />
                    Status Management
                  </CardTitle>
                </CardHeader>
                <CardContent className="space-y-4">
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div className="space-y-2">
                      <Label>Account Status</Label>
                      <Select
                        value={user.accountStatus}
                        onValueChange={(value) =>
                          setValue("accountStatus", value as any, {
                            shouldDirty: true,
                          })
                        }
                      >
                        <SelectTrigger>
                          <SelectValue placeholder="Select account status" />
                        </SelectTrigger>
                        <SelectContent>
                          {Object.entries(accountStatusConfig).map(
                            ([key, config]) => (
                              <SelectItem key={key} value={key}>
                                <div className="flex items-center gap-2">
                                  <Icon
                                    icon={config.icon}
                                    className="w-4 h-4"
                                  />
                                  {config.label}
                                </div>
                              </SelectItem>
                            )
                          )}
                        </SelectContent>
                      </Select>
                    </div>

                    <div className="space-y-2">
                      <Label>Validation Status</Label>
                      <Select
                        value={user.validationStatus}
                        onValueChange={(value) =>
                          setValue("validationStatus", value as any, {
                            shouldDirty: true,
                          })
                        }
                      >
                        <SelectTrigger>
                          <SelectValue placeholder="Select validation status" />
                        </SelectTrigger>
                        <SelectContent>
                          {Object.entries(validationStatusConfig).map(
                            ([key, config]) => (
                              <SelectItem key={key} value={key}>
                                <div className="flex items-center gap-2">
                                  <Icon
                                    icon={config.icon}
                                    className="w-4 h-4"
                                  />
                                  {config.label}
                                </div>
                              </SelectItem>
                            )
                          )}
                        </SelectContent>
                      </Select>
                    </div>
                  </div>
                </CardContent>
              </Card>

              {/* Additional Information */}
              <Card>
                <CardHeader>
                  <CardTitle className="flex items-center gap-2">
                    <Icon icon="heroicons:document-text" className="w-5 h-5" />
                    Additional Information
                  </CardTitle>
                </CardHeader>
                <CardContent className="space-y-4">
                  <div className="space-y-2">
                    <Label htmlFor="department">Department</Label>
                    <Input
                      id="department"
                      {...register("profile.department")}
                      placeholder="e.g., Sales, Marketing, IT"
                    />
                  </div>

                  <div className="space-y-2">
                    <Label htmlFor="notes">Admin Notes</Label>
                    <Textarea
                      id="notes"
                      {...register("profile.notes")}
                      placeholder="Internal admin notes about this user..."
                      rows={3}
                    />
                  </div>
                </CardContent>
              </Card>
            </div>

            {/* Settings Sidebar */}
            <div className="space-y-6">
              <Card>
                <CardHeader>
                  <CardTitle className="flex items-center gap-2">
                    <Icon icon="heroicons:key" className="w-5 h-5" />
                    Security
                  </CardTitle>
                </CardHeader>
                <CardContent className="space-y-4">
                  {canChangePassword && (
                    <Button
                      variant="outline"
                      className="w-full"
                      onClick={() => setShowPasswordDialog(true)}
                    >
                      <Icon icon="heroicons:key" className="w-4 h-4 mr-2" />
                      Change Password
                    </Button>
                  )}

                  <div className="flex items-center justify-between">
                    <div className="space-y-0.5">
                      <Label>Active Account</Label>
                      <p className="text-xs text-muted-foreground">
                        Allow user to access the system
                      </p>
                    </div>
                    <Switch
                      {...register("isActive")}
                      defaultChecked={user.isActive}
                    />
                  </div>
                </CardContent>
              </Card>

              {/* Account Information */}
              <Card>
                <CardHeader>
                  <CardTitle className="flex items-center gap-2">
                    <Icon
                      icon="heroicons:information-circle"
                      className="w-5 h-5"
                    />
                    Account Information
                  </CardTitle>
                </CardHeader>
                <CardContent className="space-y-3">
                  <div className="text-sm">
                    <span className="text-muted-foreground">Created:</span>
                    <div className="font-medium">
                      {new Date(user.createdAt).toLocaleDateString("en-US", {
                        year: "numeric",
                        month: "long",
                        day: "numeric",
                      })}
                    </div>
                    {user.createdBy && (
                      <div className="text-xs text-muted-foreground">
                        by {user.createdBy.name}
                      </div>
                    )}
                  </div>

                  <div className="text-sm">
                    <span className="text-muted-foreground">Last Updated:</span>
                    <div className="font-medium">
                      {new Date(user.updatedAt).toLocaleDateString("en-US", {
                        year: "numeric",
                        month: "long",
                        day: "numeric",
                      })}
                    </div>
                  </div>

                  {user.validatedAt && (
                    <div className="text-sm">
                      <span className="text-muted-foreground">Validated:</span>
                      <div className="font-medium">
                        {new Date(user.validatedAt).toLocaleDateString(
                          "en-US",
                          {
                            year: "numeric",
                            month: "long",
                            day: "numeric",
                          }
                        )}
                      </div>
                      {user.validatedBy && (
                        <div className="text-xs text-muted-foreground">
                          by {user.validatedBy.name}
                        </div>
                      )}
                    </div>
                  )}
                </CardContent>
              </Card>
            </div>
          </div>

          {/* Form Actions */}
          <div className="flex items-center justify-end gap-4 pt-6 border-t">
            <Button
              type="button"
              variant="outline"
              onClick={() => router.push(`/users/${userId}`)}
              disabled={loading}
            >
              Cancel
            </Button>
            <Button
              type="button"
              variant="outline"
              onClick={() => reset()}
              disabled={loading || !isDirty}
            >
              Reset Changes
            </Button>
            <Button
              type="button"
              onClick={handleFormSubmit}
              disabled={loading || !isDirty}
            >
              {loading && (
                <Icon
                  icon="heroicons:arrow-path"
                  className="mr-2 h-4 w-4 animate-spin"
                />
              )}
              Save Changes
            </Button>
          </div>
        </div>

        {/* Password Change Dialog */}
        {canChangePassword && (
          <AlertDialog
            open={showPasswordDialog}
            onOpenChange={setShowPasswordDialog}
          >
            <AlertDialogContent>
              <AlertDialogHeader>
                <AlertDialogTitle>Change Password</AlertDialogTitle>
                <AlertDialogDescription>
                  Enter the current password and a new password for {user.name}.
                </AlertDialogDescription>
              </AlertDialogHeader>

              <div className="space-y-4">
                <div className="space-y-2">
                  <Label>Current Password</Label>
                  <Input
                    type="password"
                    value={passwordForm.currentPassword}
                    onChange={(e) =>
                      setPasswordForm((prev) => ({
                        ...prev,
                        currentPassword: e.target.value,
                      }))
                    }
                    placeholder="Enter current password"
                  />
                </div>
                <div className="space-y-2">
                  <Label>New Password</Label>
                  <Input
                    type="password"
                    value={passwordForm.newPassword}
                    onChange={(e) =>
                      setPasswordForm((prev) => ({
                        ...prev,
                        newPassword: e.target.value,
                      }))
                    }
                    placeholder="Enter new password"
                  />
                </div>
                <div className="space-y-2">
                  <Label>Confirm New Password</Label>
                  <Input
                    type="password"
                    value={passwordForm.confirmPassword}
                    onChange={(e) =>
                      setPasswordForm((prev) => ({
                        ...prev,
                        confirmPassword: e.target.value,
                      }))
                    }
                    placeholder="Confirm new password"
                  />
                </div>
              </div>

              <AlertDialogFooter>
                <AlertDialogCancel>Cancel</AlertDialogCancel>
                <AlertDialogAction
                  onClick={handlePasswordChange}
                  disabled={passwordLoading}
                >
                  {passwordLoading && (
                    <Icon
                      icon="heroicons:arrow-path"
                      className="mr-2 h-4 w-4 animate-spin"
                    />
                  )}
                  Change Password
                </AlertDialogAction>
              </AlertDialogFooter>
            </AlertDialogContent>
          </AlertDialog>
        )}
      </div>
    </ProtectedRoute>
  );
};
export default UpdateUserPage;
-----------------------------------------------------------------------
--++--> app/[locale]/(protected)/users/create/page.tsx =======>
-----------------------------------------------------------------------
"use client";
import React, { useState, useEffect } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { useRouter } from "next/navigation";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";
import { Badge } from "@/components/ui/badge";
import { Icon } from "@/components/ui/icon";
import { Alert, AlertDescription } from "@/components/ui/alert";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { Link } from "@/i18n/routing";
import { usersApiClient } from "@/lib/api/clients/auth/users.client";
import { useAuthStore } from "@/lib/stores/auth/auth.store";
import { toast } from "sonner";
import { cn } from "@/lib/utils/ui.utils";
import { ProtectedRoute } from "@/components/route/protected-route";
import { USER_PERMISSIONS } from "@/lib/constants/auth";
// Form schema
const createUserSchema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters"),
  email: z.string().email("Please enter a valid email address"),
  userType: z.enum(
    [
      "ADMIN",
      "MANAGER",
      "SUPPORT",
      "SELLER",
      "LIVREUR",
      "CUSTOMER",
      "BUYER",
      "VENDOR",
      "WAREHOUSE",
      "DISPATCHER",
    ],
    {
      required_error: "Please select a user type",
    }
  ),
  phone: z.string().optional(),
  city: z.string().optional(),
  roleId: z.string().optional(),
  profile: z
    .object({
      department: z.string().optional(),
      notes: z.string().optional(),
    })
    .optional(),
  isActive: z.boolean().default(true),
});
type CreateUserFormData = z.infer<typeof createUserSchema>;
// User type configurations
const userTypeConfig = {
  ADMIN: {
    label: "Admin",
    description: "Full system access and management",
    color: "destructive" as const,
    icon: "heroicons:shield-check",
    requiredUserTypes: ["ADMIN"], // Only ADMINs can create ADMINs
  },
  MANAGER: {
    label: "Manager",
    description: "Team and operations management",
    color: "warning" as const,
    icon: "heroicons:user-group",
    requiredUserTypes: ["ADMIN", "MANAGER"], // ADMINs and MANAGERs can create MANAGERs
  },
  SUPPORT: {
    label: "Support",
    description: "Customer support and assistance",
    color: "info" as const,
    icon: "heroicons:chat-bubble-left-right",
    requiredUserTypes: ["ADMIN", "MANAGER"],
  },
  SELLER: {
    label: "Seller",
    description: "Sales and client management",
    color: "success" as const,
    icon: "heroicons:currency-dollar",
    requiredUserTypes: ["ADMIN", "MANAGER"],
  },
  LIVREUR: {
    label: "Delivery",
    description: "Package delivery and logistics",
    color: "secondary" as const,
    icon: "heroicons:truck",
    requiredUserTypes: ["ADMIN", "MANAGER"],
  },
  CUSTOMER: {
    label: "Customer",
    description: "External customer account",
    color: "primary" as const,
    icon: "heroicons:user",
    requiredUserTypes: ["ADMIN", "MANAGER", "SUPPORT"],
  },
  BUYER: {
    label: "Buyer",
    description: "Purchasing and procurement",
    color: "success" as const,
    icon: "heroicons:shopping-cart",
    requiredUserTypes: ["ADMIN", "MANAGER"],
  },
  VENDOR: {
    label: "Vendor",
    description: "External vendor/supplier",
    color: "warning" as const,
    icon: "heroicons:building-storefront",
    requiredUserTypes: ["ADMIN", "MANAGER"],
  },
  WAREHOUSE: {
    label: "Warehouse",
    description: "Inventory and warehouse management",
    color: "secondary" as const,
    icon: "heroicons:building-office-2",
    requiredUserTypes: ["ADMIN", "MANAGER"],
  },
  DISPATCHER: {
    label: "Dispatcher",
    description: "Logistics coordination",
    color: "info" as const,
    icon: "heroicons:map",
    requiredUserTypes: ["ADMIN", "MANAGER"],
  },
};
const CreateUserPageContent = () => {
  const router = useRouter();
  const { hasPermission, user } = useAuthStore();
  const [loading, setLoading] = useState(false);
  const [roles, setRoles] = useState<
    Array<{
      id: string;
      name: string;
      description?: string;
      userTypes: string[];
    }>
  >([]);

  // Check permissions
  const canCreateUsers = hasPermission(USER_PERMISSIONS.CREATE_USER);

  const {
    register,
    handleSubmit,
    watch,
    setValue,
    formState: { errors },
    reset,
  } = useForm<CreateUserFormData>({
    resolver: zodResolver(createUserSchema),
    defaultValues: {
      isActive: true,
      profile: {
        department: "",
        notes: "",
      },
    },
  });

  const watchedUserType = watch("userType");

  // Check if current user can create the selected user type
  const canCreateUserType = (targetUserType: string) => {
    if (!user?.userType || !targetUserType) return false;

    const config =
      userTypeConfig[targetUserType as keyof typeof userTypeConfig];
    return config?.requiredUserTypes.includes(user.userType) || false;
  };

  // Filter user types based on current user's permissions
  const availableUserTypes = Object.entries(userTypeConfig).filter(
    ([key, config]) => canCreateUserType(key)
  );

  // Fetch available roles
  useEffect(() => {
    const fetchRoles = async () => {
      try {
        // Mock data for now - replace with actual API call
        setRoles([
          {
            id: "1",
            name: "System Admin",
            description: "Full system access",
            userTypes: ["ADMIN"],
          },
          {
            id: "2",
            name: "Operations Manager",
            description: "Operations oversight",
            userTypes: ["MANAGER"],
          },
          {
            id: "cmfayo10k0006584key16cnw2",
            name: "Sales Representative",
            description: "Sales operations",
            userTypes: ["SELLER"],
          },
          {
            id: "4",
            name: "Support Agent",
            description: "Customer support",
            userTypes: ["SUPPORT"],
          },
          {
            id: "5",
            name: "Delivery Driver",
            description: "Package delivery",
            userTypes: ["LIVREUR"],
          },
          {
            id: "6",
            name: "Standard Customer",
            description: "Customer access",
            userTypes: ["CUSTOMER"],
          },
          {
            id: "7",
            name: "Procurement Officer",
            description: "Purchasing operations",
            userTypes: ["BUYER"],
          },
          {
            id: "8",
            name: "Vendor Account",
            description: "Vendor portal access",
            userTypes: ["VENDOR"],
          },
          {
            id: "9",
            name: "Warehouse Staff",
            description: "Inventory management",
            userTypes: ["WAREHOUSE"],
          },
          {
            id: "10",
            name: "Logistics Coordinator",
            description: "Dispatch operations",
            userTypes: ["DISPATCHER"],
          },
        ]);
      } catch (error) {
        console.error("Failed to fetch roles:", error);
      }
    };

    fetchRoles();
  }, []);

  // Filter roles based on selected user type
  const availableRoles = roles.filter((role) =>
    watchedUserType ? role.userTypes.includes(watchedUserType) : true
  );

  // Handle user type change
  useEffect(() => {
    if (watchedUserType && availableRoles.length > 0) {
      setValue("roleId", availableRoles[0].id);
    }
  }, [watchedUserType, availableRoles, setValue]);

  const onSubmit = async (data: CreateUserFormData) => {
    if (!canCreateUsers) {
      toast.error("You don't have permission to create users");
      return;
    }

    // Additional check: verify user can create this specific user type
    if (!canCreateUserType(data.userType)) {
      toast.error(`You don't have permission to create ${data.userType} users`);
      return;
    }

    setLoading(true);
    try {
      const result = await usersApiClient.createUser({
        ...data,
        profile: data.profile || {},
      });

      if (result.success) {
        toast.success(
          "User created successfully! Password reset email has been sent."
        );
        router.push("/users");
      } else {
        toast.error(result.error?.message || "Failed to create user");
      }
    } catch (error) {
      console.error("Error creating user:", error);
      toast.error("An unexpected error occurred");
    } finally {
      setLoading(false);
    }
  };

  const handleFormSubmit = () => {
    handleSubmit(onSubmit)();
  };

  if (!canCreateUsers) {
    return (
      <div className="container mx-auto py-8">
        <Alert color="destructive">
          <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
          <AlertDescription>
            You don't have permission to create users. Please contact your
            administrator.
          </AlertDescription>
        </Alert>
      </div>
    );
  }

  return (
    <div className="container mx-auto py-6 space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-default-900">
            Create New User
          </h1>
          <p className="text-default-600">
            Add a new user to your system. They will receive an email with login
            instructions.
          </p>
        </div>
        <Link href="/users">
          <Button variant="outline">
            <Icon icon="heroicons:arrow-left" className="w-4 h-4 mr-2" />
            Back to Users
          </Button>
        </Link>
      </div>

      {/* Permissions Alert */}
      {availableUserTypes.length === 0 && (
        <Alert color="warning">
          <Icon icon="heroicons:information-circle" className="h-4 w-4" />
          <AlertDescription>
            You don't have permission to create any user types. Please contact
            your administrator.
          </AlertDescription>
        </Alert>
      )}

      {/* Info Alert */}
      <Alert color="info" variant="soft">
        <Icon icon="heroicons:information-circle" className="h-4 w-4" />
        <AlertDescription>
          The user will be created with INACTIVE status and will receive an
          email with password reset instructions to complete their account
          setup.
        </AlertDescription>
      </Alert>

      {/* Current User Permissions Info */}
      {process.env.NODE_ENV === "development" && (
        <Alert color="info" variant="soft">
          <Icon icon="heroicons:code-bracket" className="h-4 w-4" />
          <AlertDescription>
            <div>
              Your user type ({user?.userType}) can create:{" "}
              {availableUserTypes
                .map(([key, config]) => config.label)
                .join(", ") || "None"}
            </div>
          </AlertDescription>
        </Alert>
      )}

      <div className="space-y-6">
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          {/* Main Information */}
          <div className="lg:col-span-2 space-y-6">
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:user" className="w-5 h-5" />
                  Basic Information
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                {/* Name */}
                <div className="space-y-2">
                  <Label
                    htmlFor="name"
                    className={cn("", { "text-destructive": errors.name })}
                  >
                    Full Name *
                  </Label>
                  <Input
                    id="name"
                    {...register("name")}
                    placeholder="Enter full name"
                    className={cn("", {
                      "border-destructive focus:border-destructive":
                        errors.name,
                    })}
                  />
                  {errors.name && (
                    <p className="text-xs text-destructive">
                      {errors.name.message}
                    </p>
                  )}
                </div>

                {/* Email */}
                <div className="space-y-2">
                  <Label
                    htmlFor="email"
                    className={cn("", { "text-destructive": errors.email })}
                  >
                    Email Address *
                  </Label>
                  <Input
                    id="email"
                    type="email"
                    {...register("email")}
                    placeholder="user@example.com"
                    className={cn("", {
                      "border-destructive focus:border-destructive":
                        errors.email,
                    })}
                  />
                  {errors.email && (
                    <p className="text-xs text-destructive">
                      {errors.email.message}
                    </p>
                  )}
                </div>

                {/* Phone and City */}
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div className="space-y-2">
                    <Label htmlFor="phone">Phone Number</Label>
                    <Input
                      id="phone"
                      {...register("phone")}
                      placeholder="+1 (555) 123-4567"
                    />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="city">City</Label>
                    <Input
                      id="city"
                      {...register("city")}
                      placeholder="Enter city"
                    />
                  </div>
                </div>
              </CardContent>
            </Card>

            {/* User Type and Role */}
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:identification" className="w-5 h-5" />
                  User Type & Role
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                {/* User Type */}
                <div className="space-y-2">
                  <Label
                    className={cn("", { "text-destructive": errors.userType })}
                  >
                    User Type *
                  </Label>
                  <Select
                    onValueChange={(value) =>
                      setValue("userType", value as any)
                    }
                    disabled={availableUserTypes.length === 0}
                  >
                    <SelectTrigger
                      className={cn("", {
                        "border-destructive": errors.userType,
                      })}
                    >
                      <SelectValue placeholder="Select user type" />
                    </SelectTrigger>
                    <SelectContent>
                      {availableUserTypes.map(([key, config]) => (
                        <SelectItem key={key} value={key}>
                          <div className="flex items-center gap-3">
                            <Icon icon={config.icon} className="w-4 h-4" />
                            <div>
                              <div className="font-medium">{config.label}</div>
                              <div className="text-xs text-muted-foreground">
                                {config.description}
                              </div>
                            </div>
                          </div>
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                  {errors.userType && (
                    <p className="text-xs text-destructive">
                      {errors.userType.message}
                    </p>
                  )}

                  {/* Show selected user type badge */}
                  {watchedUserType && (
                    <div className="mt-2">
                      <Badge
                        color={
                          userTypeConfig[
                            watchedUserType as keyof typeof userTypeConfig
                          ]?.color
                        }
                      >
                        <Icon
                          icon={
                            userTypeConfig[
                              watchedUserType as keyof typeof userTypeConfig
                            ]?.icon
                          }
                          className="w-3 h-3 mr-1"
                        />
                        {
                          userTypeConfig[
                            watchedUserType as keyof typeof userTypeConfig
                          ]?.label
                        }
                      </Badge>
                    </div>
                  )}

                  {/* Show permission warning for selected user type */}
                  {watchedUserType && !canCreateUserType(watchedUserType) && (
                    <Alert color="warning" variant="soft">
                      <Icon
                        icon="heroicons:exclamation-triangle"
                        className="h-4 w-4"
                      />
                      <AlertDescription>
                        You don't have permission to create{" "}
                        {
                          userTypeConfig[
                            watchedUserType as keyof typeof userTypeConfig
                          ]?.label
                        }{" "}
                        users.
                      </AlertDescription>
                    </Alert>
                  )}
                </div>

                {/* Role Selection */}
                {watchedUserType && canCreateUserType(watchedUserType) && (
                  <div className="space-y-2">
                    <Label>
                      Role
                      <TooltipProvider>
                        <Tooltip>
                          <TooltipTrigger asChild>
                            <Icon
                              icon="heroicons:information-circle"
                              className="w-4 h-4 ml-1 text-muted-foreground"
                            />
                          </TooltipTrigger>
                          <TooltipContent>
                            <p>
                              Roles define specific permissions for the selected
                              user type
                            </p>
                          </TooltipContent>
                        </Tooltip>
                      </TooltipProvider>
                    </Label>
                    <Select
                      onValueChange={(value) => setValue("roleId", value)}
                    >
                      <SelectTrigger>
                        <SelectValue placeholder="Select role" />
                      </SelectTrigger>
                      <SelectContent>
                        {availableRoles.map((role) => (
                          <SelectItem key={role.id} value={role.id}>
                            <div>
                              <div className="font-medium">{role.name}</div>
                              {role.description && (
                                <div className="text-xs text-muted-foreground">
                                  {role.description}
                                </div>
                              )}
                            </div>
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>
                )}
              </CardContent>
            </Card>

            {/* Additional Information */}
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:document-text" className="w-5 h-5" />
                  Additional Information
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="space-y-2">
                  <Label htmlFor="department">Department</Label>
                  <Input
                    id="department"
                    {...register("profile.department")}
                    placeholder="e.g., Sales, Marketing, IT"
                  />
                </div>

                <div className="space-y-2">
                  <Label htmlFor="notes">Notes</Label>
                  <Textarea
                    id="notes"
                    {...register("profile.notes")}
                    placeholder="Any additional notes about this user..."
                    rows={3}
                  />
                </div>
              </CardContent>
            </Card>
          </div>

          {/* Settings Sidebar */}
          <div className="space-y-6">
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:cog-6-tooth" className="w-5 h-5" />
                  Account Settings
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="flex items-center justify-between">
                  <div className="space-y-0.5">
                    <Label>Active Account</Label>
                    <p className="text-xs text-muted-foreground">
                      Allow user to access the system
                    </p>
                  </div>
                  <Switch {...register("isActive")} defaultChecked={true} />
                </div>
              </CardContent>
            </Card>

            {/* Preview Card */}
            {watchedUserType && (
              <Card>
                <CardHeader>
                  <CardTitle className="flex items-center gap-2">
                    <Icon icon="heroicons:eye" className="w-5 h-5" />
                    Preview
                  </CardTitle>
                </CardHeader>
                <CardContent className="space-y-3">
                  <div className="text-sm">
                    <span className="text-muted-foreground">User Type:</span>
                    <div className="mt-1">
                      <Badge
                        color={
                          userTypeConfig[
                            watchedUserType as keyof typeof userTypeConfig
                          ]?.color
                        }
                      >
                        {
                          userTypeConfig[
                            watchedUserType as keyof typeof userTypeConfig
                          ]?.label
                        }
                      </Badge>
                    </div>
                  </div>

                  <div className="text-sm">
                    <span className="text-muted-foreground">
                      Initial Status:
                    </span>
                    <div className="mt-1">
                      <Badge color="secondary">INACTIVE</Badge>
                    </div>
                  </div>

                  <div className="text-sm text-muted-foreground">
                    User will receive an email with password setup instructions.
                  </div>
                </CardContent>
              </Card>
            )}

            {/* Current User Permissions Card */}
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:shield-check" className="w-5 h-5" />
                  Your Permissions
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-3">
                <div className="text-sm">
                  <span className="text-muted-foreground">Your User Type:</span>
                  <div className="mt-1">
                    <Badge color="primary">{user?.userType}</Badge>
                  </div>
                </div>

                <div className="text-sm">
                  <span className="text-muted-foreground">Can Create:</span>
                  <div className="mt-1 space-y-1">
                    {availableUserTypes.length > 0 ? (
                      availableUserTypes.map(([key, config]) => (
                        <Badge
                          key={key}
                          color={config.color}
                          className="mr-1 mb-1"
                        >
                          {config.label}
                        </Badge>
                      ))
                    ) : (
                      <span className="text-xs text-muted-foreground">
                        No user types available
                      </span>
                    )}
                  </div>
                </div>
              </CardContent>
            </Card>

            {/* Help Card */}
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon
                    icon="heroicons:question-mark-circle"
                    className="w-5 h-5"
                  />
                  Need Help?
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-3">
                <p className="text-sm text-muted-foreground">
                  Learn more about user creation and management in our
                  documentation.
                </p>
                <Button variant="outline" size="md" className="w-full">
                  <Icon icon="heroicons:book-open" className="w-4 h-4 mr-2" />
                  View Documentation
                </Button>
              </CardContent>
            </Card>
          </div>
        </div>

        {/* Form Actions */}
        <div className="flex items-center justify-end gap-4 pt-6 border-t">
          <Button
            type="button"
            variant="outline"
            onClick={() => router.push("/users")}
            disabled={loading}
          >
            Cancel
          </Button>
          <Button
            type="button"
            variant="outline"
            onClick={() => reset()}
            disabled={loading}
          >
            Reset Form
          </Button>
          <Button
            type="button"
            onClick={handleFormSubmit}
            disabled={
              loading ||
              availableUserTypes.length === 0 ||
              (watchedUserType && !canCreateUserType(watchedUserType))
            }
          >
            {loading && (
              <Icon
                icon="heroicons:arrow-path"
                className="mr-2 h-4 w-4 animate-spin"
              />
            )}
            Create User
          </Button>
        </div>
      </div>
    </div>
  );
};
// Main component wrapped with ProtectedRoute
const CreateUserPage = () => {
  return (
    <ProtectedRoute
      requiredPermissions={[USER_PERMISSIONS.CREATE_USER]}
      requiredAccessLevel="FULL"
      allowedAccountStatuses={["ACTIVE"]}
      requireValidation={true}
    >
      <CreateUserPageContent />
    </ProtectedRoute>
  );
};
export default CreateUserPage;
-----------------------------------------------------------------------
--++--> app/[locale]/[...not-found]/page.tsx
--++--> app/[locale]/auth/forgot-password/page.tsx
--++--> app/[locale]/auth/login/page.tsx
--++--> app/[locale]/auth/register/page.tsx
--++--> app/[locale]/auth/reset-password/page.tsx
-----------------------------------------------------------------------
Components Folder:
-----------------------------------------------------------------------
--++--> components/route/protected-route.tsx =======>
-----------------------------------------------------------------------
"use client";
import { useEffect, useState, useRef, useMemo, useCallback } from "react";
import { useRouter, usePathname } from "next/navigation";
import { useAuthStore } from "@/lib/stores/auth/auth.store";
import { useTenantStore } from "@/lib/stores/auth/tenant.store";
import { toast } from "sonner";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Button } from "@/components/ui/button";
import {
  AlertCircle,
  Info,
  CheckCircle,
  Clock,
  Shield,
  UserX,
} from "lucide-react";
interface ProtectedRouteProps {
  children: React.ReactNode;
  requiredRoles?: string[];
  requiredPermissions?: string[];
  requiredUserTypes?: string[]; // Added this line
  requiredAccessLevel?: "NO_ACCESS" | "PROFILE_ONLY" | "LIMITED" | "FULL";
  allowedAccountStatuses?: string[];
  requireValidation?: boolean;
}
interface AccessResult {
  allowed: boolean;
  reason?: string;
  redirectTo?: string;
  showMessage?: boolean;
  messageType?: "info" | "warning" | "error";
}
// Constants
const ACCESS_LEVELS = ["NO_ACCESS", "PROFILE_ONLY", "LIMITED", "FULL"] as const;
const STATUS_CONFIGS = {
  PENDING: {
    icon: Clock,
    color: "text-blue-600",
    message:
      "Your account is pending admin approval. You'll receive an email notification once approved.",
    action: null,
  },
  INACTIVE: {
    icon: Info,
    color: "text-orange-600",
    message:
      "Please complete your profile information to activate your account.",
    action: { label: "Complete Profile", path: "/profile/complete" },
  },
  PENDING_VALIDATION: {
    icon: Shield,
    color: "text-yellow-600",
    message:
      "Your profile is under review. You have limited access until validation is complete.",
    action: null,
  },
  ACTIVE: {
    icon: CheckCircle,
    color: "text-green-600",
    message: "Your account is fully active and validated.",
    action: null,
  },
  REJECTED: {
    icon: UserX,
    color: "text-red-600",
    message:
      "Your account has been rejected. Please contact support for assistance.",
    action: { label: "Contact Support", path: "/contact" },
  },
  SUSPENDED: {
    icon: UserX,
    color: "text-red-600",
    message: "Your account has been suspended. Please contact support.",
    action: { label: "Contact Support", path: "/contact" },
  },
} as const;
const BLOCKED_REASONS = {
  PENDING: "Your account is pending admin approval",
  REJECTED: "Your account has been rejected. Please contact support",
  SUSPENDED: "Your account has been suspended. Please contact support",
} as const;
export function ProtectedRoute({
  children,
  requiredRoles = [],
  requiredPermissions = [],
  requiredUserTypes = [], // Added this line
  requiredAccessLevel,
  allowedAccountStatuses = [],
  requireValidation = false,
}: ProtectedRouteProps) {
  const router = useRouter();
  const pathname = usePathname();
  const [isInitialized, setIsInitialized] = useState(false);
  const [accessResult, setAccessResult] = useState<AccessResult>({
    allowed: false,
  });
  const initRef = useRef(false);
  const lastCheckRef = useRef<string>("");

  // Stable selectors to prevent unnecessary re-renders
  const isAuthenticated = useAuthStore((state) => state.isAuthenticated);
  const isLoading = useAuthStore((state) => state.isLoading);
  const user = useAuthStore((state) => state.user);
  const error = useAuthStore((state) => state.error);
  const isCheckingAuth = useAuthStore((state) => state.isCheckingAuth);
  const accountStatus = useAuthStore((state) => state.accountStatus);
  const validationStatus = useAuthStore((state) => state.validationStatus);
  const accessLevel = useAuthStore((state) => state.accessLevel);
  const requirements = useAuthStore((state) => state.requirements);
  const hasBlueCheckmark = useAuthStore((state) => state.hasBlueCheckmark);

  // Stable method references
  const checkAuth = useAuthStore((state) => state.checkAuth);
  const isAccountBlocked = useAuthStore((state) => state.isAccountBlocked);
  const needsProfileCompletion = useAuthStore(
    (state) => state.needsProfileCompletion
  );
  const needsValidation = useAuthStore((state) => state.needsValidation);
  const hasRole = useAuthStore((state) => state.hasRole);
  const hasAnyPermission = useAuthStore((state) => state.hasAnyPermission);
  const hasUserType = useAuthStore((state) => state.hasUserType); // Added this line

  const { fetchCurrentTenant, currentTenant } = useTenantStore();

  // Stable access check function with useCallback
  const checkAccess = useCallback((): AccessResult => {
    // Not authenticated
    if (!isAuthenticated || !user) {
      return {
        allowed: false,
        redirectTo: "/auth/login",
        reason: "Authentication required",
      };
    }

    // Account blocked scenarios
    if (isAccountBlocked()) {
      const status = accountStatus;
      const reason = status
        ? BLOCKED_REASONS[status as keyof typeof BLOCKED_REASONS]
        : "Access denied";
      const messageType = status === "PENDING" ? "info" : "error";

      return {
        allowed: false,
        redirectTo: "/auth/login",
        reason,
        showMessage: true,
        messageType,
      };
    }

    // Profile completion check
    if (needsProfileCompletion()) {
      if (
        pathname.includes("/profile/complete") ||
        pathname.includes("/auth")
      ) {
        return { allowed: true };
      }

      return {
        allowed: false,
        redirectTo: "/profile/complete",
        reason: "Please complete your profile to continue",
        showMessage: true,
        messageType: "info",
      };
    }

    // Access level check
    if (requiredAccessLevel) {
      const requiredIndex = ACCESS_LEVELS.indexOf(requiredAccessLevel);
      const currentIndex = ACCESS_LEVELS.indexOf(accessLevel || "NO_ACCESS");

      if (currentIndex < requiredIndex) {
        const isValidationRequired =
          requiredAccessLevel === "FULL" && needsValidation();
        const reason = isValidationRequired
          ? "This feature requires profile validation"
          : "Insufficient access level";

        return {
          allowed: false,
          redirectTo: "/dashboard",
          reason,
          showMessage: true,
          messageType: "warning",
        };
      }
    }

    // Account status check
    if (allowedAccountStatuses.length > 0 && accountStatus) {
      if (!allowedAccountStatuses.includes(accountStatus)) {
        return {
          allowed: false,
          redirectTo: "/dashboard",
          reason: "Your account status does not allow access to this feature",
          showMessage: true,
          messageType: "warning",
        };
      }
    }

    // Validation requirement check
    if (requireValidation && validationStatus !== "VALIDATED") {
      return {
        allowed: false,
        redirectTo: "/dashboard",
        reason: "This feature requires a validated account",
        showMessage: true,
        messageType: "warning",
      };
    }

    // User type check (Added this section)
    if (requiredUserTypes.length > 0) {
      const hasRequiredUserType = requiredUserTypes.some(
        (userType) => user.userType === userType
      );
      if (!hasRequiredUserType) {
        return {
          allowed: false,
          redirectTo: "/unauthorized",
          reason: "Access restricted to specific user types",
          showMessage: true,
          messageType: "error",
        };
      }
    }

    // Role check
    if (requiredRoles.length > 0) {
      const hasRequiredRole = requiredRoles.some((role) => hasRole(role));
      if (!hasRequiredRole) {
        return {
          allowed: false,
          redirectTo: "/unauthorized",
          reason: "Insufficient role permissions",
          showMessage: true,
          messageType: "error",
        };
      }
    }

    // Permission check
    if (requiredPermissions.length > 0) {
      const hasRequiredPermissions = hasAnyPermission(requiredPermissions);
      if (!hasRequiredPermissions) {
        return {
          allowed: false,
          redirectTo: "/unauthorized",
          reason: "Insufficient permissions",
          showMessage: true,
          messageType: "error",
        };
      }
    }

    return { allowed: true };
  }, [
    isAuthenticated,
    user,
    isAccountBlocked,
    accountStatus,
    needsProfileCompletion,
    pathname,
    accessLevel,
    requiredAccessLevel,
    needsValidation,
    allowedAccountStatuses,
    requireValidation,
    validationStatus,
    requiredUserTypes, // Added this line
    requiredRoles,
    hasRole,
    requiredPermissions,
    hasAnyPermission,
  ]);

  // Create a unique key for the current state to prevent unnecessary re-checks
  const stateKey = useMemo(() => {
    return [
      isAuthenticated,
      user?.id,
      user?.userType, // Added this line
      accountStatus,
      validationStatus,
      accessLevel,
      pathname,
      requiredAccessLevel,
      JSON.stringify(allowedAccountStatuses),
      requireValidation,
      JSON.stringify(requiredUserTypes), // Added this line
      JSON.stringify(requiredRoles),
      JSON.stringify(requiredPermissions),
    ].join("|");
  }, [
    isAuthenticated,
    user?.id,
    user?.userType, // Added this line
    accountStatus,
    validationStatus,
    accessLevel,
    pathname,
    requiredAccessLevel,
    allowedAccountStatuses,
    requireValidation,
    requiredUserTypes, // Added this line
    requiredRoles,
    requiredPermissions,
  ]);

  // Initialize authentication - only once
  useEffect(() => {
    if (initRef.current) return;
    initRef.current = true;

    const initialize = async () => {
      try {
        if (!isCheckingAuth) {
          await checkAuth();
        }

        // Fetch tenant data if authenticated and not loaded
        if (isAuthenticated && user && !currentTenant) {
          await fetchCurrentTenant().catch(console.error);
        }
      } catch (error) {
        console.error("Auth initialization failed:", error);
      } finally {
        setIsInitialized(true);
      }
    };

    initialize();
  }, []); // Empty dependency array - only run once

  // Check access when state changes
  useEffect(() => {
    if (!isInitialized || isLoading || isCheckingAuth) return;

    // Prevent unnecessary re-checks
    if (lastCheckRef.current === stateKey) return;
    lastCheckRef.current = stateKey;

    const result = checkAccess();
    setAccessResult(result);
  }, [isInitialized, isLoading, isCheckingAuth, stateKey, checkAccess]);

  // Handle redirects and messages - separate effect to prevent loops
  useEffect(() => {
    if (!isInitialized || isLoading || isCheckingAuth || accessResult.allowed) {
      return;
    }

    // Only show message and redirect if we have a valid access result
    if (accessResult.reason) {
      if (accessResult.showMessage) {
        const toastFn = {
          error: toast.error,
          warning: toast.warning,
          info: toast.info,
        }[accessResult.messageType || "info"];

        toastFn(accessResult.reason);
      }

      if (accessResult.redirectTo) {
        router.replace(accessResult.redirectTo);
      }
    }
  }, [
    accessResult.allowed,
    accessResult.reason,
    accessResult.redirectTo,
    accessResult.showMessage,
    accessResult.messageType,
    isInitialized,
    isLoading,
    isCheckingAuth,
    router,
  ]);

  // Loading state
  if (!isInitialized || isLoading || isCheckingAuth) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center space-y-4">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto" />
          <p className="text-muted-foreground">Initializing...</p>
        </div>
      </div>
    );
  }

  // Error state
  if (error) {
    return (
      <div className="flex items-center justify-center min-h-screen p-4">
        <div className="max-w-md w-full space-y-6 text-center">
          <Alert variant="outline">
            <AlertCircle className="h-4 w-4" />
            <AlertDescription>
              <div className="font-medium">Authentication Error</div>
              <div className="text-sm mt-1">{error}</div>
            </AlertDescription>
          </Alert>
          <Button
            onClick={() => {
              initRef.current = false;
              window.location.reload();
            }}
            className="w-full"
          >
            Retry
          </Button>
        </div>
      </div>
    );
  }

  // Access denied state
  if (!accessResult.allowed) {
    const statusConfig = accountStatus
      ? STATUS_CONFIGS[accountStatus as keyof typeof STATUS_CONFIGS]
      : null;

    const IconComponent = statusConfig?.icon || AlertCircle;

    return (
      <div className="flex items-center justify-center min-h-screen p-4">
        <div className="max-w-md w-full space-y-6 text-center">
          <div className="flex justify-center">
            <div className="rounded-full bg-default-100 p-3">
              <IconComponent
                className={`h-12 w-12 ${
                  statusConfig?.color || "text-gray-600"
                }`}
              />
            </div>
          </div>

          <div className="space-y-3">
            <h3 className="text-xl font-semibold text-default-900">
              Access Status
            </h3>
            <p className="text-sm text-default-600 leading-relaxed">
              {statusConfig?.message || accessResult.reason || "Access denied"}
            </p>

            {hasBlueCheckmark && (
              <div className="flex items-center justify-center gap-2 text-sm text-green-600">
                <CheckCircle className="h-4 w-4" />
                Verified Account
              </div>
            )}

            {requirements.length > 0 && (
              <div className="text-left">
                <div className="text-sm font-medium text-default-700 mb-2">
                  Requirements:
                </div>
                <ul className="text-xs text-default-600 space-y-1">
                  {requirements.map((req, index) => (
                    <li key={index} className="flex items-center gap-2">
                      <div className="w-1.5 h-1.5 rounded-full bg-default-400" />
                      {req}
                    </li>
                  ))}
                </ul>
              </div>
            )}
          </div>

          <div className="space-y-3">
            {statusConfig?.action && (
              <Button
                onClick={() => router.push(statusConfig.action!.path)}
                className="w-full"
              >
                {statusConfig.action.label}
              </Button>
            )}

            <Button
              variant="outline"
              onClick={() => router.push("/auth/login")}
              className="w-full"
            >
              Back to Login
            </Button>
          </div>

          {process.env.NODE_ENV === "development" && (
            <div className="mt-4 p-3 bg-muted rounded-lg text-xs text-left text-muted-foreground">
              <strong>Dev Info:</strong>
              <br />
              <strong>Account Status:</strong> {accountStatus}
              <br />
              <strong>Validation Status:</strong> {validationStatus}
              <br />
              <strong>Access Level:</strong> {accessLevel}
              <br />
              <strong>Required Access:</strong> {requiredAccessLevel || "Any"}
              <br />
              <strong>Required User Types:</strong>{" "}
              {requiredUserTypes.length > 0
                ? requiredUserTypes.join(", ")
                : "Any"}
              <br />
              <strong>Current User Type:</strong> {user?.userType || "None"}
              <br />
              <strong>Reason:</strong> {accessResult.reason}
            </div>
          )}
        </div>
      </div>
    );
  }

  return <>{children}</>;
}
-----------------------------------------------------------------------
--++--> components/users/users-table.tsx =======>
-----------------------------------------------------------------------
import * as React from "react";
import {
  ColumnDef,
  ColumnFiltersState,
  SortingState,
  VisibilityState,
  flexRender,
  getCoreRowModel,
  getFilteredRowModel,
  getPaginationRowModel,
  getSortedRowModel,
  useReactTable,
} from "@tanstack/react-table";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Checkbox } from "@/components/ui/checkbox";
import { Icon } from "@/components/ui/icon";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Textarea } from "@/components/ui/textarea";
import { Link } from "@/i18n/routing";
import { usersApiClient } from "@/lib/api/clients/auth/users.client";
import { useAuthStore } from "@/lib/stores/auth/auth.store";
import { toast } from "sonner";
import * as XLSX from "xlsx";
// Enhanced Types
interface User {
  id: string;
  email: string;
  name: string;
  userType: string;
  avatar?: string;
  isActive: boolean;
  lastLogin?: string;
  createdAt: string;
  updatedAt: string;
  accountStatus:
    | "PENDING"
    | "INACTIVE"
    | "PENDING_VALIDATION"
    | "ACTIVE"
    | "REJECTED"
    | "SUSPENDED";
  validationStatus: "PENDING" | "VALIDATED" | "REJECTED";
  profileCompleted: boolean;
  validationNotes?: string;
  validatedAt?: string;
  profile?: {
    phone?: string;
    address?: {
      city?: string;
      state?: string;
      country?: string;
    };
    cin?: string;
    cinDocuments?: string[];
    bankDetails?: any;
    profilePhoto?: string;
  };
  role: {
    id: string;
    name: string;
    description?: string;
  };
  tenant: {
    name: string;
    slug: string;
  };
  createdBy?: {
    id: string;
    name: string;
    email: string;
  };
  validatedBy?: {
    id: string;
    name: string;
    email: string;
  };
}
interface UsersResponse {
  data: User[];
  meta: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
}
// Utility function to format dates
const formatDate = (dateString: string, format: "short" | "long" = "short") => {
  const date = new Date(dateString);
  if (format === "short") {
    return date.toLocaleDateString("en-US", {
      month: "short",
      day: "2-digit",
      year: "numeric",
    });
  }
  return date.toLocaleDateString("en-US", {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  });
};
// Simple Table Components
const Table = ({
  children,
  className = "",
}: {
  children: React.ReactNode;
  className?: string;
}) => (
  <table className={`w-full text-left border-collapse ${className}`}>
    {children}
  </table>
);
const TableHeader = ({ children }: { children: React.ReactNode }) => (
  <thead className="bg-gray-50">{children}</thead>
);
const TableBody = ({ children }: { children: React.ReactNode }) => (
  <tbody>{children}</tbody>
);
const TableRow = ({
  children,
  className = "",
  ...props
}: {
  children: React.ReactNode;
  className?: string;
  [key: string]: any;
}) => (
  <tr className={`border-b hover:bg-gray-50 ${className}`} {...props}>
    {children}
  </tr>
);
const TableHead = ({
  children,
  className = "",
}: {
  children: React.ReactNode;
  className?: string;
}) => (
  <th
    className={`px-4 py-3 text-left text-sm font-medium text-gray-900 ${className}`}
  >
    {children}
  </th>
);
const TableCell = ({
  children,
  className = "",
}: {
  children: React.ReactNode;
  className?: string;
}) => (
  <td className={`px-4 py-3 text-sm text-gray-700 ${className}`}>{children}</td>
);
// Status badge components
const AccountStatusBadge = ({ status }: { status: string }) => {
  const statusConfig = {
    PENDING: {
      color: "bg-yellow-100 text-yellow-800",
      label: "Pending Approval",
      icon: "",
    },
    INACTIVE: {
      color: "bg-gray-100 text-gray-800",
      label: "Inactive",
      icon: "",
    },
    PENDING_VALIDATION: {
      color: "bg-blue-100 text-blue-800",
      label: "Pending Validation",
      icon: "",
    },
    ACTIVE: {
      color: "bg-green-100 text-green-800",
      label: "Active",
      icon: "",
    },
    REJECTED: {
      color: "bg-red-100 text-red-800",
      label: "Rejected",
      icon: "",
    },
    SUSPENDED: {
      color: "bg-red-100 text-red-800",
      label: "Suspended",
      icon: "",
    },
  };

  const config =
    statusConfig[status as keyof typeof statusConfig] || statusConfig.INACTIVE;

  return (
    <span
      className={`inline-flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium ${config.color}`}
    >
      <span>{config.icon}</span>
      {config.label}
    </span>
  );
};
const ValidationStatusBadge = ({
  status,
  isValidated,
}: {
  status: string;
  isValidated?: boolean;
}) => {
  if (status === "VALIDATED" && isValidated) {
    return (
      <span className="inline-flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium bg-green-100 text-green-800">
        <span className="text-blue-500"></span>
        Validated
      </span>
    );
  }

  const statusConfig = {
    PENDING: {
      color: "bg-yellow-100 text-yellow-800",
      label: "Pending",
      icon: "",
    },
    VALIDATED: {
      color: "bg-green-100 text-green-800",
      label: "Validated",
      icon: "",
    },
    REJECTED: {
      color: "bg-red-100 text-red-800",
      label: "Rejected",
      icon: "",
    },
  };

  const config =
    statusConfig[status as keyof typeof statusConfig] || statusConfig.PENDING;

  return (
    <span
      className={`inline-flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium ${config.color}`}
    >
      <span>{config.icon}</span>
      {config.label}
    </span>
  );
};
// Enhanced table columns
const createColumns = (
  onDelete: (user: User) => void,
  onApproveRegistration: (user: User) => void,
  onRejectRegistration: (user: User) => void,
  onValidateProfile: (user: User) => void,
  onRejectProfile: (user: User) => void,
  onSuspend: (user: User) => void,
  onReactivate: (user: User) => void,
  hasUpdatePermission: boolean,
  hasDeletePermission: boolean,
  hasApprovePermission: boolean,
  hasValidatePermission: boolean
): ColumnDef<User>[] => [
  {
    id: "select",
    header: ({ table }) => (
      <Checkbox
        checked={
          table.getIsAllPageRowsSelected() ||
          (table.getIsSomePageRowsSelected() && "indeterminate")
        }
        onCheckedChange={(value) => table.toggleAllPageRowsSelected(!!value)}
        aria-label="Select all"
      />
    ),
    cell: ({ row }) => (
      <Checkbox
        checked={row.getIsSelected()}
        onCheckedChange={(value) => row.toggleSelected(!!value)}
        aria-label="Select row"
      />
    ),
    enableSorting: false,
    enableHiding: false,
  },
  {
    accessorKey: "name",
    header: "User",
    cell: ({ row }) => {
      const user = row.original;
      return (
        <div className="flex items-center space-x-3">
          <Avatar size="md" shape="circle">
            <AvatarImage
              src={user.profile?.profilePhoto || user.avatar || ""}
              alt={user.name}
            />
            <AvatarFallback>
              {user.name
                ?.split(" ")
                .map((n) => n[0])
                .join("")
                .toUpperCase() || "U"}
            </AvatarFallback>
          </Avatar>
          <div>
            <div className="font-medium flex items-center gap-2">
              {user.name}
              {user.validationStatus === "VALIDATED" && (
                <span className="text-blue-500" title="Verified Profile">
                  
                </span>
              )}
            </div>
            <div className="text-sm text-gray-500">{user.email}</div>
            {user.profile?.phone && (
              <div className="text-xs text-gray-400">{user.profile.phone}</div>
            )}
          </div>
        </div>
      );
    },
  },
  {
    accessorKey: "userType",
    header: "User Type",
    cell: ({ row }) => {
      const userType = row.getValue("userType") as string;
      const colorMap: Record<string, string> = {
        ADMIN: "bg-red-100 text-red-800",
        MANAGER: "bg-orange-100 text-orange-800",
        SELLER: "bg-blue-100 text-blue-800",
        CUSTOMER: "bg-green-100 text-green-800",
        LIVREUR: "bg-purple-100 text-purple-800",
        SUPPORT: "bg-blue-100 text-blue-800",
        BUYER: "bg-green-100 text-green-800",
        VENDOR: "bg-orange-100 text-orange-800",
        WAREHOUSE: "bg-gray-100 text-gray-800",
        DISPATCHER: "bg-indigo-100 text-indigo-800",
      };
      return (
        <span
          className={`inline-flex px-2 py-1 rounded-full text-xs font-medium capitalize ${
            colorMap[userType] || "bg-gray-100 text-gray-800"
          }`}
        >
          {userType.toLowerCase().replace("_", " ")}
        </span>
      );
    },
  },
  {
    accessorKey: "accountStatus",
    header: "Account Status",
    cell: ({ row }) => {
      const status = row.getValue("accountStatus") as string;
      return <AccountStatusBadge status={status} />;
    },
  },
  {
    accessorKey: "validationStatus",
    header: "Validation",
    cell: ({ row }) => {
      const user = row.original;
      return (
        <ValidationStatusBadge
          status={user.validationStatus}
          isValidated={user.validationStatus === "VALIDATED"}
        />
      );
    },
  },
  {
    accessorKey: "role",
    header: "Role",
    cell: ({ row }) => {
      const role = row.original.role;
      return (
        <div>
          <div className="font-medium capitalize">{role.name}</div>
          {role.description && (
            <div className="text-sm text-gray-500">{role.description}</div>
          )}
        </div>
      );
    },
  },
  {
    accessorKey: "profileCompleted",
    header: "Profile",
    cell: ({ row }) => {
      const completed = row.getValue("profileCompleted") as boolean;
      return (
        <span
          className={`inline-flex px-2 py-1 rounded-full text-xs font-medium ${
            completed
              ? "bg-green-100 text-green-800"
              : "bg-yellow-100 text-yellow-800"
          }`}
        >
          {completed ? "Complete" : "Incomplete"}
        </span>
      );
    },
  },
  {
    accessorKey: "createdAt",
    header: "Created",
    cell: ({ row }) => {
      const user = row.original;
      return (
        <div>
          <div>{formatDate(user.createdAt)}</div>
          {user.createdBy && (
            <div className="text-xs text-gray-500">
              by {user.createdBy.name}
            </div>
          )}
        </div>
      );
    },
  },
  {
    id: "actions",
    header: "Actions",
    enableHiding: false,
    cell: ({ row }) => {
      const user = row.original;

      return (
        <DropdownMenu>
          <DropdownMenuTrigger asChild>
            <Button variant="ghost" size="md">
              <Icon icon="heroicons:ellipsis-horizontal" className="h-4 w-4" />
            </Button>
          </DropdownMenuTrigger>
          <DropdownMenuContent align="end">
            <DropdownMenuItem asChild>
              <Link href={`/users/${user.id}`}>
                <Icon icon="heroicons:eye" className="mr-2 h-4 w-4" />
                View Details
              </Link>
            </DropdownMenuItem>

            {hasUpdatePermission && (
              <DropdownMenuItem asChild>
                <Link href={`/users/${user.id}/edit`}>
                  <Icon
                    icon="heroicons:pencil-square"
                    className="mr-2 h-4 w-4"
                  />
                  Edit User
                </Link>
              </DropdownMenuItem>
            )}

            {/* Registration Approval Actions */}
            {hasApprovePermission && user.accountStatus === "PENDING" && (
              <>
                <DropdownMenuSeparator />
                <DropdownMenuItem onClick={() => onApproveRegistration(user)}>
                  <Icon
                    icon="heroicons:check"
                    className="mr-2 h-4 w-4 text-green-600"
                  />
                  Approve Registration
                </DropdownMenuItem>
                <DropdownMenuItem onClick={() => onRejectRegistration(user)}>
                  <Icon
                    icon="heroicons:x-mark"
                    className="mr-2 h-4 w-4 text-red-600"
                  />
                  Reject Registration
                </DropdownMenuItem>
              </>
            )}

            {/* Profile Validation Actions */}
            {hasValidatePermission &&
              user.accountStatus === "PENDING_VALIDATION" && (
                <>
                  <DropdownMenuSeparator />
                  <DropdownMenuItem onClick={() => onValidateProfile(user)}>
                    <Icon
                      icon="heroicons:shield-check"
                      className="mr-2 h-4 w-4 text-blue-600"
                    />
                    Validate Profile
                  </DropdownMenuItem>
                  <DropdownMenuItem onClick={() => onRejectProfile(user)}>
                    <Icon
                      icon="heroicons:shield-exclamation"
                      className="mr-2 h-4 w-4 text-red-600"
                    />
                    Reject Profile
                  </DropdownMenuItem>
                </>
              )}

            {/* Suspend/Reactivate Actions */}
            {hasUpdatePermission && (
              <>
                <DropdownMenuSeparator />
                {user.accountStatus === "SUSPENDED" ? (
                  <DropdownMenuItem onClick={() => onReactivate(user)}>
                    <Icon
                      icon="heroicons:play"
                      className="mr-2 h-4 w-4 text-green-600"
                    />
                    Reactivate User
                  </DropdownMenuItem>
                ) : (
                  user.accountStatus === "ACTIVE" && (
                    <DropdownMenuItem onClick={() => onSuspend(user)}>
                      <Icon
                        icon="heroicons:pause"
                        className="mr-2 h-4 w-4 text-orange-600"
                      />
                      Suspend User
                    </DropdownMenuItem>
                  )
                )}
              </>
            )}

            {hasDeletePermission && (
              <>
                <DropdownMenuSeparator />
                <DropdownMenuItem
                  className="text-red-600 focus:text-red-600"
                  onClick={() => onDelete(user)}
                >
                  <Icon icon="heroicons:trash" className="mr-2 h-4 w-4" />
                  Delete User
                </DropdownMenuItem>
              </>
            )}
          </DropdownMenuContent>
        </DropdownMenu>
      );
    },
  },
];
// Action Dialog Component
const ActionDialog = ({
  open,
  onOpenChange,
  title,
  description,
  onConfirm,
  loading,
  showMessage = false,
  message,
  onMessageChange,
}: {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  title: string;
  description: string;
  onConfirm: () => void;
  loading?: boolean;
  showMessage?: boolean;
  message?: string;
  onMessageChange?: (message: string) => void;
}) => (
  <Dialog open={open} onOpenChange={onOpenChange}>
    <DialogContent>
      <DialogHeader>
        <DialogTitle>{title}</DialogTitle>
        <DialogDescription>{description}</DialogDescription>
      </DialogHeader>

      {showMessage && (
        <div className="space-y-2">
          <label className="text-sm font-medium">Message (optional)</label>
          <Textarea
            placeholder="Add a message for the user..."
            value={message || ""}
            onChange={(e) => onMessageChange?.(e.target.value)}
          />
        </div>
      )}

      <DialogFooter>
        <Button size="md" variant="outline" onClick={() => onOpenChange(false)}>
          Cancel
        </Button>
        <Button size="md" onClick={onConfirm} disabled={loading}>
          {loading && (
            <Icon
              icon="heroicons:arrow-path"
              className="mr-2 h-4 w-4 animate-spin"
            />
          )}
          Confirm
        </Button>
      </DialogFooter>
    </DialogContent>
  </Dialog>
);
// Main Enhanced Users Table Component
const UsersTable = () => {
  const { hasPermission } = useAuthStore();
  const [users, setUsers] = React.useState<User[]>([]);
  const [loading, setLoading] = React.useState(true);
  const [pagination, setPagination] = React.useState({
    page: 1,
    limit: 10,
    total: 0,
    totalPages: 0,
  });

  // Table state
  const [sorting, setSorting] = React.useState<SortingState>([]);
  const [columnFilters, setColumnFilters] = React.useState<ColumnFiltersState>(
    []
  );
  const [columnVisibility, setColumnVisibility] =
    React.useState<VisibilityState>({});
  const [rowSelection, setRowSelection] = React.useState({});

  // Enhanced filters state
  const [filters, setFilters] = React.useState({
    search: "",
    userType: "",
    isActive: "",
    roleId: "",
    accountStatus: "",
    validationStatus: "",
  });

  // Dialog states
  const [deleteDialog, setDeleteDialog] = React.useState<{
    open: boolean;
    user: User | null;
  }>({ open: false, user: null });

  const [actionDialog, setActionDialog] = React.useState<{
    open: boolean;
    type:
      | "approve"
      | "reject"
      | "validate"
      | "rejectProfile"
      | "suspend"
      | "reactivate"
      | null;
    user: User | null;
    message: string;
  }>({ open: false, type: null, user: null, message: "" });

  const [actionLoading, setActionLoading] = React.useState(false);

  // Permissions
  const hasUpdatePermission = hasPermission("users:update");
  const hasDeletePermission = hasPermission("users:delete");
  const hasApprovePermission = hasPermission("users:approve");
  const hasValidatePermission = hasPermission("users:validate");

  // Fetch users data with enhanced filters
  const fetchUsers = React.useCallback(async () => {
    try {
      setLoading(true);

      const apiFilters: any = {
        page: pagination.page,
        limit: pagination.limit,
      };

      // Add all filters
      if (filters.search) apiFilters.search = filters.search;
      if (filters.userType) apiFilters.userType = filters.userType;
      if (filters.isActive !== "")
        apiFilters.isActive = filters.isActive === "true";
      if (filters.roleId) apiFilters.roleId = filters.roleId;
      if (filters.accountStatus)
        apiFilters.accountStatus = filters.accountStatus;
      if (filters.validationStatus)
        apiFilters.validationStatus = filters.validationStatus;

      const result = await usersApiClient.getUsers(apiFilters);

      if (result.data && result.data[0] && result.data[0].data) {
        setUsers(result.data[0].data);
        setPagination((prev) => ({
          ...prev,
          total: result.data[0].meta.total,
          totalPages: result.data[0].meta.totalPages,
        }));
      } else {
        throw new Error(result.error?.message || "Failed to fetch users");
      }
    } catch (error) {
      console.error("Error fetching users:", error);
      toast.error("Failed to fetch users");
    } finally {
      setLoading(false);
    }
  }, [pagination.page, pagination.limit, filters]);

  // Fetch special user lists
  const fetchPendingRegistrations = async () => {
    try {
      const result = await usersApiClient.getPendingRegistrations();
      if (result.success) {
        setUsers(result.data);
        setPagination((prev) => ({
          ...prev,
          total: result.data.length,
          totalPages: 1,
        }));
      }
    } catch (error) {
      toast.error("Failed to fetch pending registrations");
    }
  };

  const fetchPendingValidations = async () => {
    try {
      const result = await usersApiClient.getPendingValidations();
      if (result.success) {
        setUsers(result.data);
        setPagination((prev) => ({
          ...prev,
          total: result.data.length,
          totalPages: 1,
        }));
      }
    } catch (error) {
      toast.error("Failed to fetch pending validations");
    }
  };

  React.useEffect(() => {
    fetchUsers();
  }, [fetchUsers]);

  // Enhanced action handlers
  const handleApproveRegistration = async (user: User) => {
    setActionDialog({
      open: true,
      type: "approve",
      user,
      message: `Welcome to our platform! Your registration has been approved.`,
    });
  };

  const handleRejectRegistration = async (user: User) => {
    setActionDialog({
      open: true,
      type: "reject",
      user,
      message: `We're sorry, but your registration could not be approved at this time.`,
    });
  };

  const handleValidateProfile = async (user: User) => {
    setActionDialog({
      open: true,
      type: "validate",
      user,
      message: `Congratulations! Your profile has been validated.`,
    });
  };

  const handleRejectProfile = async (user: User) => {
    setActionDialog({
      open: true,
      type: "rejectProfile",
      user,
      message: `Your profile requires additional information. Please review and update.`,
    });
  };

  const handleSuspend = async (user: User) => {
    setActionDialog({ open: true, type: "suspend", user, message: "" });
  };

  const handleReactivate = async (user: User) => {
    setActionDialog({ open: true, type: "reactivate", user, message: "" });
  };

  const executeAction = async () => {
    if (!actionDialog.user || !actionDialog.type) return;

    setActionLoading(true);
    try {
      let result;
      const { user, type, message } = actionDialog;

      switch (type) {
        case "approve":
          result = await usersApiClient.approveRegistration(user.id, {
            approve: true,
            message,
          });
          break;
        case "reject":
          result = await usersApiClient.approveRegistration(user.id, {
            approve: false,
            message,
          });
          break;
        case "validate":
          result = await usersApiClient.validateProfile(user.id, {
            action: "VALIDATE",
            notes: message,
          });
          break;
        case "rejectProfile":
          result = await usersApiClient.validateProfile(user.id, {
            action: "REJECT",
            notes: message,
          });
          break;
        case "suspend":
          result = await usersApiClient.suspendUser(user.id);
          break;
        case "reactivate":
          result = await usersApiClient.reactivateUser(user.id);
          break;
      }

      if (result?.success) {
        toast.success(`User ${type} successfully`);
        fetchUsers();
        setActionDialog({ open: false, type: null, user: null, message: "" });
      } else {
        toast.error(result?.error?.message || `Failed to ${type} user`);
      }
    } catch (error) {
      toast.error(`Failed to ${actionDialog.type} user`);
    } finally {
      setActionLoading(false);
    }
  };

  // Handle search with debouncing
  const searchTimerRef = React.useRef<NodeJS.Timeout>();

  const debouncedSearch = React.useCallback((value: string) => {
    if (searchTimerRef.current) {
      clearTimeout(searchTimerRef.current);
    }
    searchTimerRef.current = setTimeout(() => {
      setFilters((prev) => ({ ...prev, search: value }));
      setPagination((prev) => ({ ...prev, page: 1 }));
    }, 500);
  }, []);

  // Handle filter changes
  const handleFilterChange = (key: string, value: string) => {
    setFilters((prev) => ({ ...prev, [key]: value }));
    setPagination((prev) => ({ ...prev, page: 1 }));
  };

  // Handle pagination
  const handlePageChange = (newPage: number) => {
    setPagination((prev) => ({ ...prev, page: newPage }));
  };

  const handlePageSizeChange = (newSize: number) => {
    setPagination((prev) => ({ ...prev, limit: newSize, page: 1 }));
  };

  // Handle delete user
  const handleDeleteUser = async (user: User) => {
    try {
      const response = await usersApiClient.deleteUser(user.id);
      if (response.success) {
        toast.success("User deleted successfully");
        fetchUsers();
        setDeleteDialog({ open: false, user: null });
      } else {
        toast.error(response.error?.message || "Failed to delete user");
      }
    } catch (error) {
      console.error("Error deleting user:", error);
      toast.error("Failed to delete user");
    }
  };

  // Enhanced export with new fields
  const handleExportExcel = () => {
    try {
      const exportData = users.map((user) => ({
        Name: user.name,
        Email: user.email,
        "User Type": user.userType,
        Role: user.role.name,
        Phone: user.profile?.phone || "N/A",
        "Account Status": user.accountStatus,
        "Validation Status": user.validationStatus,
        "Profile Completed": user.profileCompleted ? "Yes" : "No",
        "Is Active": user.isActive ? "Active" : "Inactive",
        "Last Login": user.lastLogin
          ? formatDate(user.lastLogin, "long")
          : "Never",
        "Created At": formatDate(user.createdAt, "long"),
        "Created By": user.createdBy?.name || "Self-registered",
        "Validated At": user.validatedAt
          ? formatDate(user.validatedAt, "long")
          : "N/A",
        "Validated By": user.validatedBy?.name || "N/A",
        CIN: user.profile?.cin || "N/A",
        Location: user.profile?.address
          ? `${user.profile.address.city || ""}, ${
              user.profile.address.state || ""
            }, ${user.profile.address.country || ""}`.replace(
              /^,\s*|,\s*$/g,
              ""
            )
          : "N/A",
      }));

      const worksheet = XLSX.utils.json_to_sheet(exportData);
      const workbook = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(workbook, worksheet, "Users");

      const maxWidth = exportData.reduce(
        (w, r) => Math.max(w, Object.keys(r).length),
        10
      );
      worksheet["!cols"] = Array(maxWidth).fill({ width: 20 });

      const today = new Date().toISOString().split("T")[0];
      XLSX.writeFile(workbook, `users-export-${today}.xlsx`);
      toast.success("Users data exported successfully");
    } catch (error) {
      console.error("Export error:", error);
      toast.error("Failed to export users data");
    }
  };

  // Table configuration
  const columns = React.useMemo(
    () =>
      createColumns(
        (user) => setDeleteDialog({ open: true, user }),
        handleApproveRegistration,
        handleRejectRegistration,
        handleValidateProfile,
        handleRejectProfile,
        handleSuspend,
        handleReactivate,
        hasUpdatePermission,
        hasDeletePermission,
        hasApprovePermission,
        hasValidatePermission
      ),
    [
      hasUpdatePermission,
      hasDeletePermission,
      hasApprovePermission,
      hasValidatePermission,
    ]
  );

  const table = useReactTable({
    data: users,
    columns,
    onSortingChange: setSorting,
    onColumnFiltersChange: setColumnFilters,
    getCoreRowModel: getCoreRowModel(),
    getPaginationRowModel: getPaginationRowModel(),
    getSortedRowModel: getSortedRowModel(),
    getFilteredRowModel: getFilteredRowModel(),
    onColumnVisibilityChange: setColumnVisibility,
    onRowSelectionChange: setRowSelection,
    state: {
      sorting,
      columnFilters,
      columnVisibility,
      rowSelection,
    },
    manualPagination: true,
    pageCount: pagination.totalPages,
  });

  const selectedRowsCount = table.getFilteredSelectedRowModel().rows.length;

  return (
    <div className="space-y-4 mx-4">
      {/* Quick Action Buttons */}
      <div className="flex flex-wrap gap-2">
        {hasApprovePermission && (
          <Button
            variant="outline"
            size="md"
            onClick={fetchPendingRegistrations}
          >
            <Icon icon="heroicons:user-plus" className="h-4 w-4 mr-2" />
            Pending Registrations
          </Button>
        )}
        {hasValidatePermission && (
          <Button variant="outline" size="md" onClick={fetchPendingValidations}>
            <Icon icon="heroicons:document-check" className="h-4 w-4 mr-2" />
            Pending Validations
          </Button>
        )}
        <Button variant="outline" size="md" onClick={fetchUsers}>
          <Icon icon="heroicons:users" className="h-4 w-4 mr-2" />
          All Users
        </Button>
      </div>

      {/* Enhanced Filters */}
      <div className="flex flex-col sm:flex-row gap-4">
        <div className="flex-1 space-y-2 sm:space-y-0 sm:flex sm:items-center sm:space-x-2">
          <Input
            placeholder="Search users..."
            className="sm:max-w-sm"
            onChange={(e) => debouncedSearch(e.target.value)}
          />

          <Select
            value={filters.userType || "all"}
            onValueChange={(value) =>
              handleFilterChange("userType", value === "all" ? "" : value)
            }
          >
            <SelectTrigger className="sm:w-[150px]">
              <SelectValue placeholder="User Type" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">All Types</SelectItem>
              <SelectItem value="ADMIN">Admin</SelectItem>
              <SelectItem value="MANAGER">Manager</SelectItem>
              <SelectItem value="SELLER">Seller</SelectItem>
              <SelectItem value="CUSTOMER">Customer</SelectItem>
              <SelectItem value="LIVREUR">Livreur</SelectItem>
              <SelectItem value="SUPPORT">Support</SelectItem>
              <SelectItem value="BUYER">Buyer</SelectItem>
              <SelectItem value="VENDOR">Vendor</SelectItem>
              <SelectItem value="WAREHOUSE">Warehouse</SelectItem>
              <SelectItem value="DISPATCHER">Dispatcher</SelectItem>
            </SelectContent>
          </Select>

          <Select
            value={filters.accountStatus || "all"}
            onValueChange={(value) =>
              handleFilterChange("accountStatus", value === "all" ? "" : value)
            }
          >
            <SelectTrigger className="sm:w-[160px]">
              <SelectValue placeholder="Account Status" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">All Status</SelectItem>
              <SelectItem value="PENDING">Pending</SelectItem>
              <SelectItem value="INACTIVE">Inactive</SelectItem>
              <SelectItem value="PENDING_VALIDATION">
                Pending Validation
              </SelectItem>
              <SelectItem value="ACTIVE">Active</SelectItem>
              <SelectItem value="REJECTED">Rejected</SelectItem>
              <SelectItem value="SUSPENDED">Suspended</SelectItem>
            </SelectContent>
          </Select>

          <Select
            value={filters.validationStatus || "all"}
            onValueChange={(value) =>
              handleFilterChange(
                "validationStatus",
                value === "all" ? "" : value
              )
            }
          >
            <SelectTrigger className="sm:w-[140px]">
              <SelectValue placeholder="Validation" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">All Validation</SelectItem>
              <SelectItem value="PENDING">Pending</SelectItem>
              <SelectItem value="VALIDATED">Validated</SelectItem>
              <SelectItem value="REJECTED">Rejected</SelectItem>
            </SelectContent>
          </Select>
        </div>

        <div className="flex items-center space-x-2">
          <Button variant="outline" size="md" onClick={handleExportExcel}>
            <Icon
              icon="heroicons:document-arrow-down"
              className="h-4 w-4 mr-2"
            />
            Export Excel
          </Button>
        </div>
      </div>

      {/* Table */}
      <div className="border rounded-lg overflow-hidden">
        <Table>
          <TableHeader>
            {table.getHeaderGroups().map((headerGroup) => (
              <TableRow key={headerGroup.id}>
                {headerGroup.headers.map((header) => (
                  <TableHead key={header.id}>
                    {header.isPlaceholder
                      ? null
                      : flexRender(
                          header.column.columnDef.header,
                          header.getContext()
                        )}
                  </TableHead>
                ))}
              </TableRow>
            ))}
          </TableHeader>
          <TableBody>
            {loading ? (
              Array.from({ length: 5 }).map((_, index) => (
                <TableRow key={index}>
                  {columns.map((_, cellIndex) => (
                    <TableCell key={cellIndex}>
                      <div className="h-4 bg-gray-200 rounded animate-pulse" />
                    </TableCell>
                  ))}
                </TableRow>
              ))
            ) : table.getRowModel().rows?.length ? (
              table.getRowModel().rows.map((row) => (
                <TableRow
                  key={row.id}
                  data-state={row.getIsSelected() && "selected"}
                >
                  {row.getVisibleCells().map((cell) => (
                    <TableCell key={cell.id}>
                      {flexRender(
                        cell.column.columnDef.cell,
                        cell.getContext()
                      )}
                    </TableCell>
                  ))}
                </TableRow>
              ))
            ) : (
              <TableRow>
                <TableCell
                  colSpan={columns.length}
                  className="h-24 text-center"
                >
                  No users found.
                </TableCell>
              </TableRow>
            )}
          </TableBody>
        </Table>
      </div>

      {/* Pagination */}
      <div className="flex flex-col sm:flex-row items-center justify-between gap-4 pb-4">
        <div className="text-sm text-gray-600">
          Showing {(pagination.page - 1) * pagination.limit + 1} to{" "}
          {Math.min(pagination.page * pagination.limit, pagination.total)} of{" "}
          {pagination.total} users
        </div>

        <div className="flex items-center space-x-2">
          <div className="flex items-center space-x-2">
            <span className="text-sm">Rows per page:</span>
            <Select
              value={pagination.limit.toString()}
              onValueChange={(value) => handlePageSizeChange(Number(value))}
            >
              <SelectTrigger className="w-16">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="5">5</SelectItem>
                <SelectItem value="10">10</SelectItem>
                <SelectItem value="20">20</SelectItem>
                <SelectItem value="50">50</SelectItem>
              </SelectContent>
            </Select>
          </div>

          <div className="flex items-center space-x-1">
            <Button
              variant="outline"
              size="md"
              onClick={() => handlePageChange(1)}
              disabled={pagination.page === 1}
            >
              <Icon icon="heroicons:chevron-double-left" className="h-4 w-4" />
            </Button>
            <Button
              variant="outline"
              size="md"
              onClick={() => handlePageChange(pagination.page - 1)}
              disabled={pagination.page === 1}
            >
              <Icon icon="heroicons:chevron-left" className="h-4 w-4" />
            </Button>

            <span className="px-3 py-1 text-sm">
              Page {pagination.page} of {pagination.totalPages}
            </span>

            <Button
              variant="outline"
              size="md"
              onClick={() => handlePageChange(pagination.page + 1)}
              disabled={pagination.page >= pagination.totalPages}
            >
              <Icon icon="heroicons:chevron-right" className="h-4 w-4" />
            </Button>
            <Button
              variant="outline"
              size="md"
              onClick={() => handlePageChange(pagination.totalPages)}
              disabled={pagination.page >= pagination.totalPages}
            >
              <Icon icon="heroicons:chevron-double-right" className="h-4 w-4" />
            </Button>
          </div>
        </div>
      </div>

      {/* Delete Confirmation Dialog */}
      <AlertDialog
        open={deleteDialog.open}
        onOpenChange={(open) => setDeleteDialog({ open, user: null })}
      >
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure?</AlertDialogTitle>
            <AlertDialogDescription>
              This action cannot be undone. This will permanently delete the
              user
              <strong> {deleteDialog.user?.name}</strong> and remove all
              associated data.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={() =>
                deleteDialog.user && handleDeleteUser(deleteDialog.user)
              }
              className="bg-red-600 text-white hover:bg-red-700"
            >
              Delete User
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* Action Dialog */}
      <ActionDialog
        open={actionDialog.open}
        onOpenChange={(open) =>
          setActionDialog({ open, type: null, user: null, message: "" })
        }
        title={`${
          actionDialog.type === "approve"
            ? "Approve Registration"
            : actionDialog.type === "reject"
            ? "Reject Registration"
            : actionDialog.type === "validate"
            ? "Validate Profile"
            : actionDialog.type === "rejectProfile"
            ? "Reject Profile"
            : actionDialog.type === "suspend"
            ? "Suspend User"
            : actionDialog.type === "reactivate"
            ? "Reactivate User"
            : ""
        }`}
        description={`Are you sure you want to ${actionDialog.type} ${actionDialog.user?.name}?`}
        onConfirm={executeAction}
        loading={actionLoading}
        showMessage={[
          "approve",
          "reject",
          "validate",
          "rejectProfile",
        ].includes(actionDialog.type || "")}
        message={actionDialog.message}
        onMessageChange={(message) =>
          setActionDialog((prev) => ({ ...prev, message }))
        }
      />
    </div>
  );
};
export default UsersTable;
-----------------------------------------------------------------------
Lib Folder:
-----------------------------------------------------------------------
--++--> lib/api/clients/auth/auth.client =======>
import { BaseApiClient, ApiResponse } from "../../base.client";
import type {
  LoginRequest,
  RegisterRequest,
  LoginResponse,
  RegisterResponse,
  AccountStatusResponse,
  RefreshTokenRequest,
  CompleteProfileRequest,
  ResetPasswordRequest,
  ForgotPasswordRequest,
} from "@/lib/types/auth/auth.types";
export class AuthApiClient extends BaseApiClient {
  constructor() {
    super("auth");
  }

  async login(request: LoginRequest): Promise<ApiResponse<LoginResponse>> {
    return this.post<LoginResponse>("/api/auth/login", request);
  }

  async register(
    request: RegisterRequest
  ): Promise<ApiResponse<RegisterResponse>> {
    return this.post<RegisterResponse>("/api/auth/register", request);
  }

  async refreshToken(
    request: RefreshTokenRequest
  ): Promise<ApiResponse<LoginResponse>> {
    return this.post<LoginResponse>("/api/auth/refresh", request);
  }

  async logout(request: RefreshTokenRequest): Promise<ApiResponse<void>> {
    return this.post<void>("/api/auth/logout", request);
  }

  async getProfile(): Promise<ApiResponse<any>> {
    return this.get<any>("/api/auth/profile");
  }

  async getAccountStatus(): Promise<ApiResponse<AccountStatusResponse>> {
    return this.get<AccountStatusResponse>("/api/auth/status");
  }

  async completeProfile(
    request: CompleteProfileRequest
  ): Promise<ApiResponse<any>> {
    return this.patch<any>("/api/auth/complete-profile", request);
  }

  async forgotPassword(
    request: ForgotPasswordRequest
  ): Promise<ApiResponse<{ message: string }>> {
    return this.post<{ message: string }>("/api/auth/forgot-password", request);
  }

  async resetPassword(
    request: ResetPasswordRequest
  ): Promise<ApiResponse<{ message: string }>> {
    return this.post<{ message: string }>("/api/auth/reset-password", request);
  }
}
export const authApiClient = new AuthApiClient();
-----------------------------------------------------------------------
--++--> lib/api/clients/auth/users.client.ts =======>
import { BaseApiClient, ApiResponse } from "../../base.client";
import type {
  User,
  CreateUserRequest,
  UpdateUserRequest,
  UserFilters,
} from "@/lib/types/database/schema.types";
// New types for the enhanced functionality
export interface ApproveRegistrationRequest {
  approve: boolean;
  message?: string;
}
export interface ValidateProfileRequest {
  action: "VALIDATE" | "REJECT";
  notes?: string;
}
export interface CompleteProfileRequest {
  phone?: string;
  city?: string;
  address: string;
  cin: string;
  cinDocuments?: string[];
  bankDetails?: any;
  profilePhoto?: string;
}
export class UsersApiClient extends BaseApiClient {
  constructor() {
    super("users");
  }

  // ========================================
  // USER MANAGEMENT ENDPOINTS
  // ========================================

  async createUser(request: CreateUserRequest): Promise<ApiResponse<User>> {
    return this.post<User>("/api/users", request);
  }

  async getUsers(filters?: UserFilters) {
    return this.getPaginated<User>("/api/users", filters);
  }

  async getUserById(id: string): Promise<ApiResponse<User>> {
    return this.get<User>(`/api/users/${id}`);
  }

  async updateUser(
    id: string,
    request: UpdateUserRequest
  ): Promise<ApiResponse<User>> {
    return this.patch<User>(`/api/users/${id}`, request);
  }

  async deleteUser(id: string): Promise<ApiResponse<void>> {
    return this.delete<void>(`/api/users/${id}`);
  }

  async deactivateUser(id: string): Promise<ApiResponse<User>> {
    return this.patch<User>(`/api/users/${id}/deactivate`, {});
  }

  async reactivateUser(id: string): Promise<ApiResponse<User>> {
    return this.patch<User>(`/api/users/${id}/reactivate`, {});
  }

  async changeUserPassword(
    id: string,
    request: {
      currentPassword: string;
      newPassword: string;
    }
  ): Promise<ApiResponse<{ message: string }>> {
    return this.patch<{ message: string }>(
      `/api/users/${id}/change-password`,
      request
    );
  }

  // ========================================
  // NEW ENHANCED USER WORKFLOW ENDPOINTS
  // ========================================

  /**
   * Get all users with PENDING account status awaiting admin approval
   */
  async getPendingRegistrations(): Promise<ApiResponse<User[]>> {
    return this.get<User[]>("/api/users/pending-registrations");
  }

  /**
   * Get all users with PENDING_VALIDATION status awaiting profile validation
   */
  async getPendingValidations(): Promise<ApiResponse<User[]>> {
    return this.get<User[]>("/api/users/pending-validations");
  }

  /**
   * Approve or reject a user registration (for PENDING users)
   */
  async approveRegistration(
    userId: string,
    request: ApproveRegistrationRequest
  ): Promise<ApiResponse<User>> {
    return this.patch<User>(
      `/api/users/${userId}/approve-registration`,
      request
    );
  }

  /**
   * Validate or reject a user profile (for PENDING_VALIDATION users)
   */
  async validateProfile(
    userId: string,
    request: ValidateProfileRequest
  ): Promise<ApiResponse<User>> {
    return this.patch<User>(`/api/users/${userId}/validate-profile`, request);
  }

  /**
   * Suspend a user account (moves to SUSPENDED status)
   */
  async suspendUser(userId: string): Promise<ApiResponse<User>> {
    return this.patch<User>(`/api/users/${userId}/suspend`, {});
  }

  /**
   * Complete user profile (moves from INACTIVE to PENDING_VALIDATION)
   */
  async completeProfile(
    request: CompleteProfileRequest
  ): Promise<ApiResponse<User>> {
    return this.patch<User>("/api/users/me/complete-profile", request);
  }

  /**
   * Get current user profile
   */
  async getMyProfile(): Promise<ApiResponse<User>> {
    return this.get<User>("/api/users/me");
  }

  /**
   * Assign a role to a user
   */
  async assignRole(userId: string, roleId: string): Promise<ApiResponse<User>> {
    return this.patch<User>(`/api/users/${userId}/role`, { roleId });
  }

  /**
   * Get user permissions based on their role and account status
   */
  async getUserPermissions(userId: string): Promise<
    ApiResponse<{
      userId: string;
      email: string;
      userType: string;
      accountStatus: string;
      validationStatus: string;
      role: any;
      permissions: string[];
      isActive: boolean;
    }>
  > {
    return this.get(`/api/users/${userId}/permissions`);
  }

  // ========================================
  // BULK OPERATIONS
  // ========================================

  /**
   * Bulk approve multiple registrations
   */
  async bulkApproveRegistrations(
    userIds: string[],
    message?: string
  ): Promise<ApiResponse<{ successful: number; failed: string[] }>> {
    return this.post("/api/users/bulk/approve-registrations", {
      userIds,
      message,
    });
  }

  /**
   * Bulk validate multiple profiles
   */
  async bulkValidateProfiles(
    userIds: string[],
    action: "VALIDATE" | "REJECT",
    notes?: string
  ): Promise<ApiResponse<{ successful: number; failed: string[] }>> {
    return this.post("/api/users/bulk/validate-profiles", {
      userIds,
      action,
      notes,
    });
  }

  /**
   * Bulk suspend multiple users
   */
  async bulkSuspendUsers(
    userIds: string[]
  ): Promise<ApiResponse<{ successful: number; failed: string[] }>> {
    return this.post("/api/users/bulk/suspend", { userIds });
  }

  /**
   * Export users with current filters
   */
  async exportUsers(filters?: UserFilters): Promise<
    ApiResponse<{
      downloadUrl: string;
      filename: string;
    }>
  > {
    return this.post("/api/users/export", { filters });
  }

  // ========================================
  // STATISTICS AND ANALYTICS
  // ========================================

  /**
   * Get user statistics for dashboard
   */
  async getUserStatistics(): Promise<
    ApiResponse<{
      total: number;
      active: number;
      inactive: number;
      pending: number;
      pendingValidation: number;
      suspended: number;
      rejected: number;
      validated: number;
      byUserType: Record<string, number>;
      recentRegistrations: number;
      pendingActions: number;
    }>
  > {
    return this.get("/api/users/statistics");
  }

  /**
   * Get user activity timeline
   */
  async getUserActivity(
    userId: string,
    limit?: number
  ): Promise<
    ApiResponse<
      Array<{
        id: string;
        action: string;
        timestamp: string;
        performedBy: {
          id: string;
          name: string;
          email: string;
        };
        details?: any;
      }>
    >
  > {
    const params = limit ? `?limit=${limit}` : "";
    return this.get(`/api/users/${userId}/activity${params}`);
  }
}
// Export singleton instance
export const usersApiClient = new UsersApiClient();
-----------------------------------------------------------------------
--++--> lib/api/clients/auth/tenant.client.ts =======>
import { BaseApiClient, ApiResponse } from "../../base.client";
import type {
  Tenant,
  User,
  UserFilters,
} from "@/lib/types/database/schema.types";

export class TenantsApiClient extends BaseApiClient {
  constructor() {
    super("tenants");
  }

  // ========================================
  // TENANT MANAGEMENT ENDPOINTS
  // ========================================

  async createTenant(request: {
    name: string;
    slug: string;
    domain: string;
    logo?: string;
    settings?: any;
    isActive?: boolean;
  }): Promise<ApiResponse<Tenant>> {
    return this.post<Tenant>("/api/tenants", request);
  }

  async getTenants(filters?: {
    page?: number;
    limit?: number;
    name?: string;
    slug?: string;
    isActive?: boolean;
  }) {
    return this.getPaginated<Tenant>("/api/tenants", filters);
  }

  async getCurrentTenant(): Promise<ApiResponse<Tenant & { stats: any }>> {
    return this.get<Tenant & { stats: any }>("/api/tenants/current");
  }

  async updateCurrentTenant(request: {
    name?: string;
    slug?: string;
    domain?: string;
    logo?: string;
    settings?: any;
    isActive?: boolean;
  }): Promise<ApiResponse<Tenant>> {
    return this.patch<Tenant>("/api/tenants/current", request);
  }

  async getTenantStats() {
    return this.get<{
      totalUsers: number;
      activeUsers: number;
      newUsersThisMonth: number;
      totalRoles: number;
      totalParcels: number;
      parcelsThisMonth: number;
      totalInvoices: number;
      invoicesThisMonth: number;
      totalClaims: number;
      claimsThisMonth: number;
      recentActivity: any;
      trends: any;
    }>("/api/tenants/current/stats");
  }

  async getTenantUsers(filters?: UserFilters) {
    return this.getPaginated<User>("/api/tenants/current/users", filters);
  }

  async updateTenantSettings(settings: any): Promise<ApiResponse<Tenant>> {
    return this.patch<Tenant>("/api/tenants/current/settings", settings);
  }
}
// Export singleton instance
export const tenantsApiClient = new TenantsApiClient();
-----------------------------------------------------------------------
--++--> lib/api/base.client.ts =======>
-----------------------------------------------------------------------
import axios, {
  AxiosInstance,
  AxiosRequestConfig,
  AxiosResponse,
  AxiosError,
  InternalAxiosRequestConfig,
} from "axios";
import { API_CONFIG, ServiceName, ErrorCode } from "@/lib/config/api.config";
import { getTenantFromUrl } from "@/lib/utils/tenant.utils";
// Extend Axios request config to include metadata
interface ExtendedAxiosRequestConfig extends InternalAxiosRequestConfig {
  metadata?: {
    startTime: number;
  };
}
export interface ApiError {
  code: ErrorCode;
  message: string;
  details?: any;
  statusCode?: number;
  timestamp: string;
  requestId?: string;
}
export interface ApiResponse<T = any> {
  success: boolean;
  data?: T;
  error?: ApiError;
  message?: string;
  timestamp: string;
}
export interface PaginatedResponse<T = any> {
  data: T[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
}
export class BaseApiClient {
  protected client: AxiosInstance;
  protected serviceName: ServiceName;
  protected tenantId: string | null = null;

  constructor(serviceName: ServiceName, customConfig?: AxiosRequestConfig) {
    this.serviceName = serviceName;
    const serviceConfig = API_CONFIG.services[serviceName];

    // Get tenant ID from URL
    this.tenantId = getTenantFromUrl();

    // Create axios instance
    this.client = axios.create({
      baseURL: serviceConfig.baseURL,
      timeout: serviceConfig.timeout,
      headers: {
        ...API_CONFIG.headers.common,
        ...(this.tenantId && { [API_CONFIG.headers.tenant]: this.tenantId }),
      },
      ...customConfig,
    });

    this.setupInterceptors();
  }

  private setupInterceptors(): void {
    // Request interceptor
    this.client.interceptors.request.use(
      (config: ExtendedAxiosRequestConfig) => {
        // Add auth token
        const token = this.getAuthToken();
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }

        // Add tenant ID if available
        if (this.tenantId) {
          config.headers[API_CONFIG.headers.tenant] = this.tenantId;
        }

        // Add request timestamp for debugging
        config.metadata = { startTime: Date.now() };

        return config;
      },
      (error) => Promise.reject(this.transformError(error))
    );

    // Response interceptor
    this.client.interceptors.response.use(
      (response: AxiosResponse) => {
        // Log response time for monitoring
        const endTime = Date.now();
        const config = response.config as ExtendedAxiosRequestConfig;
        const startTime = config.metadata?.startTime || endTime;
        const duration = endTime - startTime;

        if (duration > 3000) {
          console.warn(
            `Slow API request detected: ${response.config.url} took ${duration}ms`
          );
        }

        return response;
      },
      async (error: AxiosError) => {
        // Handle token refresh
        if (error.response?.status === 401 && this.serviceName === "auth") {
          const refreshed = await this.attemptTokenRefresh();
          if (refreshed && error.config) {
            // Retry original request with new token
            const token = this.getAuthToken();
            if (token) {
              error.config.headers.Authorization = `Bearer ${token}`;
            }
            return this.client.request(error.config);
          }
        }

        return Promise.reject(this.transformError(error));
      }
    );
  }

  private getAuthToken(): string | null {
    if (typeof window === "undefined") return null;
    return localStorage.getItem("auth_token");
  }

  private async attemptTokenRefresh(): Promise<boolean> {
    try {
      const refreshToken = localStorage.getItem("refresh_token");
      if (!refreshToken) return false;

      // Only attempt refresh from auth service
      if (this.serviceName !== "auth") return false;

      const response = await axios.post(
        `${API_CONFIG.services.auth.baseURL}/api/auth/refresh`,
        { refreshToken },
        {
          headers: {
            "Content-Type": "application/json",
            ...(this.tenantId && {
              [API_CONFIG.headers.tenant]: this.tenantId,
            }),
          },
        }
      );

      if (response.data.success && response.data.data) {
        const { accessToken, refreshToken: newRefreshToken } =
          response.data.data;
        localStorage.setItem("auth_token", accessToken);
        if (newRefreshToken) {
          localStorage.setItem("refresh_token", newRefreshToken);
        }
        return true;
      }
    } catch (error) {
      console.error("Token refresh failed:", error);
      this.clearAuthTokens();
    }
    return false;
  }

  private clearAuthTokens(): void {
    if (typeof window !== "undefined") {
      localStorage.removeItem("auth_token");
      localStorage.removeItem("refresh_token");
    }
  }

  private transformError(error: any): ApiError {
    const timestamp = new Date().toISOString();

    // Network or timeout errors
    if (!error.response) {
      return {
        code: error.code === "ECONNABORTED" ? "TIMEOUT_ERROR" : "NETWORK_ERROR",
        message: error.message || "Network error occurred",
        timestamp,
      };
    }

    // HTTP errors with response
    const { status, data } = error.response;
    const statusCode = status;

    // Map status codes to error codes
    let code: ErrorCode = "SERVER_ERROR";
    switch (statusCode) {
      case 400:
        code = "VALIDATION_ERROR";
        break;
      case 401:
        code = "AUTH_ERROR";
        break;
      case 403:
        code = "PERMISSION_ERROR";
        break;
      case 404:
        code = "NOT_FOUND";
        break;
      case 409:
        code = "CONFLICT";
        break;
      case 429:
        code = "RATE_LIMIT_ERROR";
        break;
      case 500:
      case 502:
      case 503:
      case 504:
        code = "SERVER_ERROR";
        break;
    }

    return {
      code,
      message:
        data?.message || data?.error || error.message || "An error occurred",
      details: data?.details,
      statusCode,
      timestamp,
      requestId: data?.requestId,
    };
  }

  // Generic HTTP methods
  protected async get<T>(
    endpoint: string,
    config?: AxiosRequestConfig
  ): Promise<ApiResponse<T>> {
    try {
      const response = await this.client.get(endpoint, config);
      return this.transformResponse<T>(response);
    } catch (error) {
      throw error; // Error is already transformed by interceptor
    }
  }

  protected async post<T>(
    endpoint: string,
    data?: any,
    config?: AxiosRequestConfig
  ): Promise<ApiResponse<T>> {
    try {
      const response = await this.client.post(endpoint, data, config);
      return this.transformResponse<T>(response);
    } catch (error) {
      throw error;
    }
  }

  protected async put<T>(
    endpoint: string,
    data?: any,
    config?: AxiosRequestConfig
  ): Promise<ApiResponse<T>> {
    try {
      const response = await this.client.put(endpoint, data, config);
      return this.transformResponse<T>(response);
    } catch (error) {
      throw error;
    }
  }

  protected async patch<T>(
    endpoint: string,
    data?: any,
    config?: AxiosRequestConfig
  ): Promise<ApiResponse<T>> {
    try {
      const response = await this.client.patch(endpoint, data, config);
      return this.transformResponse<T>(response);
    } catch (error) {
      throw error;
    }
  }

  protected async delete<T>(
    endpoint: string,
    config?: AxiosRequestConfig
  ): Promise<ApiResponse<T>> {
    try {
      const response = await this.client.delete(endpoint, config);
      return this.transformResponse<T>(response);
    } catch (error) {
      throw error;
    }
  }

  // Paginated requests
  protected async getPaginated<T>(
    endpoint: string,
    params?: Record<string, any>,
    config?: AxiosRequestConfig
  ): Promise<PaginatedResponse<T>> {
    try {
      const response = await this.client.get(endpoint, {
        ...config,
        params: { ...params, ...config?.params },
      });

      // Handle different response formats
      if (response.data.data && response.data.pagination) {
        // Standard paginated format: { data: T[], pagination: {...} }
        return response.data;
      } else if (Array.isArray(response.data.data)) {
        // Array wrapped in data property: { data: T[] }
        return {
          data: response.data.data,
          pagination: {
            page: 1,
            limit: response.data.data.length,
            total: response.data.data.length,
            totalPages: 1,
            hasNext: false,
            hasPrev: false,
          },
        };
      } else if (Array.isArray(response.data)) {
        // Direct array response: T[]
        return {
          data: response.data,
          pagination: {
            page: 1,
            limit: response.data.length,
            total: response.data.length,
            totalPages: 1,
            hasNext: false,
            hasPrev: false,
          },
        };
      } else if (response.data.success && response.data.data) {
        // Wrapped in success envelope: { success: true, data: T[] }
        const data = Array.isArray(response.data.data)
          ? response.data.data
          : [response.data.data];
        return {
          data,
          pagination: {
            page: 1,
            limit: data.length,
            total: data.length,
            totalPages: 1,
            hasNext: false,
            hasPrev: false,
          },
        };
      }

      // Log the actual response structure for debugging
      console.error("Unexpected response structure:", {
        data: response.data,
        dataType: typeof response.data,
        isArray: Array.isArray(response.data),
        hasData: "data" in response.data,
        hasSuccess: "success" in response.data,
        hasPagination: "pagination" in response.data,
      });

      throw new Error(
        `Invalid paginated response format. Expected array or paginated object, got: ${typeof response.data}`
      );
    } catch (error) {
      throw error;
    }
  }

  private transformResponse<T>(response: AxiosResponse): ApiResponse<T> {
    return {
      success: true,
      data: response.data.data || response.data,
      message: response.data.message,
      timestamp: new Date().toISOString(),
    };
  }

  // Utility methods
  public setTenant(tenantId: string): void {
    this.tenantId = tenantId;
    this.client.defaults.headers[API_CONFIG.headers.tenant] = tenantId;
  }

  public clearTenant(): void {
    this.tenantId = null;
    delete this.client.defaults.headers[API_CONFIG.headers.tenant];
  }

  public getServiceName(): ServiceName {
    return this.serviceName;
  }

  public getBaseURL(): string {
    return this.client.defaults.baseURL || "";
  }
}
-----------------------------------------------------------------------
--++--> lib/stores/auth/auth.store.ts =======>
-----------------------------------------------------------------------
import { create } from "zustand";
import { persist } from "zustand/middleware";
import { authApiClient } from "@/lib/api/clients/auth/auth.client";
import { usersApiClient } from "@/lib/api/clients/auth/users.client";
import { setCookie, getCookie, deleteCookie } from "@/lib/utils/cookie.utils";
import type { User, UserType } from "@/lib/types/database/schema.types";
import type {
  LoginRequest,
  RegisterRequest,
  AccountStatusResponse,
  AccountStatus,
  ValidationStatus,
  AccessLevel,
} from "@/lib/types/auth/auth.types";
interface AuthState {
  // Core state
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  error: string | null;
  isInitialized: boolean;

  // Account status workflow
  accountStatus: AccountStatus | null;
  validationStatus: ValidationStatus | null;
  accessLevel: AccessLevel | null;
  requirements: string[];
  hasBlueCheckmark: boolean;

  // Token management
  accessToken: string | null;
  refreshToken: string | null;
  tokenExpiresAt: number | null;

  // Session management
  lastActivity: number;
  sessionTimeoutWarning: boolean;

  // Prevent infinite loops and duplicate calls
  isCheckingAuth: boolean;
  isRefreshing: boolean;
  checkAuthPromise: Promise<void> | null;
  refreshPromise: Promise<boolean> | null;

  // Actions
  login: (credentials: LoginRequest) => Promise<LoginResult>;
  register: (userData: RegisterRequest) => Promise<RegisterResult>;
  logout: () => Promise<void>;
  refreshSession: () => Promise<boolean>;
  checkAuth: () => Promise<void>;

  // Account status management
  updateAccountStatus: () => Promise<AccountStatusResponse | null>;
  completeProfile: (profileData: any) => Promise<ProfileResult>;

  // User management
  updateUser: (userData: Partial<User>) => void;
  updateProfile: (profileData: any) => Promise<boolean>;

  // Permission methods
  hasPermission: (permission: string) => boolean;
  hasAnyPermission: (permissions: string[]) => boolean;
  hasAllPermissions: (permissions: string[]) => boolean;
  hasRole: (roleName: string) => boolean;
  hasUserType: (userType: UserType) => boolean;

  // Access level utilities
  canAccessDashboard: () => boolean;
  canAccessFullFeatures: () => boolean;
  needsProfileCompletion: () => boolean;
  needsValidation: () => boolean;
  isAccountBlocked: () => boolean;

  // Session utilities
  updateLastActivity: () => void;
  isSessionExpired: () => boolean;
  getTimeUntilExpiry: () => number;
  setSessionTimeoutWarning: (show: boolean) => void;
  extendSession: () => Promise<void>;

  // State management
  clearError: () => void;
  setLoading: (loading: boolean) => void;
  getUserProfile: () => Promise<User | null>;
}
// Result types for better type safety
interface LoginResult {
  success: boolean;
  error?: string;
  redirectTo?: string;
  accessLevel?: AccessLevel;
  requirements?: string[];
  message?: string;
}
interface RegisterResult {
  success: boolean;
  error?: string;
  message?: string;
  accountStatus?: AccountStatus;
  nextSteps?: string[];
}
interface ProfileResult {
  success: boolean;
  error?: string;
  message?: string;
}
// Constants
const TOKEN_STORAGE_KEY = "auth_token";
const REFRESH_TOKEN_STORAGE_KEY = "refresh_token";
const SESSION_TIMEOUT = 30 * 60 * 1000; // 30 minutes
const AUTO_REFRESH_THRESHOLD = 2 * 60 * 1000; // 2 minutes before expiry
// Storage utilities
const tokenStorage = {
  store: (accessToken: string, refreshToken: string, expiresIn: number) => {
    if (typeof window === "undefined") return;

    const tokenExpiryDays = Math.ceil(expiresIn / (24 * 60 * 60));

    // Store in localStorage and cookies
    localStorage.setItem(TOKEN_STORAGE_KEY, accessToken);
    localStorage.setItem(REFRESH_TOKEN_STORAGE_KEY, refreshToken);
    setCookie(TOKEN_STORAGE_KEY, accessToken, tokenExpiryDays);
    setCookie(REFRESH_TOKEN_STORAGE_KEY, refreshToken, tokenExpiryDays);

    // Cross-tab communication
    localStorage.setItem("auth_login", Date.now().toString());
    localStorage.removeItem("auth_logout");
  },

  clear: () => {
    if (typeof window === "undefined") return;

    localStorage.removeItem(TOKEN_STORAGE_KEY);
    localStorage.removeItem(REFRESH_TOKEN_STORAGE_KEY);
    deleteCookie(TOKEN_STORAGE_KEY);
    deleteCookie(REFRESH_TOKEN_STORAGE_KEY);

    // Cross-tab communication
    localStorage.setItem("auth_logout", Date.now().toString());
    localStorage.removeItem("auth_login");
  },

  get: () => {
    if (typeof window === "undefined")
      return { accessToken: null, refreshToken: null };

    const accessToken =
      localStorage.getItem(TOKEN_STORAGE_KEY) || getCookie(TOKEN_STORAGE_KEY);
    const refreshToken =
      localStorage.getItem(REFRESH_TOKEN_STORAGE_KEY) ||
      getCookie(REFRESH_TOKEN_STORAGE_KEY);

    return { accessToken, refreshToken };
  },
};
// Access level helpers
const accessLevelHelpers = {
  canAccess: (current: AccessLevel | null, required: AccessLevel): boolean => {
    const levels = ["NO_ACCESS", "PROFILE_ONLY", "LIMITED", "FULL"];
    const currentIndex = levels.indexOf(current || "NO_ACCESS");
    const requiredIndex = levels.indexOf(required);
    return currentIndex >= requiredIndex;
  },

  getRedirectPath: (
    accessLevel: AccessLevel | null,
    accountStatus: AccountStatus | null
  ): string => {
    if (accessLevel === "PROFILE_ONLY" || accountStatus === "INACTIVE") {
      return "/profile/complete";
    }
    return "/dashboard";
  },
};
export const useAuthStore = create<AuthState>()(
  persist(
    (set, get) => ({
      // Initial state
      user: null,
      isAuthenticated: false,
      isLoading: false,
      error: null,
      isInitialized: false,
      accessToken: null,
      refreshToken: null,
      tokenExpiresAt: null,
      lastActivity: Date.now(),
      sessionTimeoutWarning: false,
      isCheckingAuth: false,
      isRefreshing: false,
      checkAuthPromise: null,
      refreshPromise: null,
      accountStatus: null,
      validationStatus: null,
      accessLevel: null,
      requirements: [],
      hasBlueCheckmark: false,

      // Optimized login method
      login: async (credentials: LoginRequest): Promise<LoginResult> => {
        set({ isLoading: true, error: null });

        try {
          const response = await authApiClient.login(credentials);

          if (!response.success || !response.data) {
            const error = response.error?.message || "Login failed";
            set({
              isLoading: false,
              error,
              isInitialized: true,
              isAuthenticated: false,
            });
            return { success: false, error };
          }

          const loginData = response.data;

          // Handle access denied scenarios
          if (loginData.accessDenied) {
            set({
              isLoading: false,
              error: loginData.message,
              isInitialized: true,
              isAuthenticated: false,
              accountStatus: loginData.accountStatus || null,
            });
            return {
              success: false,
              error: loginData.message,
              accessLevel: "NO_ACCESS",
            };
          }

          // Handle successful login
          if (
            loginData.user &&
            loginData.accessToken &&
            loginData.refreshToken
          ) {
            const {
              user,
              accessToken,
              refreshToken,
              expiresIn = 86400,
            } = loginData;
            const tokenExpiresAt = Date.now() + expiresIn * 1000;

            tokenStorage.store(accessToken, refreshToken, expiresIn);

            // Determine access level and redirect
            const accessLevel: AccessLevel = loginData.fullAccess
              ? "FULL"
              : loginData.limitedAccess
              ? "LIMITED"
              : loginData.profileAccess || loginData.requiresProfileCompletion
              ? "PROFILE_ONLY"
              : "NO_ACCESS";

            const redirectTo = accessLevelHelpers.getRedirectPath(
              accessLevel,
              loginData.accountStatus
            );

            set({
              user,
              isAuthenticated: true,
              isLoading: false,
              error: null,
              accessToken,
              refreshToken,
              tokenExpiresAt,
              lastActivity: Date.now(),
              isInitialized: true,
              sessionTimeoutWarning: false,
              accountStatus: loginData.accountStatus || user.accountStatus,
              validationStatus:
                loginData.validationStatus || user.validationStatus,
              accessLevel,
              requirements: [],
              hasBlueCheckmark: user.validationStatus === "VALIDATED",
              checkAuthPromise: null,
              refreshPromise: null,
            });

            return {
              success: true,
              redirectTo,
              accessLevel,
              message: loginData.message,
            };
          }

          const error = "Invalid login response";
          set({
            isLoading: false,
            error,
            isInitialized: true,
            isAuthenticated: false,
          });
          return { success: false, error };
        } catch (error: any) {
          const errorMessage = error?.message || "Network error during login";
          set({
            isLoading: false,
            error: errorMessage,
            isInitialized: true,
            isAuthenticated: false,
          });
          return { success: false, error: errorMessage };
        }
      },

      // Optimized register method
      register: async (userData: RegisterRequest): Promise<RegisterResult> => {
        set({ isLoading: true, error: null });

        try {
          const response = await authApiClient.register(userData);

          if (response.success && response.data) {
            const { success, message, accountStatus, nextSteps } =
              response.data;

            set({
              isLoading: false,
              error: null,
              isInitialized: true,
              accountStatus,
            });
            return { success: true, message, accountStatus, nextSteps };
          }

          const error = response.error?.message || "Registration failed";
          set({ isLoading: false, error, isInitialized: true });
          return { success: false, error };
        } catch (error: any) {
          const errorMessage =
            error?.message || "Network error during registration";
          set({ isLoading: false, error: errorMessage, isInitialized: true });
          return { success: false, error: errorMessage };
        }
      },

      // Optimized logout method
      logout: async () => {
        const { refreshToken } = get();

        // Clear tokens immediately for better UX
        tokenStorage.clear();
        set({
          user: null,
          isAuthenticated: false,
          accessToken: null,
          refreshToken: null,
          tokenExpiresAt: null,
          error: null,
          sessionTimeoutWarning: false,
          isInitialized: true,
          lastActivity: Date.now(),
          isCheckingAuth: false,
          isRefreshing: false,
          checkAuthPromise: null,
          refreshPromise: null,
          accountStatus: null,
          validationStatus: null,
          accessLevel: null,
          requirements: [],
          hasBlueCheckmark: false,
        });

        // Call logout API in background
        if (refreshToken) {
          authApiClient.logout({ refreshToken }).catch(console.error);
        }
      },

      // Optimized refresh session
      refreshSession: async (): Promise<boolean> => {
        const { isRefreshing, refreshPromise, refreshToken } = get();

        if (isRefreshing && refreshPromise) return refreshPromise;
        if (!refreshToken) {
          await get().logout();
          return false;
        }

        const promise = (async (): Promise<boolean> => {
          set({ isRefreshing: true });

          try {
            const response = await authApiClient.refreshToken({ refreshToken });

            if (response.success && response.data) {
              const {
                user,
                accessToken,
                refreshToken: newRefreshToken,
                expiresIn = 86400,
              } = response.data;
              const tokenExpiresAt = Date.now() + expiresIn * 1000;

              tokenStorage.store(accessToken, newRefreshToken, expiresIn);

              set({
                user,
                accessToken,
                refreshToken: newRefreshToken,
                tokenExpiresAt,
                lastActivity: Date.now(),
                sessionTimeoutWarning: false,
                isInitialized: true,
                isAuthenticated: true,
                isRefreshing: false,
                refreshPromise: null,
              });

              // Update account status in background
              get().updateAccountStatus().catch(console.error);
              return true;
            }

            set({ isRefreshing: false, refreshPromise: null });
            await get().logout();
            return false;
          } catch (error) {
            console.error("Token refresh failed:", error);
            set({ isRefreshing: false, refreshPromise: null });
            await get().logout();
            return false;
          }
        })();

        set({ refreshPromise: promise });
        return promise;
      },

      // Optimized checkAuth - prevents infinite loops
      checkAuth: async (): Promise<void> => {
        const state = get();

        // Early return conditions to prevent loops
        if (state.isCheckingAuth && state.checkAuthPromise)
          return state.checkAuthPromise;
        if (state.isRefreshing) return Promise.resolve();
        if (state.isInitialized && state.isAuthenticated && state.user)
          return Promise.resolve();

        const promise = (async (): Promise<void> => {
          set({ isCheckingAuth: true, checkAuthPromise: null });

          try {
            const { accessToken, refreshToken } = tokenStorage.get();

            if (!accessToken || !refreshToken) {
              set({
                isAuthenticated: false,
                isLoading: false,
                isInitialized: true,
                user: null,
                accessToken: null,
                refreshToken: null,
                tokenExpiresAt: null,
                isCheckingAuth: false,
                checkAuthPromise: null,
              });
              return;
            }

            // Set tokens without triggering additional calls
            set({ accessToken, refreshToken });

            // Single API call for profile
            const profileResponse = await authApiClient.getProfile();

            if (profileResponse.success && profileResponse.data) {
              const profile = profileResponse.data;

              set({
                user: profile,
                isAuthenticated: true,
                isLoading: false,
                lastActivity: Date.now(),
                isInitialized: true,
                error: null,
                isCheckingAuth: false,
                checkAuthPromise: null,
              });

              // Update status in background without blocking
              get().updateAccountStatus().catch(console.error);
            } else {
              // Try refresh without recursive calls
              set({ isCheckingAuth: false, checkAuthPromise: null });

              const currentState = get();
              if (!currentState.isRefreshing) {
                const refreshed = await get().refreshSession();
                if (!refreshed) {
                  set({
                    user: null,
                    isAuthenticated: false,
                    accessToken: null,
                    refreshToken: null,
                    tokenExpiresAt: null,
                    isLoading: false,
                    isInitialized: true,
                  });
                }
              }
            }
          } catch (error) {
            console.error("Auth check failed:", error);
            set({
              user: null,
              isAuthenticated: false,
              accessToken: null,
              refreshToken: null,
              tokenExpiresAt: null,
              isLoading: false,
              isInitialized: true,
              error:
                error instanceof Error
                  ? error.message
                  : "Authentication failed",
              isCheckingAuth: false,
              checkAuthPromise: null,
            });
          }
        })();

        set({ checkAuthPromise: promise });
        return promise;
      },

      // Account status management
      updateAccountStatus: async (): Promise<AccountStatusResponse | null> => {
        try {
          const response = await authApiClient.getAccountStatus();
          if (response.success && response.data) {
            const status = response.data;
            set({
              accountStatus: status.accountStatus,
              validationStatus: status.validationStatus,
              accessLevel: status.accessLevel,
              requirements: status.requirements,
              hasBlueCheckmark: status.hasBlueCheckmark,
            });
            return status;
          }
        } catch (error) {
          console.error("Failed to update account status:", error);
        }
        return null;
      },

      // Complete profile method
      completeProfile: async (profileData: any): Promise<ProfileResult> => {
        set({ isLoading: true, error: null });

        try {
          const response = await authApiClient.completeProfile(profileData);

          if (response.success && response.data) {
            const { user, message, accountStatus, validationStatus } =
              response.data;

            set({
              user,
              accountStatus,
              validationStatus,
              accessLevel: "LIMITED",
              isLoading: false,
            });

            return { success: true, message };
          }

          const error = response.error?.message || "Failed to complete profile";
          set({ isLoading: false, error });
          return { success: false, error };
        } catch (error: any) {
          const errorMessage = error?.message || "Network error";
          set({ isLoading: false, error: errorMessage });
          return { success: false, error: errorMessage };
        }
      },

      // Utility methods
      getUserProfile: async (): Promise<User | null> => {
        const { user, isAuthenticated, isCheckingAuth } = get();
        if (user && isAuthenticated) return user;
        if (!isCheckingAuth) await get().checkAuth();
        return get().user;
      },

      updateUser: (userData: Partial<User>) => {
        const { user } = get();
        if (user) set({ user: { ...user, ...userData } });
      },

      updateProfile: async (profileData: any): Promise<boolean> => {
        const { user } = get();
        if (!user) return false;

        try {
          const response = await usersApiClient.updateUser(
            user.id,
            profileData
          );
          if (response.success && response.data) {
            set({ user: response.data });
            return true;
          }
        } catch (error) {
          console.error("Profile update failed:", error);
        }
        return false;
      },

      // Permission methods
      hasPermission: (permission: string): boolean => {
        const { user } = get();
        if (!user?.role?.permissions) return false;
        const permissions = user.role.permissions;
        return permissions.includes(permission) || permissions.includes("*");
      },

      hasAnyPermission: (permissions: string[]): boolean =>
        permissions.some((permission) => get().hasPermission(permission)),

      hasAllPermissions: (permissions: string[]): boolean =>
        permissions.every((permission) => get().hasPermission(permission)),

      hasRole: (roleName: string): boolean => {
        const { user } = get();
        return user?.role?.name === roleName;
      },

      hasUserType: (userType: UserType): boolean => {
        const { user } = get();
        return user?.userType === userType;
      },

      // Access level utilities
      canAccessDashboard: (): boolean => {
        const { accessLevel } = get();
        return accessLevelHelpers.canAccess(accessLevel, "LIMITED");
      },

      canAccessFullFeatures: (): boolean => {
        const { accessLevel } = get();
        return accessLevelHelpers.canAccess(accessLevel, "FULL");
      },

      needsProfileCompletion: (): boolean => {
        const { accessLevel, accountStatus } = get();
        return accessLevel === "PROFILE_ONLY" || accountStatus === "INACTIVE";
      },

      needsValidation: (): boolean => {
        const { accountStatus, validationStatus } = get();
        return (
          accountStatus === "PENDING_VALIDATION" &&
          validationStatus === "PENDING"
        );
      },

      isAccountBlocked: (): boolean => {
        const { accessLevel, accountStatus } = get();
        return (
          accessLevel === "NO_ACCESS" ||
          accountStatus === "PENDING" ||
          accountStatus === "REJECTED" ||
          accountStatus === "SUSPENDED"
        );
      },

      // Session utilities
      updateLastActivity: () => set({ lastActivity: Date.now() }),

      isSessionExpired: (): boolean => {
        const { lastActivity } = get();
        return Date.now() - lastActivity > SESSION_TIMEOUT;
      },

      getTimeUntilExpiry: (): number => {
        const { tokenExpiresAt } = get();
        return tokenExpiresAt ? Math.max(0, tokenExpiresAt - Date.now()) : 0;
      },

      setSessionTimeoutWarning: (show: boolean) =>
        set({ sessionTimeoutWarning: show }),

      extendSession: async (): Promise<void> => {
        const { isAuthenticated, tokenExpiresAt, isRefreshing } = get();
        if (!isAuthenticated || isRefreshing) return;

        const timeUntilExpiry = tokenExpiresAt
          ? tokenExpiresAt - Date.now()
          : 0;
        if (timeUntilExpiry <= AUTO_REFRESH_THRESHOLD) {
          await get().refreshSession();
        } else {
          get().updateLastActivity();
        }
      },

      // State management
      clearError: () => set({ error: null }),
      setLoading: (loading: boolean) => set({ isLoading: loading }),
    }),
    {
      name: "auth-store",
      partialize: (state) => ({
        user: state.user,
        lastActivity: state.lastActivity,
        accountStatus: state.accountStatus,
        validationStatus: state.validationStatus,
        accessLevel: state.accessLevel,
      }),
      version: 5,
      migrate: (persistedState: any, version: number) => {
        if (version < 5) {
          return {
            user: persistedState?.user || null,
            lastActivity: persistedState?.lastActivity || Date.now(),
            accountStatus: persistedState?.accountStatus || null,
            validationStatus: persistedState?.validationStatus || null,
            accessLevel: persistedState?.accessLevel || null,
          };
        }
        return persistedState;
      },
    }
  )
);
-----------------------------------------------------------------------
--++--> lib/stores/auth/tenant.store.ts =======>
-----------------------------------------------------------------------
import { create } from "zustand";
import { persist } from "zustand/middleware";
import { tenantsApiClient } from "@/lib/api/clients/auth/tenants.client";
import { sanitizeTenantData } from "@/lib/utils/data-sanitizer.utils";
import type { Tenant } from "@/lib/types/database/schema.types";
// Extended tenant interface for UI needs
export interface ExtendedTenant extends Tenant {
  // Additional UI-specific properties
  features?: string[];
  permissions?: string[];
  stats?: {
    totalUsers?: number;
    activeUsers?: number;
    totalParcels?: number;
    totalInvoices?: number;
    totalClaims?: number;
  };
}
interface TenantState {
  // Core state
  currentTenant: ExtendedTenant | null;
  tenants: ExtendedTenant[];
  isLoading: boolean;
  error: string | null;

  // Actions
  setTenant: (tenant: ExtendedTenant) => void;
  setTenants: (tenants: ExtendedTenant[]) => void;
  addTenant: (tenant: ExtendedTenant) => void;
  updateTenant: (tenantId: string, updates: Partial<ExtendedTenant>) => void;
  removeTenant: (tenantId: string) => void;
  clearCurrentTenant: () => void;

  // API Actions
  fetchTenants: () => Promise<void>;
  fetchCurrentTenant: () => Promise<void>;
  fetchTenantById: (tenantId: string) => Promise<ExtendedTenant | null>;
  switchTenant: (tenantId: string) => Promise<boolean>;
  updateTenantSettings: (settings: any) => Promise<boolean>;

  // Utility methods
  getTenantSettings: () => any;
  getCurrentTenantId: () => string | null;
  isTenantActive: (tenantId: string) => boolean;

  // Feature/Permission checking
  hasFeature: (feature: string) => boolean;
  getTenantPermissions: () => string[];
  canAccessResource: (resource: string) => boolean;

  // Error handling
  clearError: () => void;
  setError: (error: string) => void;
}
export const useTenantStore = create<TenantState>()(
  persist(
    (set, get) => ({
      // Initial state
      currentTenant: null,
      tenants: [],
      isLoading: false,
      error: null,

      // Basic setters with data sanitization
      setTenant: (tenant: ExtendedTenant) => {
        try {
          // Sanitize tenant data to prevent React render errors
          const sanitizedTenant = sanitizeTenantData(tenant);

          set({ currentTenant: sanitizedTenant, error: null });

          // Update API client tenant context
          if (typeof window !== "undefined") {
            localStorage.setItem("current_tenant_id", sanitizedTenant.id);
          }
        } catch (error) {
          console.error("Error setting tenant:", error);
          set({ error: "Failed to set tenant data" });
        }
      },

      setTenants: (tenants: ExtendedTenant[]) => {
        try {
          // Sanitize all tenant data
          const sanitizedTenants = tenants.map((tenant) =>
            sanitizeTenantData(tenant)
          );
          set({ tenants: sanitizedTenants, error: null });
        } catch (error) {
          console.error("Error setting tenants:", error);
          set({ error: "Failed to set tenants data" });
        }
      },

      addTenant: (tenant: ExtendedTenant) => {
        try {
          const { tenants } = get();
          const sanitizedTenant = sanitizeTenantData(tenant);
          set({ tenants: [...tenants, sanitizedTenant] });
        } catch (error) {
          console.error("Error adding tenant:", error);
          set({ error: "Failed to add tenant" });
        }
      },

      updateTenant: (tenantId: string, updates: Partial<ExtendedTenant>) => {
        try {
          const { tenants, currentTenant } = get();

          // Sanitize updates
          const sanitizedUpdates = sanitizeTenantData(updates);

          // Update in tenants list
          const updatedTenants = tenants.map((tenant) =>
            tenant.id === tenantId ? { ...tenant, ...sanitizedUpdates } : tenant
          );
          set({ tenants: updatedTenants });

          // Update current tenant if it's the one being updated
          if (currentTenant?.id === tenantId) {
            set({ currentTenant: { ...currentTenant, ...sanitizedUpdates } });
          }
        } catch (error) {
          console.error("Error updating tenant:", error);
          set({ error: "Failed to update tenant" });
        }
      },

      removeTenant: (tenantId: string) => {
        try {
          const { tenants, currentTenant } = get();

          const updatedTenants = tenants.filter(
            (tenant) => tenant.id !== tenantId
          );
          set({ tenants: updatedTenants });

          // Clear current tenant if it's the one being removed
          if (currentTenant?.id === tenantId) {
            get().clearCurrentTenant();
          }
        } catch (error) {
          console.error("Error removing tenant:", error);
          set({ error: "Failed to remove tenant" });
        }
      },

      clearCurrentTenant: () => {
        set({ currentTenant: null });

        if (typeof window !== "undefined") {
          localStorage.removeItem("current_tenant_id");
        }
      },

      // API Actions with enhanced error handling
      fetchTenants: async () => {
        set({ isLoading: true, error: null });

        try {
          const response = await tenantsApiClient.getTenants();

          if (response.success && response.data) {
            // Sanitize all tenant data
            const sanitizedTenants = Array.isArray(response.data)
              ? response.data.map((tenant) => sanitizeTenantData(tenant))
              : [sanitizeTenantData(response.data)];

            set({
              tenants: sanitizedTenants,
              isLoading: false,
              error: null,
            });
          } else {
            throw new Error(
              response.error?.message || "Failed to fetch tenants"
            );
          }
        } catch (paginatedError: any) {
          console.warn("Primary getTenants failed:", paginatedError.message);

          try {
            // Fallback to current tenant
            const fallbackResponse = await tenantsApiClient.getCurrentTenant();

            if (fallbackResponse.success && fallbackResponse.data) {
              const sanitizedTenant = sanitizeTenantData(fallbackResponse.data);

              set({
                tenants: [sanitizedTenant],
                isLoading: false,
                error: null,
              });
            } else {
              throw new Error(
                fallbackResponse.error?.message || "Failed to fetch tenant data"
              );
            }
          } catch (fallbackError: any) {
            console.error("All tenant fetch methods failed:", fallbackError);
            set({
              isLoading: false,
              error:
                fallbackError?.message ||
                "Network error while fetching tenants",
            });
          }
        }
      },

      fetchCurrentTenant: async () => {
        set({ isLoading: true, error: null });

        try {
          const response = await tenantsApiClient.getCurrentTenant();

          if (response.success && response.data) {
            // Sanitize tenant data to prevent React render errors
            const sanitizedTenant = sanitizeTenantData(response.data);

            set({
              currentTenant: sanitizedTenant,
              isLoading: false,
              error: null,
            });

            // Update localStorage
            if (typeof window !== "undefined") {
              localStorage.setItem("current_tenant_id", sanitizedTenant.id);
            }
          } else {
            set({
              isLoading: false,
              error:
                response.error?.message || "Failed to fetch current tenant",
            });
          }
        } catch (error: any) {
          console.error("Fetch current tenant failed:", error);
          set({
            isLoading: false,
            error: error?.message || "Network error while fetching tenant",
          });
        }
      },

      fetchTenantById: async (tenantId: string) => {
        set({ isLoading: true, error: null });

        try {
          const response = await tenantsApiClient.getCurrentTenant();

          if (response.success && response.data) {
            const sanitizedTenant = sanitizeTenantData(response.data);

            set({ isLoading: false, error: null });
            return sanitizedTenant;
          } else {
            set({
              isLoading: false,
              error: response.error?.message || "Failed to fetch tenant",
            });
            return null;
          }
        } catch (error: any) {
          console.error("Fetch tenant by ID failed:", error);
          set({
            isLoading: false,
            error: error?.message || "Network error while fetching tenant",
          });
          return null;
        }
      },

      switchTenant: async (tenantId: string) => {
        try {
          const { tenants } = get();

          // Check if tenant exists in local list
          const tenant = tenants.find((t) => t.id === tenantId);

          if (tenant) {
            get().setTenant(tenant);
            return true;
          } else {
            // Try to fetch the tenant
            const fetchedTenant = await get().fetchTenantById(tenantId);
            if (fetchedTenant) {
              get().setTenant(fetchedTenant);
              return true;
            }
          }

          set({ error: "Failed to switch to tenant" });
          return false;
        } catch (error: any) {
          console.error("Switch tenant failed:", error);
          set({ error: error?.message || "Failed to switch tenant" });
          return false;
        }
      },

      updateTenantSettings: async (settings: any) => {
        try {
          const response = await tenantsApiClient.updateTenantSettings(
            settings
          );

          if (response.success && response.data) {
            const { currentTenant } = get();
            if (currentTenant) {
              // Sanitize settings data
              const sanitizedSettings = sanitizeTenantData({
                settings: response.data.settings,
              });

              get().updateTenant(currentTenant.id, {
                settings: sanitizedSettings.settings,
              });
            }
            return true;
          } else {
            set({
              error: response.error?.message || "Failed to update settings",
            });
            return false;
          }
        } catch (error: any) {
          console.error("Update tenant settings failed:", error);
          set({
            error: error?.message || "Network error while updating settings",
          });
          return false;
        }
      },

      // Utility methods (no changes needed)
      getTenantSettings: () => {
        const { currentTenant } = get();
        return currentTenant?.settings || {};
      },

      getCurrentTenantId: () => {
        const { currentTenant } = get();
        return currentTenant?.id || null;
      },

      isTenantActive: (tenantId: string) => {
        const { currentTenant } = get();
        return currentTenant?.id === tenantId && currentTenant?.isActive;
      },

      // Feature checking
      hasFeature: (feature: string) => {
        const { currentTenant } = get();
        if (!currentTenant?.features) return false;
        return currentTenant.features.includes(feature);
      },

      getTenantPermissions: () => {
        const { currentTenant } = get();
        return currentTenant?.permissions || [];
      },

      canAccessResource: (resource: string) => {
        const permissions = get().getTenantPermissions();
        return permissions.includes(resource) || permissions.includes("*");
      },

      // Error handling
      clearError: () => {
        set({ error: null });
      },

      setError: (error: string) => {
        set({ error });
      },
    }),
    {
      name: "tenant-store",
      partialize: (state) => ({
        currentTenant: state.currentTenant,
        tenants: state.tenants,
        // Don't persist loading states or errors
      }),
      version: 2, // Increment version to handle migration
      migrate: (persistedState: any, version: number) => {
        if (version < 2) {
          // Sanitize any persisted data that might have problematic objects
          return {
            currentTenant: persistedState?.currentTenant
              ? sanitizeTenantData(persistedState.currentTenant)
              : null,
            tenants: Array.isArray(persistedState?.tenants)
              ? persistedState.tenants.map((tenant: any) =>
                  sanitizeTenantData(tenant)
                )
              : [],
          };
        }
        return persistedState;
      },
    }
  )
);
// Helper function to initialize tenant from URL/localStorage with error handling
export const initializeTenantFromContext = async () => {
  if (typeof window === "undefined") return;

  try {
    const store = useTenantStore.getState();

    // Try to get tenant from localStorage first
    const storedTenantId = localStorage.getItem("current_tenant_id");

    if (storedTenantId && !store.currentTenant) {
      // Try to find tenant in local list or fetch it
      const existingTenant = store.tenants.find((t) => t.id === storedTenantId);

      if (existingTenant) {
        store.setTenant(existingTenant);
      } else {
        // Fetch tenant data
        await store.fetchTenantById(storedTenantId);
      }
    }
  } catch (error) {
    console.error("Failed to initialize tenant context:", error);
    // Clear potentially corrupted data
    if (typeof window !== "undefined") {
      localStorage.removeItem("current_tenant_id");
    }
  }
};
// Auto-initialize on client side with error handling
if (typeof window !== "undefined") {
  // Initialize tenant context when store is first accessed
  setTimeout(() => {
    initializeTenantFromContext().catch((error) => {
      console.error("Auto-initialization failed:", error);
    });
  }, 0);
}
-----------------------------------------------------------------------
--++--> lib/stores/parcels/cities.store.ts =======>
-----------------------------------------------------------------------
import { create } from "zustand";
import { persist } from "zustand/middleware";
import { citiesApiClient } from "@/lib/api/clients/parcels/cities.client";
import type {
  City,
  CreateCityRequest,
  UpdateCityRequest,
  CitiesFilters,
  ZoneStats,
} from "@/lib/types/parcels/cities.types";
import { toast } from "sonner";
interface CitiesState {
  // Core state
  cities: City[];
  currentCity: City | null;
  isLoading: boolean;
  error: string | null;

  // Pagination
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };

  // Filters
  filters: CitiesFilters;

  // Additional data
  pickupCities: City[];
  zoneStats: ZoneStats[];
  availableZones: string[];

  // Selection for bulk operations
  selectedCityIds: string[];

  // Actions
  setCities: (cities: City[]) => void;
  setCurrentCity: (city: City | null) => void;
  setPagination: (pagination: Partial<CitiesState["pagination"]>) => void;
  setFilters: (filters: Partial<CitiesFilters>) => void;
  clearError: () => void;
  setSelectedCityIds: (ids: string[]) => void;

  // API Actions
  fetchCities: () => Promise<void>;
  fetchCityById: (id: string) => Promise<City | null>;
  createCity: (data: CreateCityRequest) => Promise<boolean>;
  updateCity: (id: string, data: UpdateCityRequest) => Promise<boolean>;
  deleteCity: (id: string) => Promise<boolean>;
  toggleCityStatus: (id: string) => Promise<boolean>;
  fetchPickupCities: () => Promise<void>;
  fetchZoneStats: () => Promise<void>;
  fetchAvailableZones: () => Promise<void>;

  // Bulk operations
  bulkDeleteCities: (ids: string[]) => Promise<boolean>;
  bulkUpdateStatus: (ids: string[], status: boolean) => Promise<boolean>;

  // Search and validation
  searchCities: (query: string) => Promise<City[]>;
  validateCityRef: (ref: string, excludeId?: string) => Promise<boolean>;

  // Reset state
  resetState: () => void;
}
const initialState = {
  cities: [],
  currentCity: null,
  isLoading: false,
  error: null,
  pagination: {
    page: 1,
    limit: 10,
    total: 0,
    totalPages: 0,
    hasNext: false,
    hasPrev: false,
  },
  filters: {
    page: 1,
    limit: 10,
  },
  pickupCities: [],
  zoneStats: [],
  availableZones: [],
  selectedCityIds: [],
};
export const useCitiesStore = create<CitiesState>()(
  persist(
    (set, get) => ({
      ...initialState,

      // Setters
      setCities: (cities) => set({ cities }),

      setCurrentCity: (city) => set({ currentCity: city }),

      setPagination: (pagination) =>
        set((state) => ({
          pagination: { ...state.pagination, ...pagination },
        })),

      setFilters: (filters) => {
        set((state) => {
          const newFilters = { ...state.filters, ...filters };
          // Reset to page 1 when filters change (except page change)
          if (filters.page === undefined) {
            newFilters.page = 1;
          }
          return { filters: newFilters };
        });
        // Auto-fetch when filters change
        get().fetchCities();
      },

      clearError: () => set({ error: null }),

      setSelectedCityIds: (ids) => set({ selectedCityIds: ids }),

      // Fetch cities with current filters
      fetchCities: async () => {
        set({ isLoading: true, error: null });

        try {
          const { filters } = get();
          const response = await citiesApiClient.getCities(filters);

          if (response.success && response.data) {
            set({
              cities: response.data.data,
              pagination: response.data.meta,
              isLoading: false,
            });
          } else {
            throw new Error(
              response.error?.message || "Failed to fetch cities"
            );
          }
        } catch (error: any) {
          set({
            isLoading: false,
            error: error.message || "An error occurred while fetching cities",
          });
          toast.error("Failed to fetch cities");
        }
      },

      // Fetch single city by ID
      fetchCityById: async (id: string) => {
        set({ isLoading: true, error: null });

        try {
          const response = await citiesApiClient.getCityById(id);

          if (response.success && response.data) {
            set({ currentCity: response.data, isLoading: false });
            return response.data;
          } else {
            throw new Error(response.error?.message || "City not found");
          }
        } catch (error: any) {
          set({
            isLoading: false,
            error: error.message || "Failed to fetch city",
          });
          toast.error("Failed to fetch city details");
          return null;
        }
      },

      // Create new city
      createCity: async (data: CreateCityRequest) => {
        set({ isLoading: true, error: null });

        try {
          const response = await citiesApiClient.createCity(data);

          if (response.success && response.data) {
            // Add to local state
            set((state) => ({
              cities: [response.data!, ...state.cities],
              isLoading: false,
            }));

            toast.success("City created successfully");
            return true;
          } else {
            throw new Error(response.error?.message || "Failed to create city");
          }
        } catch (error: any) {
          set({
            isLoading: false,
            error: error.message || "Failed to create city",
          });
          toast.error(error.message || "Failed to create city");
          return false;
        }
      },

      // Update city
      updateCity: async (id: string, data: UpdateCityRequest) => {
        set({ isLoading: true, error: null });

        try {
          const response = await citiesApiClient.updateCity(id, data);

          if (response.success && response.data) {
            // Update in local state
            set((state) => ({
              cities: state.cities.map((city) =>
                city.id === id ? response.data! : city
              ),
              currentCity:
                state.currentCity?.id === id
                  ? response.data!
                  : state.currentCity,
              isLoading: false,
            }));

            toast.success("City updated successfully");
            return true;
          } else {
            throw new Error(response.error?.message || "Failed to update city");
          }
        } catch (error: any) {
          set({
            isLoading: false,
            error: error.message || "Failed to update city",
          });
          toast.error(error.message || "Failed to update city");
          return false;
        }
      },

      // Delete city
      deleteCity: async (id: string) => {
        set({ isLoading: true, error: null });

        try {
          const response = await citiesApiClient.deleteCity(id);

          if (response.success) {
            // Remove from local state
            set((state) => ({
              cities: state.cities.filter((city) => city.id !== id),
              currentCity:
                state.currentCity?.id === id ? null : state.currentCity,
              isLoading: false,
            }));

            toast.success("City deleted successfully");
            return true;
          } else {
            throw new Error(response.error?.message || "Failed to delete city");
          }
        } catch (error: any) {
          set({
            isLoading: false,
            error: error.message || "Failed to delete city",
          });
          toast.error(error.message || "Failed to delete city");
          return false;
        }
      },

      // Toggle city status
      toggleCityStatus: async (id: string) => {
        try {
          const response = await citiesApiClient.toggleCityStatus(id);

          if (response.success && response.data) {
            // Update in local state
            set((state) => ({
              cities: state.cities.map((city) =>
                city.id === id ? response.data! : city
              ),
              currentCity:
                state.currentCity?.id === id
                  ? response.data!
                  : state.currentCity,
            }));

            const status = response.data.status ? "activated" : "deactivated";
            toast.success(`City ${status} successfully`);
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to toggle city status"
            );
          }
        } catch (error: any) {
          toast.error(error.message || "Failed to toggle city status");
          return false;
        }
      },

      // Fetch pickup cities
      fetchPickupCities: async () => {
        try {
          const response = await citiesApiClient.getPickupCities();

          if (response.success && response.data) {
            set({ pickupCities: response.data });
          }
        } catch (error: any) {
          console.error("Failed to fetch pickup cities:", error);
        }
      },

      // Fetch zone statistics
      fetchZoneStats: async () => {
        try {
          const response = await citiesApiClient.getZoneStats();

          if (response.success && response.data) {
            set({ zoneStats: response.data });
          }
        } catch (error: any) {
          console.error("Failed to fetch zone stats:", error);
        }
      },

      // Fetch available zones
      fetchAvailableZones: async () => {
        try {
          const response = await citiesApiClient.getAvailableZones();

          if (response.success && response.data) {
            set({ availableZones: response.data });
          }
        } catch (error: any) {
          console.error("Failed to fetch available zones:", error);
        }
      },

      // Bulk delete cities
      bulkDeleteCities: async (ids: string[]) => {
        set({ isLoading: true, error: null });

        try {
          const response = await citiesApiClient.bulkDeleteCities(ids);

          if (response.success) {
            // Remove from local state
            set((state) => ({
              cities: state.cities.filter((city) => !ids.includes(city.id)),
              selectedCityIds: [],
              isLoading: false,
            }));

            toast.success(
              `${
                response.data?.deleted || ids.length
              } cities deleted successfully`
            );
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to delete cities"
            );
          }
        } catch (error: any) {
          set({
            isLoading: false,
            error: error.message || "Failed to delete cities",
          });
          toast.error(error.message || "Failed to delete cities");
          return false;
        }
      },

      // Bulk update status
      bulkUpdateStatus: async (ids: string[], status: boolean) => {
        set({ isLoading: true, error: null });

        try {
          const response = await citiesApiClient.bulkUpdateCitiesStatus(
            ids,
            status
          );

          if (response.success) {
            // Update in local state
            set((state) => ({
              cities: state.cities.map((city) =>
                ids.includes(city.id) ? { ...city, status } : city
              ),
              selectedCityIds: [],
              isLoading: false,
            }));

            const action = status ? "activated" : "deactivated";
            toast.success(
              `${
                response.data?.updated || ids.length
              } cities ${action} successfully`
            );
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to update cities"
            );
          }
        } catch (error: any) {
          set({
            isLoading: false,
            error: error.message || "Failed to update cities",
          });
          toast.error(error.message || "Failed to update cities");
          return false;
        }
      },

      // Search cities
      searchCities: async (query: string) => {
        try {
          const response = await citiesApiClient.searchCities(query);

          if (response.success && response.data) {
            return response.data;
          }
          return [];
        } catch (error) {
          console.error("Failed to search cities:", error);
          return [];
        }
      },

      // Validate city reference
      validateCityRef: async (ref: string, excludeId?: string) => {
        try {
          const response = await citiesApiClient.validateCityRef(
            ref,
            excludeId
          );

          if (response.success && response.data) {
            return response.data.isUnique;
          }
          return false;
        } catch (error) {
          console.error("Failed to validate city reference:", error);
          return false;
        }
      },

      // Reset state
      resetState: () => set(initialState),
    }),
    {
      name: "cities-store",
      partialize: (state) => ({
        filters: state.filters,
        pagination: state.pagination,
      }),
      version: 1,
    }
  )
);
-----------------------------------------------------------------------
--++--> lib/stores/parcels/parcel-statuses.store.ts =======>
-----------------------------------------------------------------------
import { create } from "zustand";
import { devtools } from "zustand/middleware";
import { parcelStatusesApiClient } from "@/lib/api/clients/parcels/parcel-statuses";
import { toast } from "sonner";
import type {
  ParcelStatus,
  CreateParcelStatusRequest,
  UpdateParcelStatusRequest,
  ParcelStatusFilters,
  OptionStats,
} from "@/lib/types/parcels/parcel-statuses.types";
interface ParcelStatusesState {
  // Parcel Statuses
  parcelStatuses: ParcelStatus[];
  parcelStatusesLoading: boolean;
  parcelStatusesFilters: ParcelStatusFilters;

  // Stats
  stats: OptionStats | null;
  statsLoading: boolean;

  // General
  error: string | null;

  // Actions - Parcel Statuses
  fetchParcelStatuses: () => Promise<void>;
  createParcelStatus: (data: CreateParcelStatusRequest) => Promise<boolean>;
  updateParcelStatus: (
    id: string,
    data: UpdateParcelStatusRequest
  ) => Promise<boolean>;
  deleteParcelStatus: (id: string) => Promise<boolean>;
  toggleParcelStatusStatus: (id: string) => Promise<boolean>;
  setParcelStatusesFilters: (filters: Partial<ParcelStatusFilters>) => void;
  bulkDeleteParcelStatuses: (ids: string[]) => Promise<boolean>;
  bulkToggleParcelStatuses: (ids: string[]) => Promise<boolean>;

  // Actions - Stats
  fetchStats: () => Promise<void>;

  // Utility Actions
  clearError: () => void;
  refreshAll: () => Promise<void>;
}
export const useParcelStatusesStore = create<ParcelStatusesState>()(
  devtools(
    (set, get) => ({
      // Initial State
      parcelStatuses: [],
      parcelStatusesLoading: false,
      parcelStatusesFilters: { page: 1, limit: 10 },

      stats: null,
      statsLoading: false,
      error: null,

      // Parcel Statuses Actions
      fetchParcelStatuses: async () => {
        set({ parcelStatusesLoading: true, error: null });
        try {
          const response = await parcelStatusesApiClient.getParcelStatuses(
            get().parcelStatusesFilters
          );
          if (response.success && response.data) {
            set({ parcelStatuses: response.data });
          } else {
            set({
              error:
                typeof response.error === "string"
                  ? response.error
                  : response.error?.message ||
                    "Failed to fetch parcel statuses",
            });
          }
        } catch (error) {
          console.error("Failed to fetch parcel statuses:", error);
          set({ error: "Failed to fetch parcel statuses" });
        } finally {
          set({ parcelStatusesLoading: false });
        }
      },

      createParcelStatus: async (data: CreateParcelStatusRequest) => {
        try {
          const response = await parcelStatusesApiClient.createParcelStatus(
            data
          );
          if (response.success && response.data) {
            // Add the new status to the beginning of the array
            set((state) => ({
              parcelStatuses: [response.data!, ...state.parcelStatuses],
            }));
            toast.success("Parcel status created successfully");
            return true;
          } else {
            toast.error(
              typeof response.error === "string"
                ? response.error
                : response.error?.message || "Failed to create parcel status"
            );

            return false;
          }
        } catch (error) {
          console.error("Failed to create parcel status:", error);
          toast.error("Failed to create parcel status");
          return false;
        }
      },

      updateParcelStatus: async (
        id: string,
        data: UpdateParcelStatusRequest
      ) => {
        try {
          const response = await parcelStatusesApiClient.updateParcelStatus(
            id,
            data
          );
          if (response.success && response.data) {
            // Update the status in the array
            set((state) => ({
              parcelStatuses: state.parcelStatuses.map((status) =>
                status.id === id ? response.data! : status
              ),
            }));
            toast.success("Parcel status updated successfully");
            return true;
          } else {
            toast.error(
              typeof response.error === "string"
                ? response.error
                : response.error?.message || "Failed to update parcel status"
            );

            return false;
          }
        } catch (error) {
          console.error("Failed to update parcel status:", error);
          toast.error("Failed to update parcel status");
          return false;
        }
      },

      deleteParcelStatus: async (id: string) => {
        try {
          const response = await parcelStatusesApiClient.deleteParcelStatus(id);
          if (response.success) {
            // Remove the status from the array
            set((state) => ({
              parcelStatuses: state.parcelStatuses.filter(
                (status) => status.id !== id
              ),
            }));
            toast.success("Parcel status deleted successfully");
            return true;
          } else {
            toast.error(
              typeof response.error === "string"
                ? response.error
                : response.error?.message || "Failed to delete parcel status"
            );

            return false;
          }
        } catch (error) {
          console.error("Failed to delete parcel status:", error);
          toast.error("Failed to delete parcel status");
          return false;
        }
      },

      toggleParcelStatusStatus: async (id: string) => {
        try {
          const response =
            await parcelStatusesApiClient.toggleParcelStatusStatus(id);
          if (response.success && response.data) {
            // Update the status in the array
            set((state) => ({
              parcelStatuses: state.parcelStatuses.map((status) =>
                status.id === id ? response.data! : status
              ),
            }));
            const newStatus = response.data.status
              ? "activated"
              : "deactivated";
            toast.success(`Parcel status ${newStatus} successfully`);
            return true;
          } else {
            toast.error(
              typeof response.error === "string"
                ? response.error
                : response.error?.message || "Failed to toggle parcel status"
            );

            return false;
          }
        } catch (error) {
          console.error("Failed to toggle parcel status:", error);
          toast.error("Failed to toggle parcel status");
          return false;
        }
      },

      setParcelStatusesFilters: (filters: Partial<ParcelStatusFilters>) => {
        set((state) => ({
          parcelStatusesFilters: { ...state.parcelStatusesFilters, ...filters },
        }));
      },

      bulkDeleteParcelStatuses: async (ids: string[]) => {
        try {
          // Since bulk delete doesn't exist in backend yet, do individual deletes
          const promises = ids.map((id) => get().deleteParcelStatus(id));
          const results = await Promise.all(promises);
          const successCount = results.filter(Boolean).length;

          if (successCount === ids.length) {
            toast.success(
              `${successCount} parcel statuses deleted successfully`
            );
            return true;
          } else {
            toast.error(
              `Only ${successCount} of ${ids.length} parcel statuses were deleted`
            );
            return false;
          }
        } catch (error) {
          console.error("Failed to bulk delete parcel statuses:", error);
          toast.error("Failed to delete parcel statuses");
          return false;
        }
      },

      bulkToggleParcelStatuses: async (ids: string[]) => {
        try {
          // Since bulk toggle doesn't exist in backend yet, do individual toggles
          const promises = ids.map((id) => get().toggleParcelStatusStatus(id));
          const results = await Promise.all(promises);
          const successCount = results.filter(Boolean).length;

          if (successCount === ids.length) {
            toast.success(
              `${successCount} parcel statuses toggled successfully`
            );
            return true;
          } else {
            toast.error(
              `Only ${successCount} of ${ids.length} parcel statuses were toggled`
            );
            return false;
          }
        } catch (error) {
          console.error("Failed to bulk toggle parcel statuses:", error);
          toast.error("Failed to toggle parcel statuses");
          return false;
        }
      },

      // Stats Actions
      fetchStats: async () => {
        set({ statsLoading: true });
        try {
          const response =
            await parcelStatusesApiClient.getParcelStatusesStats();
          if (response.success && response.data) {
            set({ stats: response.data });
          } else {
            console.error("Failed to fetch stats:", response.error);
          }
        } catch (error) {
          console.error("Failed to fetch stats:", error);
        } finally {
          set({ statsLoading: false });
        }
      },

      // Utility Actions
      clearError: () => set({ error: null }),

      refreshAll: async () => {
        await Promise.all([get().fetchParcelStatuses(), get().fetchStats()]);
      },
    }),
    { name: "parcel-statuses-store" }
  )
);
-----------------------------------------------------------------------
--++--> lib/stores/parcels/pickup-cities.store.ts =======>
-----------------------------------------------------------------------
import { create } from "zustand";
import { persist } from "zustand/middleware";
import { pickupCitiesApiClient } from "@/lib/api/clients/parcels/pickup-cities.client";
import type {
  PickupCity,
  CreatePickupCityRequest,
  UpdatePickupCityRequest,
  PickupCityFilters,
  PaginatedResponse,
  PickupCityStatistics,
} from "@/lib/types/parcels/pickup-cities.types";
import { toast } from "sonner";
interface PickupCitiesState {
  // Core state
  pickupCities: PickupCity[];
  activePickupCities: PickupCity[];
  selectedPickupCity: PickupCity | null;
  statistics: PickupCityStatistics | null;

  // UI state
  isLoading: boolean;
  isCreating: boolean;
  isUpdating: boolean;
  isDeleting: boolean;
  error: string | null;

  // Pagination state
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };

  // Filters state
  filters: PickupCityFilters;

  // Selection state for bulk operations
  selectedIds: string[];

  // Actions
  setFilters: (filters: Partial<PickupCityFilters>) => void;
  clearFilters: () => void;
  setSelectedIds: (ids: string[]) => void;
  clearSelectedIds: () => void;

  // API Actions
  fetchPickupCities: () => Promise<void>;
  fetchActivePickupCities: () => Promise<void>;
  fetchPickupCityById: (id: string) => Promise<PickupCity | null>;
  createPickupCity: (
    data: CreatePickupCityRequest
  ) => Promise<PickupCity | null>;
  updatePickupCity: (
    id: string,
    data: UpdatePickupCityRequest
  ) => Promise<PickupCity | null>;
  deletePickupCity: (id: string) => Promise<boolean>;
  togglePickupCityStatus: (id: string) => Promise<boolean>;

  // Bulk operations
  bulkDeletePickupCities: (ids: string[]) => Promise<boolean>;
  bulkToggleStatus: (ids: string[], status: boolean) => Promise<boolean>;

  // Statistics
  fetchStatistics: () => Promise<void>;

  // Utility methods
  getPickupCityById: (id: string) => PickupCity | undefined;
  resetState: () => void;
  clearError: () => void;
}
const DEFAULT_FILTERS: PickupCityFilters = {
  page: 1,
  limit: 10,
  search: "",
  sortBy: "name",
  sortParcel: "asc",
};
const DEFAULT_PAGINATION = {
  page: 1,
  limit: 10,
  total: 0,
  totalPages: 0,
  hasNext: false,
  hasPrev: false,
};
export const usePickupCitiesStore = create<PickupCitiesState>()(
  persist(
    (set, get) => ({
      // Initial state
      pickupCities: [],
      activePickupCities: [],
      selectedPickupCity: null,
      statistics: null,
      isLoading: false,
      isCreating: false,
      isUpdating: false,
      isDeleting: false,
      error: null,
      pagination: DEFAULT_PAGINATION,
      filters: DEFAULT_FILTERS,
      selectedIds: [],

      // Filter actions
      setFilters: (newFilters) => {
        const updatedFilters = { ...get().filters, ...newFilters };
        set({ filters: updatedFilters });

        // Reset to page 1 if search or other filters changed
        if ("search" in newFilters || "status" in newFilters) {
          set({ filters: { ...updatedFilters, page: 1 } });
        }

        // Auto-fetch with new filters
        get().fetchPickupCities();
      },

      clearFilters: () => {
        set({ filters: DEFAULT_FILTERS });
        get().fetchPickupCities();
      },

      setSelectedIds: (ids) => set({ selectedIds: ids }),
      clearSelectedIds: () => set({ selectedIds: [] }),

      // Fetch pickup cities with filters and pagination
      fetchPickupCities: async () => {
        const { filters } = get();
        set({ isLoading: true, error: null });

        try {
          const response = await pickupCitiesApiClient.getPickupCities(filters);

          if (response.success && response.data) {
            set({
              pickupCities: response.data.data,
              pagination: response.data.meta,
              isLoading: false,
            });
          } else {
            throw new Error(
              response.error?.message || "Failed to fetch pickup cities"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error fetching pickup cities:", error);
          set({ error: errorMessage, isLoading: false });
          toast.error("Failed to fetch pickup cities");
        }
      },

      // Fetch active pickup cities only
      fetchActivePickupCities: async () => {
        try {
          const response = await pickupCitiesApiClient.getActivePickupCities();

          if (response.success && response.data) {
            set({ activePickupCities: response.data });
          } else {
            throw new Error(
              response.error?.message || "Failed to fetch active pickup cities"
            );
          }
        } catch (error) {
          console.error("Error fetching active pickup cities:", error);
          toast.error("Failed to fetch active pickup cities");
        }
      },

      // Fetch pickup city by ID
      fetchPickupCityById: async (id: string) => {
        set({ isLoading: true, error: null });

        try {
          const response = await pickupCitiesApiClient.getPickupCityById(id);

          if (response.success && response.data) {
            set({ selectedPickupCity: response.data, isLoading: false });
            return response.data;
          } else {
            throw new Error(response.error?.message || "Pickup city not found");
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error fetching pickup city:", error);
          set({
            error: errorMessage,
            isLoading: false,
            selectedPickupCity: null,
          });
          toast.error("Failed to fetch pickup city");
          return null;
        }
      },

      // Create pickup city
      createPickupCity: async (data: CreatePickupCityRequest) => {
        set({ isCreating: true, error: null });

        try {
          const response = await pickupCitiesApiClient.createPickupCity(data);

          if (response.success && response.data) {
            const newPickupCity = response.data;

            // Add to list if it matches current filters
            const { pickupCities } = get();
            set({
              pickupCities: [newPickupCity, ...pickupCities],
              isCreating: false,
            });

            toast.success("Pickup city created successfully");

            // Refresh the list to get accurate pagination
            get().fetchPickupCities();

            return newPickupCity;
          } else {
            throw new Error(
              response.error?.message || "Failed to create pickup city"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error creating pickup city:", error);
          set({ error: errorMessage, isCreating: false });
          toast.error(`Failed to create pickup city: ${errorMessage}`);
          return null;
        }
      },

      // Update pickup city
      updatePickupCity: async (id: string, data: UpdatePickupCityRequest) => {
        set({ isUpdating: true, error: null });

        try {
          const response = await pickupCitiesApiClient.updatePickupCity(
            id,
            data
          );

          if (response.success && response.data) {
            const updatedPickupCity = response.data;

            // Update in list
            const { pickupCities } = get();
            const updatedList = pickupCities.map((city) =>
              city.id === id ? updatedPickupCity : city
            );

            set({
              pickupCities: updatedList,
              selectedPickupCity: updatedPickupCity,
              isUpdating: false,
            });

            toast.success("Pickup city updated successfully");
            return updatedPickupCity;
          } else {
            throw new Error(
              response.error?.message || "Failed to update pickup city"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error updating pickup city:", error);
          set({ error: errorMessage, isUpdating: false });
          toast.error(`Failed to update pickup city: ${errorMessage}`);
          return null;
        }
      },

      // Delete pickup city
      deletePickupCity: async (id: string) => {
        set({ isDeleting: true, error: null });

        try {
          const response = await pickupCitiesApiClient.deletePickupCity(id);

          if (response.success) {
            // Remove from list
            const { pickupCities } = get();
            const updatedList = pickupCities.filter((city) => city.id !== id);

            set({
              pickupCities: updatedList,
              selectedPickupCity: null,
              isDeleting: false,
            });

            toast.success("Pickup city deleted successfully");

            // Refresh to get accurate pagination
            get().fetchPickupCities();

            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to delete pickup city"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error deleting pickup city:", error);
          set({ error: errorMessage, isDeleting: false });
          toast.error(`Failed to delete pickup city: ${errorMessage}`);
          return false;
        }
      },

      // Toggle pickup city status
      togglePickupCityStatus: async (id: string) => {
        try {
          const response = await pickupCitiesApiClient.togglePickupCityStatus(
            id
          );

          if (response.success && response.data) {
            const updatedPickupCity = response.data;

            // Update in list
            const { pickupCities } = get();
            const updatedList = pickupCities.map((city) =>
              city.id === id ? updatedPickupCity : city
            );

            set({
              pickupCities: updatedList,
              selectedPickupCity: updatedPickupCity,
            });

            const status = updatedPickupCity.status
              ? "activated"
              : "deactivated";
            toast.success(`Pickup city ${status} successfully`);

            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to toggle pickup city status"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error toggling pickup city status:", error);
          toast.error(`Failed to toggle status: ${errorMessage}`);
          return false;
        }
      },

      // Bulk delete pickup cities
      bulkDeletePickupCities: async (ids: string[]) => {
        set({ isDeleting: true, error: null });

        try {
          const response = await pickupCitiesApiClient.bulkDeletePickupCities(
            ids
          );

          if (response.success && response.data) {
            toast.success(
              `${response.data.successful} pickup cities deleted successfully`
            );

            if (response.data.failed.length > 0) {
              toast.warning(
                `${response.data.failed.length} pickup cities could not be deleted`
              );
            }

            // Clear selection and refresh
            set({ selectedIds: [], isDeleting: false });
            get().fetchPickupCities();

            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to delete pickup cities"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error bulk deleting pickup cities:", error);
          set({ error: errorMessage, isDeleting: false });
          toast.error(`Failed to delete pickup cities: ${errorMessage}`);
          return false;
        }
      },

      // Bulk toggle status
      bulkToggleStatus: async (ids: string[], status: boolean) => {
        try {
          const response = await pickupCitiesApiClient.bulkToggleStatus(
            ids,
            status
          );

          if (response.success && response.data) {
            const action = status ? "activated" : "deactivated";
            toast.success(
              `${response.data.successful} pickup cities ${action} successfully`
            );

            if (response.data.failed.length > 0) {
              toast.warning(
                `${response.data.failed.length} pickup cities could not be ${action}`
              );
            }

            // Clear selection and refresh
            set({ selectedIds: [] });
            get().fetchPickupCities();

            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to update pickup city status"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error bulk toggling pickup city status:", error);
          toast.error(`Failed to update status: ${errorMessage}`);
          return false;
        }
      },

      // Fetch statistics
      fetchStatistics: async () => {
        try {
          const response =
            await pickupCitiesApiClient.getPickupCityStatistics();

          if (response.success && response.data) {
            set({ statistics: response.data });
          } else {
            throw new Error(
              response.error?.message || "Failed to fetch statistics"
            );
          }
        } catch (error) {
          console.error("Error fetching pickup city statistics:", error);
        }
      },

      // Utility methods
      getPickupCityById: (id: string) => {
        const { pickupCities } = get();
        return pickupCities.find((city) => city.id === id);
      },

      resetState: () => {
        set({
          pickupCities: [],
          activePickupCities: [],
          selectedPickupCity: null,
          statistics: null,
          error: null,
          pagination: DEFAULT_PAGINATION,
          filters: DEFAULT_FILTERS,
          selectedIds: [],
          isLoading: false,
          isCreating: false,
          isUpdating: false,
          isDeleting: false,
        });
      },

      clearError: () => set({ error: null }),
    }),
    {
      name: "pickup-cities-store",
      partialize: (state) => ({
        activePickupCities: state.activePickupCities,
        statistics: state.statistics,
        // Don't persist loading states or selections
      }),
      version: 1,
    }
  )
);
-----------------------------------------------------------------------
--++--> lib/stores/parcels/tariffs.store.ts =======>
-----------------------------------------------------------------------
import { create } from "zustand";
import { tariffsApiClient } from "@/lib/api/clients/parcels/tariffs.client";
import type {
  Tariff,
  CreateTariffRequest,
  UpdateTariffRequest,
  TariffFilters,
  TariffCalculationRequest,
  TariffCalculationResult,
  BulkTariffImportRequest,
  BulkImportResult,
} from "@/lib/types/parcels/tariffs.types";
import { toast } from "sonner";
interface TariffState {
  // State
  tariffs: Tariff[];
  currentTariff: Tariff | null;
  isLoading: boolean;
  error: string | null;

  // Pagination
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };

  // Filters
  filters: TariffFilters;

  // Stats
  stats: {
    totalTariffs: number;
    averageDeliveryPrice: number;
    averageReturnPrice: number;
    averageRefusalPrice: number;
    averageDeliveryDelay: number;
    priceRanges: { range: string; count: number }[];
    delayDistribution: { delay: number; count: number }[];
    cityPairCoverage: {
      totalPossiblePairs: number;
      configuredPairs: number;
      coveragePercentage: number;
    };
  } | null;

  // Missing tariffs
  missingTariffs: Array<{
    pickupCityId: string;
    destinationCityId: string;
    pickupCity: {
      id: string;
      name: string;
      ref: string;
    };
    destinationCity: {
      id: string;
      name: string;
      ref: string;
    };
    route: string;
  }>;

  // Calculation result
  calculationResult: TariffCalculationResult | null;

  // Actions
  fetchTariffs: () => Promise<void>;
  fetchTariffById: (id: string) => Promise<void>;
  createTariff: (data: CreateTariffRequest) => Promise<boolean>;
  updateTariff: (id: string, data: UpdateTariffRequest) => Promise<boolean>;
  deleteTariff: (id: string) => Promise<boolean>;
  bulkImportTariffs: (
    data: BulkTariffImportRequest
  ) => Promise<BulkImportResult | null>;
  calculateTariff: (data: TariffCalculationRequest) => Promise<boolean>;
  fetchStats: () => Promise<void>;
  fetchMissingTariffs: () => Promise<void>;
  validateRoute: (
    pickupCityId: string,
    destinationCityId: string,
    excludeId?: string
  ) => Promise<boolean>;
  duplicateTariff: (
    id: string,
    pickupCityId: string,
    destinationCityId: string
  ) => Promise<boolean>;

  // Filter actions
  setFilters: (filters: Partial<TariffFilters>) => void;
  resetFilters: () => void;

  // Utility actions
  setCurrentTariff: (tariff: Tariff | null) => void;
  clearError: () => void;
  clearCalculationResult: () => void;
}
const initialFilters: TariffFilters = {
  page: 1,
  limit: 10,
  search: "",
};
export const useTariffsStore = create<TariffState>((set, get) => ({
  // Initial state
  tariffs: [],
  currentTariff: null,
  isLoading: false,
  error: null,
  pagination: {
    page: 1,
    limit: 10,
    total: 0,
    totalPages: 0,
    hasNext: false,
    hasPrev: false,
  },
  filters: initialFilters,
  stats: null,
  missingTariffs: [],
  calculationResult: null,

  // Fetch tariffs with filters
  fetchTariffs: async () => {
    const { filters } = get();
    set({ isLoading: true, error: null });

    try {
      const result = await tariffsApiClient.getTariffs(filters);

      if (result.data) {
        set({
          tariffs: result.data[0].data,
          pagination: result.data[0].meta,
          isLoading: false,
        });
      } else {
        throw new Error("Failed to fetch tariffs");
      }
    } catch (error: any) {
      console.error("Error fetching tariffs:", error);
      set({
        error: error?.message || "Failed to fetch tariffs",
        isLoading: false,
      });
      toast.error("Failed to fetch tariffs");
    }
  },

  // Fetch single tariff
  fetchTariffById: async (id: string) => {
    set({ isLoading: true, error: null });

    try {
      const result = await tariffsApiClient.getTariffById(id);

      if (result.success && result.data) {
        set({
          currentTariff: result.data,
          isLoading: false,
        });
      } else {
        throw new Error(result.error?.message || "Failed to fetch tariff");
      }
    } catch (error: any) {
      console.error("Error fetching tariff:", error);
      set({
        error: error?.message || "Failed to fetch tariff",
        isLoading: false,
      });
      toast.error("Failed to fetch tariff details");
    }
  },

  // Create tariff
  createTariff: async (data: CreateTariffRequest) => {
    set({ isLoading: true, error: null });

    try {
      const result = await tariffsApiClient.createTariff(data);

      if (result.success && result.data) {
        // Refresh the list
        await get().fetchTariffs();
        set({ isLoading: false });
        toast.success("Tariff created successfully");
        return true;
      } else {
        throw new Error(result.error?.message || "Failed to create tariff");
      }
    } catch (error: any) {
      console.error("Error creating tariff:", error);
      const errorMessage = error?.message || "Failed to create tariff";
      set({
        error: errorMessage,
        isLoading: false,
      });
      toast.error(errorMessage);
      return false;
    }
  },

  // Update tariff
  updateTariff: async (id: string, data: UpdateTariffRequest) => {
    set({ isLoading: true, error: null });

    try {
      const result = await tariffsApiClient.updateTariff(id, data);

      if (result.success && result.data) {
        const { tariffs, currentTariff } = get();

        // Update in list
        const updatedTariffs = tariffs.map((tariff) =>
          tariff.id === id ? result.data! : tariff
        );

        set({
          tariffs: updatedTariffs,
          currentTariff:
            currentTariff?.id === id ? result.data! : currentTariff,
          isLoading: false,
        });

        toast.success("Tariff updated successfully");
        return true;
      } else {
        throw new Error(result.error?.message || "Failed to update tariff");
      }
    } catch (error: any) {
      console.error("Error updating tariff:", error);
      const errorMessage = error?.message || "Failed to update tariff";
      set({
        error: errorMessage,
        isLoading: false,
      });
      toast.error(errorMessage);
      return false;
    }
  },

  // Delete tariff
  deleteTariff: async (id: string) => {
    set({ isLoading: true, error: null });

    try {
      const result = await tariffsApiClient.deleteTariff(id);

      if (result.success) {
        const { tariffs, currentTariff } = get();

        // Remove from list
        const updatedTariffs = tariffs.filter((tariff) => tariff.id !== id);

        set({
          tariffs: updatedTariffs,
          currentTariff: currentTariff?.id === id ? null : currentTariff,
          isLoading: false,
        });

        toast.success("Tariff deleted successfully");
        return true;
      } else {
        throw new Error(result.error?.message || "Failed to delete tariff");
      }
    } catch (error: any) {
      console.error("Error deleting tariff:", error);
      const errorMessage = error?.message || "Failed to delete tariff";
      set({
        error: errorMessage,
        isLoading: false,
      });
      toast.error(errorMessage);
      return false;
    }
  },

  // Bulk import tariffs
  bulkImportTariffs: async (data: BulkTariffImportRequest) => {
    set({ isLoading: true, error: null });

    try {
      const result = await tariffsApiClient.bulkImportTariffs(data);

      if (result.success && result.data) {
        // Refresh the list
        await get().fetchTariffs();
        set({ isLoading: false });

        const importResult = result.data;
        if (importResult.failed > 0) {
          toast.warning(
            `Import completed: ${importResult.success} successful, ${importResult.failed} failed`
          );
        } else {
          toast.success(
            `Successfully imported ${importResult.success} tariffs`
          );
        }

        return importResult;
      } else {
        throw new Error(result.error?.message || "Failed to import tariffs");
      }
    } catch (error: any) {
      console.error("Error importing tariffs:", error);
      const errorMessage = error?.message || "Failed to import tariffs";
      set({
        error: errorMessage,
        isLoading: false,
      });
      toast.error(errorMessage);
      return null;
    }
  },

  // Calculate tariff
  calculateTariff: async (data: TariffCalculationRequest) => {
    set({ isLoading: true, error: null });

    try {
      const result = await tariffsApiClient.calculateTariff(data);

      if (result.success && result.data) {
        set({
          calculationResult: result.data,
          isLoading: false,
        });
        return true;
      } else {
        throw new Error(
          result.error?.message || "No tariff found for this route"
        );
      }
    } catch (error: any) {
      console.error("Error calculating tariff:", error);
      const errorMessage = error?.message || "Failed to calculate tariff";
      set({
        error: errorMessage,
        isLoading: false,
        calculationResult: null,
      });
      toast.error(errorMessage);
      return false;
    }
  },

  // Fetch stats
  fetchStats: async () => {
    try {
      const result = await tariffsApiClient.getTariffStats();

      if (result.success && result.data) {
        set({ stats: result.data });
      }
    } catch (error) {
      console.error("Error fetching tariff stats:", error);
    }
  },

  // Fetch missing tariffs
  fetchMissingTariffs: async () => {
    try {
      const result = await tariffsApiClient.getMissingTariffs();

      if (result.success && result.data) {
        set({ missingTariffs: result.data });
      }
    } catch (error) {
      console.error("Error fetching missing tariffs:", error);
    }
  },

  // Validate route
  validateRoute: async (
    pickupCityId: string,
    destinationCityId: string,
    excludeId?: string
  ) => {
    try {
      const result = await tariffsApiClient.validateTariffRoute(
        pickupCityId,
        destinationCityId,
        excludeId
      );

      if (result.success && result.data) {
        if (result.data.exists) {
          toast.error("A tariff already exists for this route");
          return false;
        }
        return true;
      }
      return true;
    } catch (error) {
      console.error("Error validating route:", error);
      return true; // Allow on validation error
    }
  },

  // Duplicate tariff
  duplicateTariff: async (
    id: string,
    pickupCityId: string,
    destinationCityId: string
  ) => {
    set({ isLoading: true, error: null });

    try {
      const result = await tariffsApiClient.duplicateTariff(
        id,
        pickupCityId,
        destinationCityId
      );

      if (result.success && result.data) {
        await get().fetchTariffs();
        set({ isLoading: false });
        toast.success("Tariff duplicated successfully");
        return true;
      } else {
        throw new Error(result.error?.message || "Failed to duplicate tariff");
      }
    } catch (error: any) {
      console.error("Error duplicating tariff:", error);
      const errorMessage = error?.message || "Failed to duplicate tariff";
      set({
        error: errorMessage,
        isLoading: false,
      });
      toast.error(errorMessage);
      return false;
    }
  },

  // Filter actions
  setFilters: (newFilters: Partial<TariffFilters>) => {
    const { filters } = get();
    const updatedFilters = { ...filters, ...newFilters };

    // Reset to page 1 when filters change (except for page changes)
    if (!newFilters.page) {
      updatedFilters.page = 1;
    }

    set({ filters: updatedFilters });

    // Auto-fetch when filters change
    get().fetchTariffs();
  },

  resetFilters: () => {
    set({ filters: initialFilters });
    get().fetchTariffs();
  },

  // Utility actions
  setCurrentTariff: (tariff: Tariff | null) => {
    set({ currentTariff: tariff });
  },

  clearError: () => {
    set({ error: null });
  },

  clearCalculationResult: () => {
    set({ calculationResult: null });
  },
}));
-----------------------------------------------------------------------
--++--> lib/stores/parcels/zones.store.ts =======>
-----------------------------------------------------------------------
import { create } from "zustand";
import { persist } from "zustand/middleware";
import { zonesApiClient } from "@/lib/api/clients/parcels/zones.client";
import { citiesApiClient } from "@/lib/api/clients/parcels/cities.client";
import type {
  Zone,
  CreateZoneRequest,
  UpdateZoneRequest,
  ZoneFilters,
  ZoneStatistics,
  AvailableCity,
} from "@/lib/types/parcels/zones.types";
import { toast } from "sonner";
interface ZonesState {
  // Data state
  zones: Zone[];
  activeZones: Zone[];
  currentZone: Zone | null;
  availableCities: AvailableCity[];
  statistics: ZoneStatistics | null;

  // UI state
  loading: boolean;
  error: string | null;
  filters: ZoneFilters;
  selectedZones: string[];

  // Pagination
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };

  // Actions
  setFilters: (filters: Partial<ZoneFilters>) => void;
  clearFilters: () => void;
  setSelectedZones: (zoneIds: string[]) => void;
  clearSelection: () => void;
  setError: (error: string | null) => void;
  clearError: () => void;

  // API actions
  fetchZones: (filters?: ZoneFilters) => Promise<void>;
  fetchActiveZones: () => Promise<void>;
  fetchZoneById: (id: string) => Promise<Zone | null>;
  fetchAvailableCities: () => Promise<void>;
  fetchStatistics: () => Promise<void>;

  // CRUD operations
  createZone: (data: CreateZoneRequest) => Promise<Zone | null>;
  updateZone: (id: string, data: UpdateZoneRequest) => Promise<Zone | null>;
  deleteZone: (id: string) => Promise<boolean>;
  toggleZoneStatus: (id: string) => Promise<boolean>;

  // Zone cities management
  addCitiesToZone: (zoneId: string, cityIds: string[]) => Promise<boolean>;
  removeCitiesFromZone: (zoneId: string, cityIds: string[]) => Promise<boolean>;

  // Bulk operations
  bulkDeleteZones: (zoneIds: string[]) => Promise<boolean>;
  bulkToggleStatus: (zoneIds: string[]) => Promise<boolean>;

  // Export
  exportZones: (filters?: ZoneFilters) => Promise<string | null>;

  // Utility methods
  getZoneById: (id: string) => Zone | undefined;
  getZonesByStatus: (status: boolean) => Zone[];
  getZonesCount: () => { total: number; active: number; inactive: number };
  refreshData: () => Promise<void>;
}
const DEFAULT_FILTERS: ZoneFilters = {
  page: 1,
  limit: 10,
  search: "",
  status: undefined,
};
const DEFAULT_PAGINATION = {
  page: 1,
  limit: 10,
  total: 0,
  totalPages: 0,
  hasNext: false,
  hasPrev: false,
};
export const useZonesStore = create<ZonesState>()(
  persist(
    (set, get) => ({
      // Initial state
      zones: [],
      activeZones: [],
      currentZone: null,
      availableCities: [],
      statistics: null,
      loading: false,
      error: null,
      filters: DEFAULT_FILTERS,
      selectedZones: [],
      pagination: DEFAULT_PAGINATION,

      // Filter and selection actions
      setFilters: (newFilters) => {
        const currentFilters = get().filters;
        const updatedFilters = { ...currentFilters, ...newFilters };

        // Reset page when filters change (except page itself)
        if (Object.keys(newFilters).some((key) => key !== "page")) {
          updatedFilters.page = 1;
        }

        set({ filters: updatedFilters });
        get().fetchZones(updatedFilters);
      },

      clearFilters: () => {
        set({ filters: DEFAULT_FILTERS });
        get().fetchZones(DEFAULT_FILTERS);
      },

      setSelectedZones: (zoneIds) => set({ selectedZones: zoneIds }),

      clearSelection: () => set({ selectedZones: [] }),

      setError: (error) => set({ error }),

      clearError: () => set({ error: null }),

      // Fetch zones with filters
      fetchZones: async (filters) => {
        set({ loading: true, error: null });

        try {
          const filtersToUse = filters || get().filters;
          const response = await zonesApiClient.getZones(filtersToUse);

          if (response.data) {
            set({
              zones: response.data[0].data,
              pagination: response.data[0].meta,
              loading: false,
            });
          } else {
            throw new Error(response.error?.message || "Failed to fetch zones");
          }
        } catch (error: any) {
          console.error("Error fetching zones:", error);
          set({
            error: error.message || "Failed to fetch zones",
            loading: false,
          });
          toast.error("Failed to fetch zones");
        }
      },

      // Fetch active zones only
      fetchActiveZones: async () => {
        try {
          const response = await zonesApiClient.getActiveZones();

          if (response.success && response.data) {
            set({ activeZones: response.data });
          }
        } catch (error: any) {
          console.error("Error fetching active zones:", error);
          toast.error("Failed to fetch active zones");
        }
      },

      // Fetch single zone
      fetchZoneById: async (id) => {
        set({ loading: true, error: null });

        try {
          const response = await zonesApiClient.getZoneById(id);

          if (response.success && response.data) {
            set({
              currentZone: response.data,
              loading: false,
            });
            return response.data;
          } else {
            throw new Error(response.error?.message || "Zone not found");
          }
        } catch (error: any) {
          console.error("Error fetching zone:", error);
          set({
            error: error.message || "Failed to fetch zone",
            loading: false,
            currentZone: null,
          });
          toast.error("Failed to fetch zone details");
          return null;
        }
      },

      // Fetch available cities for zone assignment
      fetchAvailableCities: async () => {
        try {
          const response = await citiesApiClient.getCities({
            page: 1,
            limit: 100,
            status: true,
          });

          if (response.success && response.data) {
            set({ availableCities: response.data.data });
          }
        } catch (error: any) {
          console.error("Error fetching available cities:", error);
          toast.error("Failed to fetch cities");
        }
      },

      // Fetch statistics
      fetchStatistics: async () => {
        try {
          const response = await zonesApiClient.getZoneStatistics();

          if (response.success && response.data) {
            set({ statistics: response.data });
          }
        } catch (error: any) {
          console.error("Error fetching zone statistics:", error);
        }
      },

      // Create zone
      createZone: async (data) => {
        set({ loading: true, error: null });

        try {
          const response = await zonesApiClient.createZone(data);

          if (response.success && response.data) {
            // Add to zones list
            const currentZones = get().zones;
            set({
              zones: [response.data, ...currentZones],
              loading: false,
            });

            // Update active zones if the new zone is active
            if (response.data.status) {
              get().fetchActiveZones();
            }

            // Update statistics
            get().fetchStatistics();

            toast.success("Zone created successfully");
            return response.data;
          } else {
            throw new Error(response.error?.message || "Failed to create zone");
          }
        } catch (error: any) {
          console.error("Error creating zone:", error);
          set({
            error: error.message || "Failed to create zone",
            loading: false,
          });
          toast.error(error.message || "Failed to create zone");
          return null;
        }
      },

      // Update zone
      updateZone: async (id, data) => {
        set({ loading: true, error: null });

        try {
          const response = await zonesApiClient.updateZone(id, data);

          if (response.success && response.data) {
            // Update in zones list
            const currentZones = get().zones;
            const updatedZones = currentZones.map((zone) =>
              zone.id === id ? response.data : zone
            );

            set({
              zones: updatedZones,
              currentZone: response.data,
              loading: false,
            });

            // Refresh active zones
            get().fetchActiveZones();

            // Update statistics
            get().fetchStatistics();

            toast.success("Zone updated successfully");
            return response.data;
          } else {
            throw new Error(response.error?.message || "Failed to update zone");
          }
        } catch (error: any) {
          console.error("Error updating zone:", error);
          set({
            error: error.message || "Failed to update zone",
            loading: false,
          });
          toast.error(error.message || "Failed to update zone");
          return null;
        }
      },

      // Delete zone
      deleteZone: async (id) => {
        try {
          const response = await zonesApiClient.deleteZone(id);

          if (response.success) {
            // Remove from zones list
            const currentZones = get().zones;
            const updatedZones = currentZones.filter((zone) => zone.id !== id);

            set({
              zones: updatedZones,
              currentZone: null,
            });

            // Update selected zones if needed
            const selectedZones = get().selectedZones;
            if (selectedZones.includes(id)) {
              set({
                selectedZones: selectedZones.filter((zoneId) => zoneId !== id),
              });
            }

            // Refresh active zones and statistics
            get().fetchActiveZones();
            get().fetchStatistics();

            toast.success("Zone deleted successfully");
            return true;
          } else {
            throw new Error(response.error?.message || "Failed to delete zone");
          }
        } catch (error: any) {
          console.error("Error deleting zone:", error);
          toast.error(error.message || "Failed to delete zone");
          return false;
        }
      },

      // Toggle zone status
      toggleZoneStatus: async (id) => {
        try {
          const response = await zonesApiClient.toggleZoneStatus(id);

          if (response.success && response.data) {
            // Update in zones list
            const currentZones = get().zones;
            const updatedZones = currentZones.map((zone) =>
              zone.id === id ? response.data : zone
            );

            set({ zones: updatedZones });

            // Refresh active zones
            get().fetchActiveZones();

            toast.success(
              `Zone ${
                response.data.status ? "activated" : "deactivated"
              } successfully`
            );
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to toggle zone status"
            );
          }
        } catch (error: any) {
          console.error("Error toggling zone status:", error);
          toast.error(error.message || "Failed to toggle zone status");
          return false;
        }
      },

      // Add cities to zone
      addCitiesToZone: async (zoneId, cityIds) => {
        try {
          const response = await zonesApiClient.addCitiesToZone(
            zoneId,
            cityIds
          );

          if (response.success && response.data) {
            // Update current zone if it matches
            const currentZone = get().currentZone;
            if (currentZone?.id === zoneId) {
              set({ currentZone: response.data });
            }

            toast.success("Cities added to zone successfully");
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to add cities to zone"
            );
          }
        } catch (error: any) {
          console.error("Error adding cities to zone:", error);
          toast.error(error.message || "Failed to add cities to zone");
          return false;
        }
      },

      // Remove cities from zone
      removeCitiesFromZone: async (zoneId, cityIds) => {
        try {
          const response = await zonesApiClient.removeCitiesFromZone(
            zoneId,
            cityIds
          );

          if (response.success && response.data) {
            // Update current zone if it matches
            const currentZone = get().currentZone;
            if (currentZone?.id === zoneId) {
              set({ currentZone: response.data });
            }

            toast.success("Cities removed from zone successfully");
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to remove cities from zone"
            );
          }
        } catch (error: any) {
          console.error("Error removing cities from zone:", error);
          toast.error(error.message || "Failed to remove cities from zone");
          return false;
        }
      },

      // Bulk delete zones
      bulkDeleteZones: async (zoneIds) => {
        try {
          const response = await zonesApiClient.bulkDeleteZones(zoneIds);

          if (response.success) {
            // Remove deleted zones from list
            const currentZones = get().zones;
            const remainingZones = currentZones.filter(
              (zone) => !zoneIds.includes(zone.id)
            );

            set({
              zones: remainingZones,
              selectedZones: [],
            });

            // Refresh data
            get().fetchActiveZones();
            get().fetchStatistics();

            toast.success(
              `Successfully deleted ${
                response.data?.successful || zoneIds.length
              } zone(s)`
            );

            if (response.data?.failed && response.data.failed.length > 0) {
              toast.warning(
                `Failed to delete ${response.data.failed.length} zone(s)`
              );
            }

            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to delete zones"
            );
          }
        } catch (error: any) {
          console.error("Error bulk deleting zones:", error);
          toast.error(error.message || "Failed to delete zones");
          return false;
        }
      },

      // Bulk toggle status
      bulkToggleStatus: async (zoneIds) => {
        try {
          const response = await zonesApiClient.bulkToggleStatus(zoneIds);

          if (response.success) {
            // Refresh zones to get updated statuses
            await get().fetchZones();

            set({ selectedZones: [] });

            toast.success(
              `Successfully updated ${
                response.data?.successful || zoneIds.length
              } zone(s)`
            );

            if (response.data?.failed && response.data.failed.length > 0) {
              toast.warning(
                `Failed to update ${response.data.failed.length} zone(s)`
              );
            }

            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to update zones"
            );
          }
        } catch (error: any) {
          console.error("Error bulk toggling zone status:", error);
          toast.error(error.message || "Failed to update zones");
          return false;
        }
      },

      // Export zones
      // Export zones - FIXED VERSION
      exportZones: async (filters) => {
        set({ loading: true, error: null });

        try {
          const filtersToUse = filters || get().filters;

          // Send the request with the correct structure
          const result = await zonesApiClient.exportZones({
            page: filtersToUse.page || 1,
            limit: filtersToUse.limit || 1000,
            search: filtersToUse.search || "",
            status: filtersToUse.status,
          });

          if (result.success && result.data) {
            set({ loading: false });
            toast.success(
              `Exported ${result.data.totalRecords} zones successfully`
            );
            return result.data.downloadUrl;
          } else {
            throw new Error(result.error?.message || "Failed to export zones");
          }
        } catch (error: any) {
          console.error("Error exporting zones:", error);
          const errorMessage = error?.message || "Failed to export zones";
          set({
            error: errorMessage,
            loading: false,
          });
          toast.error(errorMessage);
          return null;
        }
      },

      // Utility methods
      getZoneById: (id) => {
        return get().zones.find((zone) => zone.id === id);
      },

      getZonesByStatus: (status) => {
        return get().zones.filter((zone) => zone.status === status);
      },

      getZonesCount: () => {
        const zones = get().zones;
        return {
          total: zones.length,
          active: zones.filter((zone) => zone.status).length,
          inactive: zones.filter((zone) => !zone.status).length,
        };
      },

      // Refresh all data
      refreshData: async () => {
        const promises = [
          get().fetchZones(),
          get().fetchActiveZones(),
          get().fetchStatistics(),
          get().fetchAvailableCities(),
        ];

        await Promise.allSettled(promises);
      },
    }),
    {
      name: "zones-store",
      partialize: (state) => ({
        filters: state.filters,
        selectedZones: state.selectedZones,
      }),
      version: 1,
    }
  )
);
-----------------------------------------------------------------------
Types folders:
-----------------------------------------------------------------------
--++--> lib/types/parcels/cities.types.ts =======>
-----------------------------------------------------------------------
export interface City {
  id: string;
  tenantId: string;
  ref: string;
  name: string;
  zone: string;
  pickupCity: boolean;
  status: boolean;
  createdAt: string;
  updatedAt: string;
  createdBy: string | null;
  updatedBy: string | null;
  _count?: {
    pickupTariffs: number;
    destinationTariffs: number;
    zones: number;
  };
}
export interface CreateCityRequest {
  ref: string;
  name: string;
  zone: string;
  pickupCity: boolean;
  status?: boolean;
}
export interface UpdateCityRequest {
  ref?: string;
  name?: string;
  zone?: string;
  pickupCity?: boolean;
  status?: boolean;
}
export interface CitiesFilters {
  page?: number;
  limit?: number;
  search?: string;
  ref?: string;
  zone?: string;
  pickupCity?: boolean;
  status?: boolean;
}
export interface ZoneStats {
  zone: string;
  count: number;
}
export interface CitiesPaginatedResponse {
  data: City[];
  meta: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
}
-----------------------------------------------------------------------
Providers Folder:
-----------------------------------------------------------------------
--++--> providers/auth.provider.tsx =======>
-----------------------------------------------------------------------
"use client";
import React, { useEffect, useState, useCallback, useRef } from "react";
import { useRouter, usePathname } from "next/navigation";
import { useAuthStore } from "@/lib/stores/auth/auth.store";
import { useTenantStore } from "@/lib/stores/auth/tenant.store";
import { getTenantFromUrl } from "@/lib/utils/tenant.utils";
import { toast } from "sonner";
interface AuthProviderProps {
  children: React.ReactNode;
}
// Constants
const THROTTLE_DELAY = 500;
const SESSION_CHECK_INTERVAL = 60 * 1000; // 1 minute
const SESSION_WARNING_TIME = 5 * 60 * 1000; // 5 minutes
const ACTIVITY_THRESHOLD = 5 * 60 * 1000; // 5 minutes
const ONLINE_RECHECK_DELAY = 2000;
const PUBLIC_ROUTES = ["/auth", "/"];
const LIMITED_ROUTES = [
  "/dashboard",
  "/profile",
  "/settings",
  "/validation-status",
];
const ACCOUNT_STATUS_MESSAGES = {
  PENDING: "Your account is pending admin approval.",
  REJECTED: "Your account has been rejected. Please contact support.",
  SUSPENDED: "Your account has been suspended. Please contact support.",
} as const;
const REQUIREMENT_MESSAGES = {
  "Admin approval required": "Your account is pending admin approval.",
  "Complete profile information": "Please complete your profile information.",
  "Profile validation by admin": "Your profile is being validated by an admin.",
} as const;
export default function AuthProvider({ children }: AuthProviderProps) {
  const [isInitialized, setIsInitialized] = useState(false);
  const initializationRef = useRef(false);
  const timersRef = useRef<{
    eventThrottle?: NodeJS.Timeout;
    sessionCheck?: NodeJS.Timeout;
    routeValidation?: NodeJS.Timeout;
  }>({});

  const router = useRouter();
  const pathname = usePathname();

  const {
    checkAuth,
    isAuthenticated,
    logout,
    user,
    isInitialized: authInitialized,
    isCheckingAuth,
    accountStatus,
    accessLevel,
    requirements,
    updateAccountStatus,
    isAccountBlocked,
    needsProfileCompletion,
    needsValidation,
  } = useAuthStore();

  const { fetchCurrentTenant, currentTenant } = useTenantStore();

  // Cleanup timers utility
  const cleanupTimers = useCallback(() => {
    Object.values(timersRef.current).forEach((timer) => {
      if (timer) clearTimeout(timer);
    });
    timersRef.current = {};
  }, []);

  // Route access validation
  const validateRouteAccess = useCallback(() => {
    if (!isAuthenticated || !user || !pathname) return true;

    // Skip validation for public routes
    if (PUBLIC_ROUTES.some((route) => pathname.startsWith(route))) {
      return true;
    }

    // Check blocked account
    if (isAccountBlocked()) {
      const message =
        ACCOUNT_STATUS_MESSAGES[
          accountStatus as keyof typeof ACCOUNT_STATUS_MESSAGES
        ] || "Access denied.";
      toast.error(message);
      router.replace("/auth/login");
      return false;
    }

    // Handle profile completion requirement
    if (needsProfileCompletion()) {
      if (
        !pathname.includes("/profile/complete") &&
        !pathname.includes("/auth")
      ) {
        toast.info("Please complete your profile to continue.");
        router.replace("/profile/complete");
        return false;
      }
      return true;
    }

    // Handle validation requirement
    if (needsValidation()) {
      const isLimitedRoute = LIMITED_ROUTES.some((route) =>
        pathname.startsWith(route)
      );
      if (!isLimitedRoute && !pathname.includes("/auth")) {
        toast.warning(
          "This feature requires profile validation. You have limited access until validation is complete."
        );
        router.replace("/dashboard");
        return false;
      }
    }

    return true;
  }, [
    isAuthenticated,
    user,
    pathname,
    accountStatus,
    isAccountBlocked,
    needsProfileCompletion,
    needsValidation,
    router,
  ]);

  // Initialize auth and tenant context
  const initializeAuth = useCallback(async () => {
    if (initializationRef.current) return;
    initializationRef.current = true;

    try {
      // Set tenant context
      const tenantId = getTenantFromUrl();
      if (tenantId) {
        localStorage.setItem("utl_tenant_id", tenantId);
      } else {
        console.warn("No tenant ID found in URL");
      }

      // Check authentication if needed
      if (!authInitialized && !isCheckingAuth) {
        await checkAuth();
      }

      // Get fresh auth state and fetch additional data if authenticated
      const authState = useAuthStore.getState();
      if (authState.isAuthenticated && authState.user) {
        const promises = [];

        // Update account status
        promises.push(
          updateAccountStatus().catch((error) => {
            console.warn("Failed to fetch account status:", error);
          })
        );

        // Fetch tenant data if not loaded
        if (!currentTenant) {
          promises.push(
            fetchCurrentTenant().catch((error) => {
              console.warn("Failed to fetch tenant data:", error);
            })
          );
        }

        // Execute in parallel, don't block on failures
        await Promise.allSettled(promises);
      }
    } catch (error) {
      console.error("Auth initialization failed:", error);

      // Handle specific errors with appropriate user feedback
      if (error instanceof Error) {
        if (error.message.includes("tenant")) {
          toast.error("Invalid tenant. Please check your URL.");
          router.replace("/auth/login");
        } else if (error.message.includes("network")) {
          toast.error("Network error. Please check your connection.");
        }
      }
    } finally {
      setIsInitialized(true);
    }
  }, [
    checkAuth,
    fetchCurrentTenant,
    authInitialized,
    currentTenant,
    isCheckingAuth,
    updateAccountStatus,
    router,
  ]);

  // Session monitoring setup
  const setupSessionMonitoring = useCallback(() => {
    if (!isAuthenticated) return;

    const sessionCheckTimer = setInterval(() => {
      const state = useAuthStore.getState();

      if (
        !state.isAuthenticated ||
        state.isCheckingAuth ||
        state.isRefreshing
      ) {
        return;
      }

      // Check session expiry
      if (state.isSessionExpired()) {
        toast.error("Your session has expired. Please sign in again.");
        logout();
        return;
      }

      // Session timeout warning
      const timeUntilExpiry = state.getTimeUntilExpiry();
      if (
        timeUntilExpiry <= SESSION_WARNING_TIME &&
        !state.sessionTimeoutWarning
      ) {
        state.setSessionTimeoutWarning(true);
        toast.warning("Your session will expire soon. Please save your work.", {
          duration: 10000,
          action: {
            label: "Extend Session",
            onClick: () => {
              state.extendSession().catch(console.error);
              state.setSessionTimeoutWarning(false);
            },
          },
        });
      }
    }, SESSION_CHECK_INTERVAL);

    timersRef.current.sessionCheck = sessionCheckTimer;
  }, [isAuthenticated, logout]);

  // Cross-tab communication handlers
  const handleStorageChange = useCallback(
    (e: StorageEvent) => {
      if (timersRef.current.eventThrottle) {
        clearTimeout(timersRef.current.eventThrottle);
      }

      timersRef.current.eventThrottle = setTimeout(() => {
        const state = useAuthStore.getState();

        switch (e.key) {
          case "auth_logout":
            if (e.newValue && state.isAuthenticated) {
              toast.info("You have been logged out in another tab.");
              logout();
            }
            break;
          case "auth_login":
            if (e.newValue && !state.isAuthenticated) {
              toast.info("You have been logged in from another tab.");
              window.location.reload();
            }
            break;
          case "auth_token":
            if (e.newValue && !state.isAuthenticated) {
              checkAuth().catch(console.error);
            }
            break;
        }
      }, THROTTLE_DELAY);
    },
    [logout, checkAuth]
  );

  const handleVisibilityChange = useCallback(() => {
    if (document.hidden || !isAuthenticated || !user) return;

    const state = useAuthStore.getState();
    if (state.isCheckingAuth || state.isRefreshing) return;

    state.updateLastActivity();

    // Check account status if user has been away
    const timeSinceActivity = Date.now() - state.lastActivity;
    if (timeSinceActivity > ACTIVITY_THRESHOLD) {
      updateAccountStatus().catch(console.error);
    }
  }, [isAuthenticated, user, updateAccountStatus]);

  const handleOnline = useCallback(() => {
    if (!isAuthenticated || !user) return;

    const state = useAuthStore.getState();
    if (state.isCheckingAuth || state.isRefreshing) return;

    setTimeout(() => {
      const currentState = useAuthStore.getState();
      if (!currentState.isCheckingAuth && !currentState.isRefreshing) {
        Promise.allSettled([checkAuth(), updateAccountStatus()]).catch(
          console.error
        );
      }
    }, ONLINE_RECHECK_DELAY);
  }, [isAuthenticated, user, checkAuth, updateAccountStatus]);

  const handleOffline = useCallback(() => {
    toast.warning("You're offline. Some features may not work properly.");
  }, []);

  // Main initialization effect
  useEffect(() => {
    if (isInitialized || initializationRef.current) return;
    initializeAuth();
  }, [initializeAuth, isInitialized]);

  // Route validation effect
  useEffect(() => {
    if (!isInitialized || isCheckingAuth) return;

    if (timersRef.current.routeValidation) {
      clearTimeout(timersRef.current.routeValidation);
    }

    timersRef.current.routeValidation = setTimeout(() => {
      validateRouteAccess();
    }, 100);

    return () => {
      if (timersRef.current.routeValidation) {
        clearTimeout(timersRef.current.routeValidation);
      }
    };
  }, [
    isInitialized,
    isCheckingAuth,
    pathname,
    isAuthenticated,
    accountStatus,
    accessLevel,
    validateRouteAccess,
  ]);

  // Event listeners and session monitoring
  useEffect(() => {
    if (!isInitialized) return;

    // Add event listeners
    window.addEventListener("storage", handleStorageChange);
    document.addEventListener("visibilitychange", handleVisibilityChange, {
      passive: true,
    });
    window.addEventListener("online", handleOnline, { passive: true });
    window.addEventListener("offline", handleOffline, { passive: true });

    // Setup session monitoring
    setupSessionMonitoring();

    return () => {
      // Cleanup event listeners
      window.removeEventListener("storage", handleStorageChange);
      document.removeEventListener("visibilitychange", handleVisibilityChange);
      window.removeEventListener("online", handleOnline);
      window.removeEventListener("offline", handleOffline);

      // Cleanup timers
      cleanupTimers();
    };
  }, [
    isInitialized,
    handleStorageChange,
    handleVisibilityChange,
    handleOnline,
    handleOffline,
    setupSessionMonitoring,
    cleanupTimers,
  ]);

  // Requirements notifications
  useEffect(() => {
    if (!isInitialized || !isAuthenticated || !requirements.length) return;

    // Show only the first unhandled requirement to avoid toast spam
    const firstRequirement =
      requirements[0] as keyof typeof REQUIREMENT_MESSAGES;
    const message = REQUIREMENT_MESSAGES[firstRequirement];

    if (message) {
      toast.info(message, { duration: 10000 });
    }
  }, [isInitialized, isAuthenticated, requirements]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      cleanupTimers();
      initializationRef.current = false;
    };
  }, [cleanupTimers]);

  return <>{children}</>;
}
-----------------------------------------------------------------------
--++--> middleware.ts =======>
-----------------------------------------------------------------------
import createMiddleware from "next-intl/middleware";
import { NextRequest, NextResponse } from "next/server";
import { locales } from "@/config";
// Types
type AccountStatus =
  | "PENDING"
  | "INACTIVE"
  | "PENDING_VALIDATION"
  | "ACTIVE"
  | "REJECTED"
  | "SUSPENDED";
type ValidationStatus = "PENDING" | "VALIDATED" | "REJECTED";
type AccessLevel = "NO_ACCESS" | "PROFILE_ONLY" | "LIMITED" | "FULL";
interface TokenPayload {
  sub: string;
  email: string;
  roleId: string;
  userType: string;
  tenantId: string;
  exp: number;
  iat: number;
}
interface UserSession {
  userId: string;
  email: string;
  userType: string;
  accountStatus: AccountStatus;
  validationStatus: ValidationStatus;
  profileCompleted: boolean;
  isActive: boolean;
  tenantId: string;
}
interface TenantInfo {
  id: string;
  domain: string;
  name: string;
}
// Constants
const ROUTE_PATTERNS = {
  public: new Set(["/", "/about", "/contact", "/terms", "/privacy"]),
  auth: new Set([
    "/auth/login",
    "/auth/register",
    "/auth/forgot-password",
    "/auth/reset-password",
  ]),
  profileOnly: new Set(["/profile/complete", "/profile/edit"]),
  limited: new Set([
    "/dashboard",
    "/profile",
    "/settings/profile",
    "/notifications",
    "/validation-status",
    "/upload-documents",
  ]),
  fullAccess: new Set([
    "/users",
    "/roles",
    "/analytics",
    "/settings/admin",
    "/reports",
    "/management",
  ]),
  validatedOnly: new Set([
    "/parcels",
    "/invoices",
    "/claims",
    "/marketplace",
    "/parcels",
    "/transactions",
  ]),
} as const;
const LOCALE_REGEX = /^\/([a-z]{2})(?=\/|$)/;
const BEARER_PREFIX = "Bearer ";
// Security headers
const SECURITY_HEADERS = {
  "x-frame-options": "DENY",
  "x-content-type-options": "nosniff",
  "referrer-policy": "origin-when-cross-origin",
  "x-xss-protection": "1; mode=block",
} as const;
// Cache for user data and tenant info
const userCache = new Map<string, { data: UserSession; expiry: number }>();
const tenantCache = new Map<string, { data: TenantInfo; expiry: number }>();
const CACHE_DURATION = 2 * 60 * 1000; // 2 minutes
// Logging utility
const log = (level: "INFO" | "WARN" | "ERROR", message: string, data?: any) => {
  const timestamp = new Date().toISOString();
  const logMessage = `[MIDDLEWARE ${level}] ${timestamp}: ${message}`;

  if (data) {
    console.log(logMessage, data);
  } else {
    console.log(logMessage);
  }
};
// Core functions
const removeLocalePrefix = (pathname: string): string =>
  pathname.replace(LOCALE_REGEX, "") || "/";
const getLocaleFromPath = (pathname: string): string =>
  pathname.match(LOCALE_REGEX)?.[1] || "en";
const isRouteInCategory = (pathname: string, routes: Set<string>): boolean => {
  const routeWithoutLocale = removeLocalePrefix(pathname);
  if (routes.has(routeWithoutLocale)) return true;
  for (const route of Array.from(routes)) {
    if (routeWithoutLocale.startsWith(route + "/")) return true;
  }
  return false;
};
const getAuthToken = (request: NextRequest): string | null => {
  const cookieToken = request.cookies.get("auth_token")?.value;
  if (cookieToken) return cookieToken;
  const authHeader = request.headers.get("authorization");
  return authHeader?.startsWith(BEARER_PREFIX)
    ? authHeader.slice(BEARER_PREFIX.length)
    : null;
};
const decodeJWTPayload = (token: string): TokenPayload | null => {
  try {
    const [, payload] = token.split(".");
    if (!payload) return null;
    return JSON.parse(atob(payload));
  } catch {
    return null;
  }
};
const isTokenValid = (payload: TokenPayload): boolean => {
  const now = Math.floor(Date.now() / 1000);
  return payload.exp > now;
};
// Get tenant ID based on environment
const getTenantId = async (request: NextRequest): Promise<string | null> => {
  const isDev = process.env.NODE_ENV === "development";
  const url = new URL(request.url);

  log("INFO", `Getting tenant ID for environment: ${process.env.NODE_ENV}`, {
    isDev,
    hostname: url.hostname,
    searchParams: Object.fromEntries(url.searchParams),
  });

  if (isDev) {
    // Development: Check URL param first, then environment variable
    const tenantFromUrl = url.searchParams.get("tenant");
    if (tenantFromUrl) {
      log("INFO", "Using tenant from URL parameter", { tenant: tenantFromUrl });
      return tenantFromUrl;
    }

    const devTenantId = process.env.NEXT_PUBLIC_DEV_TENANT_ID;
    if (devTenantId) {
      log("INFO", "Using tenant from environment variable", {
        tenant: devTenantId,
      });
      return devTenantId;
    }

    log("WARN", "No tenant ID found in development mode");
    return null;
  }

  // Production: Get tenant by domain
  const domain = url.hostname;
  const cacheKey = `tenant_${domain}`;
  const cached = tenantCache.get(cacheKey);

  if (cached && cached.expiry > Date.now()) {
    log("INFO", "Using cached tenant info", {
      tenantId: cached.data.id,
      domain,
    });
    return cached.data.id;
  }

  try {
    const backendUrl =
      process.env.NEXT_PUBLIC_AUTH_SERVICE_URL || "http://localhost:3001";
    const tenantApiUrl = `${backendUrl}/api/tenants/by-domain/${domain}`;

    log("INFO", "Fetching tenant by domain", { domain, apiUrl: tenantApiUrl });

    const response = await fetch(tenantApiUrl, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
      },
      signal: AbortSignal.timeout(3000),
    });

    if (!response.ok) {
      log("ERROR", "Failed to fetch tenant by domain", {
        status: response.status,
        statusText: response.statusText,
        domain,
      });
      return null;
    }

    const result = await response.json();

    if (result.success && result.data) {
      const tenantInfo: TenantInfo = {
        id: result.data.id,
        domain: result.data.domain,
        name: result.data.name,
      };

      // Cache tenant info
      tenantCache.set(cacheKey, {
        data: tenantInfo,
        expiry: Date.now() + CACHE_DURATION,
      });

      log("INFO", "Successfully fetched tenant by domain", {
        tenantId: tenantInfo.id,
        tenantName: tenantInfo.name,
        domain,
      });

      return tenantInfo.id;
    }

    log("WARN", "Invalid tenant API response", { response: result });
    return null;
  } catch (error: any) {
    log("ERROR", "Error fetching tenant by domain", {
      error: error.message,
      domain,
    });
    return null;
  }
};
// Get real user data from your API with tenant context
const fetchUserData = async (
  userId: string,
  token: string,
  tenantId: string
): Promise<UserSession | null> => {
  const cacheKey = `${tenantId}_${userId}`;
  const cached = userCache.get(cacheKey);

  if (cached && cached.expiry > Date.now()) {
    log("INFO", "Using cached user data", { userId, tenantId });
    return cached.data;
  }

  try {
    const baseUrl =
      process.env.NEXT_PUBLIC_AUTH_SERVICE_URL || "http://localhost:3001";
    const apiUrl = `${baseUrl}/api/auth/profile`;

    log("INFO", "Fetching user data from API", {
      userId,
      tenantId,
      apiUrl,
      hasToken: !!token,
    });

    const response = await fetch(apiUrl, {
      method: "GET",
      headers: {
        Authorization: `Bearer ${token}`,
        "Content-Type": "application/json",
        "X-Tenant-ID": tenantId,
      },
      signal: AbortSignal.timeout(2500),
    });

    if (!response.ok) {
      log("ERROR", "Failed to fetch user data", {
        status: response.status,
        statusText: response.statusText,
        userId,
        tenantId,
      });
      return null;
    }

    const result = await response.json();

    if (!result.success || !result.data) {
      log("WARN", "Invalid user API response", {
        response: result,
        userId,
        tenantId,
      });
      return null;
    }

    const user = result.data;
    const userSession: UserSession = {
      userId: user.id || userId,
      email: user.email,
      userType: user.userType,
      accountStatus: user.accountStatus || "PENDING",
      validationStatus: user.validationStatus || "PENDING",
      profileCompleted: user.profileCompleted || false,
      isActive: user.isActive || false,
      tenantId: user.tenantId || tenantId,
    };

    // Cache for 2 minutes
    userCache.set(cacheKey, {
      data: userSession,
      expiry: Date.now() + CACHE_DURATION,
    });

    log("INFO", "Successfully fetched user data", {
      userId: userSession.userId,
      userType: userSession.userType,
      accountStatus: userSession.accountStatus,
      validationStatus: userSession.validationStatus,
      tenantId: userSession.tenantId,
    });

    return userSession;
  } catch (error: any) {
    log("ERROR", "Error fetching user data", {
      error: error.message,
      userId,
      tenantId,
    });
    return null;
  }
};
const getAccessLevel = (user: UserSession): AccessLevel => {
  const accessLevel = (() => {
    switch (user.accountStatus) {
      case "PENDING":
      case "REJECTED":
      case "SUSPENDED":
        return "NO_ACCESS";
      case "INACTIVE":
        return "PROFILE_ONLY";
      case "PENDING_VALIDATION":
        return "LIMITED";
      case "ACTIVE":
        return user.validationStatus === "VALIDATED" ? "FULL" : "LIMITED";
      default:
        return "NO_ACCESS";
    }
  })();

  log("INFO", "Calculated access level", {
    userId: user.userId,
    userType: user.userType,
    accountStatus: user.accountStatus,
    validationStatus: user.validationStatus,
    accessLevel,
  });

  return accessLevel;
};
const checkRouteAccess = (pathname: string, user: UserSession | null) => {
  const locale = getLocaleFromPath(pathname);
  const routeWithoutLocale = removeLocalePrefix(pathname);

  log("INFO", "Checking route access", {
    pathname,
    routeWithoutLocale,
    locale,
    hasUser: !!user,
    userType: user?.userType,
    accountStatus: user?.accountStatus,
  });

  // Public routes
  if (isRouteInCategory(pathname, ROUTE_PATTERNS.public)) {
    log("INFO", "Route access granted - public route", { pathname });
    return { allowed: true };
  }

  // Auth routes
  if (isRouteInCategory(pathname, ROUTE_PATTERNS.auth)) {
    if (user) {
      log("INFO", "Redirecting authenticated user from auth route", {
        pathname,
        userId: user.userId,
      });
      return { allowed: false, redirectTo: `/${locale}/dashboard` };
    }
    log("INFO", "Route access granted - auth route for unauthenticated user", {
      pathname,
    });
    return { allowed: true };
  }

  // Require authentication
  if (!user) {
    log("INFO", "Route access denied - authentication required", { pathname });
    return { allowed: false, redirectTo: `/${locale}/auth/login` };
  }

  const accessLevel = getAccessLevel(user);

  // No access
  if (accessLevel === "NO_ACCESS") {
    log("WARN", "Route access denied - no access level", {
      pathname,
      userId: user.userId,
      accountStatus: user.accountStatus,
    });
    return { allowed: false, redirectTo: `/${locale}/auth/login` };
  }

  // Profile-only access
  if (accessLevel === "PROFILE_ONLY") {
    const allowed = isRouteInCategory(pathname, ROUTE_PATTERNS.profileOnly);
    log(
      "INFO",
      `Route access ${allowed ? "granted" : "denied"} - profile only`,
      {
        pathname,
        userId: user.userId,
        accessLevel,
      }
    );
    return allowed
      ? { allowed: true }
      : { allowed: false, redirectTo: `/${locale}/profile/complete` };
  }

  // Limited access
  if (accessLevel === "LIMITED") {
    if (
      isRouteInCategory(pathname, ROUTE_PATTERNS.profileOnly) ||
      isRouteInCategory(pathname, ROUTE_PATTERNS.limited)
    ) {
      log("INFO", "Route access granted - limited access allowed", {
        pathname,
        userId: user.userId,
      });
      return { allowed: true };
    }

    if (isRouteInCategory(pathname, ROUTE_PATTERNS.fullAccess)) {
      log("WARN", "Route access denied - full access required", {
        pathname,
        userId: user.userId,
        accessLevel,
      });
      return { allowed: false, redirectTo: `/${locale}/dashboard` };
    }

    if (
      user.validationStatus !== "VALIDATED" &&
      isRouteInCategory(pathname, ROUTE_PATTERNS.validatedOnly)
    ) {
      log("WARN", "Route access denied - validation required", {
        pathname,
        userId: user.userId,
        validationStatus: user.validationStatus,
      });
      return { allowed: false, redirectTo: `/${locale}/dashboard` };
    }

    log("INFO", "Route access granted - limited access default", {
      pathname,
      userId: user.userId,
    });
    return { allowed: true };
  }

  // Full access
  log("INFO", "Route access granted - full access", {
    pathname,
    userId: user.userId,
    accessLevel,
  });
  return { allowed: true };
};
export default async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;
  const startTime = Date.now();

  log("INFO", "=== MIDDLEWARE START ===", {
    pathname,
    method: request.method,
    userAgent: request.headers.get("user-agent")?.slice(0, 100),
  });

  // Handle i18n first
  const i18nMiddleware = createMiddleware({
    locales,
    defaultLocale: "en",
  });
  const i18nResponse = i18nMiddleware(request);

  if (i18nResponse?.status >= 300 && i18nResponse.status < 400) {
    log("INFO", "I18n redirect triggered", {
      status: i18nResponse.status,
      location: i18nResponse.headers.get("location"),
    });
    return i18nResponse;
  }

  // Get tenant ID
  const tenantId = await getTenantId(request);
  if (!tenantId) {
    log("ERROR", "No tenant ID found - blocking request", { pathname });
    return NextResponse.json({ error: "Tenant not found" }, { status: 400 });
  }

  // Get and validate token
  const token = getAuthToken(request);
  let userSession: UserSession | null = null;

  if (token) {
    log("INFO", "Token found, validating...", { hasToken: true });
    const payload = decodeJWTPayload(token);

    if (payload && isTokenValid(payload)) {
      log("INFO", "Token is valid, fetching user data...", {
        userId: payload.sub,
        userType: payload.userType,
        tenantId: payload.tenantId,
      });

      // Fetch real user data from API with tenant context
      userSession = await fetchUserData(payload.sub, token, tenantId);
    } else {
      log("WARN", "Invalid or expired token", { hasPayload: !!payload });
    }
  } else {
    log("INFO", "No token found", { pathname });
  }

  // Check access
  const { allowed, redirectTo } = checkRouteAccess(pathname, userSession);

  if (!allowed && redirectTo) {
    log("INFO", "Access denied - redirecting", {
      from: pathname,
      to: redirectTo,
      userId: userSession?.userId,
    });
    return NextResponse.redirect(new URL(redirectTo, request.url));
  }

  // Add headers
  const headers = new Headers(i18nResponse?.headers);
  Object.entries(SECURITY_HEADERS).forEach(([key, value]) => {
    headers.set(key, value);
  });

  // Add tenant and user context headers
  headers.set("x-tenant-id", tenantId);

  if (userSession) {
    headers.set("x-user-id", userSession.userId);
    headers.set("x-user-type", userSession.userType);
    headers.set("x-account-status", userSession.accountStatus);
    headers.set("x-validation-status", userSession.validationStatus);
  }

  const executionTime = Date.now() - startTime;
  log("INFO", "=== MIDDLEWARE END ===", {
    pathname,
    allowed,
    executionTime: `${executionTime}ms`,
    tenantId,
    userId: userSession?.userId,
    userType: userSession?.userType,
    accessLevel: userSession ? getAccessLevel(userSession) : "NO_USER",
  });

  return new NextResponse(i18nResponse?.body, {
    status: i18nResponse?.status,
    statusText: i18nResponse?.statusText,
    headers,
  });
}
export const config = {
  matcher: ["/((?!api|_next/static|_next/image|favicon.ico|images|icons).*)"],
};
===============================================================================================================
# WORKFLOW DES COMMANDES
===============================================================================================================
## TAPE 1 : CRATION DE COLIS

**Vue Client (Seller)**
Cette tape permet au client (seller) de crer un nouveau colis en renseignant toutes les informations ncessaires  la livraison.

### 1. Accs au formulaire de cration
- Le client navigue vers : Gestion des colis > Nouveau Colis
- Le systme affiche le formulaire de cration de colis

### 2. Saisie des informations obligatoires
Le client renseigne les champs suivants :

**Informations destinataire :**
- Destinataire* (obligatoire) : Nom du destinataire
- Tlphone* (obligatoire) : Numro de tlphone du destinataire
- Ville* (obligatoire) : Ville de livraison (slection via liste droulante)
- Adresse* (obligatoire) : Adresse complte de livraison

**Informations colis :**
- Code suivi (facultatif) : Code de suivi personnalis
- Marchandise (facultatif) : produit (slection via liste droulante)
- Quantit (facultatif) : Nombre d'articles
- Prix* (obligatoire) : Montant de la commande
- Commentaire (facultatif) : Informations complmentaires (autre tlphone, date de livraison souhaite, etc.)

**Options spciales :**
- Interdit d'ouvrir le colis : Case  cocher
- Colis  remplacer : Case  cocher
- Colis de Stock : Case  cocher

**Actions disponibles**
- Enregistrer : Valide et cre le colis
- Reset : Remet  zro tous les champs du formulaire

### 3. Vue client - Suivi des colis crs
**Accs :** Menu Gestion des colis > Colis pour ramassage

Aprs la cration d'un colis, le client peut consulter ses colis en attente de ramassage dans une interface ddie.

**Informations affiches dans le tableau :**
- Code d'envoi : Identifiant unique du colis (ex: BSK0925539432LE)
- Destinataire : Nom du destinataire
- Statut : Badge color indiquant l'tat actuel
  - "Nouveau Colis" : colis cr, en attente de traitement
  - "Attente De Ramassage" : colis prt pour collecte
- Date de cration : Date et heure de cration du colis
- Prix : Montant de la commande (en DH)
- Tlphone : Numro du destinataire
- Ville : Ville de destination
- Bon de livraison : Rfrence du bon associ (ex: BL-280225-0192950-16-161)
- Actions : Boutons d'actions disponibles (icne information, icne update et icne delete)

**NB:** icne update et icne delete si le status de colis est "Nouveau colis"
**Icne information :** Accs aux dtails via le bouton d'actions

### Vue administrateur - Supervision des colis
**Accs :** Menu Colis

**Informations affiches dans le tableau de bord :**
- Code d'envoi : Identifiant unique du colis
- Date d'expdition : Date de cration du colis
- Tlphone : Numro du destinataire
- Nom du magasin : Nom du client (seller)
- tat : Statut actuel du colis (Non paye, paye, facture)
- Statut : Badge color indiquant l'tat
- Ville : Ville de destination
- Prix : Montant de la commande
- Actions : Boutons d'actions disponibles pour chaque colis

**Actions disponibles par colis :**
L'administrateur dispose d'un menu d'actions contextuel pour chaque colis avec les options suivantes :
-  Dtails du suivi : Consultation de l'historique complet du colis
-  Information du colis : Affichage des dtails de la commande
-  Modifier le colis : dition des informations du colis
-  Change Ville : Modification de la ville de destination
-  Change Vendeur : Rassignation du vendeur/client
-  Rinitialiser ce colis : Remise  zro du statut du colis
-  Relance ce colis : Relancement du processus de traitement

## TAPE 2 : CRATION DES BONS DE LIVRAISON

Cette tape correspond  la rception physique des colis  l'agence et  la gnration automatique des bons de livraison. Le systme utilise la technologie de scan de codes-barres pour traiter les colis et mettre  jour automatiquement leur statut selon la zone gographique.

### 1. Accs  l'interface de scan
- L'agent navigue vers : Menu > Bons de livraison
- Clic sur le bouton "Code Bar Scanner" dans la barre d'outils

### 2. Interface de scan
L'interface propose deux mthodes de scan :
- **Scan manuel ou douchette :** Champ de saisie "CLIC ICI AVANT LE SCAN" pour saisie manuelle ou par douchette le code
- **Scan camra :** Bouton " Utiliser Camera" pour scan automatique via webcam/camra mobile (scan qr code or barcode)

### 3. Traitement automatique du scan
Une fois le code-barres scann ou saisi :
- Le systme identifie automatiquement le colis
- Gnre un bon de livraison avec rfrence unique
- Met  jour le statut selon la logique gographique

### 4. Logique de changement de statut

**Cas 1 : Destination dans la mme zone que l'agence**
- Condition : Ville de destination = Zone de l'agence de ramassage
- Nouveau statut : "Reu"
- Action : Le colis reste dans l'agence pour livraison locale

**Cas 2 : Destination dans une zone diffrente**
- Condition : Ville de destination  Zone de l'agence de ramassage
- Nouveau statut : "Ramass"
- Action : Le colis doit tre transfr vers l'agence de destination

### 4. Interface de gestion des bons de livraison
Vue tableau des bons crs :
- Rfrence: Code unique du bon (BL-XXXXXX-XXX)
- Client
- Date de cration: Date et heure de cration du bon
- Date de rception
- Statut
- Colis: Nombre de colis dans le bon
- Total: Montant total en DH
- Actions:
  -  Dtails du bon : Consultation dtaille du bon de livraison
  -  Bon bien reu : Confirmation de rception du bon
  -  Voir en PDF : Gnration et tlchargement du bon au format PDF
  -  Voir les tiquettes : Affichage/impression des tiquettes de colis

## CRATION DE BONS DE LIVRAISON (INTERFACE CLIENT)

Cette fonctionnalit permet au client (seller) de crer ses propres bons de livraison (au cas o il ne va pas se dplacer  l'agence) en slectionnant les colis qu'il souhaite regrouper.

### 1. Accs  l'interface de cration
- Le client navigue vers : Menu > Bons de livraison
- La page affiche la liste des bons existants
- Clic sur le bouton "+ Ajouter Bon de livraison"
- Une deuxime page s'affiche:
  - Indicateur de nombre de colis ligibles pour cration d'un bon
  - Bouton principal : "+ Crer bon de livraison"

### 2. Cration de bons de livraison
- Clic sur ce bouton pour accder  l'interface dtaille de slection des colis
- Une fois le bouton "Crer bon de livraison" cliqu, le systme affiche l'interface complte avec :

**Liste des nouveaux colis disponibles:** Tableau des colis ligibles pour ajout au bon :
- Code d'envoi: Identifiant unique du colis
- Destinataire: Nom du destinataire
- Date de cration: Date de cration du colis
- Prix: Montant en DH
- Ville: Ville de destination
- Actions: Bouton "+" pour ajouter le colis et Case  cocher pour slection multiple et Bouton "Ajouter" (en bas) : Ajouter tous les colis slectionns

**Liste des colis ajouts au bon:** Section qui affiche les colis slectionns pour le bon en cours de cration.
- Vide initialement : "Aucun enregistrement disponible" / "Aucune entres correspondants trouvs"
- Aprs ajout : Liste des colis inclus dans le bon

**Tickets et Bon de livraison - Obtenir en PDF** Trois options de gnration disponibles :
- Gnration du premier type de ticket (Premire image)
- Gnration de deuxime type de ticket (deuxime image)
- Gnration de bon de livraison (troisieme image)

### 3. Vue tableau des bons de livraison
Aprs cration, les bons apparaissent dans le tableau principal :
- Rfrence
- Date de cration
- Statut
- Colis
- Actions

## CRATION DES BONS DE DISTRIBUTION

Cette tape permet  l'administrateur d'affecter les colis aux livreurs en crant des bons de distribution. Le processus implique la slection d'une zone gographique, l'assignation d'un livreur spcifique, puis la slection des colis  distribuer soit manuellement soit par scan.

### 1. Accs  l'interface de distribution
- L'administrateur navigue vers : Menu > Bons de distribution
- Clic sur le bouton "+ Ajouter Bon De Distribution"
- **Slection de la zone:**
  - Liste droulante des zones disponibles
  - Affichage du nombre de colis en attente par zone
- **Slection du livreur:**
  - Liste droulante des livreurs disponibles pour la zone slectionne

### 2. Cration du bon et slection des colis
Une fois le bouton "Crer" cliqu, le systme affiche l'interface de slection des colis :

**Liste des nouveaux colis disponibles:** Tableau des colis ligibles pour distribution dans la zone slectionne
- Code d'envoi
- Client
- Date de rception
- Ville
- Livreur
- Adresse
- Commentaire
- Prix
- Statut
- Actions: (Boutons d'ajout et slection + Case  cocher)

**Liste des colis ajouts au bon :** Affiche les colis slectionns pour le bon de distribution en cours

**Interface de scan pour retrait de colis:**
- Champ de scan : "CLIC ICI AVANT LE SCAN"
- Scan camra : Bouton " Utiliser Camera" (scan qr code or barcode)
- Fonctionnalit : Permet de retirer des colis du bon par scan

### 3. Vue tableau des bons de distribution crs
Une fois crs, les bons apparaissent dans le tableau principal des bons de distribution :
- Rfrence
- Date de cration
- Date d'Enregistrement
- Zone
- Livreur
- Statut
- Colis
- Actions:
  -  Dtails du bon : Consultation dtaille
  -  Supprimer le bon : Suppression du bon
  -  Modifier le bon : dition des paramtres
  -  Voir en PDF : Gnration du document
  -  Export Excel : Export des donnes

### 3. Logique de changement de statut aprs distribution

**Cas 1 : Distribution dans la mme zone (livraison locale)**
- Condition : Ville de destination = Zone de ramassage/agence
- Changement de statut : "Reu"  "En distribution"
- Action : Le colis passe directement en phase de livraison finale
- Workflow : Colis  Bon de livraison Bon de distribution  Livraison directe

**Cas 2 : Distribution vers une zone diffrente (transfert inter-agences)**
- Condition : Ville de destination  Zone de ramassage/agence
- tape intermdiaire : Cration d'un "Bon d'envoi" ( dtailler)
- Action : Le colis doit tre transfr vers l'agence de la zone de destination
- Workflow : Colis  Bon de livraison Bon d'envoi ( Transfert  a l l'agence destination ) Bon de distribution  Livraison

## CRATION DES BONS D'ENVOI

Cette tape gre les colis qui doivent tre transfrs vers d'autres zones gographiques. Lorsqu'un colis  une destination diffrente de la zone de ramassage, il passe par un bon d'envoi avant d'tre achemin vers l'agence de destination approprie.

### 1. Accs  l'interface de cration
- L'administrateur navigue vers : Menu > Bons d'envoi
- Clic sur le bouton "+ Ajouter Bon D'envoi ( Zone )"
- **Slection de la zone de destination**
  - Liste droulante des zones de destination disponibles
  - Slection de la zone vers laquelle transfrer les colis

### 2. Cration du bon et slection des colis
**Liste des nouveaux colis disponibles :** Tableau des colis ligibles pour transfert vers la zone slectionne
- Code d'envoi
- Client
- Date de ramassage
- Prix
- Ville
- Actions: (Boutons d'ajout et Case  cocher)

**Liste des colis ajouts au bon :** Section "LIST DES COLIS AJOUTS" Affiche les colis slectionns pour le bon d'envoi
- Toutes les elements de liste de colis disponible + la colonne scanned (indicateur de scan)

**Interface de scan :**
- Champ de scan : "CLIC ICI AVANT LE SCAN"
- Scan camra : Bouton " Utiliser Camera" (scan qr code or barcode)
- Fonctionnalit : Retrait de colis du bon par scan

### 3. Vue tableau des bons d'envoi crs
Une fois crs, les bons d'envoi apparaissent dans le tableau principal :
- Rfrence
- Date de cration
- Date de rception
- Zone
- Statut
- Colis
- Actions:
  -  Dtails du bon : Consultation dtaille du bon d'envoi
  -  Bon bien reu :
  -  Modifier le bon : dition des paramtres du bon d'envoi
  -  Voir en PDF : Gnration et tlchargement du bon au format PDF
  -  Export Excel : Export des donnes du bon vers Excel

### 4. Changement de statut des colis
**Transition automatique :** Une fois les colis ajouts au bon d'envoi et le bon finalis :
- Statut prcdent : "Ramass"
- Nouveau statut : "Expdi"
- Action : Les colis sont prts pour transfert physique vers l'agence de destination

### 5. Workflow de transfert inter-agences
- **Agence source :** Cration du bon d'envoi (statut "Ramasse")
- **Expdition :** Colis passent au statut "Expdi"
- **Transport :** Acheminement physique vers agence de destination
- **Agence destination :** Rception et scan des colis
- **Suite du processus :** Cration de bons de distribution locaux

## GESTION DES BONS DE PAIEMENT

Le module de bons de paiement gre la comptabilit et les rglements financiers dans le systme. Il se divise en deux catgories principales : les paiements aux livreurs individuels et les paiements aux modrateurs de zone pour les transferts inter-agences.

- **Bons de paiement pour livreur :** Rglement des livreurs individuels
- **Bons de paiement pour zone :** Comptabilit avec les modrateurs de zone

## BONS DE PAIEMENT POUR LIVREUR

Cette fonctionnalit permet de crer et grer les paiements destins aux livreurs individuels pour les livraisons effectues dans leur zone d'intervention.

### 1. Accs  l'interface
- Navigation : Menu > Bons de paiement > Pour livreur
- Clic sur "+ Ajouter Bon Pour Livreur"

### 2. Cration de bon de paiement pour livreur
- **Slectionner la zone:** Liste droulante avec statistiques (Affichage du nombre de livraisons russies et checs)
- **Slection du livreur:** Liste droulante des livreurs avec statistiques individuelles (Affichage du nombre de livraisons russies et checs)
- **Cration et configuration du bon:**

**Liste des nouveaux colis:** Tableau des colis livrs ligibles au paiement :
- Code d'envoi
- Client
- Tlphone
- Date de livraison
- Statut
- Ville
- Prix
- Frais
- Total
- Actions:
  - Dtails du suivi : Historique complet
  - Information du colis : Dtails de la commande
  - Modifier le colis : dition des informations
  - Change Ville : Modification destination
  - Change Vendeur : Rassignation vendeur
  - Colis non livr : Marquage chec livraison
  - Changer le prix : Ajustement montant
  - Remboursement : Gestion des retours

**Section "AUTRES FRAIS"** Interface pour ajouter des frais supplmentaires :
- Dsignation : Description du frais
- Quantit
- Prix unitaire
- Total

### 3. Vue tableau des bons de paiement
Interface principale des bons crs :
- Rfrence
- Date de cration
- Date Changement de statuts
- Zone
- Livreur
- Portefeuille
- Screen
- Statut
- Colis (Nb)
- Total

### 4. Cycle de vie des bons de paiement
Changement de statut se fait en 3 tapes

**1. Attente de paiement**
- Bon cr avec les colis livrs
- En attente de traitement financier

**2. Encore de traitement**
- Paiement en cours de traitement
- Vrifications comptables en cours

**3. Pay**
- Paiement effectu au livreur
- Clture comptable du bon

Lors du passage au statut "Pay", une popup s'affiche avec :
- Champ Virement : Montant du virement
- Champ Cash : Montant en espces
- Bouton "Pay" : Confirmation finale du paiement

## BONS DE PAIEMENT POUR ZONE

Cette fonctionnalit gre la comptabilit avec les modrateurs de zone pour les transferts inter-agences. Elle permet de rgler financirement les zones qui ont reu et trait des colis provenant d'autres agences.

### 1. Accs  l'interface
- Navigation : Menu > Bons de paiement > Pour zone
- Clic sur "+ Ajouter Bon Pour Zone"

### 2. Slection de la zone

### 3. Cration et configuration du bon
**Liste des nouveaux colis:** Tableau des colis livrs dans la zone ligibles au paiement
- Code d'envoi
- Client
- Tlphone
- Date de livraison
- Statut
- Ville
- Prix
- Frais
- Total

**Liste des colis ajouts:**
- Code d'envoi
- Client
- Tlphone
- Date de livraison
- Statut
- Ville
- Prix
- Frais
- Total

### 4. Vue tableau des bons de paiement pour zone
Interface principale des bons crs :
- Rfrence
- Date de cration
- Date Changement de statuts
- Zone
- Statut
- Colis
- Total

### 5. Gestion des statuts de paiement
Cycle de vie des bons de paiement pour zone :

**1. Attente de paiement**
- Bon cr pour la zone
- En attente de traitement comptable

**2. En cours de traitement**
- Paiement en cours de validation
- Vrifications inter-agences

**3. Pay**
- Rglement effectu  la zone
- Clture comptable du transfert

## GESTION DES BONS DE RETOUR

### Bons de retour pour livreur

**Table contents :**
- Rfrence
- Date de cration
- Livreur
- Type
- Statut
- Colis
- Actions

*Exemple :*
BRL-240925-0126910-76-133 | 2025-09-24 13:20 | Youness RBT | Demande | Incomplet | 0 | 22 | 2 | update/delete

**Crer Bons de retour for livreur:**
- Slection le livreur
- Select LISTE DES COLIS DEMANDE DE RETOUR
- Create Bons de retour

### Bons de retour pour zone

**Table contents :**
- Rfrence
- Date de cration
- Date de rception
- Ville
- Statut
- Colis
- Actions

*Exemple :*
BRV-170925-0126750-79-V | 2025-09-17 13:51 | 2025-09-17 16:03 | HUB CASABLANCA | Reu | 3 | details/voir/delete
(youness bousaou ali housni)

**Crer Bons de retour for zone:**
- Slection la zone
- List des colis ajouts
- Create Bons de retour

### Bons de retour pour client (customer)

**Table contents :**
- Rfrence
- Date de cration
- Date de rception
- Nom du magasin
- Statut
- Colis
- Actions

*Exemple :*
BRC-160925-0126540-77-138 | 2025-09-16 17:33 | 2025-09-17 09:36 | Metalivraison - (546) | Reu | 1Nouveau | 6 | details/voir/export
(milad settaoui milad settaoui)

**Crer Bons de retour for customer:**
- Slection le client
- Ajouter liste des colis returne
- create Bons de retour for customer
===============================================================================================================
Nest js backend Parcels-Service:
===============================================================================================================
--++--> prisma/schema.prisma =======>
-----------------------------------------------------------------------
generator client {
  provider = "prisma-client-js"
}
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}
// ========================================
// CORE REFERENCE DATA
// These models define the foundational data for the delivery system
// ========================================
/**
 * City Model
 * Represents cities where packages can be picked up or delivered
 * Supports multi-tenant architecture with soft deletes
 */
model City {
  id         String  @id @default(cuid()) // Unique identifier using CUID
  tenantId   String // Multi-tenant support - isolates data per organization
  ref        String // Business reference code (e.g., "CAS" for Casablanca)
  name       String // Display name of the city
  zone       String? // Optional zone grouping for logistics
  pickupCity Boolean @default(false) // Whether this city accepts package pickups
  status     Boolean @default(true) // Active/inactive flag for business operations

  // Soft delete pattern - allows data recovery and maintains referential integrity
  isDeleted Boolean   @default(false) // Soft delete flag
  deletedAt DateTime? // Timestamp when deleted
  deletedBy String? // User who performed the deletion

  // Audit trail - tracks data changes for compliance and debugging
  createdAt DateTime @default(now()) // Record creation timestamp
  updatedAt DateTime @updatedAt // Auto-updated on record changes
  createdBy String? // User who created the record
  updatedBy String? // User who last updated the record

  // Relations - Define how cities connect to other entities
  pickupTariffs        Tariff[]       @relation("PickupCity") // Tariffs where this city is pickup
  destinationTariffs   Tariff[]       @relation("DestinationCity") // Tariffs where this city is destination
  zones                ZoneCity[] // Many-to-many relationship with zones
  parcelsAsPickup      Parcel[]       @relation("PickupCity") // Parcels picked up from this city
  parcelsAsDestination Parcel[]       @relation("DestinationCity") // Parcels delivered to this city
  deliverySlips        DeliverySlip[] // Delivery slips for this city

  // Optimized indexes for common query patterns
  @@unique([tenantId, ref, isDeleted]) // Ensures unique business codes per tenant
  @@index([tenantId, isDeleted, status]) // Fast tenant + active city queries
  @@index([tenantId, isDeleted, pickupCity]) // Quick pickup city filtering
  @@index([tenantId, zone]) // Zone-based queries within tenant
  @@index([name]) // City name searches
  @@map("cities") // Custom table name
}
/**
 * PickupCity Model
 * Specialized reference for pickup locations/hubs
 * Separate from regular cities for operational flexibility
 */
model PickupCity {
  id       String  @id @default(cuid())
  tenantId String // Multi-tenant isolation
  ref      String // Business reference (e.g., "CAS_HUB")
  name     String // Display name (e.g., "HUB CASABLANCA")
  status   Boolean @default(true) // Active status

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations
  tariffs Tariff[] @relation("PickupCityRef") // Optional tariff reference

  // Indexes and constraints
  @@unique([tenantId, ref, isDeleted]) // Unique pickup city refs per tenant
  @@index([tenantId, isDeleted, status]) // Active pickup cities per tenant
  @@map("pickup_cities")
}
/**
 * Tariff Model
 * Defines pricing and delivery terms between city pairs
 * Core business logic for cost calculation
 */
model Tariff {
  id                String  @id @default(cuid())
  tenantId          String // Multi-tenant support
  pickupCityId      String // Source city for package
  destinationCityId String // Destination city for package
  deliveryPrice     Decimal @db.Decimal(10, 2) // Standard delivery fee (precise decimal for money)
  returnPrice       Decimal @default(0) @db.Decimal(10, 2) // Fee for returning undelivered packages
  refusalPrice      Decimal @default(0) @db.Decimal(10, 2) // Fee for refused packages
  deliveryDelay     Int     @db.SmallInt // Expected delivery time in days

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations
  pickupCity      City        @relation("PickupCity", fields: [pickupCityId], references: [id])
  destinationCity City        @relation("DestinationCity", fields: [destinationCityId], references: [id])
  pickupCityRef   PickupCity? @relation("PickupCityRef", fields: [pickupCityRefId], references: [id])
  pickupCityRefId String? // Optional reference to pickup city hub
  parcels         Parcel[] // Parcels using this tariff

  // Optimized indexes for route-based pricing queries
  @@unique([tenantId, pickupCityId, destinationCityId, isDeleted]) // Unique routes per tenant
  @@index([tenantId, isDeleted]) // Tenant-wide tariff queries
  @@index([pickupCityId, destinationCityId]) // Fast route-based lookups
  @@map("tariffs")
}
/**
 * Zone Model
 * Logical grouping of cities for operational management
 * Used for organizing delivery routes and staff assignments
 */
model Zone {
  id       String  @id @default(cuid())
  tenantId String // Multi-tenant support
  name     String // Zone name (e.g., "HUB CASABLANCA")
  status   Boolean @default(true) // Active status

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations - Zones coordinate multiple operational processes
  cities              ZoneCity[] // Cities within this zone
  distributionSlips   DistributionSlip[] // Distribution assignments for this zone
  shippingSlips       ShippingSlip[] // Inter-zone shipments to this zone
  returnSlipsForZone  ReturnSlip[]       @relation("ReturnSlipZone") // Returns processed by zone
  paymentSlipsForZone PaymentSlip[]      @relation("PaymentSlipZone") // Payments processed by zone

  // Indexes for zone-based operations
  @@unique([tenantId, name, isDeleted]) // Unique zone names per tenant
  @@index([tenantId, isDeleted, status]) // Active zones per tenant
  @@map("zones")
}
/**
 * ZoneCity Junction Table
 * Many-to-many relationship between zones and cities
 * Allows flexible city-to-zone assignments
 */
model ZoneCity {
  zoneId String // Reference to zone
  cityId String // Reference to city

  // Relations with cascade delete - if zone/city deleted, remove assignment
  zone Zone @relation(fields: [zoneId], references: [id], onDelete: Cascade)
  city City @relation(fields: [cityId], references: [id], onDelete: Cascade)

  @@id([zoneId, cityId]) // Composite primary key - more efficient than separate ID
  @@map("zone_cities")
}
/**
 * ParcelStatus Model
 * Defines the workflow states an parcel can be in
 * Core to tracking package lifecycle
 */
model ParcelStatus {
  id       String  @id @default(cuid())
  tenantId String // Multi-tenant support
  code     String  @db.VarChar(50) // Business code (e.g., "NEW_PACKAGE", "DELIVERED")
  name     String  @db.VarChar(100) // Display name (e.g., "Nouveau Colis", "Livr")
  color    String  @db.VarChar(7) // Hex color for UI display (#FF0000)
  isLocked Boolean @default(false) // Whether status can be manually changed
  status   Boolean @default(true) // Active status

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations
  parcels               Parcel[] // Parcels in this status
  parcelStatusHistories ParcelStatusHistory[] // Status change history

  // Constraints and indexes
  @@unique([tenantId, code, isDeleted]) // Unique status codes per tenant
  @@unique([tenantId, color, isDeleted]) // Unique colors per tenant (UI requirement)
  @@index([tenantId, isDeleted, status]) // Active statuses per tenant
  @@map("parcel_statuses")
}
// ========================================
// PARCELS CORE
// The heart of the delivery system - manages package parcels
// ========================================
/**
 * Parcel Model
 * Central entity representing a package delivery request
 * Contains all information needed for pickup, delivery, and payment
 */
model Parcel {
  id       String @id @default(cuid())
  tenantId String // Multi-tenant support
  userId   String // Seller/client who created the parcel
  code     String @unique @db.VarChar(50) // Unique business code (e.g., BSK0925539432LE)

  // Customer information - who receives the package
  recipientName    String  @db.VarChar(200) // Customer name
  recipientPhone   String  @db.VarChar(20) // Primary contact number
  recipientAddress String  @db.Text // Full delivery address
  alternativePhone String? @db.VarChar(20) // Backup contact number

  // Location - pickup and delivery cities
  pickupCityId      String // Where package is collected
  destinationCityId String // Where package is delivered

  // Package details - what's being delivered
  trackingCode String? @db.VarChar(100) // Custom tracking code from seller
  productName  String? @db.VarChar(200) // Product description
  quantity     Int?    @default(1) @db.SmallInt // Number of items
  price        Decimal @db.Decimal(12, 2) // COD amount (Cash on Delivery value)
  comment      String? @db.Text // Special delivery instructions

  // Package handling options - business rules
  cannotOpen Boolean @default(false) // Package cannot be opened for inspection
  canReplace Boolean @default(false) // Can substitute with different item
  isStock    Boolean @default(false) // Is this a stock/inventory item

  // Status and workflow tracking
  parcelStatusId   String // Current status reference
  parcelStatusCode String        @db.VarChar(50) // Current status code (for fast queries)
  paymentStatus    PaymentStatus @default(PENDING) // Payment processing state

  // Pricing - calculated from tariff, stored for historical accuracy
  deliveryPrice Decimal @db.Decimal(10, 2) // Standard delivery fee
  returnPrice   Decimal @default(0) @db.Decimal(10, 2) // Return fee if undelivered
  refusalPrice  Decimal @default(0) @db.Decimal(10, 2) // Refusal fee if rejected
  deliveryDelay Int     @db.SmallInt // Expected delivery days
  tariffId      String? // Reference to tariff used for pricing

  // Delivery tracking - operational data
  deliveryAttempts Int       @default(0) @db.SmallInt // How many delivery attempts made
  lastAttemptDate  DateTime? // When last delivery was attempted
  deliveredAt      DateTime? // When successfully delivered
  deliveredBy      String? // ID of delivery person who completed

  // Return/Refusal tracking - handling failed deliveries
  returnedAt    DateTime? // When package was returned to sender
  returnReason  String?   @db.Text // Why package was returned
  refusedAt     DateTime? // When package was refused by recipient
  refusalReason String?   @db.Text // Why package was refused

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations - how parcels connect to other system components
  pickupCity      City         @relation("PickupCity", fields: [pickupCityId], references: [id])
  destinationCity City         @relation("DestinationCity", fields: [destinationCityId], references: [id])
  parcelStatus    ParcelStatus @relation(fields: [parcelStatusId], references: [id])
  tariff          Tariff?      @relation(fields: [tariffId], references: [id])

  // Status change history for audit trail
  statusHistory ParcelStatusHistory[]

  // Slip associations - tracking through various operational documents
  deliverySlipItems     DeliverySlipItem[] // When parcel is collected from sender
  distributionSlipItems DistributionSlipItem[] // When parcel is assigned for delivery
  shippingSlipItems     ShippingSlipItem[] // When parcel is shipped between zones
  returnSlipItems       ReturnSlipItem[] // When parcel is returned to sender
  paymentSlipItems      PaymentSlipItem[] // When payment is processed

  // Optimized indexes for common query patterns
  @@index([tenantId, isDeleted]) // Basic tenant filtering
  @@index([tenantId, userId, isDeleted]) // Parcels by user
  @@index([tenantId, parcelStatusCode, isDeleted]) // Parcels by status
  @@index([tenantId, paymentStatus, isDeleted]) // Parcels by payment status
  @@index([tenantId, createdAt, isDeleted]) // Time-based queries within tenant
  @@index([recipientPhone, tenantId]) // Customer phone lookup
  @@index([pickupCityId, destinationCityId]) // Route-based queries
  @@index([deliveredAt]) // Delivered parcels analytics
  @@map("parcels")
}
/**
 * ParcelStatusHistory Model
 * Tracks all status changes for an parcel
 * Provides complete audit trail of parcel lifecycle
 */
model ParcelStatusHistory {
  id             String   @id @default(cuid())
  parcelId       String // Reference to the parcel
  parcelStatusId String // Reference to the status
  statusCode     String   @db.VarChar(50) // Status code for fast queries
  comment        String?  @db.Text // Optional comment about the change
  changedBy      String? // User who made the change
  changedAt      DateTime @default(now()) // When the change occurred

  // Relations with cascade delete - if parcel deleted, remove history
  parcel       Parcel       @relation(fields: [parcelId], references: [id], onDelete: Cascade)
  parcelStatus ParcelStatus @relation(fields: [parcelStatusId], references: [id])

  // Optimized indexes for history queries
  @@index([parcelId, changedAt]) // Parcel history timeline
  @@index([statusCode, changedAt]) // Status-based reporting and analytics
  @@map("parcel_status_history")
}
// ========================================
// DELIVERY SLIPS (Bons de livraison)
// Documents for tracking package collection from senders
// ========================================
/**
 * DeliverySlip Model
 * Represents a collection document for packages from senders
 * Groups multiple parcels for efficient pickup operations
 */
model DeliverySlip {
  id        String  @id @default(cuid())
  tenantId  String // Multi-tenant support
  userId    String // Client/seller who created the slip
  reference String  @unique @db.VarChar(50) // Business reference (BL-XXXXXX-XXX)
  cityId    String? // City where packages are collected

  status DeliverySlipStatus @default(PENDING) // Processing status

  // Reception tracking - when packages are actually collected
  receivedAt DateTime? // When collection was completed
  receivedBy String? // Staff member who performed collection

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations
  city  City?              @relation(fields: [cityId], references: [id])
  items DeliverySlipItem[] // Individual parcels on this slip

  // Optimized indexes for operational queries
  @@index([tenantId, userId, isDeleted]) // Slips by client
  @@index([tenantId, status, isDeleted]) // Slips by processing status
  @@index([tenantId, createdAt, isDeleted]) // Time-based slip queries
  @@map("delivery_slips")
}
/**
 * DeliverySlipItem Model
 * Junction table linking parcels to delivery slips
 * Tracks scanning/processing of individual packages
 */
model DeliverySlipItem {
  deliverySlipId String // Reference to delivery slip
  parcelId       String // Reference to parcel
  scanned        Boolean   @default(false) // Whether package was scanned/processed
  scannedAt      DateTime? // When scanning occurred
  scannedBy      String? // Who performed the scan

  // Relations with cascade delete
  deliverySlip DeliverySlip @relation(fields: [deliverySlipId], references: [id], onDelete: Cascade)
  parcel       Parcel       @relation(fields: [parcelId], references: [id])

  @@id([deliverySlipId, parcelId]) // Composite primary key - efficient and prevents duplicates
  @@index([parcelId]) // Reverse lookup - find slips for an parcel
  @@map("delivery_slip_items")
}
// ========================================
// SHIPPING SLIPS (Bons d'envoi)
// Documents for inter-zone package transfers
// ========================================
/**
 * ShippingSlip Model
 * Manages transfer of packages between different zones/hubs
 * Critical for multi-location delivery networks
 */
model ShippingSlip {
  id                String @id @default(cuid())
  tenantId          String // Multi-tenant support
  reference         String @unique @db.VarChar(50) // Business reference (BE-XXXXXX-XXX)
  destinationZoneId String // Zone receiving the packages

  status ShippingSlipStatus @default(PENDING) // Transfer status

  // Shipping process tracking
  shippedAt  DateTime? // When packages left origin
  shippedBy  String? // Who sent the packages
  receivedAt DateTime? // When packages arrived at destination
  receivedBy String? // Who received the packages

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations
  destinationZone Zone               @relation(fields: [destinationZoneId], references: [id])
  items           ShippingSlipItem[] // Individual parcels being shipped

  // Optimized indexes for logistics queries
  @@index([tenantId, status, isDeleted]) // Slips by status
  @@index([tenantId, createdAt, isDeleted]) // Time-based queries
  @@index([destinationZoneId, status]) // Zone-specific shipping status
  @@map("shipping_slips")
}
/**
 * ShippingSlipItem Model
 * Links individual parcels to shipping slips
 * Tracks package movement between zones
 */
model ShippingSlipItem {
  shippingSlipId String // Reference to shipping slip
  parcelId       String // Reference to parcel being shipped
  scanned        Boolean   @default(false) // Whether package was scanned for shipping
  scannedAt      DateTime? // When scan occurred
  scannedBy      String? // Who performed the scan

  // Relations with cascade delete
  shippingSlip ShippingSlip @relation(fields: [shippingSlipId], references: [id], onDelete: Cascade)
  parcel       Parcel       @relation(fields: [parcelId], references: [id])

  @@id([shippingSlipId, parcelId]) // Composite primary key
  @@index([parcelId]) // Reverse lookup capability
  @@map("shipping_slip_items")
}
// ========================================
// DISTRIBUTION SLIPS (Bons de distribution)
// Documents for assigning packages to delivery personnel
// ========================================
/**
 * DistributionSlip Model
 * Assigns packages to delivery personnel for final delivery
 * Core document for last-mile delivery operations
 */
model DistributionSlip {
  id               String  @id @default(cuid())
  tenantId         String // Multi-tenant support
  reference        String  @unique @db.VarChar(50) // Business reference (BD-XXXXXX-XXX)
  zoneId           String // Zone where delivery occurs
  deliveryPersonId String? // Assigned delivery person

  status DistributionSlipStatus @default(PENDING) // Assignment status

  // Assignment tracking
  assignedAt DateTime? // When assigned to delivery person
  assignedBy String? // Who made the assignment

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations
  zone  Zone                   @relation(fields: [zoneId], references: [id])
  items DistributionSlipItem[] // Parcels assigned for delivery

  // Optimized indexes for delivery management
  @@index([tenantId, status, isDeleted]) // Slips by status
  @@index([tenantId, createdAt, isDeleted]) // Time-based queries
  @@index([zoneId, status]) // Zone-specific distribution status
  @@index([deliveryPersonId, status]) // Person-specific assignments
  @@map("distribution_slips")
}
/**
 * DistributionSlipItem Model
 * Links parcels to distribution assignments
 * Tracks individual package assignments to delivery staff
 */
model DistributionSlipItem {
  distributionSlipId String // Reference to distribution slip
  parcelId           String // Reference to parcel for delivery
  scanned            Boolean   @default(false) // Whether assignment was scanned/confirmed
  scannedAt          DateTime? // When scan occurred
  scannedBy          String? // Who performed the scan

  // Relations with cascade delete
  distributionSlip DistributionSlip @relation(fields: [distributionSlipId], references: [id], onDelete: Cascade)
  parcel           Parcel           @relation(fields: [parcelId], references: [id])

  @@id([distributionSlipId, parcelId]) // Composite primary key
  @@index([parcelId]) // Reverse lookup capability
  @@map("distribution_slip_items")
}
// ========================================
// RETURN SLIPS (Bons de retour)
// Documents for handling undelivered packages
// ========================================
/**
 * ReturnSlip Model
 * Manages packages that couldn't be delivered and need to be returned
 * Supports different return types: from drivers, zones, or back to customers
 */
model ReturnSlip {
  id        String         @id @default(cuid())
  tenantId  String // Multi-tenant support
  reference String         @unique @db.VarChar(50) // Business reference (BRL/BRV/BRC-XXXXXX-XXX)
  type      ReturnSlipType // Type of return (DRIVER/ZONE/CUSTOMER)

  // Type-specific associations - polymorphic relationship pattern
  deliveryPersonId String? // For DRIVER type - returns from delivery staff
  zoneId           String? // For ZONE type - returns from operational zones
  customerId       String? // For CUSTOMER type - returns to specific customers
  customerName     String? @db.VarChar(200) // Display name for customer returns

  status ReturnSlipStatus @default(PENDING) // Processing status

  // Processing workflow tracking
  processedAt DateTime? // When return processing started
  processedBy String? // Who initiated processing
  receivedAt  DateTime? // When returned packages were received
  receivedBy  String? // Who received the returned packages

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations
  zone  Zone?            @relation("ReturnSlipZone", fields: [zoneId], references: [id])
  items ReturnSlipItem[] // Individual parcels being returned

  // Optimized indexes for return management
  @@index([tenantId, type, isDeleted]) // Returns by type
  @@index([tenantId, status, isDeleted]) // Returns by processing status
  @@index([tenantId, createdAt, isDeleted]) // Time-based return queries
  @@index([deliveryPersonId, status]) // Driver-specific returns
  @@index([zoneId, status]) // Zone-specific returns
  @@index([customerId]) // Customer-specific returns
  @@map("return_slips")
}
/**
 * ReturnSlipItem Model
 * Links individual parcels to return slips
 * Captures return reasons and processing details
 */
model ReturnSlipItem {
  returnSlipId String // Reference to return slip
  parcelId     String // Reference to parcel being returned
  returnReason String?   @db.Text // Detailed reason for return
  scanned      Boolean   @default(false) // Whether return was scanned/processed
  scannedAt    DateTime? // When scan occurred
  scannedBy    String? // Who performed the scan

  // Relations with cascade delete
  returnSlip ReturnSlip @relation(fields: [returnSlipId], references: [id], onDelete: Cascade)
  parcel     Parcel     @relation(fields: [parcelId], references: [id])

  @@id([returnSlipId, parcelId]) // Composite primary key
  @@index([parcelId]) // Reverse lookup capability
  @@map("return_slip_items")
}
// ========================================
// PAYMENT SLIPS (Bons de paiement)
// Documents for processing delivery payments and fees
// ========================================
/**
 * PaymentSlip Model
 * Manages payment collection and distribution for delivery services
 * Handles payments to delivery personnel and zone operations
 */
model PaymentSlip {
  id        String          @id @default(cuid())
  tenantId  String // Multi-tenant support
  reference String          @unique @db.VarChar(50) // Business reference (BPL/BPV-XXXXXX-XXX)
  type      PaymentSlipType // Payment type (DRIVER/ZONE)

  // Type-specific associations
  deliveryPersonId String? // For DRIVER type - payments to delivery staff
  zoneId           String? // For ZONE type - payments to zone operations

  // Payment amount breakdown - using Decimal for financial precision
  totalAmount    Decimal @default(0) @db.Decimal(12, 2) // Total payment amount
  cashAmount     Decimal @default(0) @db.Decimal(12, 2) // Cash component
  transferAmount Decimal @default(0) @db.Decimal(12, 2) // Bank transfer component
  additionalFees Decimal @default(0) @db.Decimal(12, 2) // Extra fees and charges

  status PaymentSlipStatus @default(PENDING) // Payment processing status

  // Payment workflow tracking
  processedAt DateTime? // When payment processing started
  processedBy String? // Who initiated processing
  paidAt      DateTime? // When payment was completed
  paidBy      String? // Who completed the payment

  // Additional information
  notes String? @db.Text // Payment notes and comments

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations
  zone            Zone?                      @relation("PaymentSlipZone", fields: [zoneId], references: [id])
  items           PaymentSlipItem[] // Individual parcel payments
  additionalItems PaymentSlipAdditionalFee[] // Extra fees and charges

  // Optimized indexes for financial queries
  @@index([tenantId, type, isDeleted]) // Payments by type
  @@index([tenantId, status, isDeleted]) // Payments by status
  @@index([tenantId, createdAt, isDeleted]) // Time-based payment queries
  @@index([deliveryPersonId, status]) // Driver-specific payments
  @@index([zoneId, status]) // Zone-specific payments
  @@map("payment_slips")
}
/**
 * PaymentSlipItem Model
 * Links individual parcel payments to payment slips
 * Tracks specific fees for each parcel (delivery, return, refusal)
 */
model PaymentSlipItem {
  paymentSlipId String // Reference to payment slip
  parcelId      String // Reference to parcel
  feeType       String  @db.VarChar(20) // Type of fee (DELIVERY, RETURN, REFUSAL)
  amount        Decimal @db.Decimal(10, 2) // Payment amount for this parcel/fee

  // Relations with cascade delete
  paymentSlip PaymentSlip @relation(fields: [paymentSlipId], references: [id], onDelete: Cascade)
  parcel      Parcel      @relation(fields: [parcelId], references: [id])

  @@id([paymentSlipId, parcelId, feeType]) // Composite primary key - prevents duplicate fee types per parcel
  @@index([parcelId]) // Reverse lookup capability
  @@map("payment_slip_items")
}
/**
 * PaymentSlipAdditionalFee Model
 * Handles extra fees and charges not tied to specific parcels
 * Examples: fuel costs, equipment rental, bonus payments
 */
model PaymentSlipAdditionalFee {
  id            String  @id @default(cuid())
  paymentSlipId String // Reference to payment slip
  description   String  @db.VarChar(200) // Fee description
  quantity      Int     @default(1) @db.SmallInt // Quantity for unit-based fees
  unitPrice     Decimal @db.Decimal(10, 2) // Price per unit
  totalPrice    Decimal @db.Decimal(10, 2) // Total fee amount (quantity  unit price)

  // Relations with cascade delete
  paymentSlip PaymentSlip @relation(fields: [paymentSlipId], references: [id], onDelete: Cascade)

  @@index([paymentSlipId]) // Payment slip lookup
  @@map("payment_slip_additional_fees")
}
// ========================================
// ENUMS
// Define the possible values for status and type fields
// ========================================
/**
 * PaymentStatus Enum
 * Tracks the payment lifecycle for parcels
 */
enum PaymentStatus {
  PENDING // Payment not yet received
  PAID // Payment has been received
  INVOICED // Invoice has been generated
}
/**
 * DeliverySlipStatus Enum
 * Tracks the collection process status
 */
enum DeliverySlipStatus {
  PENDING // Created but packages not yet collected
  RECEIVED // Packages have been collected and processed
  CANCELLED // Collection was cancelled
}
/**
 * ShippingSlipStatus Enum
 * Tracks inter-zone transfer status
 */
enum ShippingSlipStatus {
  PENDING // Created but not yet shipped
  SHIPPED // Packages have been sent to destination
  RECEIVED // Packages received at destination zone
  CANCELLED // Shipment was cancelled
}
/**
 * DistributionSlipStatus Enum
 * Tracks delivery assignment status
 */
enum DistributionSlipStatus {
  PENDING // Created but not yet assigned to delivery person
  ASSIGNED // Assigned to delivery person for delivery
  COMPLETED // All packages have been delivered
  CANCELLED // Distribution assignment was cancelled
}
/**
 * ReturnSlipType Enum
 * Defines different types of return processes
 */
enum ReturnSlipType {
  DRIVER // Return from delivery driver to hub (BRL - Bon de Retour Livreur)
  ZONE // Return from zone to central hub (BRV - Bon de Retour Ville)
  CUSTOMER // Return to customer/sender (BRC - Bon de Retour Client)
}
/**
 * ReturnSlipStatus Enum
 * Tracks return processing status
 */
enum ReturnSlipStatus {
  PENDING // Created but processing not started
  INCOMPLETE // Partially processed - some items handled
  RECEIVED // All items have been processed and received
  CANCELLED // Return process was cancelled
}
/**
 * PaymentSlipType Enum
 * Defines different payment slip types
 */
enum PaymentSlipType {
  DRIVER // Payment to delivery driver (BPL - Bon de Paiement Livreur)
  ZONE // Payment to zone operations (BPV - Bon de Paiement Ville)
}
/**
 * PaymentSlipStatus Enum
 * Tracks payment processing workflow
 */
enum PaymentSlipStatus {
  PENDING // Created but processing not started
  IN_PROCESSING // Payment is being processed
  AWAITING_PAYMENT // Waiting for actual payment to be made
  VERIFIED // Payment has been verified
  PAID // Payment completed successfully
  CANCELLED // Payment was cancelled
}
-----------------------------------------------------------------------
--++--> prisma/seed.ts =======>
-----------------------------------------------------------------------
import { PrismaClient } from '@prisma/client';
import { Decimal } from '@prisma/client/runtime/library';
const prisma = new PrismaClient();
/**
 * Reset Database Function
 * Clears all data in reverse dependency parcel to avoid foreign key constraints
 */
async function resetDatabase() {
  console.log(' Resetting parcels database...');

  // Delete in reverse parcel of dependencies to avoid foreign key constraint errors
  await prisma.paymentSlipAdditionalFee.deleteMany({});
  await prisma.paymentSlipItem.deleteMany({});
  await prisma.paymentSlip.deleteMany({});

  await prisma.returnSlipItem.deleteMany({});
  await prisma.returnSlip.deleteMany({});

  await prisma.distributionSlipItem.deleteMany({});
  await prisma.distributionSlip.deleteMany({});

  await prisma.shippingSlipItem.deleteMany({});
  await prisma.shippingSlip.deleteMany({});

  await prisma.deliverySlipItem.deleteMany({});
  await prisma.deliverySlip.deleteMany({});

  await prisma.parcelStatusHistory.deleteMany({});
  await prisma.parcel.deleteMany({});

  await prisma.tariff.deleteMany({});
  await prisma.parcelStatus.deleteMany({});
  await prisma.zoneCity.deleteMany({});
  await prisma.zone.deleteMany({});
  await prisma.pickupCity.deleteMany({});
  await prisma.city.deleteMany({});

  console.log(' Database reset completed');
}
async function main() {
  console.log(' Starting Parcels service seed...');

  // Reset database - comment out if you want to preserve existing data
  await resetDatabase();

  // Multi-tenant configuration
  const tenantId = 'cmfo1utdj00005820owl4mluk';
  const adminUserId = 'cmfo1utlp000g5820u6jov7rw';

  console.log(` Seeding data for tenant: ${tenantId}`);

  // ========================================
  // 1. CREATE CITIES
  // ========================================

  const cities = await Promise.all([
    // Major pickup cities - can accept packages for collection
    prisma.city.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'CAS',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'CAS',
        name: 'Casablanca',
        zone: 'Zone A',
        pickupCity: true, // Can accept pickups
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.city.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'RAB',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'RAB',
        name: 'Rabat',
        zone: 'Zone A',
        pickupCity: true,
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.city.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'MAR',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'MAR',
        name: 'Marrakech',
        zone: 'Zone B',
        pickupCity: true,
        status: true,
        createdBy: adminUserId,
      },
    }),

    // Delivery-only cities - cannot accept pickups
    prisma.city.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'FEZ',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'FEZ',
        name: 'Fez',
        zone: 'Zone B',
        pickupCity: false, // Delivery only
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.city.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'TAN',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'TAN',
        name: 'Tangier',
        zone: 'Zone C',
        pickupCity: false,
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.city.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'AGA',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'AGA',
        name: 'Agadir',
        zone: 'Zone C',
        pickupCity: false,
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.city.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'SALE',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'SALE',
        name: 'Sal',
        zone: 'Zone A',
        pickupCity: false,
        status: true,
        createdBy: adminUserId,
      },
    }),
  ]);

  console.log(` Created ${cities.length} cities`);

  // ========================================
  // 2. CREATE PICKUP CITIES (HUBS)
  // ========================================

  const pickupCities = await Promise.all([
    prisma.pickupCity.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'CAS_HUB',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'CAS_HUB',
        name: 'HUB CASABLANCA',
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.pickupCity.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'RAB_HUB',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'RAB_HUB',
        name: 'HUB RABAT',
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.pickupCity.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'MAR_HUB',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'MAR_HUB',
        name: 'HUB MARRAKECH',
        status: true,
        createdBy: adminUserId,
      },
    }),
  ]);

  console.log(` Created ${pickupCities.length} pickup cities`);

  // ========================================
  // 3. CREATE ZONES
  // ========================================

  const zones = await Promise.all([
    prisma.zone.upsert({
      where: {
        tenantId_name_isDeleted: {
          tenantId,
          name: 'HUB CASABLANCA',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        name: 'HUB CASABLANCA',
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.zone.upsert({
      where: {
        tenantId_name_isDeleted: {
          tenantId,
          name: 'HUB RABAT',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        name: 'HUB RABAT',
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.zone.upsert({
      where: {
        tenantId_name_isDeleted: {
          tenantId,
          name: 'HUB MARRAKECH',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        name: 'HUB MARRAKECH',
        status: true,
        createdBy: adminUserId,
      },
    }),
  ]);

  console.log(` Created ${zones.length} zones`);

  // ========================================
  // 4. ASSIGN CITIES TO ZONES
  // ========================================

  // Get city and zone references for assignments
  const casablancaCity = cities.find((c) => c.ref === 'CAS');
  const rabatCity = cities.find((c) => c.ref === 'RAB');
  const saleCity = cities.find((c) => c.ref === 'SALE');
  const fezCity = cities.find((c) => c.ref === 'FEZ');
  const marrakechCity = cities.find((c) => c.ref === 'MAR');
  const tangierCity = cities.find((c) => c.ref === 'TAN');
  const agadirCity = cities.find((c) => c.ref === 'AGA');

  const casablancaZone = zones.find((z) => z.name === 'HUB CASABLANCA');
  const rabatZone = zones.find((z) => z.name === 'HUB RABAT');
  const marrakechZone = zones.find((z) => z.name === 'HUB MARRAKECH');

  // Create zone-city assignments
  const zoneAssignments = [];

  // Casablanca Zone
  if (casablancaCity && casablancaZone) {
    zoneAssignments.push(
      prisma.zoneCity.upsert({
        where: {
          zoneId_cityId: {
            zoneId: casablancaZone.id,
            cityId: casablancaCity.id,
          },
        },
        update: {},
        create: {
          zoneId: casablancaZone.id,
          cityId: casablancaCity.id,
        },
      }),
    );
  }

  // Rabat Zone (includes Rabat and Sal)
  if (rabatCity && saleCity && rabatZone) {
    zoneAssignments.push(
      prisma.zoneCity.upsert({
        where: {
          zoneId_cityId: {
            zoneId: rabatZone.id,
            cityId: rabatCity.id,
          },
        },
        update: {},
        create: {
          zoneId: rabatZone.id,
          cityId: rabatCity.id,
        },
      }),
      prisma.zoneCity.upsert({
        where: {
          zoneId_cityId: {
            zoneId: rabatZone.id,
            cityId: saleCity.id,
          },
        },
        update: {},
        create: {
          zoneId: rabatZone.id,
          cityId: saleCity.id,
        },
      }),
    );
  }

  // Marrakech Zone (includes Marrakech, Fez, Tangier, Agadir)
  if (marrakechCity && fezCity && tangierCity && agadirCity && marrakechZone) {
    zoneAssignments.push(
      prisma.zoneCity.upsert({
        where: {
          zoneId_cityId: {
            zoneId: marrakechZone.id,
            cityId: marrakechCity.id,
          },
        },
        update: {},
        create: {
          zoneId: marrakechZone.id,
          cityId: marrakechCity.id,
        },
      }),
      prisma.zoneCity.upsert({
        where: {
          zoneId_cityId: {
            zoneId: marrakechZone.id,
            cityId: fezCity.id,
          },
        },
        update: {},
        create: {
          zoneId: marrakechZone.id,
          cityId: fezCity.id,
        },
      }),
      prisma.zoneCity.upsert({
        where: {
          zoneId_cityId: {
            zoneId: marrakechZone.id,
            cityId: tangierCity.id,
          },
        },
        update: {},
        create: {
          zoneId: marrakechZone.id,
          cityId: tangierCity.id,
        },
      }),
      prisma.zoneCity.upsert({
        where: {
          zoneId_cityId: {
            zoneId: marrakechZone.id,
            cityId: agadirCity.id,
          },
        },
        update: {},
        create: {
          zoneId: marrakechZone.id,
          cityId: agadirCity.id,
        },
      }),
    );
  }

  await Promise.all(zoneAssignments);
  console.log(` Created zone-city assignments`);

  // ========================================
  // 5. CREATE PARCEL STATUSES
  // ========================================

  const parcelStatuses = await Promise.all([
    // Initial parcel status
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'NEW_PACKAGE',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'NEW_PACKAGE',
        name: 'Nouveau Colis',
        color: '#3B82F6', // Blue
        isLocked: true, // System-managed status
        status: true,
        createdBy: adminUserId,
      },
    }),

    // Collection and processing statuses
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'RECEIVED',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'RECEIVED',
        name: 'Reu',
        color: '#10B981', // Emerald
        isLocked: false,
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'COLLECTED',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'COLLECTED',
        name: 'Ramass',
        color: '#8B5CF6', // Purple
        isLocked: false,
        status: true,
        createdBy: adminUserId,
      },
    }),

    // Shipping and transfer statuses
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'DISPATCHED',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'DISPATCHED',
        name: 'Expdi',
        color: '#F59E0B', // Amber
        isLocked: false,
        status: true,
        createdBy: adminUserId,
      },
    }),

    // Distribution and delivery statuses
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'PUT_IN_DISTRIBUTION',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'PUT_IN_DISTRIBUTION',
        name: 'Mis en distribution',
        color: '#06B6D4', // Cyan
        isLocked: false,
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'OUT_FOR_DELIVERY',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'OUT_FOR_DELIVERY',
        name: 'En cours de livraison',
        color: '#F97316', // Orange
        isLocked: false,
        status: true,
        createdBy: adminUserId,
      },
    }),

    // Final delivery statuses
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'DELIVERED',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'DELIVERED',
        name: 'Livr',
        color: '#22C55E', // Green
        isLocked: true, // System-managed status
        status: true,
        createdBy: adminUserId,
      },
    }),

    // Return and refusal statuses
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'RETURNED',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'RETURNED',
        name: 'Retourn',
        color: '#EF4444', // Red
        isLocked: true, // System-managed status
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'REFUSED',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'REFUSED',
        name: 'Refus',
        color: '#DC2626', // Red-600
        isLocked: false,
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'CANCELLED',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'CANCELLED',
        name: 'Annul',
        color: '#6B7280', // Gray
        isLocked: false,
        status: true,
        createdBy: adminUserId,
      },
    }),
  ]);

  console.log(` Created ${parcelStatuses.length} parcel statuses`);

  // ========================================
  // 6. CREATE TARIFFS (PRICING ROUTES)
  // ========================================

  if (
    casablancaCity &&
    rabatCity &&
    fezCity &&
    marrakechCity &&
    tangierCity &&
    agadirCity
  ) {
    const tariffs = await Promise.all([
      // From Casablanca to other cities
      prisma.tariff.upsert({
        where: {
          tenantId_pickupCityId_destinationCityId_isDeleted: {
            tenantId,
            pickupCityId: casablancaCity.id,
            destinationCityId: rabatCity.id,
            isDeleted: false,
          },
        },
        update: {},
        create: {
          tenantId,
          pickupCityId: casablancaCity.id,
          destinationCityId: rabatCity.id,
          deliveryPrice: new Decimal('25.00'), // Using Decimal for precision
          returnPrice: new Decimal('20.00'),
          refusalPrice: new Decimal('15.00'),
          deliveryDelay: 1,
          createdBy: adminUserId,
        },
      }),
      prisma.tariff.upsert({
        where: {
          tenantId_pickupCityId_destinationCityId_isDeleted: {
            tenantId,
            pickupCityId: casablancaCity.id,
            destinationCityId: fezCity.id,
            isDeleted: false,
          },
        },
        update: {},
        create: {
          tenantId,
          pickupCityId: casablancaCity.id,
          destinationCityId: fezCity.id,
          deliveryPrice: new Decimal('40.00'),
          returnPrice: new Decimal('35.00'),
          refusalPrice: new Decimal('25.00'),
          deliveryDelay: 2,
          createdBy: adminUserId,
        },
      }),
      prisma.tariff.upsert({
        where: {
          tenantId_pickupCityId_destinationCityId_isDeleted: {
            tenantId,
            pickupCityId: casablancaCity.id,
            destinationCityId: marrakechCity.id,
            isDeleted: false,
          },
        },
        update: {},
        create: {
          tenantId,
          pickupCityId: casablancaCity.id,
          destinationCityId: marrakechCity.id,
          deliveryPrice: new Decimal('35.00'),
          returnPrice: new Decimal('30.00'),
          refusalPrice: new Decimal('20.00'),
          deliveryDelay: 2,
          createdBy: adminUserId,
        },
      }),
      prisma.tariff.upsert({
        where: {
          tenantId_pickupCityId_destinationCityId_isDeleted: {
            tenantId,
            pickupCityId: casablancaCity.id,
            destinationCityId: tangierCity.id,
            isDeleted: false,
          },
        },
        update: {},
        create: {
          tenantId,
          pickupCityId: casablancaCity.id,
          destinationCityId: tangierCity.id,
          deliveryPrice: new Decimal('45.00'),
          returnPrice: new Decimal('40.00'),
          refusalPrice: new Decimal('30.00'),
          deliveryDelay: 3,
          createdBy: adminUserId,
        },
      }),
      prisma.tariff.upsert({
        where: {
          tenantId_pickupCityId_destinationCityId_isDeleted: {
            tenantId,
            pickupCityId: casablancaCity.id,
            destinationCityId: agadirCity.id,
            isDeleted: false,
          },
        },
        update: {},
        create: {
          tenantId,
          pickupCityId: casablancaCity.id,
          destinationCityId: agadirCity.id,
          deliveryPrice: new Decimal('50.00'),
          returnPrice: new Decimal('45.00'),
          refusalPrice: new Decimal('35.00'),
          deliveryDelay: 3,
          createdBy: adminUserId,
        },
      }),

      // From Rabat to other cities
      prisma.tariff.upsert({
        where: {
          tenantId_pickupCityId_destinationCityId_isDeleted: {
            tenantId,
            pickupCityId: rabatCity.id,
            destinationCityId: casablancaCity.id,
            isDeleted: false,
          },
        },
        update: {},
        create: {
          tenantId,
          pickupCityId: rabatCity.id,
          destinationCityId: casablancaCity.id,
          deliveryPrice: new Decimal('25.00'),
          returnPrice: new Decimal('20.00'),
          refusalPrice: new Decimal('15.00'),
          deliveryDelay: 1,
          createdBy: adminUserId,
        },
      }),

      // From Marrakech to other cities
      prisma.tariff.upsert({
        where: {
          tenantId_pickupCityId_destinationCityId_isDeleted: {
            tenantId,
            pickupCityId: marrakechCity.id,
            destinationCityId: casablancaCity.id,
            isDeleted: false,
          },
        },
        update: {},
        create: {
          tenantId,
          pickupCityId: marrakechCity.id,
          destinationCityId: casablancaCity.id,
          deliveryPrice: new Decimal('35.00'),
          returnPrice: new Decimal('30.00'),
          refusalPrice: new Decimal('20.00'),
          deliveryDelay: 2,
          createdBy: adminUserId,
        },
      }),
    ]);

    console.log(` Created ${tariffs.length} tariff routes`);
  }

  // ========================================
  // 7. CREATE SAMPLE PARCELS
  // ========================================

  const newPackageStatus = parcelStatuses.find((s) => s.code === 'NEW_PACKAGE');

  if (newPackageStatus && casablancaCity && rabatCity && marrakechCity) {
    // Get tariffs for sample parcels
    const casaToRabatTariff = await prisma.tariff.findFirst({
      where: {
        tenantId,
        pickupCityId: casablancaCity.id,
        destinationCityId: rabatCity.id,
        isDeleted: false,
      },
    });

    const casaToMarrakechTariff = await prisma.tariff.findFirst({
      where: {
        tenantId,
        pickupCityId: casablancaCity.id,
        destinationCityId: marrakechCity.id,
        isDeleted: false,
      },
    });

    const sampleParcels = [];

    if (casaToRabatTariff) {
      sampleParcels.push(
        prisma.parcel.create({
          data: {
            tenantId,
            userId: adminUserId,
            code: 'BSK0925539432LE',
            recipientName: 'Ahmed Benjelloun',
            recipientPhone: '+212661234567',
            recipientAddress: '123 Avenue Mohammed V, Agdal, Rabat',
            alternativePhone: '+212537123456',
            pickupCityId: casablancaCity.id,
            destinationCityId: rabatCity.id,
            productName: 'Smartphone Case Premium',
            quantity: 1,
            price: new Decimal('350.00'),
            comment: 'Appeler avant livraison - Livraison aprs 14h',
            parcelStatusId: newPackageStatus.id,
            parcelStatusCode: newPackageStatus.code,
            deliveryPrice: casaToRabatTariff.deliveryPrice,
            returnPrice: casaToRabatTariff.returnPrice,
            refusalPrice: casaToRabatTariff.refusalPrice,
            deliveryDelay: casaToRabatTariff.deliveryDelay,
            tariffId: casaToRabatTariff.id,
            createdBy: adminUserId,
          },
        }),
        prisma.parcel.create({
          data: {
            tenantId,
            userId: adminUserId,
            code: 'BSK0925539433LE',
            recipientName: 'Fatima El Mansouri',
            recipientPhone: '+212662345678',
            recipientAddress: '456 Rue Hassan II, Centre-ville, Rabat',
            pickupCityId: casablancaCity.id,
            destinationCityId: rabatCity.id,
            productName: 'Laptop Charger Dell',
            quantity: 1,
            price: new Decimal('450.00'),
            parcelStatusId: newPackageStatus.id,
            parcelStatusCode: newPackageStatus.code,
            deliveryPrice: casaToRabatTariff.deliveryPrice,
            returnPrice: casaToRabatTariff.returnPrice,
            refusalPrice: casaToRabatTariff.refusalPrice,
            deliveryDelay: casaToRabatTariff.deliveryDelay,
            tariffId: casaToRabatTariff.id,
            createdBy: adminUserId,
          },
        }),
      );
    }

    if (casaToMarrakechTariff) {
      sampleParcels.push(
        prisma.parcel.create({
          data: {
            tenantId,
            userId: adminUserId,
            code: 'BSK0925539434LE',
            recipientName: 'Youssef Benali',
            recipientPhone: '+212663456789',
            recipientAddress: '789 Avenue Mohammed VI, Gueliz, Marrakech',
            pickupCityId: casablancaCity.id,
            destinationCityId: marrakechCity.id,
            productName: 'Wireless Headphones',
            quantity: 2,
            price: new Decimal('680.00'),
            comment: 'Fragile - Manipuler avec prcaution',
            cannotOpen: true, // Special handling
            parcelStatusId: newPackageStatus.id,
            parcelStatusCode: newPackageStatus.code,
            deliveryPrice: casaToMarrakechTariff.deliveryPrice,
            returnPrice: casaToMarrakechTariff.returnPrice,
            refusalPrice: casaToMarrakechTariff.refusalPrice,
            deliveryDelay: casaToMarrakechTariff.deliveryDelay,
            tariffId: casaToMarrakechTariff.id,
            createdBy: adminUserId,
          },
        }),
      );
    }

    const createdParcels = await Promise.all(sampleParcels);
    console.log(` Created ${createdParcels.length} sample parcels`);

    // Create status history for each parcel
    const statusHistories = createdParcels.map((parcel) =>
      prisma.parcelStatusHistory.create({
        data: {
          parcelId: parcel.id,
          parcelStatusId: newPackageStatus.id,
          statusCode: newPackageStatus.code,
          comment: 'Parcel created successfully',
          changedBy: adminUserId,
        },
      }),
    );

    await Promise.all(statusHistories);
    console.log(
      ` Created status history for ${statusHistories.length} parcels`,
    );
  }

  // ========================================
  // COMPLETION SUMMARY
  // ========================================

  console.log('\n Parcels service seed completed successfully!');
  console.log('\n Created Data Summary:');
  console.log(`Tenant ID: ${tenantId}`);
  console.log(`Cities: ${cities.length}`);
  console.log(`Pickup Cities: ${pickupCities.length}`);
  console.log(`Zones: ${zones.length}`);
  console.log(`Parcel Statuses: ${parcelStatuses.length}`);

  const totalTariffs = await prisma.tariff.count({
    where: { tenantId, isDeleted: false },
  });
  const totalParcels = await prisma.parcel.count({
    where: { tenantId, isDeleted: false },
  });

  console.log(`Tariff Routes: ${totalTariffs}`);
  console.log(`Sample Parcels: ${totalParcels}`);

  console.log('\n Database seeding completed - Ready for testing!');
}
// Execute the seeding process
main()
  .catch((e) => {
    console.error(' Parcels seed failed:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
-----------------------------------------------------------------------
--++--> src/modules/delivery-slips/dto/parcel.dto.ts =======>
-----------------------------------------------------------------------
import {
  IsString,
  IsArray,
  IsOptional,
  IsEnum,
  IsBoolean,
  IsNotEmpty,
  ArrayNotEmpty,
  MaxLength,
  IsDateString,
} from 'class-validator';
import { Transform, Type } from 'class-transformer';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { PaginationDto } from '../../../common/dto/pagination.dto';
export enum DeliverySlipStatus {
  PENDING = 'PENDING',
  RECEIVED = 'RECEIVED',
  CANCELLED = 'CANCELLED',
}
export class CreateDeliverySlipDto {
  @ApiPropertyOptional({
    example: 'cuid123',
    description: 'City ID where packages are collected (optional)',
  })
  @IsOptional()
  @IsString()
  cityId?: string;

  @ApiPropertyOptional({
    example: ['cuid1', 'cuid2', 'cuid3'],
    description: 'Array of parcel IDs to include in this delivery slip',
  })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  parcelIds?: string[];

  @ApiPropertyOptional({
    example: 'Morning pickup route - Zone A',
    description: 'Additional notes for the delivery slip',
  })
  @IsOptional()
  @IsString()
  @MaxLength(500)
  notes?: string;

  @ApiPropertyOptional({
    example: true,
    description: 'Create slip and immediately mark as received',
    default: false,
  })
  @IsOptional()
  @IsBoolean()
  autoReceive?: boolean = false;
}
export class UpdateDeliverySlipDto {
  @ApiPropertyOptional({
    example: 'cuid123',
    description: 'Update city ID',
  })
  @IsOptional()
  @IsString()
  cityId?: string;

  @ApiPropertyOptional({
    example: 'Updated notes for delivery slip',
    description: 'Update notes',
  })
  @IsOptional()
  @IsString()
  @MaxLength(500)
  notes?: string;

  @ApiPropertyOptional({
    enum: DeliverySlipStatus,
    example: DeliverySlipStatus.RECEIVED,
    description: 'Update slip status',
  })
  @IsOptional()
  @IsEnum(DeliverySlipStatus)
  status?: DeliverySlipStatus;
}
export class DeliverySlipQueryDto extends PaginationDto {
  @ApiPropertyOptional({
    example: 'BL-280225-0192950',
    description: 'Search by reference or customer info',
  })
  @IsOptional()
  @IsString()
  search?: string;

  @ApiPropertyOptional({
    enum: DeliverySlipStatus,
    example: DeliverySlipStatus.PENDING,
    description: 'Filter by slip status',
  })
  @IsOptional()
  @IsEnum(DeliverySlipStatus)
  status?: DeliverySlipStatus;

  @ApiPropertyOptional({
    example: 'cuid123',
    description: 'Filter by city ID',
  })
  @IsOptional()
  @IsString()
  cityId?: string;

  @ApiPropertyOptional({
    example: 'cuid456',
    description: 'Filter by creator user ID',
  })
  @IsOptional()
  @IsString()
  userId?: string;

  @ApiPropertyOptional({
    example: '2024-01-01',
    description: 'Filter by start date',
  })
  @IsOptional()
  @IsDateString()
  startDate?: string;

  @ApiPropertyOptional({
    example: '2024-01-31',
    description: 'Filter by end date',
  })
  @IsOptional()
  @IsDateString()
  endDate?: string;

  @ApiPropertyOptional({
    example: 'createdAt',
    description: 'Sort field',
    default: 'createdAt',
  })
  @IsOptional()
  @IsString()
  sortBy?: string = 'createdAt';

  @ApiPropertyOptional({
    example: 'desc',
    description: 'Sort direction',
    default: 'desc',
  })
  @IsOptional()
  @IsString()
  sortParcel?: 'asc' | 'desc' = 'desc';
}
export class AddParcelsToSlipDto {
  @ApiProperty({
    example: ['cuid1', 'cuid2'],
    description: 'Array of parcel IDs to add',
  })
  @IsArray()
  @ArrayNotEmpty()
  @IsString({ each: true })
  parcelIds: string[];

  @ApiPropertyOptional({
    example: 'Added via scanner',
    description: 'Comment for the addition',
  })
  @IsOptional()
  @IsString()
  @MaxLength(200)
  comment?: string;

  @ApiPropertyOptional({
    example: true,
    description: 'Mark parcels as scanned immediately',
    default: true,
  })
  @IsOptional()
  @IsBoolean()
  markAsScanned?: boolean = true;
}
export class RemoveParcelsFromSlipDto {
  @ApiProperty({
    example: ['cuid1', 'cuid2'],
    description: 'Array of parcel IDs to remove',
  })
  @IsArray()
  @ArrayNotEmpty()
  @IsString({ each: true })
  parcelIds: string[];

  @ApiPropertyOptional({
    example: 'Removed due to address issue',
    description: 'Reason for removal',
  })
  @IsOptional()
  @IsString()
  @MaxLength(200)
  reason?: string;
}
export class ReceiveSlipDto {
  @ApiPropertyOptional({
    example: 'All packages received and verified',
    description: 'Reception notes',
  })
  @IsOptional()
  @IsString()
  @MaxLength(500)
  notes?: string;

  @ApiPropertyOptional({
    example: ['cuid1', 'cuid2'],
    description: 'Specific parcel IDs to mark as received (if not all)',
  })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  parcelIds?: string[];

  @ApiPropertyOptional({
    example: true,
    description: 'Force reception even if not all parcels are scanned',
    default: false,
  })
  @IsOptional()
  @IsBoolean()
  forceReceive?: boolean = false;
}
export class DeliverySlipResponseDto {
  @ApiProperty()
  id: string;

  @ApiProperty()
  tenantId: string;

  @ApiProperty()
  userId: string;

  @ApiProperty()
  reference: string;

  @ApiPropertyOptional()
  cityId?: string;

  @ApiProperty()
  status: DeliverySlipStatus;

  @ApiPropertyOptional()
  receivedAt?: Date;

  @ApiPropertyOptional()
  receivedBy?: string;

  @ApiPropertyOptional()
  notes?: string;

  @ApiProperty()
  createdAt: Date;

  @ApiProperty()
  updatedAt: Date;

  @ApiPropertyOptional()
  createdBy?: string;

  @ApiPropertyOptional()
  updatedBy?: string;

  // Relations
  @ApiPropertyOptional()
  city?: {
    id: string;
    name: string;
    ref: string;
  };

  @ApiPropertyOptional()
  creator?: {
    id: string;
    name: string;
    email: string;
  };

  @ApiProperty()
  items: DeliverySlipItemResponseDto[];

  @ApiProperty()
  summary: {
    totalParcels: number;
    scannedParcels: number;
    unscannedParcels: number;
    totalValue: number;
  };
}
export class DeliverySlipItemResponseDto {
  @ApiProperty()
  deliverySlipId: string;

  @ApiProperty()
  parcelId: string;

  @ApiProperty()
  scanned: boolean;

  @ApiPropertyOptional()
  scannedAt?: Date;

  @ApiPropertyOptional()
  scannedBy?: string;

  // Parcel details
  @ApiProperty()
  parcel: {
    id: string;
    code: string;
    recipientName: string;
    recipientPhone: string;
    destinationCity: string;
    price: number;
    statusCode: string;
    statusName: string;
  };
}
export class DeliverySlipStatsDto {
  @ApiProperty()
  totalSlips: number;

  @ApiProperty()
  pendingSlips: number;

  @ApiProperty()
  receivedSlips: number;

  @ApiProperty()
  cancelledSlips: number;

  @ApiProperty()
  totalParcelsInSlips: number;

  @ApiProperty()
  totalValueInSlips: number;

  @ApiProperty()
  averageParcelsPerSlip: number;

  @ApiProperty()
  recentActivity: Array<{
    date: string;
    slipsCreated: number;
    slipsReceived: number;
  }>;

  @ApiProperty()
  topCities: Array<{
    cityName: string;
    slipCount: number;
    parcelCount: number;
  }>;
}
export class BulkSlipActionDto {
  @ApiProperty({
    example: ['cuid1', 'cuid2'],
    description: 'Array of delivery slip IDs',
  })
  @IsArray()
  @ArrayNotEmpty()
  @IsString({ each: true })
  slipIds: string[];

  @ApiProperty({
    example: 'RECEIVE',
    description: 'Action to perform (RECEIVE, CANCEL, DELETE)',
  })
  @IsString()
  @IsNotEmpty()
  action: string;

  @ApiPropertyOptional({
    example: 'Bulk reception of morning slips',
    description: 'Comment for the bulk action',
  })
  @IsOptional()
  @IsString()
  comment?: string;
}
-----------------------------------------------------------------------
--++--> src/modules/delivery-slips/delivery-slips.controller.ts =======>
-----------------------------------------------------------------------
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiParam,
  ApiBearerAuth,
  ApiBadRequestResponse,
  ApiNotFoundResponse,
  ApiForbiddenResponse,
  ApiConflictResponse,
} from '@nestjs/swagger';
import { DeliverySlipsService } from './delivery-slips.service';
import {
  CreateDeliverySlipDto,
  UpdateDeliverySlipDto,
  DeliverySlipQueryDto,
  AddParcelsToSlipDto,
  RemoveParcelsFromSlipDto,
  ReceiveSlipDto,
  DeliverySlipResponseDto,
  DeliverySlipStatsDto,
  BulkSlipActionDto,
} from './dto/delivery-slip.dto';
import { PaginatedResult } from '../../common/dto/pagination.dto';
import { GlobalAuth, CurrentTenant, CurrentUser } from '@network-saas/auth-lib';
import { ParseCuidPipe } from '../../common/pipes/parse-cuid.pipe';
@ApiTags('delivery-slips')
@ApiBearerAuth()
@Controller('delivery-slips')
export class DeliverySlipsController {
  constructor(private readonly deliverySlipsService: DeliverySlipsService) {}

  @Post()
  @GlobalAuth('delivery_slips:create')
  @ApiOperation({
    summary: 'Create delivery slip',
    description:
      'Create a new delivery slip for parcel collection. Sellers can only create for their parcels.',
  })
  @ApiResponse({
    status: 201,
    description: 'Delivery slip created successfully',
    type: DeliverySlipResponseDto,
  })
  @ApiBadRequestResponse({
    description: 'Invalid parcels or city provided',
  })
  @ApiForbiddenResponse({
    description: 'Sellers can only create slips for their own parcels',
  })
  async create(
    @Body() createDto: CreateDeliverySlipDto,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<DeliverySlipResponseDto> {
    return this.deliverySlipsService.create(
      createDto,
      tenantId,
      user.id,
      user.userType,
    );
  }

  @Get()
  @GlobalAuth('delivery_slips:read')
  @ApiOperation({
    summary: 'Get delivery slips',
    description:
      'Retrieve delivery slips with filtering. Sellers only see their own slips.',
  })
  @ApiResponse({
    status: 200,
    description: 'Delivery slips retrieved successfully',
    type: PaginatedResult<DeliverySlipResponseDto>,
  })
  async findAll(
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
    @Query() query: DeliverySlipQueryDto,
  ): Promise<PaginatedResult<DeliverySlipResponseDto>> {
    return this.deliverySlipsService.findAll(
      tenantId,
      query,
      user.id,
      user.userType,
    );
  }

  @Get('available-parcels')
  @GlobalAuth('delivery_slips:create')
  @ApiOperation({
    summary: 'Get available parcels',
    description:
      'Get parcels that can be added to delivery slips (NEW_PACKAGE status, not in other slips)',
  })
  @ApiResponse({
    status: 200,
    description: 'Available parcels retrieved successfully',
    schema: {
      type: 'array',
      items: {
        type: 'object',
        properties: {
          id: { type: 'string' },
          code: { type: 'string' },
          recipientName: { type: 'string' },
          recipientPhone: { type: 'string' },
          price: { type: 'number' },
          createdAt: { type: 'string', format: 'date-time' },
          pickupCity: { type: 'object' },
          destinationCity: { type: 'object' },
        },
      },
    },
  })
  async getAvailableParcels(
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
    @Query('cityId') cityId?: string,
  ): Promise<any[]> {
    return this.deliverySlipsService.getAvailableParcels(
      tenantId,
      user.id,
      user.userType,
      cityId,
    );
  }

  @Get('statistics')
  @GlobalAuth('delivery_slips:read')
  @ApiOperation({
    summary: 'Get delivery slip statistics',
    description: 'Get comprehensive statistics about delivery slips',
  })
  @ApiResponse({
    status: 200,
    description: 'Statistics retrieved successfully',
    type: DeliverySlipStatsDto,
  })
  async getStatistics(
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<DeliverySlipStatsDto> {
    return this.deliverySlipsService.getStatistics(
      tenantId,
      user.id,
      user.userType,
    );
  }

  @Post('bulk-action')
  @GlobalAuth('delivery_slips:update')
  @ApiOperation({
    summary: 'Bulk actions on delivery slips',
    description:
      'Perform bulk actions (RECEIVE, CANCEL, DELETE) on multiple delivery slips',
  })
  @ApiResponse({
    status: 200,
    description: 'Bulk action completed',
    schema: {
      type: 'object',
      properties: {
        success: { type: 'number' },
        failed: { type: 'number' },
        errors: { type: 'array', items: { type: 'string' } },
      },
    },
  })
  async bulkAction(
    @Body() bulkActionDto: BulkSlipActionDto,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<{ success: number; failed: number; errors: string[] }> {
    return this.deliverySlipsService.bulkAction(
      bulkActionDto,
      tenantId,
      user.id,
    );
  }

  @Get(':id')
  @GlobalAuth('delivery_slips:read')
  @ApiOperation({
    summary: 'Get delivery slip by ID',
    description: 'Retrieve a specific delivery slip with all details and items',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Delivery slip ID' })
  @ApiResponse({
    status: 200,
    description: 'Delivery slip retrieved successfully',
    type: DeliverySlipResponseDto,
  })
  @ApiNotFoundResponse({ description: 'Delivery slip not found' })
  @ApiForbiddenResponse({
    description: 'Cannot access delivery slip created by other users',
  })
  async findOne(
    @Param('id', ParseCuidPipe) id: string,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<DeliverySlipResponseDto> {
    return this.deliverySlipsService.findOne(
      id,
      tenantId,
      user.id,
      user.userType,
    );
  }

  @Get(':id/pdf')
  @GlobalAuth('delivery_slips:read')
  @ApiOperation({
    summary: 'Download delivery slip PDF',
    description: 'Generate and download delivery slip as PDF document',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Delivery slip ID' })
  @ApiResponse({
    status: 200,
    description: 'PDF generated successfully',
    schema: {
      type: 'string',
      format: 'binary',
    },
    headers: {
      'Content-Type': {
        description: 'application/pdf',
        schema: { type: 'string' },
      },
      'Content-Disposition': {
        description: 'attachment; filename="delivery-slip-{reference}.pdf"',
        schema: { type: 'string' },
      },
    },
  })
  async downloadPdf(
    @Param('id', ParseCuidPipe) id: string,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<any> {
    // This would generate and return a PDF
    // For now, return a placeholder response
    return { message: 'PDF generation - to be implemented' };
  }

  @Get(':id/labels')
  @GlobalAuth('delivery_slips:read')
  @ApiOperation({
    summary: 'Download parcel labels',
    description:
      'Generate and download shipping labels for all parcels in the delivery slip',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Delivery slip ID' })
  @ApiResponse({
    status: 200,
    description: 'Labels generated successfully',
    schema: {
      type: 'string',
      format: 'binary',
    },
  })
  async downloadLabels(
    @Param('id', ParseCuidPipe) id: string,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<any> {
    // This would generate shipping labels
    return { message: 'Label generation - to be implemented' };
  }

  @Patch(':id')
  @GlobalAuth('delivery_slips:update')
  @ApiOperation({
    summary: 'Update delivery slip',
    description: 'Update delivery slip details (only for pending slips)',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Delivery slip ID' })
  @ApiResponse({
    status: 200,
    description: 'Delivery slip updated successfully',
    type: DeliverySlipResponseDto,
  })
  @ApiNotFoundResponse({ description: 'Delivery slip not found' })
  @ApiBadRequestResponse({
    description: 'Cannot update received delivery slip',
  })
  @ApiForbiddenResponse({
    description: 'Can only update your own delivery slips',
  })
  async update(
    @Param('id', ParseCuidPipe) id: string,
    @Body() updateDto: UpdateDeliverySlipDto,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<DeliverySlipResponseDto> {
    return this.deliverySlipsService.update(
      id,
      updateDto,
      tenantId,
      user.id,
      user.userType,
    );
  }

  @Post(':id/add-parcels')
  @GlobalAuth('delivery_slips:update')
  @ApiOperation({
    summary: 'Add parcels to delivery slip',
    description:
      'Add parcels to an existing delivery slip (scanner integration)',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Delivery slip ID' })
  @ApiResponse({
    status: 200,
    description: 'Parcels added successfully',
    type: DeliverySlipResponseDto,
  })
  @ApiBadRequestResponse({ description: 'Invalid parcels or slip status' })
  @ApiConflictResponse({ description: 'Some parcels already in other slips' })
  async addParcels(
    @Param('id', ParseCuidPipe) id: string,
    @Body() addParcelsDto: AddParcelsToSlipDto,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<DeliverySlipResponseDto> {
    return this.deliverySlipsService.addParcels(
      id,
      addParcelsDto,
      tenantId,
      user.id,
      user.userType,
    );
  }

  @Post(':id/remove-parcels')
  @GlobalAuth('delivery_slips:update')
  @ApiOperation({
    summary: 'Remove parcels from delivery slip',
    description: 'Remove parcels from delivery slip and reset their status',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Delivery slip ID' })
  @ApiResponse({
    status: 200,
    description: 'Parcels removed successfully',
    type: DeliverySlipResponseDto,
  })
  @ApiBadRequestResponse({ description: 'Cannot remove from received slip' })
  async removeParcels(
    @Param('id', ParseCuidPipe) id: string,
    @Body() removeParcelsDto: RemoveParcelsFromSlipDto,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<DeliverySlipResponseDto> {
    return this.deliverySlipsService.removeParcels(
      id,
      removeParcelsDto,
      tenantId,
      user.id,
      user.userType,
    );
  }

  @Post(':id/receive')
  @GlobalAuth('delivery_slips:receive')
  @ApiOperation({
    summary: 'Mark delivery slip as received',
    description: 'Mark delivery slip as received (all packages collected)',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Delivery slip ID' })
  @ApiResponse({
    status: 200,
    description: 'Delivery slip marked as received',
    type: DeliverySlipResponseDto,
  })
  @ApiBadRequestResponse({
    description: 'Slip not in pending status or has unscanned parcels',
  })
  async receiveSlip(
    @Param('id', ParseCuidPipe) id: string,
    @Body() receiveDto: ReceiveSlipDto,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<DeliverySlipResponseDto> {
    return this.deliverySlipsService.receiveSlip(
      id,
      receiveDto,
      tenantId,
      user.id,
    );
  }

  @Post(':id/scan/:parcelCode')
  @GlobalAuth('delivery_slips:scan')
  @ApiOperation({
    summary: 'Scan parcel into delivery slip',
    description:
      'Scan an parcel directly into this delivery slip (scanner integration)',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Delivery slip ID' })
  @ApiParam({
    name: 'parcelCode',
    type: 'string',
    description: 'Parcel code to scan',
  })
  @ApiResponse({
    status: 200,
    description: 'Parcel scanned successfully',
    schema: {
      type: 'object',
      properties: {
        success: { type: 'boolean' },
        message: { type: 'string' },
        parcelDetails: { type: 'object' },
      },
    },
  })
  async scanParcel(
    @Param('id', ParseCuidPipe) id: string,
    @Param('parcelCode') parcelCode: string,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<any> {
    // This integrates with the scanner service
    // Implementation would call scanner service with slip context
    return {
      success: true,
      message: 'Scanner integration - to be implemented',
      parcelDetails: {},
    };
  }

  @Get(':id/barcode')
  @GlobalAuth('delivery_slips:read')
  @ApiOperation({
    summary: 'Get delivery slip barcode',
    description: 'Generate barcode for the delivery slip for scanning',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Delivery slip ID' })
  @ApiResponse({
    status: 200,
    description: 'Barcode generated successfully',
    schema: {
      type: 'object',
      properties: {
        reference: { type: 'string' },
        barcodeData: { type: 'string' },
        barcodeImage: { type: 'string' },
        qrCodeImage: { type: 'string' },
      },
    },
  })
  async getBarcode(
    @Param('id', ParseCuidPipe) id: string,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<any> {
    const deliverySlip = await this.deliverySlipsService.findOne(
      id,
      tenantId,
      user.id,
      user.userType,
    );

    return {
      reference: deliverySlip.reference,
      barcodeData: deliverySlip.reference,
      // These would be generated by a barcode library
      barcodeImage: `data:image/png;base64,${deliverySlip.reference}`, // Placeholder
      qrCodeImage: `data:image/png;base64,QR${deliverySlip.reference}`, // Placeholder
    };
  }

  @Delete(':id')
  @GlobalAuth('delivery_slips:delete')
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({
    summary: 'Delete delivery slip',
    description:
      'Soft delete delivery slip (only pending slips, resets parcel statuses)',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Delivery slip ID' })
  @ApiResponse({
    status: 204,
    description: 'Delivery slip deleted successfully',
  })
  @ApiNotFoundResponse({ description: 'Delivery slip not found' })
  @ApiBadRequestResponse({
    description: 'Can only delete pending delivery slips',
  })
  async remove(
    @Param('id', ParseCuidPipe) id: string,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<void> {
    await this.deliverySlipsService.remove(id, tenantId, user.id);
  }
}
-----------------------------------------------------------------------
--++--> src/modules/delivery-slips/delivery-slips.module.ts =======>
-----------------------------------------------------------------------
import { Module } from '@nestjs/common';
import { DeliverySlipsService } from './delivery-slips.service';
import { DeliverySlipsController } from './delivery-slips.controller';
import { PrismaModule } from '../../shared/services/prisma/prisma.module';
import { RedisModule } from '../../shared/services/redis/redis.module';
@Module({
  imports: [PrismaModule, RedisModule],
  controllers: [DeliverySlipsController],
  providers: [DeliverySlipsService],
  exports: [DeliverySlipsService],
})
export class DeliverySlipsModule {}
-----------------------------------------------------------------------
--++--> src/modules/delivery-slips/services/delivery-slips.service.ts =======>
-----------------------------------------------------------------------
import {
  Injectable,
  NotFoundException,
  BadRequestException,
  ConflictException,
  Logger,
  ForbiddenException,
} from '@nestjs/common';
import { PrismaService } from '../../shared/services/prisma/prisma.service';
import { RedisService } from '../../shared/services/redis/redis.service';
import {
  CreateDeliverySlipDto,
  UpdateDeliverySlipDto,
  DeliverySlipQueryDto,
  AddParcelsToSlipDto,
  RemoveParcelsFromSlipDto,
  ReceiveSlipDto,
  DeliverySlipResponseDto,
  DeliverySlipStatsDto,
  BulkSlipActionDto,
  DeliverySlipStatus,
} from './dto/delivery-slip.dto';
import { PaginatedResult } from '../../common/dto/pagination.dto';
@Injectable()
export class DeliverySlipsService {
  private readonly logger = new Logger(DeliverySlipsService.name);

  constructor(
    private prisma: PrismaService,
    private redis: RedisService,
  ) {}

  /**
   * Create a new delivery slip
   * Can be created by sellers for their parcels or by admins for any parcels
   */
  async create(
    createDto: CreateDeliverySlipDto,
    tenantId: string,
    userId: string,
    userType: string,
  ): Promise<DeliverySlipResponseDto> {
    // Generate unique reference
    const reference = await this.generateSlipReference(tenantId);

    // If parcelIds are provided, validate them
    let validParcelIds: string[] = [];
    if (createDto.parcelIds && createDto.parcelIds.length > 0) {
      validParcelIds = await this.validateParcelsForSlip(
        createDto.parcelIds,
        tenantId,
        userId,
        userType,
      );
    }

    // Validate city if provided
    if (createDto.cityId) {
      await this.validateCity(createDto.cityId, tenantId);
    }

    // Create the delivery slip
    const deliverySlip = await this.prisma.deliverySlip.create({
      data: {
        tenantId,
        userId,
        reference,
        cityId: createDto.cityId,
        status: DeliverySlipStatus.PENDING,
        createdBy: userId,
      },
    });

    // Add parcels to the slip if provided
    if (validParcelIds.length > 0) {
      await this.addParcelsToSlipInternal(
        deliverySlip.id,
        validParcelIds,
        userId,
        createDto.autoReceive || false,
      );

      // If autoReceive is true, mark slip as received
      if (createDto.autoReceive) {
        await this.receiveSlipInternal(
          deliverySlip.id,
          userId,
          'Auto-received on creation',
        );
      }
    }

    // Clear cache
    await this.clearCache(tenantId);

    this.logger.log(
      `Created delivery slip ${reference} with ${validParcelIds.length} parcels for tenant ${tenantId}`,
    );

    return this.findOne(deliverySlip.id, tenantId);
  }

  /**
   * Get delivery slips with filtering and pagination
   */
  async findAll(
    tenantId: string,
    query: DeliverySlipQueryDto,
    userId?: string,
    userType?: string,
  ): Promise<PaginatedResult<DeliverySlipResponseDto>> {
    const {
      page = 1,
      limit = 10,
      search,
      status,
      cityId,
      userId: filterUserId,
      startDate,
      endDate,
      sortBy = 'createdAt',
      sortParcel = 'desc',
    } = query;

    const skip = (page - 1) * limit;

    // Build where clause
    const where: any = {
      tenantId,
      isDeleted: false,
    };

    // If user is SELLER, only show their own delivery slips
    if (userType === 'SELLER') {
      where.userId = userId;
    } else if (filterUserId) {
      where.userId = filterUserId;
    }

    if (search) {
      where.OR = [
        { reference: { contains: search, mode: 'insensitive' } },
        {
          items: {
            some: {
              parcel: {
                OR: [
                  { code: { contains: search, mode: 'insensitive' } },
                  { recipientName: { contains: search, mode: 'insensitive' } },
                  { recipientPhone: { contains: search, mode: 'insensitive' } },
                ],
              },
            },
          },
        },
      ];
    }

    if (status) {
      where.status = status;
    }

    if (cityId) {
      where.cityId = cityId;
    }

    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) {
        where.createdAt.gte = new Date(startDate);
      }
      if (endDate) {
        where.createdAt.lte = new Date(endDate + 'T23:59:59.999Z');
      }
    }

    // Get total count
    const total = await this.prisma.deliverySlip.count({ where });

    // Get delivery slips
    const deliverySlips = await this.prisma.deliverySlip.findMany({
      where,
      skip,
      take: limit,
      orderBy: { [sortBy]: sortParcel },
      include: this.getSlipIncludes(),
    });

    const data = deliverySlips.map((slip) => this.mapToResponseDto(slip));

    return new PaginatedResult(data, page, limit, total);
  }

  /**
   * Get single delivery slip by ID
   */
  async findOne(
    id: string,
    tenantId: string,
    userId?: string,
    userType?: string,
  ): Promise<DeliverySlipResponseDto> {
    const deliverySlip = await this.prisma.deliverySlip.findFirst({
      where: {
        id,
        tenantId,
        isDeleted: false,
      },
      include: this.getSlipIncludes(),
    });

    if (!deliverySlip) {
      throw new NotFoundException('Delivery slip not found');
    }

    // Check access permissions
    if (userType === 'SELLER' && deliverySlip.userId !== userId) {
      throw new ForbiddenException('You can only view your own delivery slips');
    }

    return this.mapToResponseDto(deliverySlip);
  }

  /**
   * Update delivery slip
   */
  async update(
    id: string,
    updateDto: UpdateDeliverySlipDto,
    tenantId: string,
    userId: string,
    userType: string,
  ): Promise<DeliverySlipResponseDto> {
    const existing = await this.prisma.deliverySlip.findFirst({
      where: { id, tenantId, isDeleted: false },
    });

    if (!existing) {
      throw new NotFoundException('Delivery slip not found');
    }

    // Check permissions
    if (userType === 'SELLER' && existing.userId !== userId) {
      throw new ForbiddenException(
        'You can only update your own delivery slips',
      );
    }

    // Check if slip can be updated
    if (existing.status === DeliverySlipStatus.RECEIVED) {
      throw new BadRequestException('Cannot update received delivery slip');
    }

    // Validate city if being updated
    if (updateDto.cityId) {
      await this.validateCity(updateDto.cityId, tenantId);
    }

    const updated = await this.prisma.deliverySlip.update({
      where: { id },
      data: {
        ...updateDto,
        updatedBy: userId,
      },
    });

    await this.clearCache(tenantId);

    this.logger.log(
      `Updated delivery slip ${existing.reference} for tenant ${tenantId}`,
    );

    return this.findOne(id, tenantId);
  }

  /**
   * Add parcels to delivery slip
   */
  async addParcels(
    id: string,
    addParcelsDto: AddParcelsToSlipDto,
    tenantId: string,
    userId: string,
    userType: string,
  ): Promise<DeliverySlipResponseDto> {
    const deliverySlip = await this.prisma.deliverySlip.findFirst({
      where: { id, tenantId, isDeleted: false },
    });

    if (!deliverySlip) {
      throw new NotFoundException('Delivery slip not found');
    }

    // Check permissions
    if (userType === 'SELLER' && deliverySlip.userId !== userId) {
      throw new ForbiddenException(
        'You can only modify your own delivery slips',
      );
    }

    // Check if slip can be modified
    if (deliverySlip.status !== DeliverySlipStatus.PENDING) {
      throw new BadRequestException(
        'Can only add parcels to pending delivery slips',
      );
    }

    // Validate and add parcels
    const validParcelIds = await this.validateParcelsForSlip(
      addParcelsDto.parcelIds,
      tenantId,
      userId,
      userType,
    );

    await this.addParcelsToSlipInternal(
      id,
      validParcelIds,
      userId,
      addParcelsDto.markAsScanned || true,
      addParcelsDto.comment,
    );

    await this.clearCache(tenantId);

    this.logger.log(
      `Added ${validParcelIds.length} parcels to delivery slip ${deliverySlip.reference}`,
    );

    return this.findOne(id, tenantId);
  }

  /**
   * Remove parcels from delivery slip
   */
  async removeParcels(
    id: string,
    removeParcelsDto: RemoveParcelsFromSlipDto,
    tenantId: string,
    userId: string,
    userType: string,
  ): Promise<DeliverySlipResponseDto> {
    const deliverySlip = await this.prisma.deliverySlip.findFirst({
      where: { id, tenantId, isDeleted: false },
    });

    if (!deliverySlip) {
      throw new NotFoundException('Delivery slip not found');
    }

    // Check permissions
    if (userType === 'SELLER' && deliverySlip.userId !== userId) {
      throw new ForbiddenException(
        'You can only modify your own delivery slips',
      );
    }

    // Check if slip can be modified
    if (deliverySlip.status !== DeliverySlipStatus.PENDING) {
      throw new BadRequestException(
        'Can only remove parcels from pending delivery slips',
      );
    }

    // Remove parcels from slip
    await this.prisma.deliverySlipItem.deleteMany({
      where: {
        deliverySlipId: id,
        parcelId: { in: removeParcelsDto.parcelIds },
      },
    });

    // Reset parcel statuses back to NEW_PACKAGE
    const newPackageStatus = await this.prisma.parcelStatus.findFirst({
      where: { tenantId, code: 'NEW_PACKAGE', isDeleted: false },
    });

    if (newPackageStatus) {
      await this.prisma.parcel.updateMany({
        where: { id: { in: removeParcelsDto.parcelIds } },
        data: {
          parcelStatusId: newPackageStatus.id,
          parcelStatusCode: newPackageStatus.code,
          updatedBy: userId,
        },
      });

      // Create status history entries
      for (const parcelId of removeParcelsDto.parcelIds) {
        await this.prisma.parcelStatusHistory.create({
          data: {
            parcelId,
            parcelStatusId: newPackageStatus.id,
            statusCode: newPackageStatus.code,
            comment: `Removed from delivery slip: ${removeParcelsDto.reason || 'No reason provided'}`,
            changedBy: userId,
          },
        });
      }
    }

    await this.clearCache(tenantId);

    this.logger.log(
      `Removed ${removeParcelsDto.parcelIds.length} parcels from delivery slip ${deliverySlip.reference}`,
    );

    return this.findOne(id, tenantId);
  }

  /**
   * Mark delivery slip as received
   */
  async receiveSlip(
    id: string,
    receiveDto: ReceiveSlipDto,
    tenantId: string,
    userId: string,
  ): Promise<DeliverySlipResponseDto> {
    const deliverySlip = await this.prisma.deliverySlip.findFirst({
      where: { id, tenantId, isDeleted: false },
      include: { items: true },
    });

    if (!deliverySlip) {
      throw new NotFoundException('Delivery slip not found');
    }

    if (deliverySlip.status !== DeliverySlipStatus.PENDING) {
      throw new BadRequestException('Delivery slip is not in pending status');
    }

    // Check if all items are scanned (unless forced)
    if (!receiveDto.forceReceive) {
      const unscannedItems = deliverySlip.items.filter((item) => !item.scanned);
      if (unscannedItems.length > 0) {
        throw new BadRequestException(
          `Cannot receive slip: ${unscannedItems.length} parcels are not scanned. Use forceReceive=true to override.`,
        );
      }
    }

    await this.receiveSlipInternal(id, userId, receiveDto.notes);
    await this.clearCache(tenantId);

    this.logger.log(
      `Received delivery slip ${deliverySlip.reference} for tenant ${tenantId}`,
    );

    return this.findOne(id, tenantId);
  }

  /**
   * Get available parcels for delivery slips
   */
  async getAvailableParcels(
    tenantId: string,
    userId?: string,
    userType?: string,
    cityId?: string,
  ): Promise<any[]> {
    const where: any = {
      tenantId,
      isDeleted: false,
      parcelStatusCode: 'NEW_PACKAGE', // Only new packages can be added to delivery slips
      deliverySlipItems: { none: {} }, // Not already in a delivery slip
    };

    // Sellers can only see their own parcels
    if (userType === 'SELLER') {
      where.userId = userId;
    }

    // Filter by city if provided
    if (cityId) {
      where.pickupCityId = cityId;
    }

    const parcels = await this.prisma.parcel.findMany({
      where,
      select: {
        id: true,
        code: true,
        recipientName: true,
        recipientPhone: true,
        price: true,
        createdAt: true,
        pickupCity: {
          select: { id: true, name: true, ref: true },
        },
        destinationCity: {
          select: { id: true, name: true, ref: true },
        },
      },
      orderBy: { createdAt: 'desc' },
      take: 100, // Limit for performance
    });

    return parcels.map((parcel) => ({
      ...parcel,
      price: Number(parcel.price),
    }));
  }

  /**
   * Get delivery slip statistics
   */
  async getStatistics(
    tenantId: string,
    userId?: string,
    userType?: string,
  ): Promise<DeliverySlipStatsDto> {
    const cached = await this.redis.getTenantCache(
      tenantId,
      `delivery-slips-stats:${userId || 'all'}`,
    );
    if (cached) {
      return JSON.parse(cached);
    }

    const baseWhere: any = { tenantId, isDeleted: false };
    if (userType === 'SELLER') {
      baseWhere.userId = userId;
    }

    // Replace the Promise.all section around line 530-560

    const [
      totalSlips,
      statusCounts,
      parcelCount,
      parcelValues,
      recentActivity,
      topCities,
    ] = await Promise.all([
      // Total slips count
      this.prisma.deliverySlip.count({ where: baseWhere }),

      // Count by status
      this.prisma.deliverySlip.groupBy({
        by: ['status'],
        where: baseWhere,
        _count: true,
      }),

      // Count of parcels in delivery slips
      this.prisma.deliverySlipItem.count({
        where: {
          deliverySlip: baseWhere,
        },
      }),

      // Get all parcels to calculate total value
      this.prisma.deliverySlipItem.findMany({
        where: {
          deliverySlip: baseWhere,
        },
        include: {
          parcel: {
            select: { price: true },
          },
        },
      }),

      // Recent activity (last 7 days)
      this.getRecentActivity(tenantId, userId, userType),

      // Top cities
      this.getTopCities(tenantId, userId, userType),
    ]);

    // Calculate total value
    const totalValue = parcelValues.reduce(
      (sum, item) => sum + Number(item.parcel.price),
      0,
    );

    // Process status counts
    const statusMap = statusCounts.reduce(
      (acc, item) => {
        acc[item.status] = item._count;
        return acc;
      },
      {} as Record<string, number>,
    );

    const stats: DeliverySlipStatsDto = {
      totalSlips,
      pendingSlips: statusMap[DeliverySlipStatus.PENDING] || 0,
      receivedSlips: statusMap[DeliverySlipStatus.RECEIVED] || 0,
      cancelledSlips: statusMap[DeliverySlipStatus.CANCELLED] || 0,
      totalParcelsInSlips: parcelCount,
      totalValueInSlips: totalValue,
      averageParcelsPerSlip: totalSlips > 0 ? parcelCount / totalSlips : 0,
      recentActivity,
      topCities,
    };

    // Cache for 30 minutes
    await this.redis.setTenantCache(
      tenantId,
      `delivery-slips-stats:${userId || 'all'}`,
      JSON.stringify(stats),
      1800,
    );

    return stats;
  }

  /**
   * Bulk actions on delivery slips
   */
  async bulkAction(
    bulkActionDto: BulkSlipActionDto,
    tenantId: string,
    userId: string,
  ): Promise<{ success: number; failed: number; errors: string[] }> {
    const { slipIds, action, comment } = bulkActionDto;
    const errors: string[] = [];
    let success = 0;
    let failed = 0;

    for (const slipId of slipIds) {
      try {
        switch (action.toUpperCase()) {
          case 'RECEIVE':
            await this.receiveSlip(
              slipId,
              { notes: comment },
              tenantId,
              userId,
            );
            break;
          case 'CANCEL':
            await this.update(
              slipId,
              { status: DeliverySlipStatus.CANCELLED },
              tenantId,
              userId,
              'ADMIN',
            );
            break;
          case 'DELETE':
            await this.remove(slipId, tenantId, userId);
            break;
          default:
            throw new BadRequestException(`Unknown action: ${action}`);
        }
        success++;
      } catch (error) {
        failed++;
        errors.push(`Slip ${slipId}: ${error.message}`);
      }
    }

    return { success, failed, errors };
  }

  /**
   * Soft delete delivery slip
   */
  async remove(id: string, tenantId: string, userId: string): Promise<void> {
    const existing = await this.prisma.deliverySlip.findFirst({
      where: { id, tenantId, isDeleted: false },
    });

    if (!existing) {
      throw new NotFoundException('Delivery slip not found');
    }

    // Can only delete pending slips
    if (existing.status !== DeliverySlipStatus.PENDING) {
      throw new BadRequestException('Can only delete pending delivery slips');
    }

    // Remove all items first and reset parcel statuses
    const items = await this.prisma.deliverySlipItem.findMany({
      where: { deliverySlipId: id },
      select: { parcelId: true },
    });

    if (items.length > 0) {
      const parcelIds = items.map((item) => item.parcelId);
      const newPackageStatus = await this.prisma.parcelStatus.findFirst({
        where: { tenantId, code: 'NEW_PACKAGE', isDeleted: false },
      });

      if (newPackageStatus) {
        await this.prisma.parcel.updateMany({
          where: { id: { in: parcelIds } },
          data: {
            parcelStatusId: newPackageStatus.id,
            parcelStatusCode: newPackageStatus.code,
          },
        });
      }
    }

    // Soft delete
    await this.prisma.deliverySlip.update({
      where: { id },
      data: {
        isDeleted: true,
        deletedAt: new Date(),
        deletedBy: userId,
      },
    });

    await this.clearCache(tenantId);

    this.logger.log(
      `Deleted delivery slip ${existing.reference} for tenant ${tenantId}`,
    );
  }

  // Private helper methods

  private async generateSlipReference(tenantId: string): Promise<string> {
    const date = new Date();
    const year = date.getFullYear().toString().slice(-2);
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');

    // Get daily counter
    const counterKey = `delivery-slip-counter:${tenantId}:${year}${month}${day}`;
    const counter = await this.redis.incr(counterKey);
    await this.redis.expire(counterKey, 86400); // Expire after 1 day

    const randomSuffix = Math.random().toString(10).substring(2, 5);

    return `BL-${day}${month}${year}-${String(counter).padStart(7, '0')}-${randomSuffix}`;
  }

  private async validateCity(cityId: string, tenantId: string): Promise<void> {
    const city = await this.prisma.city.findFirst({
      where: {
        id: cityId,
        tenantId,
        isDeleted: false,
        status: true,
      },
    });

    if (!city) {
      throw new BadRequestException('Invalid or inactive city');
    }
  }

  private async validateParcelsForSlip(
    parcelIds: string[],
    tenantId: string,
    userId: string,
    userType: string,
  ): Promise<string[]> {
    const where: any = {
      id: { in: parcelIds },
      tenantId,
      isDeleted: false,
      parcelStatusCode: 'NEW_PACKAGE',
      deliverySlipItems: { none: {} }, // Not already in a delivery slip
    };

    // Sellers can only add their own parcels
    if (userType === 'SELLER') {
      where.userId = userId;
    }

    const validParcels = await this.prisma.parcel.findMany({
      where,
      select: { id: true, code: true },
    });

    if (validParcels.length !== parcelIds.length) {
      const validIds = validParcels.map((o) => o.id);
      const invalidIds = parcelIds.filter((id) => !validIds.includes(id));
      throw new BadRequestException(
        `Some parcels are invalid or cannot be added: ${invalidIds.length} out of ${parcelIds.length}`,
      );
    }

    return validParcels.map((o) => o.id);
  }

  private async addParcelsToSlipInternal(
    slipId: string,
    parcelIds: string[],
    userId: string,
    markAsScanned: boolean = false,
    comment?: string,
  ): Promise<void> {
    // Add items to slip
    await this.prisma.deliverySlipItem.createMany({
      data: parcelIds.map((parcelId) => ({
        deliverySlipId: slipId,
        parcelId,
        scanned: markAsScanned,
        scannedAt: markAsScanned ? new Date() : null,
        scannedBy: markAsScanned ? userId : null,
      })),
      skipDuplicates: true,
    });

    // If parcels are being scanned/received, update their status
    if (markAsScanned) {
      // Determine if pickup city = destination city for status logic
      const parcels = await this.prisma.parcel.findMany({
        where: { id: { in: parcelIds } },
        include: {
          pickupCity: true,
          destinationCity: true,
        },
      });

      for (const parcel of parcels) {
        // If same city, status becomes "RECEIVED", if different city, status becomes "COLLECTED"
        const isSameCity = parcel.pickupCityId === parcel.destinationCityId;
        const newStatusCode = isSameCity ? 'RECEIVED' : 'COLLECTED';

        const newStatus = await this.prisma.parcelStatus.findFirst({
          where: { code: newStatusCode, isDeleted: false },
        });

        if (newStatus) {
          await this.prisma.parcel.update({
            where: { id: parcel.id },
            data: {
              parcelStatusId: newStatus.id,
              parcelStatusCode: newStatus.code,
              updatedBy: userId,
            },
          });

          // Create status history
          await this.prisma.parcelStatusHistory.create({
            data: {
              parcelId: parcel.id,
              parcelStatusId: newStatus.id,
              statusCode: newStatus.code,
              comment: comment || 'Added to delivery slip and scanned',
              changedBy: userId,
            },
          });
        }
      }
    }
  }

  private async receiveSlipInternal(
    slipId: string,
    userId: string,
    notes?: string,
  ): Promise<void> {
    await this.prisma.deliverySlip.update({
      where: { id: slipId },
      data: {
        status: DeliverySlipStatus.RECEIVED,
        receivedAt: new Date(),
        receivedBy: userId,
        updatedBy: userId,
      },
    });

    // Mark all unscanned items as scanned
    await this.prisma.deliverySlipItem.updateMany({
      where: {
        deliverySlipId: slipId,
        scanned: false,
      },
      data: {
        scanned: true,
        scannedAt: new Date(),
        scannedBy: userId,
      },
    });
  }

  private async getRecentActivity(
    tenantId: string,
    userId?: string,
    userType?: string,
  ): Promise<any[]> {
    const baseWhere: any = { tenantId, isDeleted: false };
    if (userType === 'SELLER') {
      baseWhere.userId = userId;
    }

    // Get data for last 7 days
    const sevenDaysAgo = new Date();
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

    const activity = await this.prisma.deliverySlip.groupBy({
      by: ['createdAt', 'status'],
      where: {
        ...baseWhere,
        createdAt: { gte: sevenDaysAgo },
      },
      _count: true,
    });

    // Process into daily stats
    const dailyStats = new Map<
      string,
      { slipsCreated: number; slipsReceived: number }
    >();

    for (let i = 0; i < 7; i++) {
      const date = new Date();
      date.setDate(date.getDate() - i);
      const dateStr = date.toISOString().split('T')[0];
      dailyStats.set(dateStr, { slipsCreated: 0, slipsReceived: 0 });
    }

    activity.forEach((item) => {
      const dateStr = item.createdAt.toISOString().split('T')[0];
      const stats = dailyStats.get(dateStr) || {
        slipsCreated: 0,
        slipsReceived: 0,
      };

      stats.slipsCreated += item._count;
      if (item.status === DeliverySlipStatus.RECEIVED) {
        stats.slipsReceived += item._count;
      }

      dailyStats.set(dateStr, stats);
    });

    return Array.from(dailyStats.entries()).map(([date, stats]) => ({
      date,
      ...stats,
    }));
  }

  private async getTopCities(
    tenantId: string,
    userId?: string,
    userType?: string,
  ): Promise<any[]> {
    const baseWhere: any = { tenantId, isDeleted: false };
    if (userType === 'SELLER') {
      baseWhere.userId = userId;
    }

    const cityStats = await this.prisma.deliverySlip.groupBy({
      by: ['cityId'],
      where: baseWhere,
      _count: true,
      orderBy: { _count: { cityId: 'desc' } },
      take: 5,
    });

    // Get city names
    const cityIds = cityStats
      .map((stat) => stat.cityId)
      .filter(Boolean) as string[];
    const cities = await this.prisma.city.findMany({
      where: { id: { in: cityIds } },
      select: { id: true, name: true },
    });

    return cityStats.map((stat) => {
      const city = cities.find((c) => c.id === stat.cityId);
      return {
        cityName: city?.name || 'Unknown',
        slipCount: stat._count,
        parcelCount: 0, // This would need additional query
      };
    });
  }

  private getSlipIncludes() {
    return {
      city: {
        select: { id: true, name: true, ref: true },
      },
      items: {
        include: {
          parcel: {
            select: {
              id: true,
              code: true,
              recipientName: true,
              recipientPhone: true,
              price: true,
              parcelStatusCode: true,
              parcelStatus: {
                select: { name: true, color: true },
              },
              destinationCity: {
                select: { name: true },
              },
            },
          },
        },
      },
    };
  }

  private mapToResponseDto(slip: any): DeliverySlipResponseDto {
    const totalParcels = slip.items?.length || 0;
    const scannedParcels =
      slip.items?.filter((item: any) => item.scanned).length || 0;
    const totalValue =
      slip.items?.reduce(
        (sum: number, item: any) => sum + Number(item.parcel.price),
        0,
      ) || 0;

    return {
      id: slip.id,
      tenantId: slip.tenantId,
      userId: slip.userId,
      reference: slip.reference,
      cityId: slip.cityId,
      status: slip.status,
      receivedAt: slip.receivedAt,
      receivedBy: slip.receivedBy,
      notes: slip.notes,
      createdAt: slip.createdAt,
      updatedAt: slip.updatedAt,
      createdBy: slip.createdBy,
      updatedBy: slip.updatedBy,
      city: slip.city,
      creator: slip.creator,
      items:
        slip.items?.map((item: any) => ({
          deliverySlipId: item.deliverySlipId,
          parcelId: item.parcelId,
          scanned: item.scanned,
          scannedAt: item.scannedAt,
          scannedBy: item.scannedBy,
          parcel: {
            id: item.parcel.id,
            code: item.parcel.code,
            recipientName: item.parcel.recipientName,
            recipientPhone: item.parcel.recipientPhone,
            destinationCity: item.parcel.destinationCity.name,
            price: Number(item.parcel.price),
            statusCode: item.parcel.parcelStatusCode,
            statusName: item.parcel.parcelStatus.name,
          },
        })) || [],
      summary: {
        totalParcels,
        scannedParcels,
        unscannedParcels: totalParcels - scannedParcels,
        totalValue,
      },
    };
  }

  private async clearCache(tenantId: string): Promise<void> {
    const keys = [
      'delivery-slips',
      'delivery-slips-stats:all',
      'available-parcels',
    ];

    for (const key of keys) {
      await this.redis.delTenantCache(tenantId, key);
    }

    // Clear user-specific caches using the new Redis methods
    const userKeys = await this.redis.keys(
      `tenant:${tenantId}:delivery-slips-stats:*`,
    );
    if (userKeys.length > 0) {
      await this.redis.delMultiple(userKeys);
    }
  }
}
-----------------------------------------------------------------------
--++--> src/modules/scanner/dto/scanner.dto.ts =======>
-----------------------------------------------------------------------
import {
  IsString,
  IsArray,
  IsOptional,
  IsEnum,
  IsBoolean,
  IsNotEmpty,
  ArrayNotEmpty,
  MaxLength,
} from 'class-validator';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
export enum ScannerAction {
  ADD_TO_SLIP = 'ADD_TO_SLIP',
  REMOVE_FROM_SLIP = 'REMOVE_FROM_SLIP',
  CHANGE_STATUS = 'CHANGE_STATUS',
  VERIFY_PACKAGE = 'VERIFY_PACKAGE',
  ASSIGN_TO_DELIVERY = 'ASSIGN_TO_DELIVERY',
}
export enum SlipType {
  DELIVERY_SLIP = 'DELIVERY_SLIP',
  SHIPPING_SLIP = 'SHIPPING_SLIP',
  DISTRIBUTION_SLIP = 'DISTRIBUTION_SLIP',
  RETURN_SLIP = 'RETURN_SLIP',
  PAYMENT_SLIP = 'PAYMENT_SLIP',
}
export class SingleScanDto {
  @ApiProperty({
    example: 'BSK0925539432LE',
    description: 'Parcel code or barcode to scan',
  })
  @IsString()
  @IsNotEmpty()
  @MaxLength(100)
  code: string;

  @ApiProperty({
    enum: ScannerAction,
    example: ScannerAction.ADD_TO_SLIP,
    description: 'Action to perform with the scanned code',
  })
  @IsEnum(ScannerAction)
  action: ScannerAction;

  @ApiPropertyOptional({
    enum: SlipType,
    example: SlipType.DELIVERY_SLIP,
    description:
      'Type of slip being worked with (required for slip operations)',
  })
  @IsOptional()
  @IsEnum(SlipType)
  slipType?: SlipType;

  @ApiPropertyOptional({
    example: 'cuid123',
    description: 'Slip ID (required for slip operations)',
  })
  @IsOptional()
  @IsString()
  slipId?: string;

  @ApiPropertyOptional({
    example: 'Package successfully added to delivery slip',
    description: 'Optional comment for the scan operation',
  })
  @IsOptional()
  @IsString()
  @MaxLength(500)
  comment?: string;

  @ApiPropertyOptional({
    example: 'DELIVERED',
    description: 'New status code (required for status change actions)',
  })
  @IsOptional()
  @IsString()
  newStatusCode?: string;

  @ApiPropertyOptional({
    example: 'cuid456',
    description: 'Delivery person ID (required for assignment actions)',
  })
  @IsOptional()
  @IsString()
  deliveryPersonId?: string;
}
export class BulkScanDto {
  @ApiProperty({
    example: ['BSK0925539432LE', 'BSK0925539433LE'],
    description: 'Array of parcel codes to scan',
  })
  @IsArray()
  @ArrayNotEmpty()
  @IsString({ each: true })
  codes: string[];

  @ApiProperty({
    enum: ScannerAction,
    example: ScannerAction.ADD_TO_SLIP,
    description: 'Action to perform on all scanned codes',
  })
  @IsEnum(ScannerAction)
  action: ScannerAction;

  @ApiPropertyOptional({
    enum: SlipType,
    example: SlipType.DELIVERY_SLIP,
    description: 'Type of slip being worked with',
  })
  @IsOptional()
  @IsEnum(SlipType)
  slipType?: SlipType;

  @ApiPropertyOptional({
    example: 'cuid123',
    description: 'Slip ID for bulk operations',
  })
  @IsOptional()
  @IsString()
  slipId?: string;

  @ApiPropertyOptional({
    example: 'Bulk scan operation from mobile scanner',
    description: 'Comment for the bulk operation',
  })
  @IsOptional()
  @IsString()
  @MaxLength(500)
  comment?: string;

  @ApiPropertyOptional({
    example: 'DELIVERED',
    description: 'New status code for bulk status changes',
  })
  @IsOptional()
  @IsString()
  newStatusCode?: string;

  @ApiPropertyOptional({
    example: 'cuid456',
    description: 'Delivery person ID for bulk assignments',
  })
  @IsOptional()
  @IsString()
  deliveryPersonId?: string;
}
export class ValidateCodeDto {
  @ApiProperty({
    example: 'BSK0925539432LE',
    description: 'Code to validate',
  })
  @IsString()
  @IsNotEmpty()
  @MaxLength(100)
  code: string;

  @ApiPropertyOptional({
    enum: SlipType,
    example: SlipType.DELIVERY_SLIP,
    description: 'Expected slip type context',
  })
  @IsOptional()
  @IsEnum(SlipType)
  expectedSlipType?: SlipType;

  @ApiPropertyOptional({
    example: 'cuid123',
    description: 'Slip ID for context validation',
  })
  @IsOptional()
  @IsString()
  slipId?: string;
}
export class ScanResultDto {
  @ApiProperty({
    example: true,
    description: 'Whether the scan was successful',
  })
  success: boolean;

  @ApiProperty({
    example: 'BSK0925539432LE',
    description: 'The scanned code',
  })
  code: string;

  @ApiProperty({
    enum: ScannerAction,
    example: ScannerAction.ADD_TO_SLIP,
    description: 'Action that was performed',
  })
  action: ScannerAction;

  @ApiPropertyOptional({
    example: 'Package successfully added to delivery slip',
    description: 'Result message',
  })
  message?: string;

  @ApiPropertyOptional({
    example: 'Parcel not found',
    description: 'Error message if scan failed',
  })
  error?: string;

  @ApiPropertyOptional({
    description: 'Parcel details if found',
    type: 'object',
    properties: {
      id: { type: 'string' },
      code: { type: 'string' },
      recipientName: { type: 'string' },
      recipientPhone: { type: 'string' },
      statusCode: { type: 'string' },
      statusName: { type: 'string' },
      destinationCity: { type: 'string' },
      price: { type: 'number' },
    },
  })
  parcelDetails?: {
    id: string;
    code: string;
    recipientName: string;
    recipientPhone: string;
    statusCode: string;
    statusName: string;
    destinationCity: string;
    price: number;
  };

  @ApiPropertyOptional({
    example: '2024-01-15T10:30:00Z',
    description: 'Timestamp when scan was performed',
  })
  scannedAt?: Date;
}
export class BulkScanResultDto {
  @ApiProperty({
    example: 5,
    description: 'Number of successful scans',
  })
  successful: number;

  @ApiProperty({
    example: 2,
    description: 'Number of failed scans',
  })
  failed: number;

  @ApiProperty({
    example: 7,
    description: 'Total number of codes processed',
  })
  total: number;

  @ApiProperty({
    type: [ScanResultDto],
    description: 'Detailed results for each scan',
  })
  results: ScanResultDto[];

  @ApiProperty({
    example: [
      'BSK0925539434LE: Parcel not found',
      'BSK0925539435LE: Invalid status',
    ],
    description: 'List of errors encountered',
  })
  errors: string[];

  @ApiProperty({
    example: '2024-01-15T10:30:00Z',
    description: 'When the bulk operation started',
  })
  processedAt: Date;
}
export class CodeValidationDto {
  @ApiProperty({
    example: true,
    description: 'Whether the code is valid',
  })
  isValid: boolean;

  @ApiProperty({
    example: 'BSK0925539432LE',
    description: 'The validated code',
  })
  code: string;

  @ApiProperty({
    example: 'PARCEL',
    description: 'Type of code (PARCEL, SLIP, etc.)',
  })
  codeType: string;

  @ApiPropertyOptional({
    example: 'Valid parcel code',
    description: 'Validation message',
  })
  message?: string;

  @ApiPropertyOptional({
    example: 'Parcel not found',
    description: 'Error message if invalid',
  })
  error?: string;

  @ApiPropertyOptional({
    description: 'Entity details if code is valid',
    type: 'object',
  })
  entityDetails?: any;

  @ApiPropertyOptional({
    type: [String],
    example: [ScannerAction.ADD_TO_SLIP, ScannerAction.CHANGE_STATUS],
    description: 'Available actions for this code',
  })
  availableActions?: ScannerAction[];
}
export class ScannerSessionDto {
  @ApiProperty({
    example: 'cuid123',
    description: 'Session ID for tracking continuous scanning',
  })
  sessionId: string;

  @ApiProperty({
    enum: SlipType,
    example: SlipType.DELIVERY_SLIP,
    description: 'Type of slip being processed in this session',
  })
  slipType: SlipType;

  @ApiPropertyOptional({
    example: 'cuid456',
    description: 'Slip ID being worked on',
  })
  slipId?: string;

  @ApiProperty({
    example: 15,
    description: 'Number of items scanned in this session',
  })
  itemsScanned: number;

  @ApiProperty({
    example: 2,
    description: 'Number of errors in this session',
  })
  errorsCount: number;

  @ApiProperty({
    example: '2024-01-15T10:30:00Z',
    description: 'When the session started',
  })
  startedAt: Date;

  @ApiPropertyOptional({
    example: '2024-01-15T11:00:00Z',
    description: 'When the session ended',
  })
  endedAt?: Date;

  @ApiProperty({
    example: true,
    description: 'Whether the session is currently active',
  })
  isActive: boolean;
}
export class StartScanSessionDto {
  @ApiProperty({
    enum: SlipType,
    example: SlipType.DELIVERY_SLIP,
    description: 'Type of slip to work with in this session',
  })
  @IsEnum(SlipType)
  slipType: SlipType;

  @ApiPropertyOptional({
    example: 'cuid123',
    description: 'Existing slip ID to work with',
  })
  @IsOptional()
  @IsString()
  slipId?: string;

  @ApiPropertyOptional({
    example: 'Mobile scanner session for morning pickup',
    description: 'Session description or notes',
  })
  @IsOptional()
  @IsString()
  @MaxLength(200)
  description?: string;
}
-----------------------------------------------------------------------
--++--> src/modules/scanner/scanner.controller.ts =======>
-----------------------------------------------------------------------
import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  Delete,
  Query,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiParam,
  ApiBearerAuth,
  ApiBadRequestResponse,
  ApiNotFoundResponse,
} from '@nestjs/swagger';
import { ScannerService } from './scanner.service';
import {
  SingleScanDto,
  BulkScanDto,
  ValidateCodeDto,
  ScanResultDto,
  BulkScanResultDto,
  CodeValidationDto,
  ScannerSessionDto,
  StartScanSessionDto,
} from './dto/scanner.dto';
import { GlobalAuth, CurrentTenant, CurrentUser } from '@network-saas/auth-lib';
import { ParseCuidPipe } from '../../common/pipes/parse-cuid.pipe';
@ApiTags('scanner')
@ApiBearerAuth()
@Controller('scanner')
export class ScannerController {
  constructor(private readonly scannerService: ScannerService) {}

  @Post('scan')
  @GlobalAuth('scanner:use')
  @ApiOperation({
    summary: 'Single scan operation',
    description:
      'Perform a single barcode/QR code scan operation with specified action',
  })
  @ApiResponse({
    status: 200,
    description: 'Scan operation completed',
    type: ScanResultDto,
  })
  @ApiBadRequestResponse({
    description: 'Invalid scan parameters or unsupported action',
  })
  async singleScan(
    @Body() scanDto: SingleScanDto,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<ScanResultDto> {
    return this.scannerService.singleScan(scanDto, tenantId, user.id);
  }

  @Post('bulk-scan')
  @GlobalAuth('scanner:bulk_scan')
  @ApiOperation({
    summary: 'Bulk scan operation',
    description:
      'Perform bulk scanning operations on multiple codes simultaneously',
  })
  @ApiResponse({
    status: 200,
    description: 'Bulk scan operation completed',
    type: BulkScanResultDto,
  })
  @ApiBadRequestResponse({
    description: 'Invalid bulk scan parameters',
  })
  async bulkScan(
    @Body() bulkScanDto: BulkScanDto,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<BulkScanResultDto> {
    return this.scannerService.bulkScan(bulkScanDto, tenantId, user.id);
  }

  @Post('validate')
  @GlobalAuth('scanner:use')
  @ApiOperation({
    summary: 'Validate code',
    description:
      'Validate a barcode/QR code and get available actions without performing any operation',
  })
  @ApiResponse({
    status: 200,
    description: 'Code validation completed',
    type: CodeValidationDto,
  })
  async validateCode(
    @Body() validateDto: ValidateCodeDto,
    @CurrentTenant() tenantId: string,
  ): Promise<CodeValidationDto> {
    return this.scannerService.validateCode(validateDto, tenantId);
  }

  @Get('validate/:code')
  @GlobalAuth('scanner:use')
  @ApiOperation({
    summary: 'Quick validate code',
    description: 'Quick validation of a code via URL parameter',
  })
  @ApiParam({
    name: 'code',
    description: 'Code to validate',
    example: 'BSK0925539432LE',
  })
  @ApiResponse({
    status: 200,
    description: 'Code validation completed',
    type: CodeValidationDto,
  })
  async quickValidateCode(
    @Param('code') code: string,
    @CurrentTenant() tenantId: string,
  ): Promise<CodeValidationDto> {
    return this.scannerService.validateCode({ code }, tenantId);
  }

  @Post('session/start')
  @GlobalAuth('scanner:use')
  @ApiOperation({
    summary: 'Start scanning session',
    description: 'Start a new scanning session for continuous operations',
  })
  @ApiResponse({
    status: 201,
    description: 'Scanning session started successfully',
    type: ScannerSessionDto,
  })
  async startScanSession(
    @Body() sessionDto: StartScanSessionDto,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<ScannerSessionDto> {
    return this.scannerService.startScanSession(sessionDto, tenantId, user.id);
  }

  @Get('session/:sessionId')
  @GlobalAuth('scanner:use')
  @ApiOperation({
    summary: 'Get scanning session',
    description: 'Get details of an active or completed scanning session',
  })
  @ApiParam({
    name: 'sessionId',
    description: 'Scanning session ID',
    example: 'scan_1640995200000_abc123',
  })
  @ApiResponse({
    status: 200,
    description: 'Scanning session details retrieved',
    type: ScannerSessionDto,
  })
  @ApiNotFoundResponse({
    description: 'Scanning session not found',
  })
  async getScanSession(
    @Param('sessionId') sessionId: string,
    @CurrentTenant() tenantId: string,
  ): Promise<ScannerSessionDto | null> {
    return this.scannerService.getScanSession(sessionId, tenantId);
  }

  @Delete('session/:sessionId')
  @GlobalAuth('scanner:use')
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({
    summary: 'End scanning session',
    description: 'End an active scanning session',
  })
  @ApiParam({
    name: 'sessionId',
    description: 'Scanning session ID to end',
    example: 'scan_1640995200000_abc123',
  })
  @ApiResponse({
    status: 204,
    description: 'Scanning session ended successfully',
  })
  async endScanSession(
    @Param('sessionId') sessionId: string,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<void> {
    await this.scannerService.endScanSession(sessionId, tenantId, user.id);
  }

  @Post('camera-scan')
  @GlobalAuth('scanner:camera')
  @ApiOperation({
    summary: 'Camera scan operation',
    description: 'Perform scanning using camera input (mobile/webcam)',
  })
  @ApiResponse({
    status: 200,
    description: 'Camera scan completed',
    type: ScanResultDto,
  })
  async cameraScan(
    @Body() scanDto: SingleScanDto,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<ScanResultDto> {
    // Camera scan is essentially the same as regular scan but with different permission
    return this.scannerService.singleScan(scanDto, tenantId, user.id);
  }

  @Get('stats')
  @GlobalAuth('scanner:use')
  @ApiOperation({
    summary: 'Get scanner statistics',
    description: 'Get scanning statistics for the current user or system',
  })
  @ApiResponse({
    status: 200,
    description: 'Scanner statistics retrieved',
    schema: {
      type: 'object',
      properties: {
        totalScansToday: { type: 'number' },
        successfulScansToday: { type: 'number' },
        failedScansToday: { type: 'number' },
        totalScansThisWeek: { type: 'number' },
        averageScansPerSession: { type: 'number' },
        topScannedActions: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              action: { type: 'string' },
              count: { type: 'number' },
            },
          },
        },
        recentSessions: {
          type: 'array',
          items: { $ref: '#/components/schemas/ScannerSessionDto' },
        },
      },
    },
  })
  async getScannerStats(
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
    @Query('global') global?: boolean,
  ): Promise<any> {
    // This would be implemented to show scanning statistics
    // For now, return mock data structure
    return {
      totalScansToday: 156,
      successfulScansToday: 148,
      failedScansToday: 8,
      totalScansThisWeek: 892,
      averageScansPerSession: 24,
      topScannedActions: [
        { action: 'ADD_TO_SLIP', count: 89 },
        { action: 'CHANGE_STATUS', count: 45 },
        { action: 'VERIFY_PACKAGE', count: 22 },
      ],
      recentSessions: [],
    };
  }

  @Get('history')
  @GlobalAuth('scanner:use')
  @ApiOperation({
    summary: 'Get scan history',
    description: 'Get recent scanning history for the current user',
  })
  @ApiResponse({
    status: 200,
    description: 'Scan history retrieved',
    schema: {
      type: 'object',
      properties: {
        scans: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              code: { type: 'string' },
              action: { type: 'string' },
              success: { type: 'boolean' },
              timestamp: { type: 'string', format: 'date-time' },
              parcelDetails: { type: 'object' },
            },
          },
        },
        pagination: {
          type: 'object',
          properties: {
            page: { type: 'number' },
            limit: { type: 'number' },
            total: { type: 'number' },
          },
        },
      },
    },
  })
  async getScanHistory(
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
    @Query('page') page: number = 1,
    @Query('limit') limit: number = 50,
  ): Promise<any> {
    // This would be implemented to show recent scan history
    // For now, return empty structure
    return {
      scans: [],
      pagination: {
        page,
        limit,
        total: 0,
      },
    };
  }
}
-----------------------------------------------------------------------
--++--> src/modules/scanner/scanner.module.ts =======>
-----------------------------------------------------------------------
import { Module } from '@nestjs/common';
import { ScannerService } from './scanner.service';
import { ScannerController } from './scanner.controller';
import { PrismaModule } from '../../shared/services/prisma/prisma.module';
import { RedisModule } from '../../shared/services/redis/redis.module';
@Module({
  imports: [PrismaModule, RedisModule],
  controllers: [ScannerController],
  providers: [ScannerService],
  exports: [ScannerService],
})
export class ScannerModule {}
-----------------------------------------------------------------------
--++--> src/modules/scanner/scanner.service.ts =======>
-----------------------------------------------------------------------
import {
  Injectable,
  NotFoundException,
  BadRequestException,
  Logger,
  ConflictException,
} from '@nestjs/common';
import { PrismaService } from '../../shared/services/prisma/prisma.service';
import { RedisService } from '../../shared/services/redis/redis.service';
import {
  SingleScanDto,
  BulkScanDto,
  ValidateCodeDto,
  ScanResultDto,
  BulkScanResultDto,
  CodeValidationDto,
  ScannerSessionDto,
  StartScanSessionDto,
  ScannerAction,
  SlipType,
} from './dto/scanner.dto';
@Injectable()
export class ScannerService {
  private readonly logger = new Logger(ScannerService.name);

  constructor(
    private prisma: PrismaService,
    private redis: RedisService,
  ) {}

  /**
   * Perform a single scan operation
   */
  async singleScan(
    scanDto: SingleScanDto,
    tenantId: string,
    userId: string,
  ): Promise<ScanResultDto> {
    const {
      code,
      action,
      slipType,
      slipId,
      comment,
      newStatusCode,
      deliveryPersonId,
    } = scanDto;

    try {
      // First validate the code
      const validation = await this.validateCode(
        { code, expectedSlipType: slipType, slipId },
        tenantId,
      );

      if (!validation.isValid) {
        return {
          success: false,
          code,
          action,
          error: validation.error,
        };
      }

      // Get parcel details
      const parcel = await this.getorderByCode(code, tenantId);
      if (!parcel) {
        return {
          success: false,
          code,
          action,
          error: 'Parcel not found',
        };
      }

      // Perform the requested action
      let result: ScanResultDto;
      switch (action) {
        case ScannerAction.ADD_TO_SLIP:
          result = await this.addParcelToSlip(
            parcel,
            slipType!,
            slipId!,
            userId,
            code,
            action,
            comment,
          );
          break;
        case ScannerAction.REMOVE_FROM_SLIP:
          result = await this.removeParcelFromSlip(
            parcel,
            slipType!,
            slipId!,
            userId,
            code,
            action,
            comment,
          );
          break;
        case ScannerAction.CHANGE_STATUS:
          result = await this.changeParcelStatus(
            parcel,
            newStatusCode!,
            userId,
            code,
            action,
            comment,
          );
          break;
        case ScannerAction.VERIFY_PACKAGE:
          result = await this.verifyPackage(
            parcel,
            userId,
            code,
            action,
            comment,
          );
          break;
        case ScannerAction.ASSIGN_TO_DELIVERY:
          result = await this.assignToDeliveryPerson(
            parcel,
            deliveryPersonId!,
            userId,
            code,
            action,
            comment,
          );
          break;
        default:
          throw new BadRequestException(`Unsupported action: ${action}`);
      }

      // Log scan operation
      await this.logScanOperation(
        code,
        action,
        result.success,
        tenantId,
        userId,
        result.error,
      );

      return {
        ...result,
        code,
        action,
        scannedAt: new Date(),
        parcelDetails: {
          id: parcel.id,
          code: parcel.code,
          recipientName: parcel.recipientName,
          recipientPhone: parcel.recipientPhone,
          statusCode: parcel.parcelStatusCode,
          statusName: parcel.parcelStatus.name,
          destinationCity: parcel.destinationCity.name,
          price: Number(parcel.price),
        },
      };
    } catch (error) {
      this.logger.error(`Scan operation failed for code ${code}:`, error);

      return {
        success: false,
        code,
        action,
        error: error.message,
        scannedAt: new Date(),
      };
    }
  }

  /**
   * Perform bulk scan operations
   */
  async bulkScan(
    bulkScanDto: BulkScanDto,
    tenantId: string,
    userId: string,
  ): Promise<BulkScanResultDto> {
    const {
      codes,
      action,
      slipType,
      slipId,
      comment,
      newStatusCode,
      deliveryPersonId,
    } = bulkScanDto;

    const results: ScanResultDto[] = [];
    const errors: string[] = [];
    let successful = 0;
    let failed = 0;

    this.logger.log(`Starting bulk scan operation for ${codes.length} codes`);

    // Process each code
    for (const code of codes) {
      try {
        const singleScanDto: SingleScanDto = {
          code,
          action,
          slipType,
          slipId,
          comment,
          newStatusCode,
          deliveryPersonId,
        };

        const result = await this.singleScan(singleScanDto, tenantId, userId);
        results.push(result);

        if (result.success) {
          successful++;
        } else {
          failed++;
          errors.push(`${code}: ${result.error}`);
        }
      } catch (error) {
        failed++;
        errors.push(`${code}: ${error.message}`);
        results.push({
          success: false,
          code,
          action,
          error: error.message,
          scannedAt: new Date(),
        });
      }
    }

    const bulkResult: BulkScanResultDto = {
      successful,
      failed,
      total: codes.length,
      results,
      errors,
      processedAt: new Date(),
    };

    // Log bulk operation summary
    this.logger.log(
      `Bulk scan completed: ${successful} successful, ${failed} failed out of ${codes.length} codes`,
    );

    return bulkResult;
  }

  /**
   * Validate a code before scanning
   */
  async validateCode(
    validateDto: ValidateCodeDto,
    tenantId: string,
  ): Promise<CodeValidationDto> {
    const { code, expectedSlipType, slipId } = validateDto;

    try {
      // Check if it's an parcel code
      const parcel = await this.getorderByCode(code, tenantId);

      if (parcel) {
        const availableActions = this.getAvailableActionsForParcel(
          parcel,
          expectedSlipType,
        );

        return {
          isValid: true,
          code,
          codeType: 'PARCEL',
          message: 'Valid parcel code',
          entityDetails: {
            id: parcel.id,
            code: parcel.code,
            recipientName: parcel.recipientName,
            statusCode: parcel.parcelStatusCode,
            statusName: parcel.parcelStatus.name,
          },
          availableActions,
        };
      }

      // Check if it's a slip code (delivery slip, shipping slip, etc.)
      const slip = await this.getSlipByCode(code, tenantId);
      if (slip) {
        return {
          isValid: true,
          code,
          codeType: 'SLIP',
          message: 'Valid slip code',
          entityDetails: slip,
          availableActions: [ScannerAction.VERIFY_PACKAGE],
        };
      }

      // Code not found
      return {
        isValid: false,
        code,
        codeType: 'UNKNOWN',
        error: 'Code not found in system',
      };
    } catch (error) {
      this.logger.error(`Code validation failed for ${code}:`, error);
      return {
        isValid: false,
        code,
        codeType: 'ERROR',
        error: error.message,
      };
    }
  }

  /**
   * Start a scanning session for continuous operations
   */
  async startScanSession(
    sessionDto: StartScanSessionDto,
    tenantId: string,
    userId: string,
  ): Promise<ScannerSessionDto> {
    const sessionId = this.generateSessionId();

    const session: ScannerSessionDto = {
      sessionId,
      slipType: sessionDto.slipType,
      slipId: sessionDto.slipId,
      itemsScanned: 0,
      errorsCount: 0,
      startedAt: new Date(),
      isActive: true,
    };

    // Store session in Redis with 4 hour expiry
    await this.redis.setTenantCache(
      tenantId,
      `scan-session:${sessionId}`,
      JSON.stringify({ ...session, userId }),
      14400, // 4 hours
    );

    this.logger.log(`Started scan session ${sessionId} for user ${userId}`);

    return session;
  }

  /**
   * Get active scan session
   */
  async getScanSession(
    sessionId: string,
    tenantId: string,
  ): Promise<ScannerSessionDto | null> {
    const cached = await this.redis.getTenantCache(
      tenantId,
      `scan-session:${sessionId}`,
    );

    if (!cached) {
      return null;
    }

    const session = JSON.parse(cached);
    return {
      sessionId: session.sessionId,
      slipType: session.slipType,
      slipId: session.slipId,
      itemsScanned: session.itemsScanned,
      errorsCount: session.errorsCount,
      startedAt: new Date(session.startedAt),
      endedAt: session.endedAt ? new Date(session.endedAt) : undefined,
      isActive: session.isActive,
    };
  }

  /**
   * End a scanning session
   */
  async endScanSession(
    sessionId: string,
    tenantId: string,
    userId: string,
  ): Promise<void> {
    const session = await this.getScanSession(sessionId, tenantId);

    if (session) {
      session.isActive = false;
      session.endedAt = new Date();

      await this.redis.setTenantCache(
        tenantId,
        `scan-session:${sessionId}`,
        JSON.stringify({ ...session, userId }),
        86400, // Keep for 24 hours after ending
      );

      this.logger.log(`Ended scan session ${sessionId} for user ${userId}`);
    }
  }

  // Private helper methods

  private async getorderByCode(
    code: string,
    tenantId: string,
  ): Promise<any | null> {
    return this.prisma.parcel.findFirst({
      where: {
        OR: [{ code: code }, { trackingCode: code }],
        tenantId,
        isDeleted: false,
      },
      include: {
        parcelStatus: {
          select: { id: true, code: true, name: true, color: true },
        },
        destinationCity: {
          select: { id: true, name: true, ref: true },
        },
        pickupCity: {
          select: { id: true, name: true, ref: true },
        },
      },
    });
  }

  private async getSlipByCode(
    code: string,
    tenantId: string,
  ): Promise<any | null> {
    // Check delivery slips
    let slip = await this.prisma.deliverySlip.findFirst({
      where: { reference: code, tenantId, isDeleted: false },
    });
    if (slip) return { ...slip, type: 'DELIVERY_SLIP' };

    // Check shipping slips - cast to any to avoid type mismatch
    slip = (await this.prisma.shippingSlip.findFirst({
      where: { reference: code, tenantId, isDeleted: false },
    })) as any;
    if (slip) return { ...slip, type: 'SHIPPING_SLIP' };

    // Check distribution slips - cast to any to avoid type mismatch
    slip = (await this.prisma.distributionSlip.findFirst({
      where: { reference: code, tenantId, isDeleted: false },
    })) as any;
    if (slip) return { ...slip, type: 'DISTRIBUTION_SLIP' };

    return null;
  }

  private getAvailableActionsForParcel(
    parcel: any,
    expectedSlipType?: SlipType,
  ): ScannerAction[] {
    const actions: ScannerAction[] = [ScannerAction.VERIFY_PACKAGE];
    const status = parcel.parcelStatusCode;

    // Add actions based on parcel status and expected slip type
    if (
      expectedSlipType === SlipType.DELIVERY_SLIP &&
      status === 'NEW_PACKAGE'
    ) {
      actions.push(ScannerAction.ADD_TO_SLIP);
    }

    if (expectedSlipType === SlipType.SHIPPING_SLIP && status === 'COLLECTED') {
      actions.push(ScannerAction.ADD_TO_SLIP);
    }

    if (
      expectedSlipType === SlipType.DISTRIBUTION_SLIP &&
      ['RECEIVED', 'DISPATCHED'].includes(status)
    ) {
      actions.push(ScannerAction.ADD_TO_SLIP, ScannerAction.ASSIGN_TO_DELIVERY);
    }

    if (
      expectedSlipType === SlipType.RETURN_SLIP &&
      ['OUT_FOR_DELIVERY', 'DELIVERY_FAILED'].includes(status)
    ) {
      actions.push(ScannerAction.ADD_TO_SLIP);
    }

    // Always allow status changes for valid transitions
    actions.push(ScannerAction.CHANGE_STATUS);

    return actions;
  }

  // Update the private methods to accept and return code/action parameters

  private async addParcelToSlip(
    parcel: any,
    slipType: SlipType,
    slipId: string,
    userId: string,
    code: string,
    action: ScannerAction,
    comment?: string,
  ): Promise<ScanResultDto> {
    try {
      switch (slipType) {
        case SlipType.DELIVERY_SLIP:
          await this.addToDeliverySlip(parcel.id, slipId, userId);
          await this.updateParcelStatus(parcel.id, 'RECEIVED', userId, comment);
          return {
            success: true,
            code,
            action,
            message: 'Parcel added to delivery slip successfully',
          };

        case SlipType.SHIPPING_SLIP:
          await this.addToShippingSlip(parcel.id, slipId, userId);
          await this.updateParcelStatus(
            parcel.id,
            'DISPATCHED',
            userId,
            comment,
          );
          return {
            success: true,
            code,
            action,
            message: 'Parcel added to shipping slip successfully',
          };

        case SlipType.DISTRIBUTION_SLIP:
          await this.addToDistributionSlip(parcel.id, slipId, userId);
          await this.updateParcelStatus(
            parcel.id,
            'PUT_IN_DISTRIBUTION',
            userId,
            comment,
          );
          return {
            success: true,
            code,
            action,
            message: 'Parcel added to distribution slip successfully',
          };

        case SlipType.RETURN_SLIP:
          await this.addToReturnSlip(parcel.id, slipId, userId);
          return {
            success: true,
            code,
            action,
            message: 'Parcel added to return slip successfully',
          };

        default:
          throw new BadRequestException(`Unsupported slip type: ${slipType}`);
      }
    } catch (error) {
      this.logger.error(
        `Failed to add parcel ${parcel.code} to ${slipType}:`,
        error,
      );
      return { success: false, code, action, error: error.message };
    }
  }

  private async removeParcelFromSlip(
    parcel: any,
    slipType: SlipType,
    slipId: string,
    userId: string,
    code: string,
    action: ScannerAction,
    comment?: string,
  ): Promise<ScanResultDto> {
    try {
      switch (slipType) {
        case SlipType.DELIVERY_SLIP:
          await this.removeFromDeliverySlip(parcel.id, slipId);
          return {
            success: true,
            code,
            action,
            message: 'Parcel removed from delivery slip successfully',
          };

        case SlipType.SHIPPING_SLIP:
          await this.removeFromShippingSlip(parcel.id, slipId);
          return {
            success: true,
            code,
            action,
            message: 'Parcel removed from shipping slip successfully',
          };

        case SlipType.DISTRIBUTION_SLIP:
          await this.removeFromDistributionSlip(parcel.id, slipId);
          return {
            success: true,
            code,
            action,
            message: 'Parcel removed from distribution slip successfully',
          };

        case SlipType.RETURN_SLIP:
          await this.removeFromReturnSlip(parcel.id, slipId);
          return {
            success: true,
            code,
            action,
            message: 'Parcel removed from return slip successfully',
          };

        default:
          throw new BadRequestException(`Unsupported slip type: ${slipType}`);
      }
    } catch (error) {
      this.logger.error(
        `Failed to remove parcel ${parcel.code} from ${slipType}:`,
        error,
      );
      return { success: false, code, action, error: error.message };
    }
  }

  private async changeParcelStatus(
    parcel: any,
    newStatusCode: string,
    userId: string,
    code: string,
    action: ScannerAction,
    comment?: string,
  ): Promise<ScanResultDto> {
    try {
      await this.updateParcelStatus(parcel.id, newStatusCode, userId, comment);
      return {
        success: true,
        code,
        action,
        message: `Parcel status changed to ${newStatusCode} successfully`,
      };
    } catch (error) {
      return { success: false, code, action, error: error.message };
    }
  }

  private async verifyPackage(
    parcel: any,
    userId: string,
    code: string,
    action: ScannerAction,
    comment?: string,
  ): Promise<ScanResultDto> {
    // Just verify that the package exists and return details
    return {
      success: true,
      code,
      action,
      message: 'Package verified successfully',
    };
  }

  private async assignToDeliveryPerson(
    parcel: any,
    deliveryPersonId: string,
    userId: string,
    code: string,
    action: ScannerAction,
    comment?: string,
  ): Promise<ScanResultDto> {
    try {
      // This would be implemented when we have delivery person management
      return {
        success: true,
        code,
        action,
        message: 'Parcel assigned to delivery person successfully',
      };
    } catch (error) {
      return { success: false, code, action, error: error.message };
    }
  }

  // Slip manipulation methods
  private async addToDeliverySlip(
    parcelId: string,
    slipId: string,
    userId: string,
  ): Promise<void> {
    // Check if already exists
    const existing = await this.prisma.deliverySlipItem.findUnique({
      where: {
        deliverySlipId_parcelId: {
          deliverySlipId: slipId,
          parcelId,
        },
      },
    });

    if (existing) {
      throw new ConflictException('Parcel already in delivery slip');
    }

    await this.prisma.deliverySlipItem.create({
      data: {
        deliverySlipId: slipId,
        parcelId,
        scanned: true,
        scannedAt: new Date(),
        scannedBy: userId,
      },
    });
  }

  private async removeFromDeliverySlip(
    parcelId: string,
    slipId: string,
  ): Promise<void> {
    await this.prisma.deliverySlipItem.delete({
      where: {
        deliverySlipId_parcelId: {
          deliverySlipId: slipId,
          parcelId,
        },
      },
    });
  }

  private async addToShippingSlip(
    parcelId: string,
    slipId: string,
    userId: string,
  ): Promise<void> {
    const existing = await this.prisma.shippingSlipItem.findUnique({
      where: {
        shippingSlipId_parcelId: {
          shippingSlipId: slipId,
          parcelId,
        },
      },
    });

    if (existing) {
      throw new ConflictException('Parcel already in shipping slip');
    }

    await this.prisma.shippingSlipItem.create({
      data: {
        shippingSlipId: slipId,
        parcelId,
        scanned: true,
        scannedAt: new Date(),
        scannedBy: userId,
      },
    });
  }

  private async removeFromShippingSlip(
    parcelId: string,
    slipId: string,
  ): Promise<void> {
    await this.prisma.shippingSlipItem.delete({
      where: {
        shippingSlipId_parcelId: {
          shippingSlipId: slipId,
          parcelId,
        },
      },
    });
  }

  private async addToDistributionSlip(
    parcelId: string,
    slipId: string,
    userId: string,
  ): Promise<void> {
    const existing = await this.prisma.distributionSlipItem.findUnique({
      where: {
        distributionSlipId_parcelId: {
          distributionSlipId: slipId,
          parcelId,
        },
      },
    });

    if (existing) {
      throw new ConflictException('Parcel already in distribution slip');
    }

    await this.prisma.distributionSlipItem.create({
      data: {
        distributionSlipId: slipId,
        parcelId,
        scanned: true,
        scannedAt: new Date(),
        scannedBy: userId,
      },
    });
  }

  private async removeFromDistributionSlip(
    parcelId: string,
    slipId: string,
  ): Promise<void> {
    await this.prisma.distributionSlipItem.delete({
      where: {
        distributionSlipId_parcelId: {
          distributionSlipId: slipId,
          parcelId,
        },
      },
    });
  }

  private async addToReturnSlip(
    parcelId: string,
    slipId: string,
    userId: string,
  ): Promise<void> {
    const existing = await this.prisma.returnSlipItem.findUnique({
      where: {
        returnSlipId_parcelId: {
          returnSlipId: slipId,
          parcelId,
        },
      },
    });

    if (existing) {
      throw new ConflictException('Parcel already in return slip');
    }

    await this.prisma.returnSlipItem.create({
      data: {
        returnSlipId: slipId,
        parcelId,
        scanned: true,
        scannedAt: new Date(),
        scannedBy: userId,
      },
    });
  }

  private async removeFromReturnSlip(
    parcelId: string,
    slipId: string,
  ): Promise<void> {
    await this.prisma.returnSlipItem.delete({
      where: {
        returnSlipId_parcelId: {
          returnSlipId: slipId,
          parcelId,
        },
      },
    });
  }

  private async updateParcelStatus(
    parcelId: string,
    newStatusCode: string,
    userId: string,
    comment?: string,
  ): Promise<void> {
    // Get the new status
    const newStatus = await this.prisma.parcelStatus.findFirst({
      where: {
        code: newStatusCode,
        isDeleted: false,
        status: true,
      },
    });

    if (!newStatus) {
      throw new BadRequestException(`Invalid status code: ${newStatusCode}`);
    }

    // Update parcel
    await this.prisma.parcel.update({
      where: { id: parcelId },
      data: {
        parcelStatusId: newStatus.id,
        parcelStatusCode: newStatus.code,
        updatedBy: userId,
      },
    });

    // Create history entry
    await this.prisma.parcelStatusHistory.create({
      data: {
        parcelId,
        parcelStatusId: newStatus.id,
        statusCode: newStatus.code,
        comment: comment || 'Status changed via scanner',
        changedBy: userId,
      },
    });
  }

  private async logScanOperation(
    code: string,
    action: ScannerAction,
    success: boolean,
    tenantId: string,
    userId: string,
    error?: string,
  ): Promise<void> {
    // You might want to create a separate ScanLog table for this
    // For now, just log to application logs
    this.logger.log(
      `Scan: ${code} | Action: ${action} | Success: ${success} | User: ${userId}${error ? ` | Error: ${error}` : ''}`,
    );
  }

  private generateSessionId(): string {
    return `scan_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;
  }
}
===============================================================================================================
===============================================================================================================
The Subject is :
- READ ALL THIS PROMPT I GIVE YOU.
- I Create A new parcels-service in my nest js project.
- So i want you help me and give me delivery-slips module in front with all pages and crud pages,
And all component and lib and store we will need to create this module in front.
_ Give me each file with page location.
===============================================================================================================
===============================================================================================================