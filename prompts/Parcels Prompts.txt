===============================================================================================================
My Next js front project structure:
===============================================================================================================
App Folder :
-----------------------------------------------------------------------
--++--> app/[locale]/(protected)/dashboard/page.tsx
--++--> app/[locale]/(protected)/profile/page.tsx
--++--> app/[locale]/(protected)/roles/page.tsx
-----------------------------------------------------------------------
--++--> app/[locale]/(protected)/users/page.tsx =======>
-----------------------------------------------------------------------
"use client";
import React from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Icon } from "@/components/ui/icon";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Badge } from "@/components/ui/badge";
import { Link } from "@/i18n/routing";
import UsersTable from "@/components/users/users-table";
import { useAuthStore } from "@/lib/stores/auth/auth.store";
import { ProtectedRoute } from "@/components/route/protected-route";
import { USER_PERMISSIONS } from "@/lib/constants/auth";
const UsersPageContent = () => {
  const { hasPermission, user, hasAnyPermission } = useAuthStore();

  // Check individual permissions
  const canViewUsers = hasPermission(USER_PERMISSIONS.READ_USERS);
  const canCreateUsers = hasPermission(USER_PERMISSIONS.CREATE_USER);
  const canUpdateUsers = hasPermission(USER_PERMISSIONS.UPDATE_USER);
  const canDeleteUsers = hasPermission(USER_PERMISSIONS.DELETE_USER);
  const canManageRoles = hasPermission(USER_PERMISSIONS.MANAGE_USER_ROLES);
  const canViewAnalytics = hasPermission(USER_PERMISSIONS.READ_USER_ANALYTICS);

  // Check if user has any user management permissions
  const hasAnyUserPermissions = hasAnyPermission([
    USER_PERMISSIONS.READ_USERS,
    USER_PERMISSIONS.CREATE_USER,
    USER_PERMISSIONS.UPDATE_USER,
    USER_PERMISSIONS.DELETE_USER,
    USER_PERMISSIONS.MANAGE_USER_ROLES,
    USER_PERMISSIONS.READ_USER_ANALYTICS,
  ]);

  // Define permission-based features
  const availableFeatures = [
    {
      id: "view",
      label: "View Users",
      enabled: canViewUsers,
      icon: "heroicons:eye",
      description: "Browse and search users",
    },
    {
      id: "create",
      label: "Create Users",
      enabled: canCreateUsers,
      icon: "heroicons:plus",
      description: "Add new users to the system",
    },
    {
      id: "update",
      label: "Edit Users",
      enabled: canUpdateUsers,
      icon: "heroicons:pencil",
      description: "Modify user information",
    },
    {
      id: "delete",
      label: "Delete Users",
      enabled: canDeleteUsers,
      icon: "heroicons:trash",
      description: "Remove users from the system",
    },
    {
      id: "roles",
      label: "Manage Roles",
      enabled: canManageRoles,
      icon: "heroicons:shield-check",
      description: "Assign and modify user roles",
    },
    {
      id: "analytics",
      label: "View Analytics",
      enabled: canViewAnalytics,
      icon: "heroicons:chart-bar",
      description: "Access user analytics and reports",
    },
  ];

  const enabledFeatures = availableFeatures.filter(
    (feature) => feature.enabled
  );
  const disabledFeatures = availableFeatures.filter(
    (feature) => !feature.enabled
  );

  // Show error if user has no permissions at all
  if (!hasAnyUserPermissions) {
    return (
      <div className="space-y-6">
        <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
          <div>
            <h1 className="text-2xl font-bold text-default-900">
              Users Management
            </h1>
            <p className="text-default-600">
              Manage your users, roles, and permissions
            </p>
          </div>
        </div>

        <Alert color="destructive">
          <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
          <AlertDescription>
            <div className="space-y-2">
              <div className="font-medium">Access Denied</div>
              <div>
                You don't have permission to access user management features.
                Please contact your administrator to request access.
              </div>
              <div className="text-sm">
                <strong>Your user type:</strong> {user?.userType || "Unknown"}
              </div>
            </div>
          </AlertDescription>
        </Alert>

        {/* Contact Support Card */}
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Icon icon="heroicons:question-mark-circle" className="w-5 h-5" />
              Need Access?
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <p className="text-sm text-muted-foreground">
              If you believe you should have access to user management features,
              please contact your system administrator or support team.
            </p>
            <div className="flex gap-2">
              <Button variant="outline" size="md">
                <Icon
                  icon="heroicons:chat-bubble-left-right"
                  className="w-4 h-4 mr-2"
                />
                Contact Support
              </Button>
              <Link href="/dashboard">
                <Button variant="outline" size="md">
                  <Icon icon="heroicons:home" className="w-4 h-4 mr-2" />
                  Return to Dashboard
                </Button>
              </Link>
            </div>
          </CardContent>
        </Card>
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
        <div>
          <h1 className="text-2xl font-bold text-default-900">
            Users Management
          </h1>
          <p className="text-default-600">
            Manage your users, roles, and permissions
          </p>
        </div>

        <div className="flex items-center gap-2">
          {canViewAnalytics && (
            <Link href="/users/analytics">
              <Button variant="outline" size="md">
                <Icon icon="heroicons:chart-bar" className="w-4 h-4 mr-2" />
                Analytics
              </Button>
            </Link>
          )}

          {canCreateUsers && (
            <Link href="/users/create">
              <Button>
                <Icon icon="heroicons:plus" className="w-4 h-4 mr-2" />
                Create User
              </Button>
            </Link>
          )}
        </div>
      </div>

      {/* Permissions Overview */}
      {process.env.NODE_ENV === "development" && (
        <Alert color="info" variant="soft">
          <Icon icon="heroicons:information-circle" className="h-4 w-4" />
          <AlertDescription>
            <div className="space-y-2">
              <div className="font-medium">
                Development Info - Your Permissions
              </div>
              <div className="flex flex-wrap gap-1">
                {enabledFeatures.map((feature) => (
                  <Badge key={feature.id} color="info" className="text-xs">
                    <Icon icon={feature.icon} className="w-3 h-3 mr-1" />
                    {feature.label}
                  </Badge>
                ))}
                {disabledFeatures.map((feature) => (
                  <Badge
                    key={feature.id}
                    color="secondary"
                    className="text-xs opacity-50"
                  >
                    <Icon icon={feature.icon} className="w-3 h-3 mr-1" />
                    {feature.label}
                  </Badge>
                ))}
              </div>
            </div>
          </AlertDescription>
        </Alert>
      )}

      {/* Limited Access Warning */}
      {hasAnyUserPermissions &&
        (!canViewUsers || enabledFeatures.length < 3) && (
          <Alert color="warning" variant="soft">
            <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
            <AlertDescription>
              <div className="space-y-1">
                <div className="font-medium">Limited Access</div>
                <div className="text-sm">
                  You have restricted access to user management features. Some
                  actions may not be available.
                </div>
                <div className="text-xs mt-2">
                  <strong>Available:</strong>{" "}
                  {enabledFeatures.map((f) => f.label).join(", ")}
                </div>
              </div>
            </AlertDescription>
          </Alert>
        )}

      {/* Users Table */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center justify-between">
            <span>All Users</span>
            {canViewUsers && (
              <Badge color="secondary" className="text-xs">
                <Icon icon="heroicons:eye" className="w-3 h-3 mr-1" />
                View Access
              </Badge>
            )}
          </CardTitle>
        </CardHeader>
        <CardContent className="p-0">
          {canViewUsers ? (
            <UsersTable />
          ) : (
            <div className="p-8 text-center">
              <div className="space-y-4">
                <Icon
                  icon="heroicons:lock-closed"
                  className="w-12 h-12 text-muted-foreground mx-auto"
                />
                <div>
                  <h3 className="font-medium text-default-900">
                    No View Permission
                  </h3>
                  <p className="text-sm text-muted-foreground mt-1">
                    You don't have permission to view the users list.
                  </p>
                </div>
                {canCreateUsers && (
                  <div>
                    <p className="text-xs text-muted-foreground mb-3">
                      You can still create new users:
                    </p>
                    <Link href="/users/create">
                      <Button size="md">
                        <Icon icon="heroicons:plus" className="w-4 h-4 mr-2" />
                        Create User
                      </Button>
                    </Link>
                  </div>
                )}
              </div>
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
};
// Main component wrapped with ProtectedRoute
const UsersPage = () => {
  return (
    <ProtectedRoute
      requiredPermissions={[USER_PERMISSIONS.READ_USERS]}
      requiredAccessLevel="LIMITED"
      allowedAccountStatuses={["ACTIVE"]}
    >
      <UsersPageContent />
    </ProtectedRoute>
  );
};
export default UsersPage;
-----------------------------------------------------------------------
--++--> app/[locale]/(protected)/users/[id]/page.tsx =======>
-----------------------------------------------------------------------
"use client";
import React, { useState, useEffect } from "react";
import { useRouter, useParams } from "next/navigation";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Icon } from "@/components/ui/icon";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Alert, AlertDescription } from "@/components/ui/alert";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Link } from "@/i18n/routing";
import { ProtectedRoute } from "@/components/route/protected-route";
import { USER_TYPES, PERMISSIONS } from "@/lib/constants/auth";
import { usersApiClient } from "@/lib/api/clients/auth/users.client";
import { useAuthStore } from "@/lib/stores/auth/auth.store";
import { toast } from "sonner";
// Status configurations
const userTypeConfig = {
  ADMIN: {
    label: "Admin",
    color: "destructive" as const,
    icon: "heroicons:shield-check",
  },
  MANAGER: {
    label: "Manager",
    color: "warning" as const,
    icon: "heroicons:user-group",
  },
  SUPPORT: {
    label: "Support",
    color: "info" as const,
    icon: "heroicons:chat-bubble-left-right",
  },
  SELLER: {
    label: "Seller",
    color: "success" as const,
    icon: "heroicons:currency-dollar",
  },
  LIVREUR: {
    label: "Delivery",
    color: "secondary" as const,
    icon: "heroicons:truck",
  },
  CUSTOMER: {
    label: "Customer",
    color: "primary" as const,
    icon: "heroicons:user",
  },
  BUYER: {
    label: "Buyer",
    color: "success" as const,
    icon: "heroicons:shopping-cart",
  },
  VENDOR: {
    label: "Vendor",
    color: "warning" as const,
    icon: "heroicons:building-storefront",
  },
  WAREHOUSE: {
    label: "Warehouse",
    color: "secondary" as const,
    icon: "heroicons:building-office-2",
  },
  DISPATCHER: {
    label: "Dispatcher",
    color: "info" as const,
    icon: "heroicons:map",
  },
};
const accountStatusConfig = {
  PENDING: {
    label: "Pending Approval",
    color: "warning" as const,
    icon: "heroicons:clock",
    description: "Awaiting admin approval",
  },
  INACTIVE: {
    label: "Inactive",
    color: "secondary" as const,
    icon: "heroicons:pause",
    description: "Account is inactive",
  },
  PENDING_VALIDATION: {
    label: "Pending Validation",
    color: "info" as const,
    icon: "heroicons:document-check",
    description: "Profile awaiting validation",
  },
  ACTIVE: {
    label: "Active",
    color: "success" as const,
    icon: "heroicons:check-circle",
    description: "Account is active",
  },
  REJECTED: {
    label: "Rejected",
    color: "destructive" as const,
    icon: "heroicons:x-circle",
    description: "Account was rejected",
  },
  SUSPENDED: {
    label: "Suspended",
    color: "destructive" as const,
    icon: "heroicons:no-symbol",
    description: "Account is suspended",
  },
};
const validationStatusConfig = {
  PENDING: {
    label: "Pending",
    color: "warning" as const,
    icon: "heroicons:clock",
  },
  VALIDATED: {
    label: "Validated",
    color: "success" as const,
    icon: "heroicons:shield-check",
  },
  REJECTED: {
    label: "Rejected",
    color: "destructive" as const,
    icon: "heroicons:shield-exclamation",
  },
};
const formatDate = (dateString: string) => {
  const date = new Date(dateString);
  return date.toLocaleDateString("en-US", {
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: "2-digit",
    minute: "2-digit",
  });
};
const UserDetailsPage = () => {
  const router = useRouter();
  const params = useParams();
  const userId = params?.id as string;
  const { hasPermission } = useAuthStore();

  const [loading, setLoading] = useState(true);
  const [user, setUser] = useState<any>(null);
  const [userActivity, setUserActivity] = useState<any[]>([]);
  const [permissions, setPermissions] = useState<any>(null);
  const [actionLoading, setActionLoading] = useState(false);
  const [deleteDialog, setDeleteDialog] = useState(false);

  const canUpdateUsers = hasPermission(PERMISSIONS.UPDATE_USER);
  const canDeleteUsers = hasPermission(PERMISSIONS.DELETE_USER);
  const canApproveUsers = hasPermission("users:approve");
  const canValidateUsers = hasPermission("users:validate");

  // Fetch user data
  useEffect(() => {
    const fetchUserData = async () => {
      if (!userId) return;

      try {
        setLoading(true);

        // Fetch user details
        const userResult = await usersApiClient.getUserById(userId);
        if (userResult.success) {
          setUser(userResult.data);
        } else {
          toast.error("Failed to fetch user data");
          router.push("/users");
          return;
        }

        // Fetch user permissions (no conditional check needed since this is admin-only)
        try {
          const permissionsResult = await usersApiClient.getUserPermissions(
            userId
          );
          if (permissionsResult.success) {
            setPermissions(permissionsResult.data);
          }
        } catch (error) {
          console.error("Error fetching permissions:", error);
        }

        // Fetch user activity (no conditional check needed since this is admin-only)
        try {
          const activityResult: any = await usersApiClient.getUserActivity(
            userId,
            10
          );
          if (activityResult.success) {
            setUserActivity(activityResult.data);
          }
        } catch (error) {
          console.error("Error fetching activity:", error);
        }
      } catch (error) {
        console.error("Error fetching user data:", error);
        toast.error("An error occurred while fetching user data");
        router.push("/users");
      } finally {
        setLoading(false);
      }
    };

    fetchUserData();
  }, [userId, router]);

  // Handle user actions
  const handleApproveRegistration = async () => {
    setActionLoading(true);
    try {
      const result = await usersApiClient.approveRegistration(userId, {
        approve: true,
        message: "Your registration has been approved!",
      });
      if (result.success) {
        setUser(result.data);
        toast.success("Registration approved successfully");
      } else {
        toast.error(result.error?.message || "Failed to approve registration");
      }
    } catch (error) {
      toast.error("An error occurred");
    } finally {
      setActionLoading(false);
    }
  };

  const handleValidateProfile = async () => {
    setActionLoading(true);
    try {
      const result = await usersApiClient.validateProfile(userId, {
        action: "VALIDATE",
        notes: "Profile validated successfully",
      });
      if (result.success) {
        setUser(result.data);
        toast.success("Profile validated successfully");
      } else {
        toast.error(result.error?.message || "Failed to validate profile");
      }
    } catch (error) {
      toast.error("An error occurred");
    } finally {
      setActionLoading(false);
    }
  };

  const handleSuspendUser = async () => {
    setActionLoading(true);
    try {
      const result = await usersApiClient.suspendUser(userId);
      if (result.success) {
        setUser(result.data);
        toast.success("User suspended successfully");
      } else {
        toast.error(result.error?.message || "Failed to suspend user");
      }
    } catch (error) {
      toast.error("An error occurred");
    } finally {
      setActionLoading(false);
    }
  };

  const handleReactivateUser = async () => {
    setActionLoading(true);
    try {
      const result = await usersApiClient.reactivateUser(userId);
      if (result.success) {
        setUser(result.data);
        toast.success("User reactivated successfully");
      } else {
        toast.error(result.error?.message || "Failed to reactivate user");
      }
    } catch (error) {
      toast.error("An error occurred");
    } finally {
      setActionLoading(false);
    }
  };

  const handleDeleteUser = async () => {
    try {
      const result = await usersApiClient.deleteUser(userId);
      if (result.success) {
        toast.success("User deleted successfully");
        router.push("/users");
      } else {
        toast.error(result.error?.message || "Failed to delete user");
      }
    } catch (error) {
      toast.error("An error occurred");
    } finally {
      setDeleteDialog(false);
    }
  };

  if (loading) {
    return (
      <ProtectedRoute
        requiredUserTypes={[USER_TYPES.ADMIN]}
        requiredPermissions={[PERMISSIONS.READ_USERS]}
        requiredAccessLevel="FULL"
      >
        <div className="container mx-auto py-6">
          <Card>
            <CardContent className="p-8">
              <div className="flex items-center justify-center space-x-2">
                <Icon
                  icon="heroicons:arrow-path"
                  className="w-5 h-5 animate-spin"
                />
                <span>Loading user details...</span>
              </div>
            </CardContent>
          </Card>
        </div>
      </ProtectedRoute>
    );
  }

  if (!user) {
    return (
      <ProtectedRoute
        requiredUserTypes={[USER_TYPES.ADMIN]}
        requiredPermissions={[PERMISSIONS.READ_USERS]}
        requiredAccessLevel="FULL"
      >
        <div className="container mx-auto py-8">
          <Alert color="destructive">
            <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
            <AlertDescription>
              User not found or has been deleted.
            </AlertDescription>
          </Alert>
        </div>
      </ProtectedRoute>
    );
  }

  const userTypeInfo =
    userTypeConfig[user.userType as keyof typeof userTypeConfig];
  const accountStatusInfo =
    accountStatusConfig[user.accountStatus as keyof typeof accountStatusConfig];
  const validationStatusInfo =
    validationStatusConfig[
      user.validationStatus as keyof typeof validationStatusConfig
    ];

  return (
    <ProtectedRoute
      requiredUserTypes={[USER_TYPES.ADMIN]}
      requiredPermissions={[PERMISSIONS.READ_USERS]}
      requiredAccessLevel="FULL"
    >
      <div className="container mx-auto py-6 space-y-6">
        {/* Header */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-4">
            <Avatar size="xl">
              <AvatarImage
                src={user.profile?.profilePhoto || user.avatar}
                alt={user.name}
              />
              <AvatarFallback className="text-lg">
                {user.name
                  ?.split(" ")
                  .map((n: string) => n[0])
                  .join("")
                  .toUpperCase() || "U"}
              </AvatarFallback>
            </Avatar>
            <div>
              <div className="flex items-center gap-2">
                <h1 className="text-3xl font-bold text-default-900">
                  {user.name}
                </h1>
                {user.validationStatus === "VALIDATED" && (
                  <TooltipProvider>
                    <Tooltip>
                      <TooltipTrigger>
                        <Icon
                          icon="heroicons:shield-check"
                          className="w-6 h-6 text-blue-500"
                        />
                      </TooltipTrigger>
                      <TooltipContent>
                        <p>Verified Profile</p>
                      </TooltipContent>
                    </Tooltip>
                  </TooltipProvider>
                )}
              </div>
              <p className="text-lg text-default-600">{user.email}</p>
              <div className="flex items-center gap-2 mt-2">
                <Badge color={userTypeInfo?.color}>
                  <Icon icon={userTypeInfo?.icon} className="w-3 h-3 mr-1" />
                  {userTypeInfo?.label}
                </Badge>
                <Badge color={accountStatusInfo?.color}>
                  <Icon
                    icon={accountStatusInfo?.icon}
                    className="w-3 h-3 mr-1"
                  />
                  {accountStatusInfo?.label}
                </Badge>
                <Badge color={validationStatusInfo?.color}>
                  <Icon
                    icon={validationStatusInfo?.icon}
                    className="w-3 h-3 mr-1"
                  />
                  {validationStatusInfo?.label}
                </Badge>
              </div>
            </div>
          </div>

          <div className="flex items-center gap-2">
            {/* Admin Actions Dropdown */}
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button disabled={actionLoading}>
                  <Icon
                    icon="heroicons:ellipsis-horizontal"
                    className="w-4 h-4 mr-2"
                  />
                  Admin Actions
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end">
                {canUpdateUsers && (
                  <DropdownMenuItem asChild>
                    <Link href={`/users/${userId}/edit`}>
                      <Icon
                        icon="heroicons:pencil-square"
                        className="mr-2 h-4 w-4"
                      />
                      Edit User
                    </Link>
                  </DropdownMenuItem>
                )}

                {/* Admin-specific actions */}
                {canApproveUsers && user.accountStatus === "PENDING" && (
                  <>
                    <DropdownMenuSeparator />
                    <DropdownMenuItem onClick={handleApproveRegistration}>
                      <Icon
                        icon="heroicons:check"
                        className="mr-2 h-4 w-4 text-green-600"
                      />
                      Approve Registration
                    </DropdownMenuItem>
                  </>
                )}

                {canValidateUsers &&
                  user.accountStatus === "PENDING_VALIDATION" && (
                    <>
                      <DropdownMenuSeparator />
                      <DropdownMenuItem onClick={handleValidateProfile}>
                        <Icon
                          icon="heroicons:shield-check"
                          className="mr-2 h-4 w-4 text-blue-600"
                        />
                        Validate Profile
                      </DropdownMenuItem>
                    </>
                  )}

                {canUpdateUsers && (
                  <>
                    <DropdownMenuSeparator />
                    {user.accountStatus === "SUSPENDED" ? (
                      <DropdownMenuItem onClick={handleReactivateUser}>
                        <Icon
                          icon="heroicons:play"
                          className="mr-2 h-4 w-4 text-green-600"
                        />
                        Reactivate User
                      </DropdownMenuItem>
                    ) : (
                      user.accountStatus === "ACTIVE" && (
                        <DropdownMenuItem onClick={handleSuspendUser}>
                          <Icon
                            icon="heroicons:pause"
                            className="mr-2 h-4 w-4 text-orange-600"
                          />
                          Suspend User
                        </DropdownMenuItem>
                      )
                    )}
                  </>
                )}

                {canDeleteUsers && (
                  <>
                    <DropdownMenuSeparator />
                    <DropdownMenuItem
                      className="text-red-600 focus:text-red-600"
                      onClick={() => setDeleteDialog(true)}
                    >
                      <Icon icon="heroicons:trash" className="mr-2 h-4 w-4" />
                      Delete User
                    </DropdownMenuItem>
                  </>
                )}
              </DropdownMenuContent>
            </DropdownMenu>

            <Link href="/users">
              <Button variant="outline">
                <Icon icon="heroicons:arrow-left" className="w-4 h-4 mr-2" />
                Back to Users
              </Button>
            </Link>
          </div>
        </div>

        {/* Status Alert */}
        {user.accountStatus !== "ACTIVE" && (
          <Alert color={accountStatusInfo?.color} variant="soft">
            <Icon icon={accountStatusInfo?.icon} className="h-4 w-4" />
            <AlertDescription>
              <strong>{accountStatusInfo?.label}:</strong>{" "}
              {accountStatusInfo?.description}
              {user.validationNotes && (
                <span className="block mt-1 text-sm">
                  {user.validationNotes}
                </span>
              )}
            </AlertDescription>
          </Alert>
        )}

        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          {/* Main Content */}
          <div className="lg:col-span-2 space-y-6">
            {/* Personal Information */}
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:user" className="w-5 h-5" />
                  Personal Information
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <h4 className="font-medium text-default-900">Full Name</h4>
                    <p className="text-default-600">
                      {user.name || "Not provided"}
                    </p>
                  </div>
                  <div>
                    <h4 className="font-medium text-default-900">Email</h4>
                    <p className="text-default-600">{user.email}</p>
                  </div>
                  <div>
                    <h4 className="font-medium text-default-900">Phone</h4>
                    <p className="text-default-600">
                      {user.phone || "Not provided"}
                    </p>
                  </div>
                  <div>
                    <h4 className="font-medium text-default-900">City</h4>
                    <p className="text-default-600">
                      {user.city || "Not provided"}
                    </p>
                  </div>
                  {user.profile?.address && (
                    <div className="md:col-span-2">
                      <h4 className="font-medium text-default-900">Address</h4>
                      <p className="text-default-600">{user.profile.address}</p>
                    </div>
                  )}
                  {user.profile?.cin && (
                    <div>
                      <h4 className="font-medium text-default-900">CIN</h4>
                      <p className="text-default-600">{user.profile.cin}</p>
                    </div>
                  )}
                  {user.profile?.department && (
                    <div>
                      <h4 className="font-medium text-default-900">
                        Department
                      </h4>
                      <p className="text-default-600">
                        {user.profile.department}
                      </p>
                    </div>
                  )}
                </div>

                {user.profile?.notes && (
                  <div>
                    <h4 className="font-medium text-default-900">Notes</h4>
                    <p className="text-default-600">{user.profile.notes}</p>
                  </div>
                )}
              </CardContent>
            </Card>

            {/* Role & Permissions */}
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:identification" className="w-5 h-5" />
                  Role & Permissions
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <h4 className="font-medium text-default-900">User Type</h4>
                    <div className="flex items-center gap-2 mt-1">
                      <Badge color={userTypeInfo?.color}>
                        <Icon
                          icon={userTypeInfo?.icon}
                          className="w-3 h-3 mr-1"
                        />
                        {userTypeInfo?.label}
                      </Badge>
                    </div>
                  </div>
                  <div>
                    <h4 className="font-medium text-default-900">Role</h4>
                    <p className="text-default-600">
                      {user.role?.name || "No role assigned"}
                    </p>
                    {user.role?.description && (
                      <p className="text-sm text-default-500">
                        {user.role.description}
                      </p>
                    )}
                  </div>
                </div>

                {permissions && permissions.permissions && (
                  <div>
                    <h4 className="font-medium text-default-900 mb-2">
                      Permissions
                    </h4>
                    <div className="flex flex-wrap gap-1">
                      {permissions.permissions.map((permission: string) => (
                        <Badge key={permission} className="outline text-xs">
                          {permission}
                        </Badge>
                      ))}
                    </div>
                  </div>
                )}
              </CardContent>
            </Card>

            {/* Activity Log */}
            {userActivity.length > 0 && (
              <Card>
                <CardHeader>
                  <CardTitle className="flex items-center gap-2">
                    <Icon icon="heroicons:clock" className="w-5 h-5" />
                    Recent Activity
                  </CardTitle>
                </CardHeader>
                <CardContent>
                  <div className="space-y-3">
                    {userActivity.map((activity) => (
                      <div
                        key={activity.id}
                        className="flex items-start gap-3 p-3 bg-default-50 rounded-lg"
                      >
                        <div className="w-2 h-2 bg-primary rounded-full mt-2"></div>
                        <div className="flex-1">
                          <p className="text-sm font-medium">
                            {activity.action}
                          </p>
                          <p className="text-xs text-default-500">
                            {formatDate(activity.timestamp)} by{" "}
                            {activity.performedBy?.name}
                          </p>
                          {activity.details && (
                            <p className="text-xs text-default-600 mt-1">
                              {activity.details}
                            </p>
                          )}
                        </div>
                      </div>
                    ))}
                  </div>
                </CardContent>
              </Card>
            )}
          </div>

          {/* Sidebar */}
          <div className="space-y-6">
            {/* Account Status */}
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon
                    icon="heroicons:information-circle"
                    className="w-5 h-5"
                  />
                  Account Status
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div>
                  <h4 className="font-medium text-default-900">
                    Account Status
                  </h4>
                  <div className="flex items-center gap-2 mt-1">
                    <Badge color={accountStatusInfo?.color}>
                      <Icon
                        icon={accountStatusInfo?.icon}
                        className="w-3 h-3 mr-1"
                      />
                      {accountStatusInfo?.label}
                    </Badge>
                  </div>
                </div>

                <div>
                  <h4 className="font-medium text-default-900">
                    Validation Status
                  </h4>
                  <div className="flex items-center gap-2 mt-1">
                    <Badge color={validationStatusInfo?.color}>
                      <Icon
                        icon={validationStatusInfo?.icon}
                        className="w-3 h-3 mr-1"
                      />
                      {validationStatusInfo?.label}
                    </Badge>
                  </div>
                </div>

                <div>
                  <h4 className="font-medium text-default-900">
                    Profile Completion
                  </h4>
                  <div className="flex items-center gap-2 mt-1">
                    <Badge
                      color={user.profileCompleted ? "success" : "warning"}
                    >
                      {user.profileCompleted ? "Complete" : "Incomplete"}
                    </Badge>
                  </div>
                </div>

                <div>
                  <h4 className="font-medium text-default-900">
                    Access Status
                  </h4>
                  <div className="flex items-center gap-2 mt-1">
                    <Badge color={user.isActive ? "success" : "destructive"}>
                      {user.isActive ? "Active" : "Inactive"}
                    </Badge>
                  </div>
                </div>
              </CardContent>
            </Card>

            {/* Account Timeline */}
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:calendar" className="w-5 h-5" />
                  Account Timeline
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div>
                  <h4 className="font-medium text-default-900">Created</h4>
                  <p className="text-sm text-default-600">
                    {formatDate(user.createdAt)}
                  </p>
                  {user.createdBy && (
                    <p className="text-xs text-default-500">
                      by {user.createdBy.name}
                    </p>
                  )}
                </div>

                <div>
                  <h4 className="font-medium text-default-900">Last Updated</h4>
                  <p className="text-sm text-default-600">
                    {formatDate(user.updatedAt)}
                  </p>
                </div>

                {user.validatedAt && (
                  <div>
                    <h4 className="font-medium text-default-900">Validated</h4>
                    <p className="text-sm text-default-600">
                      {formatDate(user.validatedAt)}
                    </p>
                    {user.validatedBy && (
                      <p className="text-xs text-default-500">
                        by {user.validatedBy.name}
                      </p>
                    )}
                  </div>
                )}

                {user.lastLogin && (
                  <div>
                    <h4 className="font-medium text-default-900">Last Login</h4>
                    <p className="text-sm text-default-600">
                      {formatDate(user.lastLogin)}
                    </p>
                  </div>
                )}
              </CardContent>
            </Card>

            {/* Tenant Information */}
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:building-office" className="w-5 h-5" />
                  Organization
                </CardTitle>
              </CardHeader>
              <CardContent>
                <div>
                  <h4 className="font-medium text-default-900">
                    {user.tenant?.name}
                  </h4>
                  <p className="text-sm text-default-500">
                    {user.tenant?.slug}
                  </p>
                </div>
              </CardContent>
            </Card>
          </div>
        </div>

        {/* Delete Confirmation Dialog */}
        <AlertDialog open={deleteDialog} onOpenChange={setDeleteDialog}>
          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>Delete User</AlertDialogTitle>
              <AlertDialogDescription>
                Are you sure you want to delete <strong>{user.name}</strong>?
                This action cannot be undone and will permanently remove all
                user data.
              </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
              <AlertDialogCancel>Cancel</AlertDialogCancel>
              <AlertDialogAction
                onClick={handleDeleteUser}
                className="bg-red-600 text-white hover:bg-red-700"
              >
                Delete User
              </AlertDialogAction>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>
      </div>
    </ProtectedRoute>
  );
};
export default UserDetailsPage;
-----------------------------------------------------------------------
--++--> app/[locale]/(protected)/users/[id]/edit/page.tsx =======>
-----------------------------------------------------------------------
"use client";
import React, { useState, useEffect } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { useRouter, useParams } from "next/navigation";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";
import { Badge } from "@/components/ui/badge";
import { Icon } from "@/components/ui/icon";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Alert, AlertDescription } from "@/components/ui/alert";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Link } from "@/i18n/routing";
import { ProtectedRoute } from "@/components/route/protected-route";
import { USER_TYPES, PERMISSIONS } from "@/lib/constants/auth";
import { usersApiClient } from "@/lib/api/clients/auth/users.client";
import { useAuthStore } from "@/lib/stores/auth/auth.store";
import { toast } from "sonner";
import { cn } from "@/lib/utils/ui.utils";
// Form schema for updating user
const updateUserSchema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters"),
  email: z.string().email("Please enter a valid email address"),
  userType: z.enum([
    "ADMIN",
    "MANAGER",
    "SUPPORT",
    "SELLER",
    "LIVREUR",
    "CUSTOMER",
    "BUYER",
    "VENDOR",
    "WAREHOUSE",
    "DISPATCHER",
  ]),
  phone: z.string().optional(),
  city: z.string().optional(),
  roleId: z.string().optional(),
  profile: z
    .object({
      department: z.string().optional(),
      notes: z.string().optional(),
      address: z.string().optional(),
      cin: z.string().optional(),
    })
    .optional(),
  accountStatus: z
    .enum([
      "PENDING",
      "INACTIVE",
      "PENDING_VALIDATION",
      "ACTIVE",
      "REJECTED",
      "SUSPENDED",
    ])
    .optional(),
  validationStatus: z.enum(["PENDING", "VALIDATED", "REJECTED"]).optional(),
  isActive: z.boolean().default(true),
});
type UpdateUserFormData = z.infer<typeof updateUserSchema>;
// User type configurations
const userTypeConfig = {
  ADMIN: {
    label: "Admin",
    color: "destructive" as const,
    icon: "heroicons:shield-check",
  },
  MANAGER: {
    label: "Manager",
    color: "warning" as const,
    icon: "heroicons:user-group",
  },
  SUPPORT: {
    label: "Support",
    color: "info" as const,
    icon: "heroicons:chat-bubble-left-right",
  },
  SELLER: {
    label: "Seller",
    color: "success" as const,
    icon: "heroicons:currency-dollar",
  },
  LIVREUR: {
    label: "Delivery",
    color: "secondary" as const,
    icon: "heroicons:truck",
  },
  CUSTOMER: {
    label: "Customer",
    color: "primary" as const,
    icon: "heroicons:user",
  },
  BUYER: {
    label: "Buyer",
    color: "success" as const,
    icon: "heroicons:shopping-cart",
  },
  VENDOR: {
    label: "Vendor",
    color: "warning" as const,
    icon: "heroicons:building-storefront",
  },
  WAREHOUSE: {
    label: "Warehouse",
    color: "secondary" as const,
    icon: "heroicons:building-office-2",
  },
  DISPATCHER: {
    label: "Dispatcher",
    color: "info" as const,
    icon: "heroicons:map",
  },
};
// Status configurations
const accountStatusConfig = {
  PENDING: {
    label: "Pending Approval",
    color: "warning" as const,
    icon: "heroicons:clock",
  },
  INACTIVE: {
    label: "Inactive",
    color: "secondary" as const,
    icon: "heroicons:pause",
  },
  PENDING_VALIDATION: {
    label: "Pending Validation",
    color: "info" as const,
    icon: "heroicons:document-check",
  },
  ACTIVE: {
    label: "Active",
    color: "success" as const,
    icon: "heroicons:check-circle",
  },
  REJECTED: {
    label: "Rejected",
    color: "destructive" as const,
    icon: "heroicons:x-circle",
  },
  SUSPENDED: {
    label: "Suspended",
    color: "destructive" as const,
    icon: "heroicons:no-symbol",
  },
};
const validationStatusConfig = {
  PENDING: {
    label: "Pending",
    color: "warning" as const,
    icon: "heroicons:clock",
  },
  VALIDATED: {
    label: "Validated",
    color: "success" as const,
    icon: "heroicons:shield-check",
  },
  REJECTED: {
    label: "Rejected",
    color: "destructive" as const,
    icon: "heroicons:shield-exclamation",
  },
};
const UpdateUserPage = () => {
  const router = useRouter();
  const params = useParams();
  const userId = params?.id as string;
  const { hasPermission } = useAuthStore();

  const [loading, setLoading] = useState(false);
  const [fetchLoading, setFetchLoading] = useState(true);
  const [user, setUser] = useState<any>(null);
  const [roles, setRoles] = useState<
    Array<{
      id: string;
      name: string;
      description?: string;
      userTypes: string[];
    }>
  >([]);
  const [showPasswordDialog, setShowPasswordDialog] = useState(false);
  const [passwordForm, setPasswordForm] = useState({
    currentPassword: "",
    newPassword: "",
    confirmPassword: "",
  });
  const [passwordLoading, setPasswordLoading] = useState(false);

  // Simplified permission checks (ProtectedRoute handles main access control)
  const canChangePassword = hasPermission("users:change_password");

  const {
    register,
    handleSubmit,
    watch,
    setValue,
    formState: { errors, isDirty },
    reset,
  } = useForm<UpdateUserFormData>({
    resolver: zodResolver(updateUserSchema),
  });

  const watchedUserType = watch("userType");

  // Fetch user data
  useEffect(() => {
    const fetchUser = async () => {
      if (!userId) return;

      try {
        setFetchLoading(true);
        const result = await usersApiClient.getUserById(userId);

        if (result.success) {
          const userData: any = result.data;
          setUser(userData);

          // Populate form with user data
          reset({
            name: userData.name || "",
            email: userData.email || "",
            userType: userData.userType,
            phone: userData.phone || "",
            city: userData.city || "",
            roleId: userData.role?.id || "",
            accountStatus: userData.accountStatus,
            validationStatus: userData.validationStatus,
            isActive: userData.isActive,
            profile: {
              department: userData.profile?.department || "",
              notes: userData.profile?.notes || "",
              address: userData.profile?.address || "",
              cin: userData.profile?.cin || "",
            },
          });
        } else {
          toast.error("Failed to fetch user data");
          router.push("/users");
        }
      } catch (error) {
        console.error("Error fetching user:", error);
        toast.error("An error occurred while fetching user data");
        router.push("/users");
      } finally {
        setFetchLoading(false);
      }
    };

    fetchUser();
  }, [userId, reset, router]);

  // Fetch available roles
  useEffect(() => {
    const fetchRoles = async () => {
      try {
        // Mock data - replace with actual API call
        setRoles([
          {
            id: "1",
            name: "System Admin",
            description: "Full system access",
            userTypes: ["ADMIN"],
          },
          {
            id: "2",
            name: "Operations Manager",
            description: "Operations oversight",
            userTypes: ["MANAGER"],
          },
          {
            id: "3",
            name: "Sales Representative",
            description: "Sales operations",
            userTypes: ["SELLER"],
          },
          {
            id: "4",
            name: "Support Agent",
            description: "Customer support",
            userTypes: ["SUPPORT"],
          },
          {
            id: "5",
            name: "Delivery Driver",
            description: "Package delivery",
            userTypes: ["LIVREUR"],
          },
          {
            id: "6",
            name: "Standard Customer",
            description: "Customer access",
            userTypes: ["CUSTOMER"],
          },
          {
            id: "7",
            name: "Procurement Officer",
            description: "Purchasing operations",
            userTypes: ["BUYER"],
          },
          {
            id: "8",
            name: "Vendor Account",
            description: "Vendor portal access",
            userTypes: ["VENDOR"],
          },
          {
            id: "9",
            name: "Warehouse Staff",
            description: "Inventory management",
            userTypes: ["WAREHOUSE"],
          },
          {
            id: "10",
            name: "Logistics Coordinator",
            description: "Dispatch operations",
            userTypes: ["DISPATCHER"],
          },
        ]);
      } catch (error) {
        console.error("Failed to fetch roles:", error);
      }
    };

    fetchRoles();
  }, []);

  // Filter roles based on selected user type
  const availableRoles = roles.filter((role) =>
    watchedUserType ? role.userTypes.includes(watchedUserType) : true
  );

  const onSubmit = async (data: UpdateUserFormData) => {
    setLoading(true);
    try {
      const result = await usersApiClient.updateUser(userId, data);

      if (result.success) {
        toast.success("User updated successfully");
        setUser(result.data);
        // Update form with new data to reset dirty state
        reset(data);
      } else {
        toast.error(result.error?.message || "Failed to update user");
      }
    } catch (error) {
      console.error("Error updating user:", error);
      toast.error("An unexpected error occurred");
    } finally {
      setLoading(false);
    }
  };

  const handlePasswordChange = async () => {
    if (!canChangePassword) {
      toast.error("You don't have permission to change passwords");
      return;
    }

    if (!passwordForm.currentPassword || !passwordForm.newPassword) {
      toast.error("Please fill in all password fields");
      return;
    }

    if (passwordForm.newPassword !== passwordForm.confirmPassword) {
      toast.error("New passwords don't match");
      return;
    }

    if (passwordForm.newPassword.length < 6) {
      toast.error("Password must be at least 6 characters");
      return;
    }

    setPasswordLoading(true);
    try {
      const result = await usersApiClient.changeUserPassword(userId, {
        currentPassword: passwordForm.currentPassword,
        newPassword: passwordForm.newPassword,
      });

      if (result.success) {
        toast.success("Password changed successfully");
        setShowPasswordDialog(false);
        setPasswordForm({
          currentPassword: "",
          newPassword: "",
          confirmPassword: "",
        });
      } else {
        toast.error(result.error?.message || "Failed to change password");
      }
    } catch (error) {
      console.error("Error changing password:", error);
      toast.error("An unexpected error occurred");
    } finally {
      setPasswordLoading(false);
    }
  };

  const handleFormSubmit = () => {
    handleSubmit(onSubmit)();
  };

  if (fetchLoading) {
    return (
      <ProtectedRoute
        requiredUserTypes={[USER_TYPES.ADMIN]}
        requiredPermissions={[PERMISSIONS.UPDATE_USER]}
        requiredAccessLevel="FULL"
      >
        <div className="container mx-auto py-6">
          <Card>
            <CardContent className="p-8">
              <div className="flex items-center justify-center space-x-2">
                <Icon
                  icon="heroicons:arrow-path"
                  className="w-5 h-5 animate-spin"
                />
                <span>Loading user data...</span>
              </div>
            </CardContent>
          </Card>
        </div>
      </ProtectedRoute>
    );
  }

  if (!user) {
    return (
      <ProtectedRoute
        requiredUserTypes={[USER_TYPES.ADMIN]}
        requiredPermissions={[PERMISSIONS.UPDATE_USER]}
        requiredAccessLevel="FULL"
      >
        <div className="container mx-auto py-8">
          <Alert color="destructive">
            <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
            <AlertDescription>
              User not found or has been deleted.
            </AlertDescription>
          </Alert>
        </div>
      </ProtectedRoute>
    );
  }

  return (
    <ProtectedRoute
      requiredUserTypes={[USER_TYPES.ADMIN]}
      requiredPermissions={[PERMISSIONS.UPDATE_USER]}
      requiredAccessLevel="FULL"
    >
      <div className="container mx-auto py-6 space-y-6">
        {/* Header */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-4">
            <Avatar size="lg">
              <AvatarImage
                src={user.profile?.profilePhoto || user.avatar}
                alt={user.name}
              />
              <AvatarFallback>
                {user.name
                  ?.split(" ")
                  .map((n: string) => n[0])
                  .join("")
                  .toUpperCase() || "U"}
              </AvatarFallback>
            </Avatar>
            <div>
              <h1 className="text-2xl font-bold text-default-900">
                Edit User - Admin Panel
              </h1>
              <p className="text-default-600">
                {user.name} • {user.email}
              </p>
              <div className="flex items-center gap-2 mt-1">
                <Badge
                  color={
                    userTypeConfig[user.userType as keyof typeof userTypeConfig]
                      ?.color
                  }
                >
                  {
                    userTypeConfig[user.userType as keyof typeof userTypeConfig]
                      ?.label
                  }
                </Badge>
                <Badge
                  color={
                    accountStatusConfig[
                      user.accountStatus as keyof typeof accountStatusConfig
                    ]?.color
                  }
                >
                  {
                    accountStatusConfig[
                      user.accountStatus as keyof typeof accountStatusConfig
                    ]?.label
                  }
                </Badge>
                {user.validationStatus === "VALIDATED" && (
                  <Badge color="success">
                    <Icon
                      icon="heroicons:shield-check"
                      className="w-3 h-3 mr-1"
                    />
                    Validated
                  </Badge>
                )}
              </div>
            </div>
          </div>
          <div className="flex items-center gap-2">
            <Link href={`/users/${userId}`}>
              <Button variant="outline">
                <Icon icon="heroicons:eye" className="w-4 h-4 mr-2" />
                View Profile
              </Button>
            </Link>
            <Link href="/users">
              <Button variant="outline">
                <Icon icon="heroicons:arrow-left" className="w-4 h-4 mr-2" />
                Back to Users
              </Button>
            </Link>
          </div>
        </div>

        {/* Admin Notice */}
        <Alert color="info" variant="soft">
          <Icon icon="heroicons:shield-check" className="h-4 w-4" />
          <AlertDescription>
            <strong>Admin Mode:</strong> You are editing user information with
            administrator privileges. All changes will be logged and auditable.
          </AlertDescription>
        </Alert>

        {/* Unsaved Changes Warning */}
        {isDirty && (
          <Alert color="warning" variant="soft">
            <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
            <AlertDescription>
              You have unsaved changes. Don't forget to save your updates.
            </AlertDescription>
          </Alert>
        )}

        <div className="space-y-6">
          <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
            {/* Main Information */}
            <div className="lg:col-span-2 space-y-6">
              <Card>
                <CardHeader>
                  <CardTitle className="flex items-center gap-2">
                    <Icon icon="heroicons:user" className="w-5 h-5" />
                    Basic Information
                  </CardTitle>
                </CardHeader>
                <CardContent className="space-y-4">
                  {/* Name */}
                  <div className="space-y-2">
                    <Label
                      htmlFor="name"
                      className={cn("", { "text-destructive": errors.name })}
                    >
                      Full Name *
                    </Label>
                    <Input
                      id="name"
                      {...register("name")}
                      placeholder="Enter full name"
                      className={cn("", {
                        "border-destructive focus:border-destructive":
                          errors.name,
                      })}
                    />
                    {errors.name && (
                      <p className="text-xs text-destructive">
                        {errors.name.message}
                      </p>
                    )}
                  </div>

                  {/* Email */}
                  <div className="space-y-2">
                    <Label
                      htmlFor="email"
                      className={cn("", { "text-destructive": errors.email })}
                    >
                      Email Address *
                    </Label>
                    <Input
                      id="email"
                      type="email"
                      {...register("email")}
                      placeholder="user@example.com"
                      className={cn("", {
                        "border-destructive focus:border-destructive":
                          errors.email,
                      })}
                    />
                    {errors.email && (
                      <p className="text-xs text-destructive">
                        {errors.email.message}
                      </p>
                    )}
                  </div>

                  {/* Phone and City */}
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div className="space-y-2">
                      <Label htmlFor="phone">Phone Number</Label>
                      <Input
                        id="phone"
                        {...register("phone")}
                        placeholder="+1 (555) 123-4567"
                      />
                    </div>
                    <div className="space-y-2">
                      <Label htmlFor="city">City</Label>
                      <Input
                        id="city"
                        {...register("city")}
                        placeholder="Enter city"
                      />
                    </div>
                  </div>

                  {/* Address and CIN */}
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div className="space-y-2">
                      <Label htmlFor="address">Address</Label>
                      <Input
                        id="address"
                        {...register("profile.address")}
                        placeholder="Full address"
                      />
                    </div>
                    <div className="space-y-2">
                      <Label htmlFor="cin">CIN</Label>
                      <Input
                        id="cin"
                        {...register("profile.cin")}
                        placeholder="National ID"
                      />
                    </div>
                  </div>
                </CardContent>
              </Card>

              {/* User Type and Role */}
              <Card>
                <CardHeader>
                  <CardTitle className="flex items-center gap-2">
                    <Icon icon="heroicons:identification" className="w-5 h-5" />
                    User Type & Role
                  </CardTitle>
                </CardHeader>
                <CardContent className="space-y-4">
                  {/* User Type */}
                  <div className="space-y-2">
                    <Label>User Type *</Label>
                    <Select
                      value={watchedUserType}
                      onValueChange={(value) =>
                        setValue("userType", value as any, {
                          shouldDirty: true,
                        })
                      }
                    >
                      <SelectTrigger>
                        <SelectValue placeholder="Select user type" />
                      </SelectTrigger>
                      <SelectContent>
                        {Object.entries(userTypeConfig).map(([key, config]) => (
                          <SelectItem key={key} value={key}>
                            <div className="flex items-center gap-3">
                              <Icon icon={config.icon} className="w-4 h-4" />
                              <div className="font-medium">{config.label}</div>
                            </div>
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>

                  {/* Role Selection */}
                  {watchedUserType && (
                    <div className="space-y-2">
                      <Label>Role</Label>
                      <Select
                        onValueChange={(value) =>
                          setValue("roleId", value, { shouldDirty: true })
                        }
                      >
                        <SelectTrigger>
                          <SelectValue placeholder="Select role" />
                        </SelectTrigger>
                        <SelectContent>
                          {availableRoles.map((role) => (
                            <SelectItem key={role.id} value={role.id}>
                              <div>
                                <div className="font-medium">{role.name}</div>
                                {role.description && (
                                  <div className="text-xs text-muted-foreground">
                                    {role.description}
                                  </div>
                                )}
                              </div>
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                    </div>
                  )}
                </CardContent>
              </Card>

              {/* Status Management - Now always visible since this is admin-only */}
              <Card>
                <CardHeader>
                  <CardTitle className="flex items-center gap-2">
                    <Icon icon="heroicons:cog-6-tooth" className="w-5 h-5" />
                    Status Management
                  </CardTitle>
                </CardHeader>
                <CardContent className="space-y-4">
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div className="space-y-2">
                      <Label>Account Status</Label>
                      <Select
                        value={user.accountStatus}
                        onValueChange={(value) =>
                          setValue("accountStatus", value as any, {
                            shouldDirty: true,
                          })
                        }
                      >
                        <SelectTrigger>
                          <SelectValue placeholder="Select account status" />
                        </SelectTrigger>
                        <SelectContent>
                          {Object.entries(accountStatusConfig).map(
                            ([key, config]) => (
                              <SelectItem key={key} value={key}>
                                <div className="flex items-center gap-2">
                                  <Icon
                                    icon={config.icon}
                                    className="w-4 h-4"
                                  />
                                  {config.label}
                                </div>
                              </SelectItem>
                            )
                          )}
                        </SelectContent>
                      </Select>
                    </div>

                    <div className="space-y-2">
                      <Label>Validation Status</Label>
                      <Select
                        value={user.validationStatus}
                        onValueChange={(value) =>
                          setValue("validationStatus", value as any, {
                            shouldDirty: true,
                          })
                        }
                      >
                        <SelectTrigger>
                          <SelectValue placeholder="Select validation status" />
                        </SelectTrigger>
                        <SelectContent>
                          {Object.entries(validationStatusConfig).map(
                            ([key, config]) => (
                              <SelectItem key={key} value={key}>
                                <div className="flex items-center gap-2">
                                  <Icon
                                    icon={config.icon}
                                    className="w-4 h-4"
                                  />
                                  {config.label}
                                </div>
                              </SelectItem>
                            )
                          )}
                        </SelectContent>
                      </Select>
                    </div>
                  </div>
                </CardContent>
              </Card>

              {/* Additional Information */}
              <Card>
                <CardHeader>
                  <CardTitle className="flex items-center gap-2">
                    <Icon icon="heroicons:document-text" className="w-5 h-5" />
                    Additional Information
                  </CardTitle>
                </CardHeader>
                <CardContent className="space-y-4">
                  <div className="space-y-2">
                    <Label htmlFor="department">Department</Label>
                    <Input
                      id="department"
                      {...register("profile.department")}
                      placeholder="e.g., Sales, Marketing, IT"
                    />
                  </div>

                  <div className="space-y-2">
                    <Label htmlFor="notes">Admin Notes</Label>
                    <Textarea
                      id="notes"
                      {...register("profile.notes")}
                      placeholder="Internal admin notes about this user..."
                      rows={3}
                    />
                  </div>
                </CardContent>
              </Card>
            </div>

            {/* Settings Sidebar */}
            <div className="space-y-6">
              <Card>
                <CardHeader>
                  <CardTitle className="flex items-center gap-2">
                    <Icon icon="heroicons:key" className="w-5 h-5" />
                    Security
                  </CardTitle>
                </CardHeader>
                <CardContent className="space-y-4">
                  {canChangePassword && (
                    <Button
                      variant="outline"
                      className="w-full"
                      onClick={() => setShowPasswordDialog(true)}
                    >
                      <Icon icon="heroicons:key" className="w-4 h-4 mr-2" />
                      Change Password
                    </Button>
                  )}

                  <div className="flex items-center justify-between">
                    <div className="space-y-0.5">
                      <Label>Active Account</Label>
                      <p className="text-xs text-muted-foreground">
                        Allow user to access the system
                      </p>
                    </div>
                    <Switch
                      {...register("isActive")}
                      defaultChecked={user.isActive}
                    />
                  </div>
                </CardContent>
              </Card>

              {/* Account Information */}
              <Card>
                <CardHeader>
                  <CardTitle className="flex items-center gap-2">
                    <Icon
                      icon="heroicons:information-circle"
                      className="w-5 h-5"
                    />
                    Account Information
                  </CardTitle>
                </CardHeader>
                <CardContent className="space-y-3">
                  <div className="text-sm">
                    <span className="text-muted-foreground">Created:</span>
                    <div className="font-medium">
                      {new Date(user.createdAt).toLocaleDateString("en-US", {
                        year: "numeric",
                        month: "long",
                        day: "numeric",
                      })}
                    </div>
                    {user.createdBy && (
                      <div className="text-xs text-muted-foreground">
                        by {user.createdBy.name}
                      </div>
                    )}
                  </div>

                  <div className="text-sm">
                    <span className="text-muted-foreground">Last Updated:</span>
                    <div className="font-medium">
                      {new Date(user.updatedAt).toLocaleDateString("en-US", {
                        year: "numeric",
                        month: "long",
                        day: "numeric",
                      })}
                    </div>
                  </div>

                  {user.validatedAt && (
                    <div className="text-sm">
                      <span className="text-muted-foreground">Validated:</span>
                      <div className="font-medium">
                        {new Date(user.validatedAt).toLocaleDateString(
                          "en-US",
                          {
                            year: "numeric",
                            month: "long",
                            day: "numeric",
                          }
                        )}
                      </div>
                      {user.validatedBy && (
                        <div className="text-xs text-muted-foreground">
                          by {user.validatedBy.name}
                        </div>
                      )}
                    </div>
                  )}
                </CardContent>
              </Card>
            </div>
          </div>

          {/* Form Actions */}
          <div className="flex items-center justify-end gap-4 pt-6 border-t">
            <Button
              type="button"
              variant="outline"
              onClick={() => router.push(`/users/${userId}`)}
              disabled={loading}
            >
              Cancel
            </Button>
            <Button
              type="button"
              variant="outline"
              onClick={() => reset()}
              disabled={loading || !isDirty}
            >
              Reset Changes
            </Button>
            <Button
              type="button"
              onClick={handleFormSubmit}
              disabled={loading || !isDirty}
            >
              {loading && (
                <Icon
                  icon="heroicons:arrow-path"
                  className="mr-2 h-4 w-4 animate-spin"
                />
              )}
              Save Changes
            </Button>
          </div>
        </div>

        {/* Password Change Dialog */}
        {canChangePassword && (
          <AlertDialog
            open={showPasswordDialog}
            onOpenChange={setShowPasswordDialog}
          >
            <AlertDialogContent>
              <AlertDialogHeader>
                <AlertDialogTitle>Change Password</AlertDialogTitle>
                <AlertDialogDescription>
                  Enter the current password and a new password for {user.name}.
                </AlertDialogDescription>
              </AlertDialogHeader>

              <div className="space-y-4">
                <div className="space-y-2">
                  <Label>Current Password</Label>
                  <Input
                    type="password"
                    value={passwordForm.currentPassword}
                    onChange={(e) =>
                      setPasswordForm((prev) => ({
                        ...prev,
                        currentPassword: e.target.value,
                      }))
                    }
                    placeholder="Enter current password"
                  />
                </div>
                <div className="space-y-2">
                  <Label>New Password</Label>
                  <Input
                    type="password"
                    value={passwordForm.newPassword}
                    onChange={(e) =>
                      setPasswordForm((prev) => ({
                        ...prev,
                        newPassword: e.target.value,
                      }))
                    }
                    placeholder="Enter new password"
                  />
                </div>
                <div className="space-y-2">
                  <Label>Confirm New Password</Label>
                  <Input
                    type="password"
                    value={passwordForm.confirmPassword}
                    onChange={(e) =>
                      setPasswordForm((prev) => ({
                        ...prev,
                        confirmPassword: e.target.value,
                      }))
                    }
                    placeholder="Confirm new password"
                  />
                </div>
              </div>

              <AlertDialogFooter>
                <AlertDialogCancel>Cancel</AlertDialogCancel>
                <AlertDialogAction
                  onClick={handlePasswordChange}
                  disabled={passwordLoading}
                >
                  {passwordLoading && (
                    <Icon
                      icon="heroicons:arrow-path"
                      className="mr-2 h-4 w-4 animate-spin"
                    />
                  )}
                  Change Password
                </AlertDialogAction>
              </AlertDialogFooter>
            </AlertDialogContent>
          </AlertDialog>
        )}
      </div>
    </ProtectedRoute>
  );
};
export default UpdateUserPage;
-----------------------------------------------------------------------
--++--> app/[locale]/(protected)/users/create/page.tsx =======>
-----------------------------------------------------------------------
"use client";
import React, { useState, useEffect } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { useRouter } from "next/navigation";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";
import { Badge } from "@/components/ui/badge";
import { Icon } from "@/components/ui/icon";
import { Alert, AlertDescription } from "@/components/ui/alert";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { Link } from "@/i18n/routing";
import { usersApiClient } from "@/lib/api/clients/auth/users.client";
import { useAuthStore } from "@/lib/stores/auth/auth.store";
import { toast } from "sonner";
import { cn } from "@/lib/utils/ui.utils";
import { ProtectedRoute } from "@/components/route/protected-route";
import { USER_PERMISSIONS } from "@/lib/constants/auth";
// Form schema
const createUserSchema = z.object({
  name: z.string().min(2, "Name must be at least 2 characters"),
  email: z.string().email("Please enter a valid email address"),
  userType: z.enum(
    [
      "ADMIN",
      "MANAGER",
      "SUPPORT",
      "SELLER",
      "LIVREUR",
      "CUSTOMER",
      "BUYER",
      "VENDOR",
      "WAREHOUSE",
      "DISPATCHER",
    ],
    {
      required_error: "Please select a user type",
    }
  ),
  phone: z.string().optional(),
  city: z.string().optional(),
  roleId: z.string().optional(),
  profile: z
    .object({
      department: z.string().optional(),
      notes: z.string().optional(),
    })
    .optional(),
  isActive: z.boolean().default(true),
});
type CreateUserFormData = z.infer<typeof createUserSchema>;
// User type configurations
const userTypeConfig = {
  ADMIN: {
    label: "Admin",
    description: "Full system access and management",
    color: "destructive" as const,
    icon: "heroicons:shield-check",
    requiredUserTypes: ["ADMIN"], // Only ADMINs can create ADMINs
  },
  MANAGER: {
    label: "Manager",
    description: "Team and operations management",
    color: "warning" as const,
    icon: "heroicons:user-group",
    requiredUserTypes: ["ADMIN", "MANAGER"], // ADMINs and MANAGERs can create MANAGERs
  },
  SUPPORT: {
    label: "Support",
    description: "Customer support and assistance",
    color: "info" as const,
    icon: "heroicons:chat-bubble-left-right",
    requiredUserTypes: ["ADMIN", "MANAGER"],
  },
  SELLER: {
    label: "Seller",
    description: "Sales and client management",
    color: "success" as const,
    icon: "heroicons:currency-dollar",
    requiredUserTypes: ["ADMIN", "MANAGER"],
  },
  LIVREUR: {
    label: "Delivery",
    description: "Package delivery and logistics",
    color: "secondary" as const,
    icon: "heroicons:truck",
    requiredUserTypes: ["ADMIN", "MANAGER"],
  },
  CUSTOMER: {
    label: "Customer",
    description: "External customer account",
    color: "primary" as const,
    icon: "heroicons:user",
    requiredUserTypes: ["ADMIN", "MANAGER", "SUPPORT"],
  },
  BUYER: {
    label: "Buyer",
    description: "Purchasing and procurement",
    color: "success" as const,
    icon: "heroicons:shopping-cart",
    requiredUserTypes: ["ADMIN", "MANAGER"],
  },
  VENDOR: {
    label: "Vendor",
    description: "External vendor/supplier",
    color: "warning" as const,
    icon: "heroicons:building-storefront",
    requiredUserTypes: ["ADMIN", "MANAGER"],
  },
  WAREHOUSE: {
    label: "Warehouse",
    description: "Inventory and warehouse management",
    color: "secondary" as const,
    icon: "heroicons:building-office-2",
    requiredUserTypes: ["ADMIN", "MANAGER"],
  },
  DISPATCHER: {
    label: "Dispatcher",
    description: "Logistics coordination",
    color: "info" as const,
    icon: "heroicons:map",
    requiredUserTypes: ["ADMIN", "MANAGER"],
  },
};
const CreateUserPageContent = () => {
  const router = useRouter();
  const { hasPermission, user } = useAuthStore();
  const [loading, setLoading] = useState(false);
  const [roles, setRoles] = useState<
    Array<{
      id: string;
      name: string;
      description?: string;
      userTypes: string[];
    }>
  >([]);

  // Check permissions
  const canCreateUsers = hasPermission(USER_PERMISSIONS.CREATE_USER);

  const {
    register,
    handleSubmit,
    watch,
    setValue,
    formState: { errors },
    reset,
  } = useForm<CreateUserFormData>({
    resolver: zodResolver(createUserSchema),
    defaultValues: {
      isActive: true,
      profile: {
        department: "",
        notes: "",
      },
    },
  });

  const watchedUserType = watch("userType");

  // Check if current user can create the selected user type
  const canCreateUserType = (targetUserType: string) => {
    if (!user?.userType || !targetUserType) return false;

    const config =
      userTypeConfig[targetUserType as keyof typeof userTypeConfig];
    return config?.requiredUserTypes.includes(user.userType) || false;
  };

  // Filter user types based on current user's permissions
  const availableUserTypes = Object.entries(userTypeConfig).filter(
    ([key, config]) => canCreateUserType(key)
  );

  // Fetch available roles
  useEffect(() => {
    const fetchRoles = async () => {
      try {
        // Mock data for now - replace with actual API call
        setRoles([
          {
            id: "1",
            name: "System Admin",
            description: "Full system access",
            userTypes: ["ADMIN"],
          },
          {
            id: "2",
            name: "Operations Manager",
            description: "Operations oversight",
            userTypes: ["MANAGER"],
          },
          {
            id: "cmfayo10k0006584key16cnw2",
            name: "Sales Representative",
            description: "Sales operations",
            userTypes: ["SELLER"],
          },
          {
            id: "4",
            name: "Support Agent",
            description: "Customer support",
            userTypes: ["SUPPORT"],
          },
          {
            id: "5",
            name: "Delivery Driver",
            description: "Package delivery",
            userTypes: ["LIVREUR"],
          },
          {
            id: "6",
            name: "Standard Customer",
            description: "Customer access",
            userTypes: ["CUSTOMER"],
          },
          {
            id: "7",
            name: "Procurement Officer",
            description: "Purchasing operations",
            userTypes: ["BUYER"],
          },
          {
            id: "8",
            name: "Vendor Account",
            description: "Vendor portal access",
            userTypes: ["VENDOR"],
          },
          {
            id: "9",
            name: "Warehouse Staff",
            description: "Inventory management",
            userTypes: ["WAREHOUSE"],
          },
          {
            id: "10",
            name: "Logistics Coordinator",
            description: "Dispatch operations",
            userTypes: ["DISPATCHER"],
          },
        ]);
      } catch (error) {
        console.error("Failed to fetch roles:", error);
      }
    };

    fetchRoles();
  }, []);

  // Filter roles based on selected user type
  const availableRoles = roles.filter((role) =>
    watchedUserType ? role.userTypes.includes(watchedUserType) : true
  );

  // Handle user type change
  useEffect(() => {
    if (watchedUserType && availableRoles.length > 0) {
      setValue("roleId", availableRoles[0].id);
    }
  }, [watchedUserType, availableRoles, setValue]);

  const onSubmit = async (data: CreateUserFormData) => {
    if (!canCreateUsers) {
      toast.error("You don't have permission to create users");
      return;
    }

    // Additional check: verify user can create this specific user type
    if (!canCreateUserType(data.userType)) {
      toast.error(`You don't have permission to create ${data.userType} users`);
      return;
    }

    setLoading(true);
    try {
      const result = await usersApiClient.createUser({
        ...data,
        profile: data.profile || {},
      });

      if (result.success) {
        toast.success(
          "User created successfully! Password reset email has been sent."
        );
        router.push("/users");
      } else {
        toast.error(result.error?.message || "Failed to create user");
      }
    } catch (error) {
      console.error("Error creating user:", error);
      toast.error("An unexpected error occurred");
    } finally {
      setLoading(false);
    }
  };

  const handleFormSubmit = () => {
    handleSubmit(onSubmit)();
  };

  if (!canCreateUsers) {
    return (
      <div className="container mx-auto py-8">
        <Alert color="destructive">
          <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
          <AlertDescription>
            You don't have permission to create users. Please contact your
            administrator.
          </AlertDescription>
        </Alert>
      </div>
    );
  }

  return (
    <div className="container mx-auto py-6 space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-default-900">
            Create New User
          </h1>
          <p className="text-default-600">
            Add a new user to your system. They will receive an email with login
            instructions.
          </p>
        </div>
        <Link href="/users">
          <Button variant="outline">
            <Icon icon="heroicons:arrow-left" className="w-4 h-4 mr-2" />
            Back to Users
          </Button>
        </Link>
      </div>

      {/* Permissions Alert */}
      {availableUserTypes.length === 0 && (
        <Alert color="warning">
          <Icon icon="heroicons:information-circle" className="h-4 w-4" />
          <AlertDescription>
            You don't have permission to create any user types. Please contact
            your administrator.
          </AlertDescription>
        </Alert>
      )}

      {/* Info Alert */}
      <Alert color="info" variant="soft">
        <Icon icon="heroicons:information-circle" className="h-4 w-4" />
        <AlertDescription>
          The user will be created with INACTIVE status and will receive an
          email with password reset instructions to complete their account
          setup.
        </AlertDescription>
      </Alert>

      {/* Current User Permissions Info */}
      {process.env.NODE_ENV === "development" && (
        <Alert color="info" variant="soft">
          <Icon icon="heroicons:code-bracket" className="h-4 w-4" />
          <AlertDescription>
            <div>
              Your user type ({user?.userType}) can create:{" "}
              {availableUserTypes
                .map(([key, config]) => config.label)
                .join(", ") || "None"}
            </div>
          </AlertDescription>
        </Alert>
      )}

      <div className="space-y-6">
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          {/* Main Information */}
          <div className="lg:col-span-2 space-y-6">
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:user" className="w-5 h-5" />
                  Basic Information
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                {/* Name */}
                <div className="space-y-2">
                  <Label
                    htmlFor="name"
                    className={cn("", { "text-destructive": errors.name })}
                  >
                    Full Name *
                  </Label>
                  <Input
                    id="name"
                    {...register("name")}
                    placeholder="Enter full name"
                    className={cn("", {
                      "border-destructive focus:border-destructive":
                        errors.name,
                    })}
                  />
                  {errors.name && (
                    <p className="text-xs text-destructive">
                      {errors.name.message}
                    </p>
                  )}
                </div>

                {/* Email */}
                <div className="space-y-2">
                  <Label
                    htmlFor="email"
                    className={cn("", { "text-destructive": errors.email })}
                  >
                    Email Address *
                  </Label>
                  <Input
                    id="email"
                    type="email"
                    {...register("email")}
                    placeholder="user@example.com"
                    className={cn("", {
                      "border-destructive focus:border-destructive":
                        errors.email,
                    })}
                  />
                  {errors.email && (
                    <p className="text-xs text-destructive">
                      {errors.email.message}
                    </p>
                  )}
                </div>

                {/* Phone and City */}
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div className="space-y-2">
                    <Label htmlFor="phone">Phone Number</Label>
                    <Input
                      id="phone"
                      {...register("phone")}
                      placeholder="+1 (555) 123-4567"
                    />
                  </div>
                  <div className="space-y-2">
                    <Label htmlFor="city">City</Label>
                    <Input
                      id="city"
                      {...register("city")}
                      placeholder="Enter city"
                    />
                  </div>
                </div>
              </CardContent>
            </Card>

            {/* User Type and Role */}
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:identification" className="w-5 h-5" />
                  User Type & Role
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                {/* User Type */}
                <div className="space-y-2">
                  <Label
                    className={cn("", { "text-destructive": errors.userType })}
                  >
                    User Type *
                  </Label>
                  <Select
                    onValueChange={(value) =>
                      setValue("userType", value as any)
                    }
                    disabled={availableUserTypes.length === 0}
                  >
                    <SelectTrigger
                      className={cn("", {
                        "border-destructive": errors.userType,
                      })}
                    >
                      <SelectValue placeholder="Select user type" />
                    </SelectTrigger>
                    <SelectContent>
                      {availableUserTypes.map(([key, config]) => (
                        <SelectItem key={key} value={key}>
                          <div className="flex items-center gap-3">
                            <Icon icon={config.icon} className="w-4 h-4" />
                            <div>
                              <div className="font-medium">{config.label}</div>
                              <div className="text-xs text-muted-foreground">
                                {config.description}
                              </div>
                            </div>
                          </div>
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                  {errors.userType && (
                    <p className="text-xs text-destructive">
                      {errors.userType.message}
                    </p>
                  )}

                  {/* Show selected user type badge */}
                  {watchedUserType && (
                    <div className="mt-2">
                      <Badge
                        color={
                          userTypeConfig[
                            watchedUserType as keyof typeof userTypeConfig
                          ]?.color
                        }
                      >
                        <Icon
                          icon={
                            userTypeConfig[
                              watchedUserType as keyof typeof userTypeConfig
                            ]?.icon
                          }
                          className="w-3 h-3 mr-1"
                        />
                        {
                          userTypeConfig[
                            watchedUserType as keyof typeof userTypeConfig
                          ]?.label
                        }
                      </Badge>
                    </div>
                  )}

                  {/* Show permission warning for selected user type */}
                  {watchedUserType && !canCreateUserType(watchedUserType) && (
                    <Alert color="warning" variant="soft">
                      <Icon
                        icon="heroicons:exclamation-triangle"
                        className="h-4 w-4"
                      />
                      <AlertDescription>
                        You don't have permission to create{" "}
                        {
                          userTypeConfig[
                            watchedUserType as keyof typeof userTypeConfig
                          ]?.label
                        }{" "}
                        users.
                      </AlertDescription>
                    </Alert>
                  )}
                </div>

                {/* Role Selection */}
                {watchedUserType && canCreateUserType(watchedUserType) && (
                  <div className="space-y-2">
                    <Label>
                      Role
                      <TooltipProvider>
                        <Tooltip>
                          <TooltipTrigger asChild>
                            <Icon
                              icon="heroicons:information-circle"
                              className="w-4 h-4 ml-1 text-muted-foreground"
                            />
                          </TooltipTrigger>
                          <TooltipContent>
                            <p>
                              Roles define specific permissions for the selected
                              user type
                            </p>
                          </TooltipContent>
                        </Tooltip>
                      </TooltipProvider>
                    </Label>
                    <Select
                      onValueChange={(value) => setValue("roleId", value)}
                    >
                      <SelectTrigger>
                        <SelectValue placeholder="Select role" />
                      </SelectTrigger>
                      <SelectContent>
                        {availableRoles.map((role) => (
                          <SelectItem key={role.id} value={role.id}>
                            <div>
                              <div className="font-medium">{role.name}</div>
                              {role.description && (
                                <div className="text-xs text-muted-foreground">
                                  {role.description}
                                </div>
                              )}
                            </div>
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>
                )}
              </CardContent>
            </Card>

            {/* Additional Information */}
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:document-text" className="w-5 h-5" />
                  Additional Information
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="space-y-2">
                  <Label htmlFor="department">Department</Label>
                  <Input
                    id="department"
                    {...register("profile.department")}
                    placeholder="e.g., Sales, Marketing, IT"
                  />
                </div>

                <div className="space-y-2">
                  <Label htmlFor="notes">Notes</Label>
                  <Textarea
                    id="notes"
                    {...register("profile.notes")}
                    placeholder="Any additional notes about this user..."
                    rows={3}
                  />
                </div>
              </CardContent>
            </Card>
          </div>

          {/* Settings Sidebar */}
          <div className="space-y-6">
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:cog-6-tooth" className="w-5 h-5" />
                  Account Settings
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="flex items-center justify-between">
                  <div className="space-y-0.5">
                    <Label>Active Account</Label>
                    <p className="text-xs text-muted-foreground">
                      Allow user to access the system
                    </p>
                  </div>
                  <Switch {...register("isActive")} defaultChecked={true} />
                </div>
              </CardContent>
            </Card>

            {/* Preview Card */}
            {watchedUserType && (
              <Card>
                <CardHeader>
                  <CardTitle className="flex items-center gap-2">
                    <Icon icon="heroicons:eye" className="w-5 h-5" />
                    Preview
                  </CardTitle>
                </CardHeader>
                <CardContent className="space-y-3">
                  <div className="text-sm">
                    <span className="text-muted-foreground">User Type:</span>
                    <div className="mt-1">
                      <Badge
                        color={
                          userTypeConfig[
                            watchedUserType as keyof typeof userTypeConfig
                          ]?.color
                        }
                      >
                        {
                          userTypeConfig[
                            watchedUserType as keyof typeof userTypeConfig
                          ]?.label
                        }
                      </Badge>
                    </div>
                  </div>

                  <div className="text-sm">
                    <span className="text-muted-foreground">
                      Initial Status:
                    </span>
                    <div className="mt-1">
                      <Badge color="secondary">INACTIVE</Badge>
                    </div>
                  </div>

                  <div className="text-sm text-muted-foreground">
                    User will receive an email with password setup instructions.
                  </div>
                </CardContent>
              </Card>
            )}

            {/* Current User Permissions Card */}
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:shield-check" className="w-5 h-5" />
                  Your Permissions
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-3">
                <div className="text-sm">
                  <span className="text-muted-foreground">Your User Type:</span>
                  <div className="mt-1">
                    <Badge color="primary">{user?.userType}</Badge>
                  </div>
                </div>

                <div className="text-sm">
                  <span className="text-muted-foreground">Can Create:</span>
                  <div className="mt-1 space-y-1">
                    {availableUserTypes.length > 0 ? (
                      availableUserTypes.map(([key, config]) => (
                        <Badge
                          key={key}
                          color={config.color}
                          className="mr-1 mb-1"
                        >
                          {config.label}
                        </Badge>
                      ))
                    ) : (
                      <span className="text-xs text-muted-foreground">
                        No user types available
                      </span>
                    )}
                  </div>
                </div>
              </CardContent>
            </Card>

            {/* Help Card */}
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon
                    icon="heroicons:question-mark-circle"
                    className="w-5 h-5"
                  />
                  Need Help?
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-3">
                <p className="text-sm text-muted-foreground">
                  Learn more about user creation and management in our
                  documentation.
                </p>
                <Button variant="outline" size="md" className="w-full">
                  <Icon icon="heroicons:book-open" className="w-4 h-4 mr-2" />
                  View Documentation
                </Button>
              </CardContent>
            </Card>
          </div>
        </div>

        {/* Form Actions */}
        <div className="flex items-center justify-end gap-4 pt-6 border-t">
          <Button
            type="button"
            variant="outline"
            onClick={() => router.push("/users")}
            disabled={loading}
          >
            Cancel
          </Button>
          <Button
            type="button"
            variant="outline"
            onClick={() => reset()}
            disabled={loading}
          >
            Reset Form
          </Button>
          <Button
            type="button"
            onClick={handleFormSubmit}
            disabled={
              loading ||
              availableUserTypes.length === 0 ||
              (watchedUserType && !canCreateUserType(watchedUserType))
            }
          >
            {loading && (
              <Icon
                icon="heroicons:arrow-path"
                className="mr-2 h-4 w-4 animate-spin"
              />
            )}
            Create User
          </Button>
        </div>
      </div>
    </div>
  );
};
// Main component wrapped with ProtectedRoute
const CreateUserPage = () => {
  return (
    <ProtectedRoute
      requiredPermissions={[USER_PERMISSIONS.CREATE_USER]}
      requiredAccessLevel="FULL"
      allowedAccountStatuses={["ACTIVE"]}
      requireValidation={true}
    >
      <CreateUserPageContent />
    </ProtectedRoute>
  );
};
export default CreateUserPage;
-----------------------------------------------------------------------
--++--> app/[locale]/[...not-found]/page.tsx
--++--> app/[locale]/auth/forgot-password/page.tsx
--++--> app/[locale]/auth/login/page.tsx
--++--> app/[locale]/auth/register/page.tsx
--++--> app/[locale]/auth/reset-password/page.tsx
-----------------------------------------------------------------------
Components Folder:
-----------------------------------------------------------------------
--++--> components/route/protected-route.tsx =======>
-----------------------------------------------------------------------
"use client";
import { useEffect, useState, useRef, useMemo, useCallback } from "react";
import { useRouter, usePathname } from "next/navigation";
import { useAuthStore } from "@/lib/stores/auth/auth.store";
import { useTenantStore } from "@/lib/stores/auth/tenant.store";
import { toast } from "sonner";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Button } from "@/components/ui/button";
import {
  AlertCircle,
  Info,
  CheckCircle,
  Clock,
  Shield,
  UserX,
} from "lucide-react";
interface ProtectedRouteProps {
  children: React.ReactNode;
  requiredRoles?: string[];
  requiredPermissions?: string[];
  requiredUserTypes?: string[]; // Added this line
  requiredAccessLevel?: "NO_ACCESS" | "PROFILE_ONLY" | "LIMITED" | "FULL";
  allowedAccountStatuses?: string[];
  requireValidation?: boolean;
}
interface AccessResult {
  allowed: boolean;
  reason?: string;
  redirectTo?: string;
  showMessage?: boolean;
  messageType?: "info" | "warning" | "error";
}
// Constants
const ACCESS_LEVELS = ["NO_ACCESS", "PROFILE_ONLY", "LIMITED", "FULL"] as const;
const STATUS_CONFIGS = {
  PENDING: {
    icon: Clock,
    color: "text-blue-600",
    message:
      "Your account is pending admin approval. You'll receive an email notification once approved.",
    action: null,
  },
  INACTIVE: {
    icon: Info,
    color: "text-orange-600",
    message:
      "Please complete your profile information to activate your account.",
    action: { label: "Complete Profile", path: "/profile/complete" },
  },
  PENDING_VALIDATION: {
    icon: Shield,
    color: "text-yellow-600",
    message:
      "Your profile is under review. You have limited access until validation is complete.",
    action: null,
  },
  ACTIVE: {
    icon: CheckCircle,
    color: "text-green-600",
    message: "Your account is fully active and validated.",
    action: null,
  },
  REJECTED: {
    icon: UserX,
    color: "text-red-600",
    message:
      "Your account has been rejected. Please contact support for assistance.",
    action: { label: "Contact Support", path: "/contact" },
  },
  SUSPENDED: {
    icon: UserX,
    color: "text-red-600",
    message: "Your account has been suspended. Please contact support.",
    action: { label: "Contact Support", path: "/contact" },
  },
} as const;
const BLOCKED_REASONS = {
  PENDING: "Your account is pending admin approval",
  REJECTED: "Your account has been rejected. Please contact support",
  SUSPENDED: "Your account has been suspended. Please contact support",
} as const;
export function ProtectedRoute({
  children,
  requiredRoles = [],
  requiredPermissions = [],
  requiredUserTypes = [], // Added this line
  requiredAccessLevel,
  allowedAccountStatuses = [],
  requireValidation = false,
}: ProtectedRouteProps) {
  const router = useRouter();
  const pathname = usePathname();
  const [isInitialized, setIsInitialized] = useState(false);
  const [accessResult, setAccessResult] = useState<AccessResult>({
    allowed: false,
  });
  const initRef = useRef(false);
  const lastCheckRef = useRef<string>("");

  // Stable selectors to prevent unnecessary re-renders
  const isAuthenticated = useAuthStore((state) => state.isAuthenticated);
  const isLoading = useAuthStore((state) => state.isLoading);
  const user = useAuthStore((state) => state.user);
  const error = useAuthStore((state) => state.error);
  const isCheckingAuth = useAuthStore((state) => state.isCheckingAuth);
  const accountStatus = useAuthStore((state) => state.accountStatus);
  const validationStatus = useAuthStore((state) => state.validationStatus);
  const accessLevel = useAuthStore((state) => state.accessLevel);
  const requirements = useAuthStore((state) => state.requirements);
  const hasBlueCheckmark = useAuthStore((state) => state.hasBlueCheckmark);

  // Stable method references
  const checkAuth = useAuthStore((state) => state.checkAuth);
  const isAccountBlocked = useAuthStore((state) => state.isAccountBlocked);
  const needsProfileCompletion = useAuthStore(
    (state) => state.needsProfileCompletion
  );
  const needsValidation = useAuthStore((state) => state.needsValidation);
  const hasRole = useAuthStore((state) => state.hasRole);
  const hasAnyPermission = useAuthStore((state) => state.hasAnyPermission);
  const hasUserType = useAuthStore((state) => state.hasUserType); // Added this line

  const { fetchCurrentTenant, currentTenant } = useTenantStore();

  // Stable access check function with useCallback
  const checkAccess = useCallback((): AccessResult => {
    // Not authenticated
    if (!isAuthenticated || !user) {
      return {
        allowed: false,
        redirectTo: "/auth/login",
        reason: "Authentication required",
      };
    }

    // Account blocked scenarios
    if (isAccountBlocked()) {
      const status = accountStatus;
      const reason = status
        ? BLOCKED_REASONS[status as keyof typeof BLOCKED_REASONS]
        : "Access denied";
      const messageType = status === "PENDING" ? "info" : "error";

      return {
        allowed: false,
        redirectTo: "/auth/login",
        reason,
        showMessage: true,
        messageType,
      };
    }

    // Profile completion check
    if (needsProfileCompletion()) {
      if (
        pathname.includes("/profile/complete") ||
        pathname.includes("/auth")
      ) {
        return { allowed: true };
      }

      return {
        allowed: false,
        redirectTo: "/profile/complete",
        reason: "Please complete your profile to continue",
        showMessage: true,
        messageType: "info",
      };
    }

    // Access level check
    if (requiredAccessLevel) {
      const requiredIndex = ACCESS_LEVELS.indexOf(requiredAccessLevel);
      const currentIndex = ACCESS_LEVELS.indexOf(accessLevel || "NO_ACCESS");

      if (currentIndex < requiredIndex) {
        const isValidationRequired =
          requiredAccessLevel === "FULL" && needsValidation();
        const reason = isValidationRequired
          ? "This feature requires profile validation"
          : "Insufficient access level";

        return {
          allowed: false,
          redirectTo: "/dashboard",
          reason,
          showMessage: true,
          messageType: "warning",
        };
      }
    }

    // Account status check
    if (allowedAccountStatuses.length > 0 && accountStatus) {
      if (!allowedAccountStatuses.includes(accountStatus)) {
        return {
          allowed: false,
          redirectTo: "/dashboard",
          reason: "Your account status does not allow access to this feature",
          showMessage: true,
          messageType: "warning",
        };
      }
    }

    // Validation requirement check
    if (requireValidation && validationStatus !== "VALIDATED") {
      return {
        allowed: false,
        redirectTo: "/dashboard",
        reason: "This feature requires a validated account",
        showMessage: true,
        messageType: "warning",
      };
    }

    // User type check (Added this section)
    if (requiredUserTypes.length > 0) {
      const hasRequiredUserType = requiredUserTypes.some(
        (userType) => user.userType === userType
      );
      if (!hasRequiredUserType) {
        return {
          allowed: false,
          redirectTo: "/unauthorized",
          reason: "Access restricted to specific user types",
          showMessage: true,
          messageType: "error",
        };
      }
    }

    // Role check
    if (requiredRoles.length > 0) {
      const hasRequiredRole = requiredRoles.some((role) => hasRole(role));
      if (!hasRequiredRole) {
        return {
          allowed: false,
          redirectTo: "/unauthorized",
          reason: "Insufficient role permissions",
          showMessage: true,
          messageType: "error",
        };
      }
    }

    // Permission check
    if (requiredPermissions.length > 0) {
      const hasRequiredPermissions = hasAnyPermission(requiredPermissions);
      if (!hasRequiredPermissions) {
        return {
          allowed: false,
          redirectTo: "/unauthorized",
          reason: "Insufficient permissions",
          showMessage: true,
          messageType: "error",
        };
      }
    }

    return { allowed: true };
  }, [
    isAuthenticated,
    user,
    isAccountBlocked,
    accountStatus,
    needsProfileCompletion,
    pathname,
    accessLevel,
    requiredAccessLevel,
    needsValidation,
    allowedAccountStatuses,
    requireValidation,
    validationStatus,
    requiredUserTypes, // Added this line
    requiredRoles,
    hasRole,
    requiredPermissions,
    hasAnyPermission,
  ]);

  // Create a unique key for the current state to prevent unnecessary re-checks
  const stateKey = useMemo(() => {
    return [
      isAuthenticated,
      user?.id,
      user?.userType, // Added this line
      accountStatus,
      validationStatus,
      accessLevel,
      pathname,
      requiredAccessLevel,
      JSON.stringify(allowedAccountStatuses),
      requireValidation,
      JSON.stringify(requiredUserTypes), // Added this line
      JSON.stringify(requiredRoles),
      JSON.stringify(requiredPermissions),
    ].join("|");
  }, [
    isAuthenticated,
    user?.id,
    user?.userType, // Added this line
    accountStatus,
    validationStatus,
    accessLevel,
    pathname,
    requiredAccessLevel,
    allowedAccountStatuses,
    requireValidation,
    requiredUserTypes, // Added this line
    requiredRoles,
    requiredPermissions,
  ]);

  // Initialize authentication - only once
  useEffect(() => {
    if (initRef.current) return;
    initRef.current = true;

    const initialize = async () => {
      try {
        if (!isCheckingAuth) {
          await checkAuth();
        }

        // Fetch tenant data if authenticated and not loaded
        if (isAuthenticated && user && !currentTenant) {
          await fetchCurrentTenant().catch(console.error);
        }
      } catch (error) {
        console.error("Auth initialization failed:", error);
      } finally {
        setIsInitialized(true);
      }
    };

    initialize();
  }, []); // Empty dependency array - only run once

  // Check access when state changes
  useEffect(() => {
    if (!isInitialized || isLoading || isCheckingAuth) return;

    // Prevent unnecessary re-checks
    if (lastCheckRef.current === stateKey) return;
    lastCheckRef.current = stateKey;

    const result = checkAccess();
    setAccessResult(result);
  }, [isInitialized, isLoading, isCheckingAuth, stateKey, checkAccess]);

  // Handle redirects and messages - separate effect to prevent loops
  useEffect(() => {
    if (!isInitialized || isLoading || isCheckingAuth || accessResult.allowed) {
      return;
    }

    // Only show message and redirect if we have a valid access result
    if (accessResult.reason) {
      if (accessResult.showMessage) {
        const toastFn = {
          error: toast.error,
          warning: toast.warning,
          info: toast.info,
        }[accessResult.messageType || "info"];

        toastFn(accessResult.reason);
      }

      if (accessResult.redirectTo) {
        router.replace(accessResult.redirectTo);
      }
    }
  }, [
    accessResult.allowed,
    accessResult.reason,
    accessResult.redirectTo,
    accessResult.showMessage,
    accessResult.messageType,
    isInitialized,
    isLoading,
    isCheckingAuth,
    router,
  ]);

  // Loading state
  if (!isInitialized || isLoading || isCheckingAuth) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center space-y-4">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto" />
          <p className="text-muted-foreground">Initializing...</p>
        </div>
      </div>
    );
  }

  // Error state
  if (error) {
    return (
      <div className="flex items-center justify-center min-h-screen p-4">
        <div className="max-w-md w-full space-y-6 text-center">
          <Alert variant="outline">
            <AlertCircle className="h-4 w-4" />
            <AlertDescription>
              <div className="font-medium">Authentication Error</div>
              <div className="text-sm mt-1">{error}</div>
            </AlertDescription>
          </Alert>
          <Button
            onClick={() => {
              initRef.current = false;
              window.location.reload();
            }}
            className="w-full"
          >
            Retry
          </Button>
        </div>
      </div>
    );
  }

  // Access denied state
  if (!accessResult.allowed) {
    const statusConfig = accountStatus
      ? STATUS_CONFIGS[accountStatus as keyof typeof STATUS_CONFIGS]
      : null;

    const IconComponent = statusConfig?.icon || AlertCircle;

    return (
      <div className="flex items-center justify-center min-h-screen p-4">
        <div className="max-w-md w-full space-y-6 text-center">
          <div className="flex justify-center">
            <div className="rounded-full bg-default-100 p-3">
              <IconComponent
                className={`h-12 w-12 ${
                  statusConfig?.color || "text-gray-600"
                }`}
              />
            </div>
          </div>

          <div className="space-y-3">
            <h3 className="text-xl font-semibold text-default-900">
              Access Status
            </h3>
            <p className="text-sm text-default-600 leading-relaxed">
              {statusConfig?.message || accessResult.reason || "Access denied"}
            </p>

            {hasBlueCheckmark && (
              <div className="flex items-center justify-center gap-2 text-sm text-green-600">
                <CheckCircle className="h-4 w-4" />
                Verified Account
              </div>
            )}

            {requirements.length > 0 && (
              <div className="text-left">
                <div className="text-sm font-medium text-default-700 mb-2">
                  Requirements:
                </div>
                <ul className="text-xs text-default-600 space-y-1">
                  {requirements.map((req, index) => (
                    <li key={index} className="flex items-center gap-2">
                      <div className="w-1.5 h-1.5 rounded-full bg-default-400" />
                      {req}
                    </li>
                  ))}
                </ul>
              </div>
            )}
          </div>

          <div className="space-y-3">
            {statusConfig?.action && (
              <Button
                onClick={() => router.push(statusConfig.action!.path)}
                className="w-full"
              >
                {statusConfig.action.label}
              </Button>
            )}

            <Button
              variant="outline"
              onClick={() => router.push("/auth/login")}
              className="w-full"
            >
              Back to Login
            </Button>
          </div>

          {process.env.NODE_ENV === "development" && (
            <div className="mt-4 p-3 bg-muted rounded-lg text-xs text-left text-muted-foreground">
              <strong>Dev Info:</strong>
              <br />
              <strong>Account Status:</strong> {accountStatus}
              <br />
              <strong>Validation Status:</strong> {validationStatus}
              <br />
              <strong>Access Level:</strong> {accessLevel}
              <br />
              <strong>Required Access:</strong> {requiredAccessLevel || "Any"}
              <br />
              <strong>Required User Types:</strong>{" "}
              {requiredUserTypes.length > 0
                ? requiredUserTypes.join(", ")
                : "Any"}
              <br />
              <strong>Current User Type:</strong> {user?.userType || "None"}
              <br />
              <strong>Reason:</strong> {accessResult.reason}
            </div>
          )}
        </div>
      </div>
    );
  }

  return <>{children}</>;
}
-----------------------------------------------------------------------
--++--> components/users/users-table.tsx =======>
-----------------------------------------------------------------------
import * as React from "react";
import {
  ColumnDef,
  ColumnFiltersState,
  SortingState,
  VisibilityState,
  flexRender,
  getCoreRowModel,
  getFilteredRowModel,
  getPaginationRowModel,
  getSortedRowModel,
  useReactTable,
} from "@tanstack/react-table";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Checkbox } from "@/components/ui/checkbox";
import { Icon } from "@/components/ui/icon";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Textarea } from "@/components/ui/textarea";
import { Link } from "@/i18n/routing";
import { usersApiClient } from "@/lib/api/clients/auth/users.client";
import { useAuthStore } from "@/lib/stores/auth/auth.store";
import { toast } from "sonner";
import * as XLSX from "xlsx";
// Enhanced Types
interface User {
  id: string;
  email: string;
  name: string;
  userType: string;
  avatar?: string;
  isActive: boolean;
  lastLogin?: string;
  createdAt: string;
  updatedAt: string;
  accountStatus:
    | "PENDING"
    | "INACTIVE"
    | "PENDING_VALIDATION"
    | "ACTIVE"
    | "REJECTED"
    | "SUSPENDED";
  validationStatus: "PENDING" | "VALIDATED" | "REJECTED";
  profileCompleted: boolean;
  validationNotes?: string;
  validatedAt?: string;
  profile?: {
    phone?: string;
    address?: {
      city?: string;
      state?: string;
      country?: string;
    };
    cin?: string;
    cinDocuments?: string[];
    bankDetails?: any;
    profilePhoto?: string;
  };
  role: {
    id: string;
    name: string;
    description?: string;
  };
  tenant: {
    name: string;
    slug: string;
  };
  createdBy?: {
    id: string;
    name: string;
    email: string;
  };
  validatedBy?: {
    id: string;
    name: string;
    email: string;
  };
}
interface UsersResponse {
  data: User[];
  meta: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
}
// Utility function to format dates
const formatDate = (dateString: string, format: "short" | "long" = "short") => {
  const date = new Date(dateString);
  if (format === "short") {
    return date.toLocaleDateString("en-US", {
      month: "short",
      day: "2-digit",
      year: "numeric",
    });
  }
  return date.toLocaleDateString("en-US", {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  });
};
// Simple Table Components
const Table = ({
  children,
  className = "",
}: {
  children: React.ReactNode;
  className?: string;
}) => (
  <table className={`w-full text-left border-collapse ${className}`}>
    {children}
  </table>
);
const TableHeader = ({ children }: { children: React.ReactNode }) => (
  <thead className="bg-gray-50">{children}</thead>
);
const TableBody = ({ children }: { children: React.ReactNode }) => (
  <tbody>{children}</tbody>
);
const TableRow = ({
  children,
  className = "",
  ...props
}: {
  children: React.ReactNode;
  className?: string;
  [key: string]: any;
}) => (
  <tr className={`border-b hover:bg-gray-50 ${className}`} {...props}>
    {children}
  </tr>
);
const TableHead = ({
  children,
  className = "",
}: {
  children: React.ReactNode;
  className?: string;
}) => (
  <th
    className={`px-4 py-3 text-left text-sm font-medium text-gray-900 ${className}`}
  >
    {children}
  </th>
);
const TableCell = ({
  children,
  className = "",
}: {
  children: React.ReactNode;
  className?: string;
}) => (
  <td className={`px-4 py-3 text-sm text-gray-700 ${className}`}>{children}</td>
);
// Status badge components
const AccountStatusBadge = ({ status }: { status: string }) => {
  const statusConfig = {
    PENDING: {
      color: "bg-yellow-100 text-yellow-800",
      label: "Pending Approval",
      icon: "⏱️",
    },
    INACTIVE: {
      color: "bg-gray-100 text-gray-800",
      label: "Inactive",
      icon: "⏸️",
    },
    PENDING_VALIDATION: {
      color: "bg-blue-100 text-blue-800",
      label: "Pending Validation",
      icon: "📋",
    },
    ACTIVE: {
      color: "bg-green-100 text-green-800",
      label: "Active",
      icon: "✅",
    },
    REJECTED: {
      color: "bg-red-100 text-red-800",
      label: "Rejected",
      icon: "❌",
    },
    SUSPENDED: {
      color: "bg-red-100 text-red-800",
      label: "Suspended",
      icon: "🚫",
    },
  };

  const config =
    statusConfig[status as keyof typeof statusConfig] || statusConfig.INACTIVE;

  return (
    <span
      className={`inline-flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium ${config.color}`}
    >
      <span>{config.icon}</span>
      {config.label}
    </span>
  );
};
const ValidationStatusBadge = ({
  status,
  isValidated,
}: {
  status: string;
  isValidated?: boolean;
}) => {
  if (status === "VALIDATED" && isValidated) {
    return (
      <span className="inline-flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium bg-green-100 text-green-800">
        <span className="text-blue-500">🛡️</span>
        Validated
      </span>
    );
  }

  const statusConfig = {
    PENDING: {
      color: "bg-yellow-100 text-yellow-800",
      label: "Pending",
      icon: "⏱️",
    },
    VALIDATED: {
      color: "bg-green-100 text-green-800",
      label: "Validated",
      icon: "🛡️",
    },
    REJECTED: {
      color: "bg-red-100 text-red-800",
      label: "Rejected",
      icon: "⚠️",
    },
  };

  const config =
    statusConfig[status as keyof typeof statusConfig] || statusConfig.PENDING;

  return (
    <span
      className={`inline-flex items-center gap-1 px-2 py-1 rounded-full text-xs font-medium ${config.color}`}
    >
      <span>{config.icon}</span>
      {config.label}
    </span>
  );
};
// Enhanced table columns
const createColumns = (
  onDelete: (user: User) => void,
  onApproveRegistration: (user: User) => void,
  onRejectRegistration: (user: User) => void,
  onValidateProfile: (user: User) => void,
  onRejectProfile: (user: User) => void,
  onSuspend: (user: User) => void,
  onReactivate: (user: User) => void,
  hasUpdatePermission: boolean,
  hasDeletePermission: boolean,
  hasApprovePermission: boolean,
  hasValidatePermission: boolean
): ColumnDef<User>[] => [
  {
    id: "select",
    header: ({ table }) => (
      <Checkbox
        checked={
          table.getIsAllPageRowsSelected() ||
          (table.getIsSomePageRowsSelected() && "indeterminate")
        }
        onCheckedChange={(value) => table.toggleAllPageRowsSelected(!!value)}
        aria-label="Select all"
      />
    ),
    cell: ({ row }) => (
      <Checkbox
        checked={row.getIsSelected()}
        onCheckedChange={(value) => row.toggleSelected(!!value)}
        aria-label="Select row"
      />
    ),
    enableSorting: false,
    enableHiding: false,
  },
  {
    accessorKey: "name",
    header: "User",
    cell: ({ row }) => {
      const user = row.original;
      return (
        <div className="flex items-center space-x-3">
          <Avatar size="md" shape="circle">
            <AvatarImage
              src={user.profile?.profilePhoto || user.avatar || ""}
              alt={user.name}
            />
            <AvatarFallback>
              {user.name
                ?.split(" ")
                .map((n) => n[0])
                .join("")
                .toUpperCase() || "U"}
            </AvatarFallback>
          </Avatar>
          <div>
            <div className="font-medium flex items-center gap-2">
              {user.name}
              {user.validationStatus === "VALIDATED" && (
                <span className="text-blue-500" title="Verified Profile">
                  🛡️
                </span>
              )}
            </div>
            <div className="text-sm text-gray-500">{user.email}</div>
            {user.profile?.phone && (
              <div className="text-xs text-gray-400">{user.profile.phone}</div>
            )}
          </div>
        </div>
      );
    },
  },
  {
    accessorKey: "userType",
    header: "User Type",
    cell: ({ row }) => {
      const userType = row.getValue("userType") as string;
      const colorMap: Record<string, string> = {
        ADMIN: "bg-red-100 text-red-800",
        MANAGER: "bg-orange-100 text-orange-800",
        SELLER: "bg-blue-100 text-blue-800",
        CUSTOMER: "bg-green-100 text-green-800",
        LIVREUR: "bg-purple-100 text-purple-800",
        SUPPORT: "bg-blue-100 text-blue-800",
        BUYER: "bg-green-100 text-green-800",
        VENDOR: "bg-orange-100 text-orange-800",
        WAREHOUSE: "bg-gray-100 text-gray-800",
        DISPATCHER: "bg-indigo-100 text-indigo-800",
      };
      return (
        <span
          className={`inline-flex px-2 py-1 rounded-full text-xs font-medium capitalize ${
            colorMap[userType] || "bg-gray-100 text-gray-800"
          }`}
        >
          {userType.toLowerCase().replace("_", " ")}
        </span>
      );
    },
  },
  {
    accessorKey: "accountStatus",
    header: "Account Status",
    cell: ({ row }) => {
      const status = row.getValue("accountStatus") as string;
      return <AccountStatusBadge status={status} />;
    },
  },
  {
    accessorKey: "validationStatus",
    header: "Validation",
    cell: ({ row }) => {
      const user = row.original;
      return (
        <ValidationStatusBadge
          status={user.validationStatus}
          isValidated={user.validationStatus === "VALIDATED"}
        />
      );
    },
  },
  {
    accessorKey: "role",
    header: "Role",
    cell: ({ row }) => {
      const role = row.original.role;
      return (
        <div>
          <div className="font-medium capitalize">{role.name}</div>
          {role.description && (
            <div className="text-sm text-gray-500">{role.description}</div>
          )}
        </div>
      );
    },
  },
  {
    accessorKey: "profileCompleted",
    header: "Profile",
    cell: ({ row }) => {
      const completed = row.getValue("profileCompleted") as boolean;
      return (
        <span
          className={`inline-flex px-2 py-1 rounded-full text-xs font-medium ${
            completed
              ? "bg-green-100 text-green-800"
              : "bg-yellow-100 text-yellow-800"
          }`}
        >
          {completed ? "Complete" : "Incomplete"}
        </span>
      );
    },
  },
  {
    accessorKey: "createdAt",
    header: "Created",
    cell: ({ row }) => {
      const user = row.original;
      return (
        <div>
          <div>{formatDate(user.createdAt)}</div>
          {user.createdBy && (
            <div className="text-xs text-gray-500">
              by {user.createdBy.name}
            </div>
          )}
        </div>
      );
    },
  },
  {
    id: "actions",
    header: "Actions",
    enableHiding: false,
    cell: ({ row }) => {
      const user = row.original;

      return (
        <DropdownMenu>
          <DropdownMenuTrigger asChild>
            <Button variant="ghost" size="md">
              <Icon icon="heroicons:ellipsis-horizontal" className="h-4 w-4" />
            </Button>
          </DropdownMenuTrigger>
          <DropdownMenuContent align="end">
            <DropdownMenuItem asChild>
              <Link href={`/users/${user.id}`}>
                <Icon icon="heroicons:eye" className="mr-2 h-4 w-4" />
                View Details
              </Link>
            </DropdownMenuItem>

            {hasUpdatePermission && (
              <DropdownMenuItem asChild>
                <Link href={`/users/${user.id}/edit`}>
                  <Icon
                    icon="heroicons:pencil-square"
                    className="mr-2 h-4 w-4"
                  />
                  Edit User
                </Link>
              </DropdownMenuItem>
            )}

            {/* Registration Approval Actions */}
            {hasApprovePermission && user.accountStatus === "PENDING" && (
              <>
                <DropdownMenuSeparator />
                <DropdownMenuItem onClick={() => onApproveRegistration(user)}>
                  <Icon
                    icon="heroicons:check"
                    className="mr-2 h-4 w-4 text-green-600"
                  />
                  Approve Registration
                </DropdownMenuItem>
                <DropdownMenuItem onClick={() => onRejectRegistration(user)}>
                  <Icon
                    icon="heroicons:x-mark"
                    className="mr-2 h-4 w-4 text-red-600"
                  />
                  Reject Registration
                </DropdownMenuItem>
              </>
            )}

            {/* Profile Validation Actions */}
            {hasValidatePermission &&
              user.accountStatus === "PENDING_VALIDATION" && (
                <>
                  <DropdownMenuSeparator />
                  <DropdownMenuItem onClick={() => onValidateProfile(user)}>
                    <Icon
                      icon="heroicons:shield-check"
                      className="mr-2 h-4 w-4 text-blue-600"
                    />
                    Validate Profile
                  </DropdownMenuItem>
                  <DropdownMenuItem onClick={() => onRejectProfile(user)}>
                    <Icon
                      icon="heroicons:shield-exclamation"
                      className="mr-2 h-4 w-4 text-red-600"
                    />
                    Reject Profile
                  </DropdownMenuItem>
                </>
              )}

            {/* Suspend/Reactivate Actions */}
            {hasUpdatePermission && (
              <>
                <DropdownMenuSeparator />
                {user.accountStatus === "SUSPENDED" ? (
                  <DropdownMenuItem onClick={() => onReactivate(user)}>
                    <Icon
                      icon="heroicons:play"
                      className="mr-2 h-4 w-4 text-green-600"
                    />
                    Reactivate User
                  </DropdownMenuItem>
                ) : (
                  user.accountStatus === "ACTIVE" && (
                    <DropdownMenuItem onClick={() => onSuspend(user)}>
                      <Icon
                        icon="heroicons:pause"
                        className="mr-2 h-4 w-4 text-orange-600"
                      />
                      Suspend User
                    </DropdownMenuItem>
                  )
                )}
              </>
            )}

            {hasDeletePermission && (
              <>
                <DropdownMenuSeparator />
                <DropdownMenuItem
                  className="text-red-600 focus:text-red-600"
                  onClick={() => onDelete(user)}
                >
                  <Icon icon="heroicons:trash" className="mr-2 h-4 w-4" />
                  Delete User
                </DropdownMenuItem>
              </>
            )}
          </DropdownMenuContent>
        </DropdownMenu>
      );
    },
  },
];
// Action Dialog Component
const ActionDialog = ({
  open,
  onOpenChange,
  title,
  description,
  onConfirm,
  loading,
  showMessage = false,
  message,
  onMessageChange,
}: {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  title: string;
  description: string;
  onConfirm: () => void;
  loading?: boolean;
  showMessage?: boolean;
  message?: string;
  onMessageChange?: (message: string) => void;
}) => (
  <Dialog open={open} onOpenChange={onOpenChange}>
    <DialogContent>
      <DialogHeader>
        <DialogTitle>{title}</DialogTitle>
        <DialogDescription>{description}</DialogDescription>
      </DialogHeader>

      {showMessage && (
        <div className="space-y-2">
          <label className="text-sm font-medium">Message (optional)</label>
          <Textarea
            placeholder="Add a message for the user..."
            value={message || ""}
            onChange={(e) => onMessageChange?.(e.target.value)}
          />
        </div>
      )}

      <DialogFooter>
        <Button size="md" variant="outline" onClick={() => onOpenChange(false)}>
          Cancel
        </Button>
        <Button size="md" onClick={onConfirm} disabled={loading}>
          {loading && (
            <Icon
              icon="heroicons:arrow-path"
              className="mr-2 h-4 w-4 animate-spin"
            />
          )}
          Confirm
        </Button>
      </DialogFooter>
    </DialogContent>
  </Dialog>
);
// Main Enhanced Users Table Component
const UsersTable = () => {
  const { hasPermission } = useAuthStore();
  const [users, setUsers] = React.useState<User[]>([]);
  const [loading, setLoading] = React.useState(true);
  const [pagination, setPagination] = React.useState({
    page: 1,
    limit: 10,
    total: 0,
    totalPages: 0,
  });

  // Table state
  const [sorting, setSorting] = React.useState<SortingState>([]);
  const [columnFilters, setColumnFilters] = React.useState<ColumnFiltersState>(
    []
  );
  const [columnVisibility, setColumnVisibility] =
    React.useState<VisibilityState>({});
  const [rowSelection, setRowSelection] = React.useState({});

  // Enhanced filters state
  const [filters, setFilters] = React.useState({
    search: "",
    userType: "",
    isActive: "",
    roleId: "",
    accountStatus: "",
    validationStatus: "",
  });

  // Dialog states
  const [deleteDialog, setDeleteDialog] = React.useState<{
    open: boolean;
    user: User | null;
  }>({ open: false, user: null });

  const [actionDialog, setActionDialog] = React.useState<{
    open: boolean;
    type:
      | "approve"
      | "reject"
      | "validate"
      | "rejectProfile"
      | "suspend"
      | "reactivate"
      | null;
    user: User | null;
    message: string;
  }>({ open: false, type: null, user: null, message: "" });

  const [actionLoading, setActionLoading] = React.useState(false);

  // Permissions
  const hasUpdatePermission = hasPermission("users:update");
  const hasDeletePermission = hasPermission("users:delete");
  const hasApprovePermission = hasPermission("users:approve");
  const hasValidatePermission = hasPermission("users:validate");

  // Fetch users data with enhanced filters
  const fetchUsers = React.useCallback(async () => {
    try {
      setLoading(true);

      const apiFilters: any = {
        page: pagination.page,
        limit: pagination.limit,
      };

      // Add all filters
      if (filters.search) apiFilters.search = filters.search;
      if (filters.userType) apiFilters.userType = filters.userType;
      if (filters.isActive !== "")
        apiFilters.isActive = filters.isActive === "true";
      if (filters.roleId) apiFilters.roleId = filters.roleId;
      if (filters.accountStatus)
        apiFilters.accountStatus = filters.accountStatus;
      if (filters.validationStatus)
        apiFilters.validationStatus = filters.validationStatus;

      const result = await usersApiClient.getUsers(apiFilters);

      if (result.data && result.data[0] && result.data[0].data) {
        setUsers(result.data[0].data);
        setPagination((prev) => ({
          ...prev,
          total: result.data[0].meta.total,
          totalPages: result.data[0].meta.totalPages,
        }));
      } else {
        throw new Error(result.error?.message || "Failed to fetch users");
      }
    } catch (error) {
      console.error("Error fetching users:", error);
      toast.error("Failed to fetch users");
    } finally {
      setLoading(false);
    }
  }, [pagination.page, pagination.limit, filters]);

  // Fetch special user lists
  const fetchPendingRegistrations = async () => {
    try {
      const result = await usersApiClient.getPendingRegistrations();
      if (result.success) {
        setUsers(result.data);
        setPagination((prev) => ({
          ...prev,
          total: result.data.length,
          totalPages: 1,
        }));
      }
    } catch (error) {
      toast.error("Failed to fetch pending registrations");
    }
  };

  const fetchPendingValidations = async () => {
    try {
      const result = await usersApiClient.getPendingValidations();
      if (result.success) {
        setUsers(result.data);
        setPagination((prev) => ({
          ...prev,
          total: result.data.length,
          totalPages: 1,
        }));
      }
    } catch (error) {
      toast.error("Failed to fetch pending validations");
    }
  };

  React.useEffect(() => {
    fetchUsers();
  }, [fetchUsers]);

  // Enhanced action handlers
  const handleApproveRegistration = async (user: User) => {
    setActionDialog({
      open: true,
      type: "approve",
      user,
      message: `Welcome to our platform! Your registration has been approved.`,
    });
  };

  const handleRejectRegistration = async (user: User) => {
    setActionDialog({
      open: true,
      type: "reject",
      user,
      message: `We're sorry, but your registration could not be approved at this time.`,
    });
  };

  const handleValidateProfile = async (user: User) => {
    setActionDialog({
      open: true,
      type: "validate",
      user,
      message: `Congratulations! Your profile has been validated.`,
    });
  };

  const handleRejectProfile = async (user: User) => {
    setActionDialog({
      open: true,
      type: "rejectProfile",
      user,
      message: `Your profile requires additional information. Please review and update.`,
    });
  };

  const handleSuspend = async (user: User) => {
    setActionDialog({ open: true, type: "suspend", user, message: "" });
  };

  const handleReactivate = async (user: User) => {
    setActionDialog({ open: true, type: "reactivate", user, message: "" });
  };

  const executeAction = async () => {
    if (!actionDialog.user || !actionDialog.type) return;

    setActionLoading(true);
    try {
      let result;
      const { user, type, message } = actionDialog;

      switch (type) {
        case "approve":
          result = await usersApiClient.approveRegistration(user.id, {
            approve: true,
            message,
          });
          break;
        case "reject":
          result = await usersApiClient.approveRegistration(user.id, {
            approve: false,
            message,
          });
          break;
        case "validate":
          result = await usersApiClient.validateProfile(user.id, {
            action: "VALIDATE",
            notes: message,
          });
          break;
        case "rejectProfile":
          result = await usersApiClient.validateProfile(user.id, {
            action: "REJECT",
            notes: message,
          });
          break;
        case "suspend":
          result = await usersApiClient.suspendUser(user.id);
          break;
        case "reactivate":
          result = await usersApiClient.reactivateUser(user.id);
          break;
      }

      if (result?.success) {
        toast.success(`User ${type} successfully`);
        fetchUsers();
        setActionDialog({ open: false, type: null, user: null, message: "" });
      } else {
        toast.error(result?.error?.message || `Failed to ${type} user`);
      }
    } catch (error) {
      toast.error(`Failed to ${actionDialog.type} user`);
    } finally {
      setActionLoading(false);
    }
  };

  // Handle search with debouncing
  const searchTimerRef = React.useRef<NodeJS.Timeout>();

  const debouncedSearch = React.useCallback((value: string) => {
    if (searchTimerRef.current) {
      clearTimeout(searchTimerRef.current);
    }
    searchTimerRef.current = setTimeout(() => {
      setFilters((prev) => ({ ...prev, search: value }));
      setPagination((prev) => ({ ...prev, page: 1 }));
    }, 500);
  }, []);

  // Handle filter changes
  const handleFilterChange = (key: string, value: string) => {
    setFilters((prev) => ({ ...prev, [key]: value }));
    setPagination((prev) => ({ ...prev, page: 1 }));
  };

  // Handle pagination
  const handlePageChange = (newPage: number) => {
    setPagination((prev) => ({ ...prev, page: newPage }));
  };

  const handlePageSizeChange = (newSize: number) => {
    setPagination((prev) => ({ ...prev, limit: newSize, page: 1 }));
  };

  // Handle delete user
  const handleDeleteUser = async (user: User) => {
    try {
      const response = await usersApiClient.deleteUser(user.id);
      if (response.success) {
        toast.success("User deleted successfully");
        fetchUsers();
        setDeleteDialog({ open: false, user: null });
      } else {
        toast.error(response.error?.message || "Failed to delete user");
      }
    } catch (error) {
      console.error("Error deleting user:", error);
      toast.error("Failed to delete user");
    }
  };

  // Enhanced export with new fields
  const handleExportExcel = () => {
    try {
      const exportData = users.map((user) => ({
        Name: user.name,
        Email: user.email,
        "User Type": user.userType,
        Role: user.role.name,
        Phone: user.profile?.phone || "N/A",
        "Account Status": user.accountStatus,
        "Validation Status": user.validationStatus,
        "Profile Completed": user.profileCompleted ? "Yes" : "No",
        "Is Active": user.isActive ? "Active" : "Inactive",
        "Last Login": user.lastLogin
          ? formatDate(user.lastLogin, "long")
          : "Never",
        "Created At": formatDate(user.createdAt, "long"),
        "Created By": user.createdBy?.name || "Self-registered",
        "Validated At": user.validatedAt
          ? formatDate(user.validatedAt, "long")
          : "N/A",
        "Validated By": user.validatedBy?.name || "N/A",
        CIN: user.profile?.cin || "N/A",
        Location: user.profile?.address
          ? `${user.profile.address.city || ""}, ${
              user.profile.address.state || ""
            }, ${user.profile.address.country || ""}`.replace(
              /^,\s*|,\s*$/g,
              ""
            )
          : "N/A",
      }));

      const worksheet = XLSX.utils.json_to_sheet(exportData);
      const workbook = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(workbook, worksheet, "Users");

      const maxWidth = exportData.reduce(
        (w, r) => Math.max(w, Object.keys(r).length),
        10
      );
      worksheet["!cols"] = Array(maxWidth).fill({ width: 20 });

      const today = new Date().toISOString().split("T")[0];
      XLSX.writeFile(workbook, `users-export-${today}.xlsx`);
      toast.success("Users data exported successfully");
    } catch (error) {
      console.error("Export error:", error);
      toast.error("Failed to export users data");
    }
  };

  // Table configuration
  const columns = React.useMemo(
    () =>
      createColumns(
        (user) => setDeleteDialog({ open: true, user }),
        handleApproveRegistration,
        handleRejectRegistration,
        handleValidateProfile,
        handleRejectProfile,
        handleSuspend,
        handleReactivate,
        hasUpdatePermission,
        hasDeletePermission,
        hasApprovePermission,
        hasValidatePermission
      ),
    [
      hasUpdatePermission,
      hasDeletePermission,
      hasApprovePermission,
      hasValidatePermission,
    ]
  );

  const table = useReactTable({
    data: users,
    columns,
    onSortingChange: setSorting,
    onColumnFiltersChange: setColumnFilters,
    getCoreRowModel: getCoreRowModel(),
    getPaginationRowModel: getPaginationRowModel(),
    getSortedRowModel: getSortedRowModel(),
    getFilteredRowModel: getFilteredRowModel(),
    onColumnVisibilityChange: setColumnVisibility,
    onRowSelectionChange: setRowSelection,
    state: {
      sorting,
      columnFilters,
      columnVisibility,
      rowSelection,
    },
    manualPagination: true,
    pageCount: pagination.totalPages,
  });

  const selectedRowsCount = table.getFilteredSelectedRowModel().rows.length;

  return (
    <div className="space-y-4 mx-4">
      {/* Quick Action Buttons */}
      <div className="flex flex-wrap gap-2">
        {hasApprovePermission && (
          <Button
            variant="outline"
            size="md"
            onClick={fetchPendingRegistrations}
          >
            <Icon icon="heroicons:user-plus" className="h-4 w-4 mr-2" />
            Pending Registrations
          </Button>
        )}
        {hasValidatePermission && (
          <Button variant="outline" size="md" onClick={fetchPendingValidations}>
            <Icon icon="heroicons:document-check" className="h-4 w-4 mr-2" />
            Pending Validations
          </Button>
        )}
        <Button variant="outline" size="md" onClick={fetchUsers}>
          <Icon icon="heroicons:users" className="h-4 w-4 mr-2" />
          All Users
        </Button>
      </div>

      {/* Enhanced Filters */}
      <div className="flex flex-col sm:flex-row gap-4">
        <div className="flex-1 space-y-2 sm:space-y-0 sm:flex sm:items-center sm:space-x-2">
          <Input
            placeholder="Search users..."
            className="sm:max-w-sm"
            onChange={(e) => debouncedSearch(e.target.value)}
          />

          <Select
            value={filters.userType || "all"}
            onValueChange={(value) =>
              handleFilterChange("userType", value === "all" ? "" : value)
            }
          >
            <SelectTrigger className="sm:w-[150px]">
              <SelectValue placeholder="User Type" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">All Types</SelectItem>
              <SelectItem value="ADMIN">Admin</SelectItem>
              <SelectItem value="MANAGER">Manager</SelectItem>
              <SelectItem value="SELLER">Seller</SelectItem>
              <SelectItem value="CUSTOMER">Customer</SelectItem>
              <SelectItem value="LIVREUR">Livreur</SelectItem>
              <SelectItem value="SUPPORT">Support</SelectItem>
              <SelectItem value="BUYER">Buyer</SelectItem>
              <SelectItem value="VENDOR">Vendor</SelectItem>
              <SelectItem value="WAREHOUSE">Warehouse</SelectItem>
              <SelectItem value="DISPATCHER">Dispatcher</SelectItem>
            </SelectContent>
          </Select>

          <Select
            value={filters.accountStatus || "all"}
            onValueChange={(value) =>
              handleFilterChange("accountStatus", value === "all" ? "" : value)
            }
          >
            <SelectTrigger className="sm:w-[160px]">
              <SelectValue placeholder="Account Status" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">All Status</SelectItem>
              <SelectItem value="PENDING">Pending</SelectItem>
              <SelectItem value="INACTIVE">Inactive</SelectItem>
              <SelectItem value="PENDING_VALIDATION">
                Pending Validation
              </SelectItem>
              <SelectItem value="ACTIVE">Active</SelectItem>
              <SelectItem value="REJECTED">Rejected</SelectItem>
              <SelectItem value="SUSPENDED">Suspended</SelectItem>
            </SelectContent>
          </Select>

          <Select
            value={filters.validationStatus || "all"}
            onValueChange={(value) =>
              handleFilterChange(
                "validationStatus",
                value === "all" ? "" : value
              )
            }
          >
            <SelectTrigger className="sm:w-[140px]">
              <SelectValue placeholder="Validation" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="all">All Validation</SelectItem>
              <SelectItem value="PENDING">Pending</SelectItem>
              <SelectItem value="VALIDATED">Validated</SelectItem>
              <SelectItem value="REJECTED">Rejected</SelectItem>
            </SelectContent>
          </Select>
        </div>

        <div className="flex items-center space-x-2">
          <Button variant="outline" size="md" onClick={handleExportExcel}>
            <Icon
              icon="heroicons:document-arrow-down"
              className="h-4 w-4 mr-2"
            />
            Export Excel
          </Button>
        </div>
      </div>

      {/* Table */}
      <div className="border rounded-lg overflow-hidden">
        <Table>
          <TableHeader>
            {table.getHeaderGroups().map((headerGroup) => (
              <TableRow key={headerGroup.id}>
                {headerGroup.headers.map((header) => (
                  <TableHead key={header.id}>
                    {header.isPlaceholder
                      ? null
                      : flexRender(
                          header.column.columnDef.header,
                          header.getContext()
                        )}
                  </TableHead>
                ))}
              </TableRow>
            ))}
          </TableHeader>
          <TableBody>
            {loading ? (
              Array.from({ length: 5 }).map((_, index) => (
                <TableRow key={index}>
                  {columns.map((_, cellIndex) => (
                    <TableCell key={cellIndex}>
                      <div className="h-4 bg-gray-200 rounded animate-pulse" />
                    </TableCell>
                  ))}
                </TableRow>
              ))
            ) : table.getRowModel().rows?.length ? (
              table.getRowModel().rows.map((row) => (
                <TableRow
                  key={row.id}
                  data-state={row.getIsSelected() && "selected"}
                >
                  {row.getVisibleCells().map((cell) => (
                    <TableCell key={cell.id}>
                      {flexRender(
                        cell.column.columnDef.cell,
                        cell.getContext()
                      )}
                    </TableCell>
                  ))}
                </TableRow>
              ))
            ) : (
              <TableRow>
                <TableCell
                  colSpan={columns.length}
                  className="h-24 text-center"
                >
                  No users found.
                </TableCell>
              </TableRow>
            )}
          </TableBody>
        </Table>
      </div>

      {/* Pagination */}
      <div className="flex flex-col sm:flex-row items-center justify-between gap-4 pb-4">
        <div className="text-sm text-gray-600">
          Showing {(pagination.page - 1) * pagination.limit + 1} to{" "}
          {Math.min(pagination.page * pagination.limit, pagination.total)} of{" "}
          {pagination.total} users
        </div>

        <div className="flex items-center space-x-2">
          <div className="flex items-center space-x-2">
            <span className="text-sm">Rows per page:</span>
            <Select
              value={pagination.limit.toString()}
              onValueChange={(value) => handlePageSizeChange(Number(value))}
            >
              <SelectTrigger className="w-16">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="5">5</SelectItem>
                <SelectItem value="10">10</SelectItem>
                <SelectItem value="20">20</SelectItem>
                <SelectItem value="50">50</SelectItem>
              </SelectContent>
            </Select>
          </div>

          <div className="flex items-center space-x-1">
            <Button
              variant="outline"
              size="md"
              onClick={() => handlePageChange(1)}
              disabled={pagination.page === 1}
            >
              <Icon icon="heroicons:chevron-double-left" className="h-4 w-4" />
            </Button>
            <Button
              variant="outline"
              size="md"
              onClick={() => handlePageChange(pagination.page - 1)}
              disabled={pagination.page === 1}
            >
              <Icon icon="heroicons:chevron-left" className="h-4 w-4" />
            </Button>

            <span className="px-3 py-1 text-sm">
              Page {pagination.page} of {pagination.totalPages}
            </span>

            <Button
              variant="outline"
              size="md"
              onClick={() => handlePageChange(pagination.page + 1)}
              disabled={pagination.page >= pagination.totalPages}
            >
              <Icon icon="heroicons:chevron-right" className="h-4 w-4" />
            </Button>
            <Button
              variant="outline"
              size="md"
              onClick={() => handlePageChange(pagination.totalPages)}
              disabled={pagination.page >= pagination.totalPages}
            >
              <Icon icon="heroicons:chevron-double-right" className="h-4 w-4" />
            </Button>
          </div>
        </div>
      </div>

      {/* Delete Confirmation Dialog */}
      <AlertDialog
        open={deleteDialog.open}
        onOpenChange={(open) => setDeleteDialog({ open, user: null })}
      >
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure?</AlertDialogTitle>
            <AlertDialogDescription>
              This action cannot be undone. This will permanently delete the
              user
              <strong> {deleteDialog.user?.name}</strong> and remove all
              associated data.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={() =>
                deleteDialog.user && handleDeleteUser(deleteDialog.user)
              }
              className="bg-red-600 text-white hover:bg-red-700"
            >
              Delete User
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* Action Dialog */}
      <ActionDialog
        open={actionDialog.open}
        onOpenChange={(open) =>
          setActionDialog({ open, type: null, user: null, message: "" })
        }
        title={`${
          actionDialog.type === "approve"
            ? "Approve Registration"
            : actionDialog.type === "reject"
            ? "Reject Registration"
            : actionDialog.type === "validate"
            ? "Validate Profile"
            : actionDialog.type === "rejectProfile"
            ? "Reject Profile"
            : actionDialog.type === "suspend"
            ? "Suspend User"
            : actionDialog.type === "reactivate"
            ? "Reactivate User"
            : ""
        }`}
        description={`Are you sure you want to ${actionDialog.type} ${actionDialog.user?.name}?`}
        onConfirm={executeAction}
        loading={actionLoading}
        showMessage={[
          "approve",
          "reject",
          "validate",
          "rejectProfile",
        ].includes(actionDialog.type || "")}
        message={actionDialog.message}
        onMessageChange={(message) =>
          setActionDialog((prev) => ({ ...prev, message }))
        }
      />
    </div>
  );
};
export default UsersTable;
-----------------------------------------------------------------------
Lib Folder:
-----------------------------------------------------------------------
--++--> lib/api/clients/auth/auth.client =======>
import { BaseApiClient, ApiResponse } from "../../base.client";
import type {
  LoginRequest,
  RegisterRequest,
  LoginResponse,
  RegisterResponse,
  AccountStatusResponse,
  RefreshTokenRequest,
  CompleteProfileRequest,
  ResetPasswordRequest,
  ForgotPasswordRequest,
} from "@/lib/types/auth/auth.types";
export class AuthApiClient extends BaseApiClient {
  constructor() {
    super("auth");
  }

  async login(request: LoginRequest): Promise<ApiResponse<LoginResponse>> {
    return this.post<LoginResponse>("/api/auth/login", request);
  }

  async register(
    request: RegisterRequest
  ): Promise<ApiResponse<RegisterResponse>> {
    return this.post<RegisterResponse>("/api/auth/register", request);
  }

  async refreshToken(
    request: RefreshTokenRequest
  ): Promise<ApiResponse<LoginResponse>> {
    return this.post<LoginResponse>("/api/auth/refresh", request);
  }

  async logout(request: RefreshTokenRequest): Promise<ApiResponse<void>> {
    return this.post<void>("/api/auth/logout", request);
  }

  async getProfile(): Promise<ApiResponse<any>> {
    return this.get<any>("/api/auth/profile");
  }

  async getAccountStatus(): Promise<ApiResponse<AccountStatusResponse>> {
    return this.get<AccountStatusResponse>("/api/auth/status");
  }

  async completeProfile(
    request: CompleteProfileRequest
  ): Promise<ApiResponse<any>> {
    return this.patch<any>("/api/auth/complete-profile", request);
  }

  async forgotPassword(
    request: ForgotPasswordRequest
  ): Promise<ApiResponse<{ message: string }>> {
    return this.post<{ message: string }>("/api/auth/forgot-password", request);
  }

  async resetPassword(
    request: ResetPasswordRequest
  ): Promise<ApiResponse<{ message: string }>> {
    return this.post<{ message: string }>("/api/auth/reset-password", request);
  }
}
export const authApiClient = new AuthApiClient();
-----------------------------------------------------------------------
--++--> lib/api/clients/auth/users.client.ts =======>
import { BaseApiClient, ApiResponse } from "../../base.client";
import type {
  User,
  CreateUserRequest,
  UpdateUserRequest,
  UserFilters,
} from "@/lib/types/database/schema.types";
// New types for the enhanced functionality
export interface ApproveRegistrationRequest {
  approve: boolean;
  message?: string;
}
export interface ValidateProfileRequest {
  action: "VALIDATE" | "REJECT";
  notes?: string;
}
export interface CompleteProfileRequest {
  phone?: string;
  city?: string;
  address: string;
  cin: string;
  cinDocuments?: string[];
  bankDetails?: any;
  profilePhoto?: string;
}
export class UsersApiClient extends BaseApiClient {
  constructor() {
    super("users");
  }

  // ========================================
  // USER MANAGEMENT ENDPOINTS
  // ========================================

  async createUser(request: CreateUserRequest): Promise<ApiResponse<User>> {
    return this.post<User>("/api/users", request);
  }

  async getUsers(filters?: UserFilters) {
    return this.getPaginated<User>("/api/users", filters);
  }

  async getUserById(id: string): Promise<ApiResponse<User>> {
    return this.get<User>(`/api/users/${id}`);
  }

  async updateUser(
    id: string,
    request: UpdateUserRequest
  ): Promise<ApiResponse<User>> {
    return this.patch<User>(`/api/users/${id}`, request);
  }

  async deleteUser(id: string): Promise<ApiResponse<void>> {
    return this.delete<void>(`/api/users/${id}`);
  }

  async deactivateUser(id: string): Promise<ApiResponse<User>> {
    return this.patch<User>(`/api/users/${id}/deactivate`, {});
  }

  async reactivateUser(id: string): Promise<ApiResponse<User>> {
    return this.patch<User>(`/api/users/${id}/reactivate`, {});
  }

  async changeUserPassword(
    id: string,
    request: {
      currentPassword: string;
      newPassword: string;
    }
  ): Promise<ApiResponse<{ message: string }>> {
    return this.patch<{ message: string }>(
      `/api/users/${id}/change-password`,
      request
    );
  }

  // ========================================
  // NEW ENHANCED USER WORKFLOW ENDPOINTS
  // ========================================

  /**
   * Get all users with PENDING account status awaiting admin approval
   */
  async getPendingRegistrations(): Promise<ApiResponse<User[]>> {
    return this.get<User[]>("/api/users/pending-registrations");
  }

  /**
   * Get all users with PENDING_VALIDATION status awaiting profile validation
   */
  async getPendingValidations(): Promise<ApiResponse<User[]>> {
    return this.get<User[]>("/api/users/pending-validations");
  }

  /**
   * Approve or reject a user registration (for PENDING users)
   */
  async approveRegistration(
    userId: string,
    request: ApproveRegistrationRequest
  ): Promise<ApiResponse<User>> {
    return this.patch<User>(
      `/api/users/${userId}/approve-registration`,
      request
    );
  }

  /**
   * Validate or reject a user profile (for PENDING_VALIDATION users)
   */
  async validateProfile(
    userId: string,
    request: ValidateProfileRequest
  ): Promise<ApiResponse<User>> {
    return this.patch<User>(`/api/users/${userId}/validate-profile`, request);
  }

  /**
   * Suspend a user account (moves to SUSPENDED status)
   */
  async suspendUser(userId: string): Promise<ApiResponse<User>> {
    return this.patch<User>(`/api/users/${userId}/suspend`, {});
  }

  /**
   * Complete user profile (moves from INACTIVE to PENDING_VALIDATION)
   */
  async completeProfile(
    request: CompleteProfileRequest
  ): Promise<ApiResponse<User>> {
    return this.patch<User>("/api/users/me/complete-profile", request);
  }

  /**
   * Get current user profile
   */
  async getMyProfile(): Promise<ApiResponse<User>> {
    return this.get<User>("/api/users/me");
  }

  /**
   * Assign a role to a user
   */
  async assignRole(userId: string, roleId: string): Promise<ApiResponse<User>> {
    return this.patch<User>(`/api/users/${userId}/role`, { roleId });
  }

  /**
   * Get user permissions based on their role and account status
   */
  async getUserPermissions(userId: string): Promise<
    ApiResponse<{
      userId: string;
      email: string;
      userType: string;
      accountStatus: string;
      validationStatus: string;
      role: any;
      permissions: string[];
      isActive: boolean;
    }>
  > {
    return this.get(`/api/users/${userId}/permissions`);
  }

  // ========================================
  // BULK OPERATIONS
  // ========================================

  /**
   * Bulk approve multiple registrations
   */
  async bulkApproveRegistrations(
    userIds: string[],
    message?: string
  ): Promise<ApiResponse<{ successful: number; failed: string[] }>> {
    return this.post("/api/users/bulk/approve-registrations", {
      userIds,
      message,
    });
  }

  /**
   * Bulk validate multiple profiles
   */
  async bulkValidateProfiles(
    userIds: string[],
    action: "VALIDATE" | "REJECT",
    notes?: string
  ): Promise<ApiResponse<{ successful: number; failed: string[] }>> {
    return this.post("/api/users/bulk/validate-profiles", {
      userIds,
      action,
      notes,
    });
  }

  /**
   * Bulk suspend multiple users
   */
  async bulkSuspendUsers(
    userIds: string[]
  ): Promise<ApiResponse<{ successful: number; failed: string[] }>> {
    return this.post("/api/users/bulk/suspend", { userIds });
  }

  /**
   * Export users with current filters
   */
  async exportUsers(filters?: UserFilters): Promise<
    ApiResponse<{
      downloadUrl: string;
      filename: string;
    }>
  > {
    return this.post("/api/users/export", { filters });
  }

  // ========================================
  // STATISTICS AND ANALYTICS
  // ========================================

  /**
   * Get user statistics for dashboard
   */
  async getUserStatistics(): Promise<
    ApiResponse<{
      total: number;
      active: number;
      inactive: number;
      pending: number;
      pendingValidation: number;
      suspended: number;
      rejected: number;
      validated: number;
      byUserType: Record<string, number>;
      recentRegistrations: number;
      pendingActions: number;
    }>
  > {
    return this.get("/api/users/statistics");
  }

  /**
   * Get user activity timeline
   */
  async getUserActivity(
    userId: string,
    limit?: number
  ): Promise<
    ApiResponse<
      Array<{
        id: string;
        action: string;
        timestamp: string;
        performedBy: {
          id: string;
          name: string;
          email: string;
        };
        details?: any;
      }>
    >
  > {
    const params = limit ? `?limit=${limit}` : "";
    return this.get(`/api/users/${userId}/activity${params}`);
  }
}
// Export singleton instance
export const usersApiClient = new UsersApiClient();
-----------------------------------------------------------------------
--++--> lib/api/clients/auth/tenant.client.ts =======>
import { BaseApiClient, ApiResponse } from "../../base.client";
import type {
  Tenant,
  User,
  UserFilters,
} from "@/lib/types/database/schema.types";

export class TenantsApiClient extends BaseApiClient {
  constructor() {
    super("tenants");
  }

  // ========================================
  // TENANT MANAGEMENT ENDPOINTS
  // ========================================

  async createTenant(request: {
    name: string;
    slug: string;
    domain: string;
    logo?: string;
    settings?: any;
    isActive?: boolean;
  }): Promise<ApiResponse<Tenant>> {
    return this.post<Tenant>("/api/tenants", request);
  }

  async getTenants(filters?: {
    page?: number;
    limit?: number;
    name?: string;
    slug?: string;
    isActive?: boolean;
  }) {
    return this.getPaginated<Tenant>("/api/tenants", filters);
  }

  async getCurrentTenant(): Promise<ApiResponse<Tenant & { stats: any }>> {
    return this.get<Tenant & { stats: any }>("/api/tenants/current");
  }

  async updateCurrentTenant(request: {
    name?: string;
    slug?: string;
    domain?: string;
    logo?: string;
    settings?: any;
    isActive?: boolean;
  }): Promise<ApiResponse<Tenant>> {
    return this.patch<Tenant>("/api/tenants/current", request);
  }

  async getTenantStats() {
    return this.get<{
      totalUsers: number;
      activeUsers: number;
      newUsersThisMonth: number;
      totalRoles: number;
      totalParcels: number;
      parcelsThisMonth: number;
      totalInvoices: number;
      invoicesThisMonth: number;
      totalClaims: number;
      claimsThisMonth: number;
      recentActivity: any;
      trends: any;
    }>("/api/tenants/current/stats");
  }

  async getTenantUsers(filters?: UserFilters) {
    return this.getPaginated<User>("/api/tenants/current/users", filters);
  }

  async updateTenantSettings(settings: any): Promise<ApiResponse<Tenant>> {
    return this.patch<Tenant>("/api/tenants/current/settings", settings);
  }
}
// Export singleton instance
export const tenantsApiClient = new TenantsApiClient();
-----------------------------------------------------------------------
--++--> lib/api/base.client.ts =======>
-----------------------------------------------------------------------
import axios, {
  AxiosInstance,
  AxiosRequestConfig,
  AxiosResponse,
  AxiosError,
  InternalAxiosRequestConfig,
} from "axios";
import { API_CONFIG, ServiceName, ErrorCode } from "@/lib/config/api.config";
import { getTenantFromUrl } from "@/lib/utils/tenant.utils";
// Extend Axios request config to include metadata
interface ExtendedAxiosRequestConfig extends InternalAxiosRequestConfig {
  metadata?: {
    startTime: number;
  };
}
export interface ApiError {
  code: ErrorCode;
  message: string;
  details?: any;
  statusCode?: number;
  timestamp: string;
  requestId?: string;
}
export interface ApiResponse<T = any> {
  success: boolean;
  data?: T;
  error?: ApiError;
  message?: string;
  timestamp: string;
}
export interface PaginatedResponse<T = any> {
  data: T[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
}
export class BaseApiClient {
  protected client: AxiosInstance;
  protected serviceName: ServiceName;
  protected tenantId: string | null = null;

  constructor(serviceName: ServiceName, customConfig?: AxiosRequestConfig) {
    this.serviceName = serviceName;
    const serviceConfig = API_CONFIG.services[serviceName];

    // Get tenant ID from URL
    this.tenantId = getTenantFromUrl();

    // Create axios instance
    this.client = axios.create({
      baseURL: serviceConfig.baseURL,
      timeout: serviceConfig.timeout,
      headers: {
        ...API_CONFIG.headers.common,
        ...(this.tenantId && { [API_CONFIG.headers.tenant]: this.tenantId }),
      },
      ...customConfig,
    });

    this.setupInterceptors();
  }

  private setupInterceptors(): void {
    // Request interceptor
    this.client.interceptors.request.use(
      (config: ExtendedAxiosRequestConfig) => {
        // Add auth token
        const token = this.getAuthToken();
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }

        // Add tenant ID if available
        if (this.tenantId) {
          config.headers[API_CONFIG.headers.tenant] = this.tenantId;
        }

        // Add request timestamp for debugging
        config.metadata = { startTime: Date.now() };

        return config;
      },
      (error) => Promise.reject(this.transformError(error))
    );

    // Response interceptor
    this.client.interceptors.response.use(
      (response: AxiosResponse) => {
        // Log response time for monitoring
        const endTime = Date.now();
        const config = response.config as ExtendedAxiosRequestConfig;
        const startTime = config.metadata?.startTime || endTime;
        const duration = endTime - startTime;

        if (duration > 3000) {
          console.warn(
            `Slow API request detected: ${response.config.url} took ${duration}ms`
          );
        }

        return response;
      },
      async (error: AxiosError) => {
        // Handle token refresh
        if (error.response?.status === 401 && this.serviceName === "auth") {
          const refreshed = await this.attemptTokenRefresh();
          if (refreshed && error.config) {
            // Retry original request with new token
            const token = this.getAuthToken();
            if (token) {
              error.config.headers.Authorization = `Bearer ${token}`;
            }
            return this.client.request(error.config);
          }
        }

        return Promise.reject(this.transformError(error));
      }
    );
  }

  private getAuthToken(): string | null {
    if (typeof window === "undefined") return null;
    return localStorage.getItem("auth_token");
  }

  private async attemptTokenRefresh(): Promise<boolean> {
    try {
      const refreshToken = localStorage.getItem("refresh_token");
      if (!refreshToken) return false;

      // Only attempt refresh from auth service
      if (this.serviceName !== "auth") return false;

      const response = await axios.post(
        `${API_CONFIG.services.auth.baseURL}/api/auth/refresh`,
        { refreshToken },
        {
          headers: {
            "Content-Type": "application/json",
            ...(this.tenantId && {
              [API_CONFIG.headers.tenant]: this.tenantId,
            }),
          },
        }
      );

      if (response.data.success && response.data.data) {
        const { accessToken, refreshToken: newRefreshToken } =
          response.data.data;
        localStorage.setItem("auth_token", accessToken);
        if (newRefreshToken) {
          localStorage.setItem("refresh_token", newRefreshToken);
        }
        return true;
      }
    } catch (error) {
      console.error("Token refresh failed:", error);
      this.clearAuthTokens();
    }
    return false;
  }

  private clearAuthTokens(): void {
    if (typeof window !== "undefined") {
      localStorage.removeItem("auth_token");
      localStorage.removeItem("refresh_token");
    }
  }

  private transformError(error: any): ApiError {
    const timestamp = new Date().toISOString();

    // Network or timeout errors
    if (!error.response) {
      return {
        code: error.code === "ECONNABORTED" ? "TIMEOUT_ERROR" : "NETWORK_ERROR",
        message: error.message || "Network error occurred",
        timestamp,
      };
    }

    // HTTP errors with response
    const { status, data } = error.response;
    const statusCode = status;

    // Map status codes to error codes
    let code: ErrorCode = "SERVER_ERROR";
    switch (statusCode) {
      case 400:
        code = "VALIDATION_ERROR";
        break;
      case 401:
        code = "AUTH_ERROR";
        break;
      case 403:
        code = "PERMISSION_ERROR";
        break;
      case 404:
        code = "NOT_FOUND";
        break;
      case 409:
        code = "CONFLICT";
        break;
      case 429:
        code = "RATE_LIMIT_ERROR";
        break;
      case 500:
      case 502:
      case 503:
      case 504:
        code = "SERVER_ERROR";
        break;
    }

    return {
      code,
      message:
        data?.message || data?.error || error.message || "An error occurred",
      details: data?.details,
      statusCode,
      timestamp,
      requestId: data?.requestId,
    };
  }

  // Generic HTTP methods
  protected async get<T>(
    endpoint: string,
    config?: AxiosRequestConfig
  ): Promise<ApiResponse<T>> {
    try {
      const response = await this.client.get(endpoint, config);
      return this.transformResponse<T>(response);
    } catch (error) {
      throw error; // Error is already transformed by interceptor
    }
  }

  protected async post<T>(
    endpoint: string,
    data?: any,
    config?: AxiosRequestConfig
  ): Promise<ApiResponse<T>> {
    try {
      const response = await this.client.post(endpoint, data, config);
      return this.transformResponse<T>(response);
    } catch (error) {
      throw error;
    }
  }

  protected async put<T>(
    endpoint: string,
    data?: any,
    config?: AxiosRequestConfig
  ): Promise<ApiResponse<T>> {
    try {
      const response = await this.client.put(endpoint, data, config);
      return this.transformResponse<T>(response);
    } catch (error) {
      throw error;
    }
  }

  protected async patch<T>(
    endpoint: string,
    data?: any,
    config?: AxiosRequestConfig
  ): Promise<ApiResponse<T>> {
    try {
      const response = await this.client.patch(endpoint, data, config);
      return this.transformResponse<T>(response);
    } catch (error) {
      throw error;
    }
  }

  protected async delete<T>(
    endpoint: string,
    config?: AxiosRequestConfig
  ): Promise<ApiResponse<T>> {
    try {
      const response = await this.client.delete(endpoint, config);
      return this.transformResponse<T>(response);
    } catch (error) {
      throw error;
    }
  }

  // Paginated requests
  protected async getPaginated<T>(
    endpoint: string,
    params?: Record<string, any>,
    config?: AxiosRequestConfig
  ): Promise<PaginatedResponse<T>> {
    try {
      const response = await this.client.get(endpoint, {
        ...config,
        params: { ...params, ...config?.params },
      });

      // Handle different response formats
      if (response.data.data && response.data.pagination) {
        // Standard paginated format: { data: T[], pagination: {...} }
        return response.data;
      } else if (Array.isArray(response.data.data)) {
        // Array wrapped in data property: { data: T[] }
        return {
          data: response.data.data,
          pagination: {
            page: 1,
            limit: response.data.data.length,
            total: response.data.data.length,
            totalPages: 1,
            hasNext: false,
            hasPrev: false,
          },
        };
      } else if (Array.isArray(response.data)) {
        // Direct array response: T[]
        return {
          data: response.data,
          pagination: {
            page: 1,
            limit: response.data.length,
            total: response.data.length,
            totalPages: 1,
            hasNext: false,
            hasPrev: false,
          },
        };
      } else if (response.data.success && response.data.data) {
        // Wrapped in success envelope: { success: true, data: T[] }
        const data = Array.isArray(response.data.data)
          ? response.data.data
          : [response.data.data];
        return {
          data,
          pagination: {
            page: 1,
            limit: data.length,
            total: data.length,
            totalPages: 1,
            hasNext: false,
            hasPrev: false,
          },
        };
      }

      // Log the actual response structure for debugging
      console.error("Unexpected response structure:", {
        data: response.data,
        dataType: typeof response.data,
        isArray: Array.isArray(response.data),
        hasData: "data" in response.data,
        hasSuccess: "success" in response.data,
        hasPagination: "pagination" in response.data,
      });

      throw new Error(
        `Invalid paginated response format. Expected array or paginated object, got: ${typeof response.data}`
      );
    } catch (error) {
      throw error;
    }
  }

  private transformResponse<T>(response: AxiosResponse): ApiResponse<T> {
    return {
      success: true,
      data: response.data.data || response.data,
      message: response.data.message,
      timestamp: new Date().toISOString(),
    };
  }

  // Utility methods
  public setTenant(tenantId: string): void {
    this.tenantId = tenantId;
    this.client.defaults.headers[API_CONFIG.headers.tenant] = tenantId;
  }

  public clearTenant(): void {
    this.tenantId = null;
    delete this.client.defaults.headers[API_CONFIG.headers.tenant];
  }

  public getServiceName(): ServiceName {
    return this.serviceName;
  }

  public getBaseURL(): string {
    return this.client.defaults.baseURL || "";
  }
}
-----------------------------------------------------------------------
--++--> lib/stores/auth/auth.store.ts =======>
-----------------------------------------------------------------------
import { create } from "zustand";
import { persist } from "zustand/middleware";
import { authApiClient } from "@/lib/api/clients/auth/auth.client";
import { usersApiClient } from "@/lib/api/clients/auth/users.client";
import { setCookie, getCookie, deleteCookie } from "@/lib/utils/cookie.utils";
import type { User, UserType } from "@/lib/types/database/schema.types";
import type {
  LoginRequest,
  RegisterRequest,
  AccountStatusResponse,
  AccountStatus,
  ValidationStatus,
  AccessLevel,
} from "@/lib/types/auth/auth.types";
interface AuthState {
  // Core state
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  error: string | null;
  isInitialized: boolean;

  // Account status workflow
  accountStatus: AccountStatus | null;
  validationStatus: ValidationStatus | null;
  accessLevel: AccessLevel | null;
  requirements: string[];
  hasBlueCheckmark: boolean;

  // Token management
  accessToken: string | null;
  refreshToken: string | null;
  tokenExpiresAt: number | null;

  // Session management
  lastActivity: number;
  sessionTimeoutWarning: boolean;

  // Prevent infinite loops and duplicate calls
  isCheckingAuth: boolean;
  isRefreshing: boolean;
  checkAuthPromise: Promise<void> | null;
  refreshPromise: Promise<boolean> | null;

  // Actions
  login: (credentials: LoginRequest) => Promise<LoginResult>;
  register: (userData: RegisterRequest) => Promise<RegisterResult>;
  logout: () => Promise<void>;
  refreshSession: () => Promise<boolean>;
  checkAuth: () => Promise<void>;

  // Account status management
  updateAccountStatus: () => Promise<AccountStatusResponse | null>;
  completeProfile: (profileData: any) => Promise<ProfileResult>;

  // User management
  updateUser: (userData: Partial<User>) => void;
  updateProfile: (profileData: any) => Promise<boolean>;

  // Permission methods
  hasPermission: (permission: string) => boolean;
  hasAnyPermission: (permissions: string[]) => boolean;
  hasAllPermissions: (permissions: string[]) => boolean;
  hasRole: (roleName: string) => boolean;
  hasUserType: (userType: UserType) => boolean;

  // Access level utilities
  canAccessDashboard: () => boolean;
  canAccessFullFeatures: () => boolean;
  needsProfileCompletion: () => boolean;
  needsValidation: () => boolean;
  isAccountBlocked: () => boolean;

  // Session utilities
  updateLastActivity: () => void;
  isSessionExpired: () => boolean;
  getTimeUntilExpiry: () => number;
  setSessionTimeoutWarning: (show: boolean) => void;
  extendSession: () => Promise<void>;

  // State management
  clearError: () => void;
  setLoading: (loading: boolean) => void;
  getUserProfile: () => Promise<User | null>;
}
// Result types for better type safety
interface LoginResult {
  success: boolean;
  error?: string;
  redirectTo?: string;
  accessLevel?: AccessLevel;
  requirements?: string[];
  message?: string;
}
interface RegisterResult {
  success: boolean;
  error?: string;
  message?: string;
  accountStatus?: AccountStatus;
  nextSteps?: string[];
}
interface ProfileResult {
  success: boolean;
  error?: string;
  message?: string;
}
// Constants
const TOKEN_STORAGE_KEY = "auth_token";
const REFRESH_TOKEN_STORAGE_KEY = "refresh_token";
const SESSION_TIMEOUT = 30 * 60 * 1000; // 30 minutes
const AUTO_REFRESH_THRESHOLD = 2 * 60 * 1000; // 2 minutes before expiry
// Storage utilities
const tokenStorage = {
  store: (accessToken: string, refreshToken: string, expiresIn: number) => {
    if (typeof window === "undefined") return;

    const tokenExpiryDays = Math.ceil(expiresIn / (24 * 60 * 60));

    // Store in localStorage and cookies
    localStorage.setItem(TOKEN_STORAGE_KEY, accessToken);
    localStorage.setItem(REFRESH_TOKEN_STORAGE_KEY, refreshToken);
    setCookie(TOKEN_STORAGE_KEY, accessToken, tokenExpiryDays);
    setCookie(REFRESH_TOKEN_STORAGE_KEY, refreshToken, tokenExpiryDays);

    // Cross-tab communication
    localStorage.setItem("auth_login", Date.now().toString());
    localStorage.removeItem("auth_logout");
  },

  clear: () => {
    if (typeof window === "undefined") return;

    localStorage.removeItem(TOKEN_STORAGE_KEY);
    localStorage.removeItem(REFRESH_TOKEN_STORAGE_KEY);
    deleteCookie(TOKEN_STORAGE_KEY);
    deleteCookie(REFRESH_TOKEN_STORAGE_KEY);

    // Cross-tab communication
    localStorage.setItem("auth_logout", Date.now().toString());
    localStorage.removeItem("auth_login");
  },

  get: () => {
    if (typeof window === "undefined")
      return { accessToken: null, refreshToken: null };

    const accessToken =
      localStorage.getItem(TOKEN_STORAGE_KEY) || getCookie(TOKEN_STORAGE_KEY);
    const refreshToken =
      localStorage.getItem(REFRESH_TOKEN_STORAGE_KEY) ||
      getCookie(REFRESH_TOKEN_STORAGE_KEY);

    return { accessToken, refreshToken };
  },
};
// Access level helpers
const accessLevelHelpers = {
  canAccess: (current: AccessLevel | null, required: AccessLevel): boolean => {
    const levels = ["NO_ACCESS", "PROFILE_ONLY", "LIMITED", "FULL"];
    const currentIndex = levels.indexOf(current || "NO_ACCESS");
    const requiredIndex = levels.indexOf(required);
    return currentIndex >= requiredIndex;
  },

  getRedirectPath: (
    accessLevel: AccessLevel | null,
    accountStatus: AccountStatus | null
  ): string => {
    if (accessLevel === "PROFILE_ONLY" || accountStatus === "INACTIVE") {
      return "/profile/complete";
    }
    return "/dashboard";
  },
};
export const useAuthStore = create<AuthState>()(
  persist(
    (set, get) => ({
      // Initial state
      user: null,
      isAuthenticated: false,
      isLoading: false,
      error: null,
      isInitialized: false,
      accessToken: null,
      refreshToken: null,
      tokenExpiresAt: null,
      lastActivity: Date.now(),
      sessionTimeoutWarning: false,
      isCheckingAuth: false,
      isRefreshing: false,
      checkAuthPromise: null,
      refreshPromise: null,
      accountStatus: null,
      validationStatus: null,
      accessLevel: null,
      requirements: [],
      hasBlueCheckmark: false,

      // Optimized login method
      login: async (credentials: LoginRequest): Promise<LoginResult> => {
        set({ isLoading: true, error: null });

        try {
          const response = await authApiClient.login(credentials);

          if (!response.success || !response.data) {
            const error = response.error?.message || "Login failed";
            set({
              isLoading: false,
              error,
              isInitialized: true,
              isAuthenticated: false,
            });
            return { success: false, error };
          }

          const loginData = response.data;

          // Handle access denied scenarios
          if (loginData.accessDenied) {
            set({
              isLoading: false,
              error: loginData.message,
              isInitialized: true,
              isAuthenticated: false,
              accountStatus: loginData.accountStatus || null,
            });
            return {
              success: false,
              error: loginData.message,
              accessLevel: "NO_ACCESS",
            };
          }

          // Handle successful login
          if (
            loginData.user &&
            loginData.accessToken &&
            loginData.refreshToken
          ) {
            const {
              user,
              accessToken,
              refreshToken,
              expiresIn = 86400,
            } = loginData;
            const tokenExpiresAt = Date.now() + expiresIn * 1000;

            tokenStorage.store(accessToken, refreshToken, expiresIn);

            // Determine access level and redirect
            const accessLevel: AccessLevel = loginData.fullAccess
              ? "FULL"
              : loginData.limitedAccess
              ? "LIMITED"
              : loginData.profileAccess || loginData.requiresProfileCompletion
              ? "PROFILE_ONLY"
              : "NO_ACCESS";

            const redirectTo = accessLevelHelpers.getRedirectPath(
              accessLevel,
              loginData.accountStatus
            );

            set({
              user,
              isAuthenticated: true,
              isLoading: false,
              error: null,
              accessToken,
              refreshToken,
              tokenExpiresAt,
              lastActivity: Date.now(),
              isInitialized: true,
              sessionTimeoutWarning: false,
              accountStatus: loginData.accountStatus || user.accountStatus,
              validationStatus:
                loginData.validationStatus || user.validationStatus,
              accessLevel,
              requirements: [],
              hasBlueCheckmark: user.validationStatus === "VALIDATED",
              checkAuthPromise: null,
              refreshPromise: null,
            });

            return {
              success: true,
              redirectTo,
              accessLevel,
              message: loginData.message,
            };
          }

          const error = "Invalid login response";
          set({
            isLoading: false,
            error,
            isInitialized: true,
            isAuthenticated: false,
          });
          return { success: false, error };
        } catch (error: any) {
          const errorMessage = error?.message || "Network error during login";
          set({
            isLoading: false,
            error: errorMessage,
            isInitialized: true,
            isAuthenticated: false,
          });
          return { success: false, error: errorMessage };
        }
      },

      // Optimized register method
      register: async (userData: RegisterRequest): Promise<RegisterResult> => {
        set({ isLoading: true, error: null });

        try {
          const response = await authApiClient.register(userData);

          if (response.success && response.data) {
            const { success, message, accountStatus, nextSteps } =
              response.data;

            set({
              isLoading: false,
              error: null,
              isInitialized: true,
              accountStatus,
            });
            return { success: true, message, accountStatus, nextSteps };
          }

          const error = response.error?.message || "Registration failed";
          set({ isLoading: false, error, isInitialized: true });
          return { success: false, error };
        } catch (error: any) {
          const errorMessage =
            error?.message || "Network error during registration";
          set({ isLoading: false, error: errorMessage, isInitialized: true });
          return { success: false, error: errorMessage };
        }
      },

      // Optimized logout method
      logout: async () => {
        const { refreshToken } = get();

        // Clear tokens immediately for better UX
        tokenStorage.clear();
        set({
          user: null,
          isAuthenticated: false,
          accessToken: null,
          refreshToken: null,
          tokenExpiresAt: null,
          error: null,
          sessionTimeoutWarning: false,
          isInitialized: true,
          lastActivity: Date.now(),
          isCheckingAuth: false,
          isRefreshing: false,
          checkAuthPromise: null,
          refreshPromise: null,
          accountStatus: null,
          validationStatus: null,
          accessLevel: null,
          requirements: [],
          hasBlueCheckmark: false,
        });

        // Call logout API in background
        if (refreshToken) {
          authApiClient.logout({ refreshToken }).catch(console.error);
        }
      },

      // Optimized refresh session
      refreshSession: async (): Promise<boolean> => {
        const { isRefreshing, refreshPromise, refreshToken } = get();

        if (isRefreshing && refreshPromise) return refreshPromise;
        if (!refreshToken) {
          await get().logout();
          return false;
        }

        const promise = (async (): Promise<boolean> => {
          set({ isRefreshing: true });

          try {
            const response = await authApiClient.refreshToken({ refreshToken });

            if (response.success && response.data) {
              const {
                user,
                accessToken,
                refreshToken: newRefreshToken,
                expiresIn = 86400,
              } = response.data;
              const tokenExpiresAt = Date.now() + expiresIn * 1000;

              tokenStorage.store(accessToken, newRefreshToken, expiresIn);

              set({
                user,
                accessToken,
                refreshToken: newRefreshToken,
                tokenExpiresAt,
                lastActivity: Date.now(),
                sessionTimeoutWarning: false,
                isInitialized: true,
                isAuthenticated: true,
                isRefreshing: false,
                refreshPromise: null,
              });

              // Update account status in background
              get().updateAccountStatus().catch(console.error);
              return true;
            }

            set({ isRefreshing: false, refreshPromise: null });
            await get().logout();
            return false;
          } catch (error) {
            console.error("Token refresh failed:", error);
            set({ isRefreshing: false, refreshPromise: null });
            await get().logout();
            return false;
          }
        })();

        set({ refreshPromise: promise });
        return promise;
      },

      // Optimized checkAuth - prevents infinite loops
      checkAuth: async (): Promise<void> => {
        const state = get();

        // Early return conditions to prevent loops
        if (state.isCheckingAuth && state.checkAuthPromise)
          return state.checkAuthPromise;
        if (state.isRefreshing) return Promise.resolve();
        if (state.isInitialized && state.isAuthenticated && state.user)
          return Promise.resolve();

        const promise = (async (): Promise<void> => {
          set({ isCheckingAuth: true, checkAuthPromise: null });

          try {
            const { accessToken, refreshToken } = tokenStorage.get();

            if (!accessToken || !refreshToken) {
              set({
                isAuthenticated: false,
                isLoading: false,
                isInitialized: true,
                user: null,
                accessToken: null,
                refreshToken: null,
                tokenExpiresAt: null,
                isCheckingAuth: false,
                checkAuthPromise: null,
              });
              return;
            }

            // Set tokens without triggering additional calls
            set({ accessToken, refreshToken });

            // Single API call for profile
            const profileResponse = await authApiClient.getProfile();

            if (profileResponse.success && profileResponse.data) {
              const profile = profileResponse.data;

              set({
                user: profile,
                isAuthenticated: true,
                isLoading: false,
                lastActivity: Date.now(),
                isInitialized: true,
                error: null,
                isCheckingAuth: false,
                checkAuthPromise: null,
              });

              // Update status in background without blocking
              get().updateAccountStatus().catch(console.error);
            } else {
              // Try refresh without recursive calls
              set({ isCheckingAuth: false, checkAuthPromise: null });

              const currentState = get();
              if (!currentState.isRefreshing) {
                const refreshed = await get().refreshSession();
                if (!refreshed) {
                  set({
                    user: null,
                    isAuthenticated: false,
                    accessToken: null,
                    refreshToken: null,
                    tokenExpiresAt: null,
                    isLoading: false,
                    isInitialized: true,
                  });
                }
              }
            }
          } catch (error) {
            console.error("Auth check failed:", error);
            set({
              user: null,
              isAuthenticated: false,
              accessToken: null,
              refreshToken: null,
              tokenExpiresAt: null,
              isLoading: false,
              isInitialized: true,
              error:
                error instanceof Error
                  ? error.message
                  : "Authentication failed",
              isCheckingAuth: false,
              checkAuthPromise: null,
            });
          }
        })();

        set({ checkAuthPromise: promise });
        return promise;
      },

      // Account status management
      updateAccountStatus: async (): Promise<AccountStatusResponse | null> => {
        try {
          const response = await authApiClient.getAccountStatus();
          if (response.success && response.data) {
            const status = response.data;
            set({
              accountStatus: status.accountStatus,
              validationStatus: status.validationStatus,
              accessLevel: status.accessLevel,
              requirements: status.requirements,
              hasBlueCheckmark: status.hasBlueCheckmark,
            });
            return status;
          }
        } catch (error) {
          console.error("Failed to update account status:", error);
        }
        return null;
      },

      // Complete profile method
      completeProfile: async (profileData: any): Promise<ProfileResult> => {
        set({ isLoading: true, error: null });

        try {
          const response = await authApiClient.completeProfile(profileData);

          if (response.success && response.data) {
            const { user, message, accountStatus, validationStatus } =
              response.data;

            set({
              user,
              accountStatus,
              validationStatus,
              accessLevel: "LIMITED",
              isLoading: false,
            });

            return { success: true, message };
          }

          const error = response.error?.message || "Failed to complete profile";
          set({ isLoading: false, error });
          return { success: false, error };
        } catch (error: any) {
          const errorMessage = error?.message || "Network error";
          set({ isLoading: false, error: errorMessage });
          return { success: false, error: errorMessage };
        }
      },

      // Utility methods
      getUserProfile: async (): Promise<User | null> => {
        const { user, isAuthenticated, isCheckingAuth } = get();
        if (user && isAuthenticated) return user;
        if (!isCheckingAuth) await get().checkAuth();
        return get().user;
      },

      updateUser: (userData: Partial<User>) => {
        const { user } = get();
        if (user) set({ user: { ...user, ...userData } });
      },

      updateProfile: async (profileData: any): Promise<boolean> => {
        const { user } = get();
        if (!user) return false;

        try {
          const response = await usersApiClient.updateUser(
            user.id,
            profileData
          );
          if (response.success && response.data) {
            set({ user: response.data });
            return true;
          }
        } catch (error) {
          console.error("Profile update failed:", error);
        }
        return false;
      },

      // Permission methods
      hasPermission: (permission: string): boolean => {
        const { user } = get();
        if (!user?.role?.permissions) return false;
        const permissions = user.role.permissions;
        return permissions.includes(permission) || permissions.includes("*");
      },

      hasAnyPermission: (permissions: string[]): boolean =>
        permissions.some((permission) => get().hasPermission(permission)),

      hasAllPermissions: (permissions: string[]): boolean =>
        permissions.every((permission) => get().hasPermission(permission)),

      hasRole: (roleName: string): boolean => {
        const { user } = get();
        return user?.role?.name === roleName;
      },

      hasUserType: (userType: UserType): boolean => {
        const { user } = get();
        return user?.userType === userType;
      },

      // Access level utilities
      canAccessDashboard: (): boolean => {
        const { accessLevel } = get();
        return accessLevelHelpers.canAccess(accessLevel, "LIMITED");
      },

      canAccessFullFeatures: (): boolean => {
        const { accessLevel } = get();
        return accessLevelHelpers.canAccess(accessLevel, "FULL");
      },

      needsProfileCompletion: (): boolean => {
        const { accessLevel, accountStatus } = get();
        return accessLevel === "PROFILE_ONLY" || accountStatus === "INACTIVE";
      },

      needsValidation: (): boolean => {
        const { accountStatus, validationStatus } = get();
        return (
          accountStatus === "PENDING_VALIDATION" &&
          validationStatus === "PENDING"
        );
      },

      isAccountBlocked: (): boolean => {
        const { accessLevel, accountStatus } = get();
        return (
          accessLevel === "NO_ACCESS" ||
          accountStatus === "PENDING" ||
          accountStatus === "REJECTED" ||
          accountStatus === "SUSPENDED"
        );
      },

      // Session utilities
      updateLastActivity: () => set({ lastActivity: Date.now() }),

      isSessionExpired: (): boolean => {
        const { lastActivity } = get();
        return Date.now() - lastActivity > SESSION_TIMEOUT;
      },

      getTimeUntilExpiry: (): number => {
        const { tokenExpiresAt } = get();
        return tokenExpiresAt ? Math.max(0, tokenExpiresAt - Date.now()) : 0;
      },

      setSessionTimeoutWarning: (show: boolean) =>
        set({ sessionTimeoutWarning: show }),

      extendSession: async (): Promise<void> => {
        const { isAuthenticated, tokenExpiresAt, isRefreshing } = get();
        if (!isAuthenticated || isRefreshing) return;

        const timeUntilExpiry = tokenExpiresAt
          ? tokenExpiresAt - Date.now()
          : 0;
        if (timeUntilExpiry <= AUTO_REFRESH_THRESHOLD) {
          await get().refreshSession();
        } else {
          get().updateLastActivity();
        }
      },

      // State management
      clearError: () => set({ error: null }),
      setLoading: (loading: boolean) => set({ isLoading: loading }),
    }),
    {
      name: "auth-store",
      partialize: (state) => ({
        user: state.user,
        lastActivity: state.lastActivity,
        accountStatus: state.accountStatus,
        validationStatus: state.validationStatus,
        accessLevel: state.accessLevel,
      }),
      version: 5,
      migrate: (persistedState: any, version: number) => {
        if (version < 5) {
          return {
            user: persistedState?.user || null,
            lastActivity: persistedState?.lastActivity || Date.now(),
            accountStatus: persistedState?.accountStatus || null,
            validationStatus: persistedState?.validationStatus || null,
            accessLevel: persistedState?.accessLevel || null,
          };
        }
        return persistedState;
      },
    }
  )
);
-----------------------------------------------------------------------
--++--> lib/stores/auth/tenant.store.ts =======>
-----------------------------------------------------------------------
import { create } from "zustand";
import { persist } from "zustand/middleware";
import { tenantsApiClient } from "@/lib/api/clients/auth/tenants.client";
import { sanitizeTenantData } from "@/lib/utils/data-sanitizer.utils";
import type { Tenant } from "@/lib/types/database/schema.types";
// Extended tenant interface for UI needs
export interface ExtendedTenant extends Tenant {
  // Additional UI-specific properties
  features?: string[];
  permissions?: string[];
  stats?: {
    totalUsers?: number;
    activeUsers?: number;
    totalParcels?: number;
    totalInvoices?: number;
    totalClaims?: number;
  };
}
interface TenantState {
  // Core state
  currentTenant: ExtendedTenant | null;
  tenants: ExtendedTenant[];
  isLoading: boolean;
  error: string | null;

  // Actions
  setTenant: (tenant: ExtendedTenant) => void;
  setTenants: (tenants: ExtendedTenant[]) => void;
  addTenant: (tenant: ExtendedTenant) => void;
  updateTenant: (tenantId: string, updates: Partial<ExtendedTenant>) => void;
  removeTenant: (tenantId: string) => void;
  clearCurrentTenant: () => void;

  // API Actions
  fetchTenants: () => Promise<void>;
  fetchCurrentTenant: () => Promise<void>;
  fetchTenantById: (tenantId: string) => Promise<ExtendedTenant | null>;
  switchTenant: (tenantId: string) => Promise<boolean>;
  updateTenantSettings: (settings: any) => Promise<boolean>;

  // Utility methods
  getTenantSettings: () => any;
  getCurrentTenantId: () => string | null;
  isTenantActive: (tenantId: string) => boolean;

  // Feature/Permission checking
  hasFeature: (feature: string) => boolean;
  getTenantPermissions: () => string[];
  canAccessResource: (resource: string) => boolean;

  // Error handling
  clearError: () => void;
  setError: (error: string) => void;
}
export const useTenantStore = create<TenantState>()(
  persist(
    (set, get) => ({
      // Initial state
      currentTenant: null,
      tenants: [],
      isLoading: false,
      error: null,

      // Basic setters with data sanitization
      setTenant: (tenant: ExtendedTenant) => {
        try {
          // Sanitize tenant data to prevent React render errors
          const sanitizedTenant = sanitizeTenantData(tenant);

          set({ currentTenant: sanitizedTenant, error: null });

          // Update API client tenant context
          if (typeof window !== "undefined") {
            localStorage.setItem("current_tenant_id", sanitizedTenant.id);
          }
        } catch (error) {
          console.error("Error setting tenant:", error);
          set({ error: "Failed to set tenant data" });
        }
      },

      setTenants: (tenants: ExtendedTenant[]) => {
        try {
          // Sanitize all tenant data
          const sanitizedTenants = tenants.map((tenant) =>
            sanitizeTenantData(tenant)
          );
          set({ tenants: sanitizedTenants, error: null });
        } catch (error) {
          console.error("Error setting tenants:", error);
          set({ error: "Failed to set tenants data" });
        }
      },

      addTenant: (tenant: ExtendedTenant) => {
        try {
          const { tenants } = get();
          const sanitizedTenant = sanitizeTenantData(tenant);
          set({ tenants: [...tenants, sanitizedTenant] });
        } catch (error) {
          console.error("Error adding tenant:", error);
          set({ error: "Failed to add tenant" });
        }
      },

      updateTenant: (tenantId: string, updates: Partial<ExtendedTenant>) => {
        try {
          const { tenants, currentTenant } = get();

          // Sanitize updates
          const sanitizedUpdates = sanitizeTenantData(updates);

          // Update in tenants list
          const updatedTenants = tenants.map((tenant) =>
            tenant.id === tenantId ? { ...tenant, ...sanitizedUpdates } : tenant
          );
          set({ tenants: updatedTenants });

          // Update current tenant if it's the one being updated
          if (currentTenant?.id === tenantId) {
            set({ currentTenant: { ...currentTenant, ...sanitizedUpdates } });
          }
        } catch (error) {
          console.error("Error updating tenant:", error);
          set({ error: "Failed to update tenant" });
        }
      },

      removeTenant: (tenantId: string) => {
        try {
          const { tenants, currentTenant } = get();

          const updatedTenants = tenants.filter(
            (tenant) => tenant.id !== tenantId
          );
          set({ tenants: updatedTenants });

          // Clear current tenant if it's the one being removed
          if (currentTenant?.id === tenantId) {
            get().clearCurrentTenant();
          }
        } catch (error) {
          console.error("Error removing tenant:", error);
          set({ error: "Failed to remove tenant" });
        }
      },

      clearCurrentTenant: () => {
        set({ currentTenant: null });

        if (typeof window !== "undefined") {
          localStorage.removeItem("current_tenant_id");
        }
      },

      // API Actions with enhanced error handling
      fetchTenants: async () => {
        set({ isLoading: true, error: null });

        try {
          const response = await tenantsApiClient.getTenants();

          if (response.success && response.data) {
            // Sanitize all tenant data
            const sanitizedTenants = Array.isArray(response.data)
              ? response.data.map((tenant) => sanitizeTenantData(tenant))
              : [sanitizeTenantData(response.data)];

            set({
              tenants: sanitizedTenants,
              isLoading: false,
              error: null,
            });
          } else {
            throw new Error(
              response.error?.message || "Failed to fetch tenants"
            );
          }
        } catch (paginatedError: any) {
          console.warn("Primary getTenants failed:", paginatedError.message);

          try {
            // Fallback to current tenant
            const fallbackResponse = await tenantsApiClient.getCurrentTenant();

            if (fallbackResponse.success && fallbackResponse.data) {
              const sanitizedTenant = sanitizeTenantData(fallbackResponse.data);

              set({
                tenants: [sanitizedTenant],
                isLoading: false,
                error: null,
              });
            } else {
              throw new Error(
                fallbackResponse.error?.message || "Failed to fetch tenant data"
              );
            }
          } catch (fallbackError: any) {
            console.error("All tenant fetch methods failed:", fallbackError);
            set({
              isLoading: false,
              error:
                fallbackError?.message ||
                "Network error while fetching tenants",
            });
          }
        }
      },

      fetchCurrentTenant: async () => {
        set({ isLoading: true, error: null });

        try {
          const response = await tenantsApiClient.getCurrentTenant();

          if (response.success && response.data) {
            // Sanitize tenant data to prevent React render errors
            const sanitizedTenant = sanitizeTenantData(response.data);

            set({
              currentTenant: sanitizedTenant,
              isLoading: false,
              error: null,
            });

            // Update localStorage
            if (typeof window !== "undefined") {
              localStorage.setItem("current_tenant_id", sanitizedTenant.id);
            }
          } else {
            set({
              isLoading: false,
              error:
                response.error?.message || "Failed to fetch current tenant",
            });
          }
        } catch (error: any) {
          console.error("Fetch current tenant failed:", error);
          set({
            isLoading: false,
            error: error?.message || "Network error while fetching tenant",
          });
        }
      },

      fetchTenantById: async (tenantId: string) => {
        set({ isLoading: true, error: null });

        try {
          const response = await tenantsApiClient.getCurrentTenant();

          if (response.success && response.data) {
            const sanitizedTenant = sanitizeTenantData(response.data);

            set({ isLoading: false, error: null });
            return sanitizedTenant;
          } else {
            set({
              isLoading: false,
              error: response.error?.message || "Failed to fetch tenant",
            });
            return null;
          }
        } catch (error: any) {
          console.error("Fetch tenant by ID failed:", error);
          set({
            isLoading: false,
            error: error?.message || "Network error while fetching tenant",
          });
          return null;
        }
      },

      switchTenant: async (tenantId: string) => {
        try {
          const { tenants } = get();

          // Check if tenant exists in local list
          const tenant = tenants.find((t) => t.id === tenantId);

          if (tenant) {
            get().setTenant(tenant);
            return true;
          } else {
            // Try to fetch the tenant
            const fetchedTenant = await get().fetchTenantById(tenantId);
            if (fetchedTenant) {
              get().setTenant(fetchedTenant);
              return true;
            }
          }

          set({ error: "Failed to switch to tenant" });
          return false;
        } catch (error: any) {
          console.error("Switch tenant failed:", error);
          set({ error: error?.message || "Failed to switch tenant" });
          return false;
        }
      },

      updateTenantSettings: async (settings: any) => {
        try {
          const response = await tenantsApiClient.updateTenantSettings(
            settings
          );

          if (response.success && response.data) {
            const { currentTenant } = get();
            if (currentTenant) {
              // Sanitize settings data
              const sanitizedSettings = sanitizeTenantData({
                settings: response.data.settings,
              });

              get().updateTenant(currentTenant.id, {
                settings: sanitizedSettings.settings,
              });
            }
            return true;
          } else {
            set({
              error: response.error?.message || "Failed to update settings",
            });
            return false;
          }
        } catch (error: any) {
          console.error("Update tenant settings failed:", error);
          set({
            error: error?.message || "Network error while updating settings",
          });
          return false;
        }
      },

      // Utility methods (no changes needed)
      getTenantSettings: () => {
        const { currentTenant } = get();
        return currentTenant?.settings || {};
      },

      getCurrentTenantId: () => {
        const { currentTenant } = get();
        return currentTenant?.id || null;
      },

      isTenantActive: (tenantId: string) => {
        const { currentTenant } = get();
        return currentTenant?.id === tenantId && currentTenant?.isActive;
      },

      // Feature checking
      hasFeature: (feature: string) => {
        const { currentTenant } = get();
        if (!currentTenant?.features) return false;
        return currentTenant.features.includes(feature);
      },

      getTenantPermissions: () => {
        const { currentTenant } = get();
        return currentTenant?.permissions || [];
      },

      canAccessResource: (resource: string) => {
        const permissions = get().getTenantPermissions();
        return permissions.includes(resource) || permissions.includes("*");
      },

      // Error handling
      clearError: () => {
        set({ error: null });
      },

      setError: (error: string) => {
        set({ error });
      },
    }),
    {
      name: "tenant-store",
      partialize: (state) => ({
        currentTenant: state.currentTenant,
        tenants: state.tenants,
        // Don't persist loading states or errors
      }),
      version: 2, // Increment version to handle migration
      migrate: (persistedState: any, version: number) => {
        if (version < 2) {
          // Sanitize any persisted data that might have problematic objects
          return {
            currentTenant: persistedState?.currentTenant
              ? sanitizeTenantData(persistedState.currentTenant)
              : null,
            tenants: Array.isArray(persistedState?.tenants)
              ? persistedState.tenants.map((tenant: any) =>
                  sanitizeTenantData(tenant)
                )
              : [],
          };
        }
        return persistedState;
      },
    }
  )
);
// Helper function to initialize tenant from URL/localStorage with error handling
export const initializeTenantFromContext = async () => {
  if (typeof window === "undefined") return;

  try {
    const store = useTenantStore.getState();

    // Try to get tenant from localStorage first
    const storedTenantId = localStorage.getItem("current_tenant_id");

    if (storedTenantId && !store.currentTenant) {
      // Try to find tenant in local list or fetch it
      const existingTenant = store.tenants.find((t) => t.id === storedTenantId);

      if (existingTenant) {
        store.setTenant(existingTenant);
      } else {
        // Fetch tenant data
        await store.fetchTenantById(storedTenantId);
      }
    }
  } catch (error) {
    console.error("Failed to initialize tenant context:", error);
    // Clear potentially corrupted data
    if (typeof window !== "undefined") {
      localStorage.removeItem("current_tenant_id");
    }
  }
};
// Auto-initialize on client side with error handling
if (typeof window !== "undefined") {
  // Initialize tenant context when store is first accessed
  setTimeout(() => {
    initializeTenantFromContext().catch((error) => {
      console.error("Auto-initialization failed:", error);
    });
  }, 0);
}
-----------------------------------------------------------------------
--++--> lib/stores/parcels/cities.store.ts =======>
-----------------------------------------------------------------------
import { create } from "zustand";
import { persist } from "zustand/middleware";
import { citiesApiClient } from "@/lib/api/clients/parcels/cities.client";
import type {
  City,
  CreateCityRequest,
  UpdateCityRequest,
  CitiesFilters,
  ZoneStats,
} from "@/lib/types/parcels/cities.types";
import { toast } from "sonner";
interface CitiesState {
  // Core state
  cities: City[];
  currentCity: City | null;
  isLoading: boolean;
  error: string | null;

  // Pagination
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };

  // Filters
  filters: CitiesFilters;

  // Additional data
  pickupCities: City[];
  zoneStats: ZoneStats[];
  availableZones: string[];

  // Selection for bulk operations
  selectedCityIds: string[];

  // Actions
  setCities: (cities: City[]) => void;
  setCurrentCity: (city: City | null) => void;
  setPagination: (pagination: Partial<CitiesState["pagination"]>) => void;
  setFilters: (filters: Partial<CitiesFilters>) => void;
  clearError: () => void;
  setSelectedCityIds: (ids: string[]) => void;

  // API Actions
  fetchCities: () => Promise<void>;
  fetchCityById: (id: string) => Promise<City | null>;
  createCity: (data: CreateCityRequest) => Promise<boolean>;
  updateCity: (id: string, data: UpdateCityRequest) => Promise<boolean>;
  deleteCity: (id: string) => Promise<boolean>;
  toggleCityStatus: (id: string) => Promise<boolean>;
  fetchPickupCities: () => Promise<void>;
  fetchZoneStats: () => Promise<void>;
  fetchAvailableZones: () => Promise<void>;

  // Bulk operations
  bulkDeleteCities: (ids: string[]) => Promise<boolean>;
  bulkUpdateStatus: (ids: string[], status: boolean) => Promise<boolean>;

  // Search and validation
  searchCities: (query: string) => Promise<City[]>;
  validateCityRef: (ref: string, excludeId?: string) => Promise<boolean>;

  // Reset state
  resetState: () => void;
}
const initialState = {
  cities: [],
  currentCity: null,
  isLoading: false,
  error: null,
  pagination: {
    page: 1,
    limit: 10,
    total: 0,
    totalPages: 0,
    hasNext: false,
    hasPrev: false,
  },
  filters: {
    page: 1,
    limit: 10,
  },
  pickupCities: [],
  zoneStats: [],
  availableZones: [],
  selectedCityIds: [],
};
export const useCitiesStore = create<CitiesState>()(
  persist(
    (set, get) => ({
      ...initialState,

      // Setters
      setCities: (cities) => set({ cities }),

      setCurrentCity: (city) => set({ currentCity: city }),

      setPagination: (pagination) =>
        set((state) => ({
          pagination: { ...state.pagination, ...pagination },
        })),

      setFilters: (filters) => {
        set((state) => {
          const newFilters = { ...state.filters, ...filters };
          // Reset to page 1 when filters change (except page change)
          if (filters.page === undefined) {
            newFilters.page = 1;
          }
          return { filters: newFilters };
        });
        // Auto-fetch when filters change
        get().fetchCities();
      },

      clearError: () => set({ error: null }),

      setSelectedCityIds: (ids) => set({ selectedCityIds: ids }),

      // Fetch cities with current filters
      fetchCities: async () => {
        set({ isLoading: true, error: null });

        try {
          const { filters } = get();
          const response = await citiesApiClient.getCities(filters);

          if (response.success && response.data) {
            set({
              cities: response.data.data,
              pagination: response.data.meta,
              isLoading: false,
            });
          } else {
            throw new Error(
              response.error?.message || "Failed to fetch cities"
            );
          }
        } catch (error: any) {
          set({
            isLoading: false,
            error: error.message || "An error occurred while fetching cities",
          });
          toast.error("Failed to fetch cities");
        }
      },

      // Fetch single city by ID
      fetchCityById: async (id: string) => {
        set({ isLoading: true, error: null });

        try {
          const response = await citiesApiClient.getCityById(id);

          if (response.success && response.data) {
            set({ currentCity: response.data, isLoading: false });
            return response.data;
          } else {
            throw new Error(response.error?.message || "City not found");
          }
        } catch (error: any) {
          set({
            isLoading: false,
            error: error.message || "Failed to fetch city",
          });
          toast.error("Failed to fetch city details");
          return null;
        }
      },

      // Create new city
      createCity: async (data: CreateCityRequest) => {
        set({ isLoading: true, error: null });

        try {
          const response = await citiesApiClient.createCity(data);

          if (response.success && response.data) {
            // Add to local state
            set((state) => ({
              cities: [response.data!, ...state.cities],
              isLoading: false,
            }));

            toast.success("City created successfully");
            return true;
          } else {
            throw new Error(response.error?.message || "Failed to create city");
          }
        } catch (error: any) {
          set({
            isLoading: false,
            error: error.message || "Failed to create city",
          });
          toast.error(error.message || "Failed to create city");
          return false;
        }
      },

      // Update city
      updateCity: async (id: string, data: UpdateCityRequest) => {
        set({ isLoading: true, error: null });

        try {
          const response = await citiesApiClient.updateCity(id, data);

          if (response.success && response.data) {
            // Update in local state
            set((state) => ({
              cities: state.cities.map((city) =>
                city.id === id ? response.data! : city
              ),
              currentCity:
                state.currentCity?.id === id
                  ? response.data!
                  : state.currentCity,
              isLoading: false,
            }));

            toast.success("City updated successfully");
            return true;
          } else {
            throw new Error(response.error?.message || "Failed to update city");
          }
        } catch (error: any) {
          set({
            isLoading: false,
            error: error.message || "Failed to update city",
          });
          toast.error(error.message || "Failed to update city");
          return false;
        }
      },

      // Delete city
      deleteCity: async (id: string) => {
        set({ isLoading: true, error: null });

        try {
          const response = await citiesApiClient.deleteCity(id);

          if (response.success) {
            // Remove from local state
            set((state) => ({
              cities: state.cities.filter((city) => city.id !== id),
              currentCity:
                state.currentCity?.id === id ? null : state.currentCity,
              isLoading: false,
            }));

            toast.success("City deleted successfully");
            return true;
          } else {
            throw new Error(response.error?.message || "Failed to delete city");
          }
        } catch (error: any) {
          set({
            isLoading: false,
            error: error.message || "Failed to delete city",
          });
          toast.error(error.message || "Failed to delete city");
          return false;
        }
      },

      // Toggle city status
      toggleCityStatus: async (id: string) => {
        try {
          const response = await citiesApiClient.toggleCityStatus(id);

          if (response.success && response.data) {
            // Update in local state
            set((state) => ({
              cities: state.cities.map((city) =>
                city.id === id ? response.data! : city
              ),
              currentCity:
                state.currentCity?.id === id
                  ? response.data!
                  : state.currentCity,
            }));

            const status = response.data.status ? "activated" : "deactivated";
            toast.success(`City ${status} successfully`);
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to toggle city status"
            );
          }
        } catch (error: any) {
          toast.error(error.message || "Failed to toggle city status");
          return false;
        }
      },

      // Fetch pickup cities
      fetchPickupCities: async () => {
        try {
          const response = await citiesApiClient.getPickupCities();

          if (response.success && response.data) {
            set({ pickupCities: response.data });
          }
        } catch (error: any) {
          console.error("Failed to fetch pickup cities:", error);
        }
      },

      // Fetch zone statistics
      fetchZoneStats: async () => {
        try {
          const response = await citiesApiClient.getZoneStats();

          if (response.success && response.data) {
            set({ zoneStats: response.data });
          }
        } catch (error: any) {
          console.error("Failed to fetch zone stats:", error);
        }
      },

      // Fetch available zones
      fetchAvailableZones: async () => {
        try {
          const response = await citiesApiClient.getAvailableZones();

          if (response.success && response.data) {
            set({ availableZones: response.data });
          }
        } catch (error: any) {
          console.error("Failed to fetch available zones:", error);
        }
      },

      // Bulk delete cities
      bulkDeleteCities: async (ids: string[]) => {
        set({ isLoading: true, error: null });

        try {
          const response = await citiesApiClient.bulkDeleteCities(ids);

          if (response.success) {
            // Remove from local state
            set((state) => ({
              cities: state.cities.filter((city) => !ids.includes(city.id)),
              selectedCityIds: [],
              isLoading: false,
            }));

            toast.success(
              `${
                response.data?.deleted || ids.length
              } cities deleted successfully`
            );
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to delete cities"
            );
          }
        } catch (error: any) {
          set({
            isLoading: false,
            error: error.message || "Failed to delete cities",
          });
          toast.error(error.message || "Failed to delete cities");
          return false;
        }
      },

      // Bulk update status
      bulkUpdateStatus: async (ids: string[], status: boolean) => {
        set({ isLoading: true, error: null });

        try {
          const response = await citiesApiClient.bulkUpdateCitiesStatus(
            ids,
            status
          );

          if (response.success) {
            // Update in local state
            set((state) => ({
              cities: state.cities.map((city) =>
                ids.includes(city.id) ? { ...city, status } : city
              ),
              selectedCityIds: [],
              isLoading: false,
            }));

            const action = status ? "activated" : "deactivated";
            toast.success(
              `${
                response.data?.updated || ids.length
              } cities ${action} successfully`
            );
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to update cities"
            );
          }
        } catch (error: any) {
          set({
            isLoading: false,
            error: error.message || "Failed to update cities",
          });
          toast.error(error.message || "Failed to update cities");
          return false;
        }
      },

      // Search cities
      searchCities: async (query: string) => {
        try {
          const response = await citiesApiClient.searchCities(query);

          if (response.success && response.data) {
            return response.data;
          }
          return [];
        } catch (error) {
          console.error("Failed to search cities:", error);
          return [];
        }
      },

      // Validate city reference
      validateCityRef: async (ref: string, excludeId?: string) => {
        try {
          const response = await citiesApiClient.validateCityRef(
            ref,
            excludeId
          );

          if (response.success && response.data) {
            return response.data.isUnique;
          }
          return false;
        } catch (error) {
          console.error("Failed to validate city reference:", error);
          return false;
        }
      },

      // Reset state
      resetState: () => set(initialState),
    }),
    {
      name: "cities-store",
      partialize: (state) => ({
        filters: state.filters,
        pagination: state.pagination,
      }),
      version: 1,
    }
  )
);
-----------------------------------------------------------------------
--++--> lib/stores/parcels/parcel-statuses.store.ts =======>
-----------------------------------------------------------------------
import { create } from "zustand";
import { devtools } from "zustand/middleware";
import { parcelStatusesApiClient } from "@/lib/api/clients/parcels/parcel-statuses";
import { toast } from "sonner";
import type {
  ParcelStatus,
  CreateParcelStatusRequest,
  UpdateParcelStatusRequest,
  ParcelStatusFilters,
  OptionStats,
} from "@/lib/types/parcels/parcel-statuses.types";
interface ParcelStatusesState {
  // Parcel Statuses
  parcelStatuses: ParcelStatus[];
  parcelStatusesLoading: boolean;
  parcelStatusesFilters: ParcelStatusFilters;

  // Stats
  stats: OptionStats | null;
  statsLoading: boolean;

  // General
  error: string | null;

  // Actions - Parcel Statuses
  fetchParcelStatuses: () => Promise<void>;
  createParcelStatus: (data: CreateParcelStatusRequest) => Promise<boolean>;
  updateParcelStatus: (
    id: string,
    data: UpdateParcelStatusRequest
  ) => Promise<boolean>;
  deleteParcelStatus: (id: string) => Promise<boolean>;
  toggleParcelStatusStatus: (id: string) => Promise<boolean>;
  setParcelStatusesFilters: (filters: Partial<ParcelStatusFilters>) => void;
  bulkDeleteParcelStatuses: (ids: string[]) => Promise<boolean>;
  bulkToggleParcelStatuses: (ids: string[]) => Promise<boolean>;

  // Actions - Stats
  fetchStats: () => Promise<void>;

  // Utility Actions
  clearError: () => void;
  refreshAll: () => Promise<void>;
}
export const useParcelStatusesStore = create<ParcelStatusesState>()(
  devtools(
    (set, get) => ({
      // Initial State
      parcelStatuses: [],
      parcelStatusesLoading: false,
      parcelStatusesFilters: { page: 1, limit: 10 },

      stats: null,
      statsLoading: false,
      error: null,

      // Parcel Statuses Actions
      fetchParcelStatuses: async () => {
        set({ parcelStatusesLoading: true, error: null });
        try {
          const response = await parcelStatusesApiClient.getParcelStatuses(
            get().parcelStatusesFilters
          );
          if (response.success && response.data) {
            set({ parcelStatuses: response.data });
          } else {
            set({
              error:
                typeof response.error === "string"
                  ? response.error
                  : response.error?.message ||
                    "Failed to fetch parcel statuses",
            });
          }
        } catch (error) {
          console.error("Failed to fetch parcel statuses:", error);
          set({ error: "Failed to fetch parcel statuses" });
        } finally {
          set({ parcelStatusesLoading: false });
        }
      },

      createParcelStatus: async (data: CreateParcelStatusRequest) => {
        try {
          const response = await parcelStatusesApiClient.createParcelStatus(
            data
          );
          if (response.success && response.data) {
            // Add the new status to the beginning of the array
            set((state) => ({
              parcelStatuses: [response.data!, ...state.parcelStatuses],
            }));
            toast.success("Parcel status created successfully");
            return true;
          } else {
            toast.error(
              typeof response.error === "string"
                ? response.error
                : response.error?.message || "Failed to create parcel status"
            );

            return false;
          }
        } catch (error) {
          console.error("Failed to create parcel status:", error);
          toast.error("Failed to create parcel status");
          return false;
        }
      },

      updateParcelStatus: async (
        id: string,
        data: UpdateParcelStatusRequest
      ) => {
        try {
          const response = await parcelStatusesApiClient.updateParcelStatus(
            id,
            data
          );
          if (response.success && response.data) {
            // Update the status in the array
            set((state) => ({
              parcelStatuses: state.parcelStatuses.map((status) =>
                status.id === id ? response.data! : status
              ),
            }));
            toast.success("Parcel status updated successfully");
            return true;
          } else {
            toast.error(
              typeof response.error === "string"
                ? response.error
                : response.error?.message || "Failed to update parcel status"
            );

            return false;
          }
        } catch (error) {
          console.error("Failed to update parcel status:", error);
          toast.error("Failed to update parcel status");
          return false;
        }
      },

      deleteParcelStatus: async (id: string) => {
        try {
          const response = await parcelStatusesApiClient.deleteParcelStatus(id);
          if (response.success) {
            // Remove the status from the array
            set((state) => ({
              parcelStatuses: state.parcelStatuses.filter(
                (status) => status.id !== id
              ),
            }));
            toast.success("Parcel status deleted successfully");
            return true;
          } else {
            toast.error(
              typeof response.error === "string"
                ? response.error
                : response.error?.message || "Failed to delete parcel status"
            );

            return false;
          }
        } catch (error) {
          console.error("Failed to delete parcel status:", error);
          toast.error("Failed to delete parcel status");
          return false;
        }
      },

      toggleParcelStatusStatus: async (id: string) => {
        try {
          const response =
            await parcelStatusesApiClient.toggleParcelStatusStatus(id);
          if (response.success && response.data) {
            // Update the status in the array
            set((state) => ({
              parcelStatuses: state.parcelStatuses.map((status) =>
                status.id === id ? response.data! : status
              ),
            }));
            const newStatus = response.data.status
              ? "activated"
              : "deactivated";
            toast.success(`Parcel status ${newStatus} successfully`);
            return true;
          } else {
            toast.error(
              typeof response.error === "string"
                ? response.error
                : response.error?.message || "Failed to toggle parcel status"
            );

            return false;
          }
        } catch (error) {
          console.error("Failed to toggle parcel status:", error);
          toast.error("Failed to toggle parcel status");
          return false;
        }
      },

      setParcelStatusesFilters: (filters: Partial<ParcelStatusFilters>) => {
        set((state) => ({
          parcelStatusesFilters: { ...state.parcelStatusesFilters, ...filters },
        }));
      },

      bulkDeleteParcelStatuses: async (ids: string[]) => {
        try {
          // Since bulk delete doesn't exist in backend yet, do individual deletes
          const promises = ids.map((id) => get().deleteParcelStatus(id));
          const results = await Promise.all(promises);
          const successCount = results.filter(Boolean).length;

          if (successCount === ids.length) {
            toast.success(
              `${successCount} parcel statuses deleted successfully`
            );
            return true;
          } else {
            toast.error(
              `Only ${successCount} of ${ids.length} parcel statuses were deleted`
            );
            return false;
          }
        } catch (error) {
          console.error("Failed to bulk delete parcel statuses:", error);
          toast.error("Failed to delete parcel statuses");
          return false;
        }
      },

      bulkToggleParcelStatuses: async (ids: string[]) => {
        try {
          // Since bulk toggle doesn't exist in backend yet, do individual toggles
          const promises = ids.map((id) => get().toggleParcelStatusStatus(id));
          const results = await Promise.all(promises);
          const successCount = results.filter(Boolean).length;

          if (successCount === ids.length) {
            toast.success(
              `${successCount} parcel statuses toggled successfully`
            );
            return true;
          } else {
            toast.error(
              `Only ${successCount} of ${ids.length} parcel statuses were toggled`
            );
            return false;
          }
        } catch (error) {
          console.error("Failed to bulk toggle parcel statuses:", error);
          toast.error("Failed to toggle parcel statuses");
          return false;
        }
      },

      // Stats Actions
      fetchStats: async () => {
        set({ statsLoading: true });
        try {
          const response =
            await parcelStatusesApiClient.getParcelStatusesStats();
          if (response.success && response.data) {
            set({ stats: response.data });
          } else {
            console.error("Failed to fetch stats:", response.error);
          }
        } catch (error) {
          console.error("Failed to fetch stats:", error);
        } finally {
          set({ statsLoading: false });
        }
      },

      // Utility Actions
      clearError: () => set({ error: null }),

      refreshAll: async () => {
        await Promise.all([get().fetchParcelStatuses(), get().fetchStats()]);
      },
    }),
    { name: "parcel-statuses-store" }
  )
);
-----------------------------------------------------------------------
--++--> lib/stores/parcels/pickup-cities.store.ts =======>
-----------------------------------------------------------------------
import { create } from "zustand";
import { persist } from "zustand/middleware";
import { pickupCitiesApiClient } from "@/lib/api/clients/parcels/pickup-cities.client";
import type {
  PickupCity,
  CreatePickupCityRequest,
  UpdatePickupCityRequest,
  PickupCityFilters,
  PaginatedResponse,
  PickupCityStatistics,
} from "@/lib/types/parcels/pickup-cities.types";
import { toast } from "sonner";
interface PickupCitiesState {
  // Core state
  pickupCities: PickupCity[];
  activePickupCities: PickupCity[];
  selectedPickupCity: PickupCity | null;
  statistics: PickupCityStatistics | null;

  // UI state
  isLoading: boolean;
  isCreating: boolean;
  isUpdating: boolean;
  isDeleting: boolean;
  error: string | null;

  // Pagination state
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };

  // Filters state
  filters: PickupCityFilters;

  // Selection state for bulk operations
  selectedIds: string[];

  // Actions
  setFilters: (filters: Partial<PickupCityFilters>) => void;
  clearFilters: () => void;
  setSelectedIds: (ids: string[]) => void;
  clearSelectedIds: () => void;

  // API Actions
  fetchPickupCities: () => Promise<void>;
  fetchActivePickupCities: () => Promise<void>;
  fetchPickupCityById: (id: string) => Promise<PickupCity | null>;
  createPickupCity: (
    data: CreatePickupCityRequest
  ) => Promise<PickupCity | null>;
  updatePickupCity: (
    id: string,
    data: UpdatePickupCityRequest
  ) => Promise<PickupCity | null>;
  deletePickupCity: (id: string) => Promise<boolean>;
  togglePickupCityStatus: (id: string) => Promise<boolean>;

  // Bulk operations
  bulkDeletePickupCities: (ids: string[]) => Promise<boolean>;
  bulkToggleStatus: (ids: string[], status: boolean) => Promise<boolean>;

  // Statistics
  fetchStatistics: () => Promise<void>;

  // Utility methods
  getPickupCityById: (id: string) => PickupCity | undefined;
  resetState: () => void;
  clearError: () => void;
}
const DEFAULT_FILTERS: PickupCityFilters = {
  page: 1,
  limit: 10,
  search: "",
  sortBy: "name",
  sortParcel: "asc",
};
const DEFAULT_PAGINATION = {
  page: 1,
  limit: 10,
  total: 0,
  totalPages: 0,
  hasNext: false,
  hasPrev: false,
};
export const usePickupCitiesStore = create<PickupCitiesState>()(
  persist(
    (set, get) => ({
      // Initial state
      pickupCities: [],
      activePickupCities: [],
      selectedPickupCity: null,
      statistics: null,
      isLoading: false,
      isCreating: false,
      isUpdating: false,
      isDeleting: false,
      error: null,
      pagination: DEFAULT_PAGINATION,
      filters: DEFAULT_FILTERS,
      selectedIds: [],

      // Filter actions
      setFilters: (newFilters) => {
        const updatedFilters = { ...get().filters, ...newFilters };
        set({ filters: updatedFilters });

        // Reset to page 1 if search or other filters changed
        if ("search" in newFilters || "status" in newFilters) {
          set({ filters: { ...updatedFilters, page: 1 } });
        }

        // Auto-fetch with new filters
        get().fetchPickupCities();
      },

      clearFilters: () => {
        set({ filters: DEFAULT_FILTERS });
        get().fetchPickupCities();
      },

      setSelectedIds: (ids) => set({ selectedIds: ids }),
      clearSelectedIds: () => set({ selectedIds: [] }),

      // Fetch pickup cities with filters and pagination
      fetchPickupCities: async () => {
        const { filters } = get();
        set({ isLoading: true, error: null });

        try {
          const response = await pickupCitiesApiClient.getPickupCities(filters);

          if (response.success && response.data) {
            set({
              pickupCities: response.data.data,
              pagination: response.data.meta,
              isLoading: false,
            });
          } else {
            throw new Error(
              response.error?.message || "Failed to fetch pickup cities"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error fetching pickup cities:", error);
          set({ error: errorMessage, isLoading: false });
          toast.error("Failed to fetch pickup cities");
        }
      },

      // Fetch active pickup cities only
      fetchActivePickupCities: async () => {
        try {
          const response = await pickupCitiesApiClient.getActivePickupCities();

          if (response.success && response.data) {
            set({ activePickupCities: response.data });
          } else {
            throw new Error(
              response.error?.message || "Failed to fetch active pickup cities"
            );
          }
        } catch (error) {
          console.error("Error fetching active pickup cities:", error);
          toast.error("Failed to fetch active pickup cities");
        }
      },

      // Fetch pickup city by ID
      fetchPickupCityById: async (id: string) => {
        set({ isLoading: true, error: null });

        try {
          const response = await pickupCitiesApiClient.getPickupCityById(id);

          if (response.success && response.data) {
            set({ selectedPickupCity: response.data, isLoading: false });
            return response.data;
          } else {
            throw new Error(response.error?.message || "Pickup city not found");
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error fetching pickup city:", error);
          set({
            error: errorMessage,
            isLoading: false,
            selectedPickupCity: null,
          });
          toast.error("Failed to fetch pickup city");
          return null;
        }
      },

      // Create pickup city
      createPickupCity: async (data: CreatePickupCityRequest) => {
        set({ isCreating: true, error: null });

        try {
          const response = await pickupCitiesApiClient.createPickupCity(data);

          if (response.success && response.data) {
            const newPickupCity = response.data;

            // Add to list if it matches current filters
            const { pickupCities } = get();
            set({
              pickupCities: [newPickupCity, ...pickupCities],
              isCreating: false,
            });

            toast.success("Pickup city created successfully");

            // Refresh the list to get accurate pagination
            get().fetchPickupCities();

            return newPickupCity;
          } else {
            throw new Error(
              response.error?.message || "Failed to create pickup city"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error creating pickup city:", error);
          set({ error: errorMessage, isCreating: false });
          toast.error(`Failed to create pickup city: ${errorMessage}`);
          return null;
        }
      },

      // Update pickup city
      updatePickupCity: async (id: string, data: UpdatePickupCityRequest) => {
        set({ isUpdating: true, error: null });

        try {
          const response = await pickupCitiesApiClient.updatePickupCity(
            id,
            data
          );

          if (response.success && response.data) {
            const updatedPickupCity = response.data;

            // Update in list
            const { pickupCities } = get();
            const updatedList = pickupCities.map((city) =>
              city.id === id ? updatedPickupCity : city
            );

            set({
              pickupCities: updatedList,
              selectedPickupCity: updatedPickupCity,
              isUpdating: false,
            });

            toast.success("Pickup city updated successfully");
            return updatedPickupCity;
          } else {
            throw new Error(
              response.error?.message || "Failed to update pickup city"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error updating pickup city:", error);
          set({ error: errorMessage, isUpdating: false });
          toast.error(`Failed to update pickup city: ${errorMessage}`);
          return null;
        }
      },

      // Delete pickup city
      deletePickupCity: async (id: string) => {
        set({ isDeleting: true, error: null });

        try {
          const response = await pickupCitiesApiClient.deletePickupCity(id);

          if (response.success) {
            // Remove from list
            const { pickupCities } = get();
            const updatedList = pickupCities.filter((city) => city.id !== id);

            set({
              pickupCities: updatedList,
              selectedPickupCity: null,
              isDeleting: false,
            });

            toast.success("Pickup city deleted successfully");

            // Refresh to get accurate pagination
            get().fetchPickupCities();

            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to delete pickup city"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error deleting pickup city:", error);
          set({ error: errorMessage, isDeleting: false });
          toast.error(`Failed to delete pickup city: ${errorMessage}`);
          return false;
        }
      },

      // Toggle pickup city status
      togglePickupCityStatus: async (id: string) => {
        try {
          const response = await pickupCitiesApiClient.togglePickupCityStatus(
            id
          );

          if (response.success && response.data) {
            const updatedPickupCity = response.data;

            // Update in list
            const { pickupCities } = get();
            const updatedList = pickupCities.map((city) =>
              city.id === id ? updatedPickupCity : city
            );

            set({
              pickupCities: updatedList,
              selectedPickupCity: updatedPickupCity,
            });

            const status = updatedPickupCity.status
              ? "activated"
              : "deactivated";
            toast.success(`Pickup city ${status} successfully`);

            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to toggle pickup city status"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error toggling pickup city status:", error);
          toast.error(`Failed to toggle status: ${errorMessage}`);
          return false;
        }
      },

      // Bulk delete pickup cities
      bulkDeletePickupCities: async (ids: string[]) => {
        set({ isDeleting: true, error: null });

        try {
          const response = await pickupCitiesApiClient.bulkDeletePickupCities(
            ids
          );

          if (response.success && response.data) {
            toast.success(
              `${response.data.successful} pickup cities deleted successfully`
            );

            if (response.data.failed.length > 0) {
              toast.warning(
                `${response.data.failed.length} pickup cities could not be deleted`
              );
            }

            // Clear selection and refresh
            set({ selectedIds: [], isDeleting: false });
            get().fetchPickupCities();

            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to delete pickup cities"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error bulk deleting pickup cities:", error);
          set({ error: errorMessage, isDeleting: false });
          toast.error(`Failed to delete pickup cities: ${errorMessage}`);
          return false;
        }
      },

      // Bulk toggle status
      bulkToggleStatus: async (ids: string[], status: boolean) => {
        try {
          const response = await pickupCitiesApiClient.bulkToggleStatus(
            ids,
            status
          );

          if (response.success && response.data) {
            const action = status ? "activated" : "deactivated";
            toast.success(
              `${response.data.successful} pickup cities ${action} successfully`
            );

            if (response.data.failed.length > 0) {
              toast.warning(
                `${response.data.failed.length} pickup cities could not be ${action}`
              );
            }

            // Clear selection and refresh
            set({ selectedIds: [] });
            get().fetchPickupCities();

            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to update pickup city status"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error bulk toggling pickup city status:", error);
          toast.error(`Failed to update status: ${errorMessage}`);
          return false;
        }
      },

      // Fetch statistics
      fetchStatistics: async () => {
        try {
          const response =
            await pickupCitiesApiClient.getPickupCityStatistics();

          if (response.success && response.data) {
            set({ statistics: response.data });
          } else {
            throw new Error(
              response.error?.message || "Failed to fetch statistics"
            );
          }
        } catch (error) {
          console.error("Error fetching pickup city statistics:", error);
        }
      },

      // Utility methods
      getPickupCityById: (id: string) => {
        const { pickupCities } = get();
        return pickupCities.find((city) => city.id === id);
      },

      resetState: () => {
        set({
          pickupCities: [],
          activePickupCities: [],
          selectedPickupCity: null,
          statistics: null,
          error: null,
          pagination: DEFAULT_PAGINATION,
          filters: DEFAULT_FILTERS,
          selectedIds: [],
          isLoading: false,
          isCreating: false,
          isUpdating: false,
          isDeleting: false,
        });
      },

      clearError: () => set({ error: null }),
    }),
    {
      name: "pickup-cities-store",
      partialize: (state) => ({
        activePickupCities: state.activePickupCities,
        statistics: state.statistics,
        // Don't persist loading states or selections
      }),
      version: 1,
    }
  )
);
-----------------------------------------------------------------------
--++--> lib/stores/parcels/tariffs.store.ts =======>
-----------------------------------------------------------------------
import { create } from "zustand";
import { tariffsApiClient } from "@/lib/api/clients/parcels/tariffs.client";
import type {
  Tariff,
  CreateTariffRequest,
  UpdateTariffRequest,
  TariffFilters,
  TariffCalculationRequest,
  TariffCalculationResult,
  BulkTariffImportRequest,
  BulkImportResult,
} from "@/lib/types/parcels/tariffs.types";
import { toast } from "sonner";
interface TariffState {
  // State
  tariffs: Tariff[];
  currentTariff: Tariff | null;
  isLoading: boolean;
  error: string | null;

  // Pagination
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };

  // Filters
  filters: TariffFilters;

  // Stats
  stats: {
    totalTariffs: number;
    averageDeliveryPrice: number;
    averageReturnPrice: number;
    averageRefusalPrice: number;
    averageDeliveryDelay: number;
    priceRanges: { range: string; count: number }[];
    delayDistribution: { delay: number; count: number }[];
    cityPairCoverage: {
      totalPossiblePairs: number;
      configuredPairs: number;
      coveragePercentage: number;
    };
  } | null;

  // Missing tariffs
  missingTariffs: Array<{
    pickupCityId: string;
    destinationCityId: string;
    pickupCity: {
      id: string;
      name: string;
      ref: string;
    };
    destinationCity: {
      id: string;
      name: string;
      ref: string;
    };
    route: string;
  }>;

  // Calculation result
  calculationResult: TariffCalculationResult | null;

  // Actions
  fetchTariffs: () => Promise<void>;
  fetchTariffById: (id: string) => Promise<void>;
  createTariff: (data: CreateTariffRequest) => Promise<boolean>;
  updateTariff: (id: string, data: UpdateTariffRequest) => Promise<boolean>;
  deleteTariff: (id: string) => Promise<boolean>;
  bulkImportTariffs: (
    data: BulkTariffImportRequest
  ) => Promise<BulkImportResult | null>;
  calculateTariff: (data: TariffCalculationRequest) => Promise<boolean>;
  fetchStats: () => Promise<void>;
  fetchMissingTariffs: () => Promise<void>;
  validateRoute: (
    pickupCityId: string,
    destinationCityId: string,
    excludeId?: string
  ) => Promise<boolean>;
  duplicateTariff: (
    id: string,
    pickupCityId: string,
    destinationCityId: string
  ) => Promise<boolean>;

  // Filter actions
  setFilters: (filters: Partial<TariffFilters>) => void;
  resetFilters: () => void;

  // Utility actions
  setCurrentTariff: (tariff: Tariff | null) => void;
  clearError: () => void;
  clearCalculationResult: () => void;
}
const initialFilters: TariffFilters = {
  page: 1,
  limit: 10,
  search: "",
};
export const useTariffsStore = create<TariffState>((set, get) => ({
  // Initial state
  tariffs: [],
  currentTariff: null,
  isLoading: false,
  error: null,
  pagination: {
    page: 1,
    limit: 10,
    total: 0,
    totalPages: 0,
    hasNext: false,
    hasPrev: false,
  },
  filters: initialFilters,
  stats: null,
  missingTariffs: [],
  calculationResult: null,

  // Fetch tariffs with filters
  fetchTariffs: async () => {
    const { filters } = get();
    set({ isLoading: true, error: null });

    try {
      const result = await tariffsApiClient.getTariffs(filters);

      if (result.data) {
        set({
          tariffs: result.data[0].data,
          pagination: result.data[0].meta,
          isLoading: false,
        });
      } else {
        throw new Error("Failed to fetch tariffs");
      }
    } catch (error: any) {
      console.error("Error fetching tariffs:", error);
      set({
        error: error?.message || "Failed to fetch tariffs",
        isLoading: false,
      });
      toast.error("Failed to fetch tariffs");
    }
  },

  // Fetch single tariff
  fetchTariffById: async (id: string) => {
    set({ isLoading: true, error: null });

    try {
      const result = await tariffsApiClient.getTariffById(id);

      if (result.success && result.data) {
        set({
          currentTariff: result.data,
          isLoading: false,
        });
      } else {
        throw new Error(result.error?.message || "Failed to fetch tariff");
      }
    } catch (error: any) {
      console.error("Error fetching tariff:", error);
      set({
        error: error?.message || "Failed to fetch tariff",
        isLoading: false,
      });
      toast.error("Failed to fetch tariff details");
    }
  },

  // Create tariff
  createTariff: async (data: CreateTariffRequest) => {
    set({ isLoading: true, error: null });

    try {
      const result = await tariffsApiClient.createTariff(data);

      if (result.success && result.data) {
        // Refresh the list
        await get().fetchTariffs();
        set({ isLoading: false });
        toast.success("Tariff created successfully");
        return true;
      } else {
        throw new Error(result.error?.message || "Failed to create tariff");
      }
    } catch (error: any) {
      console.error("Error creating tariff:", error);
      const errorMessage = error?.message || "Failed to create tariff";
      set({
        error: errorMessage,
        isLoading: false,
      });
      toast.error(errorMessage);
      return false;
    }
  },

  // Update tariff
  updateTariff: async (id: string, data: UpdateTariffRequest) => {
    set({ isLoading: true, error: null });

    try {
      const result = await tariffsApiClient.updateTariff(id, data);

      if (result.success && result.data) {
        const { tariffs, currentTariff } = get();

        // Update in list
        const updatedTariffs = tariffs.map((tariff) =>
          tariff.id === id ? result.data! : tariff
        );

        set({
          tariffs: updatedTariffs,
          currentTariff:
            currentTariff?.id === id ? result.data! : currentTariff,
          isLoading: false,
        });

        toast.success("Tariff updated successfully");
        return true;
      } else {
        throw new Error(result.error?.message || "Failed to update tariff");
      }
    } catch (error: any) {
      console.error("Error updating tariff:", error);
      const errorMessage = error?.message || "Failed to update tariff";
      set({
        error: errorMessage,
        isLoading: false,
      });
      toast.error(errorMessage);
      return false;
    }
  },

  // Delete tariff
  deleteTariff: async (id: string) => {
    set({ isLoading: true, error: null });

    try {
      const result = await tariffsApiClient.deleteTariff(id);

      if (result.success) {
        const { tariffs, currentTariff } = get();

        // Remove from list
        const updatedTariffs = tariffs.filter((tariff) => tariff.id !== id);

        set({
          tariffs: updatedTariffs,
          currentTariff: currentTariff?.id === id ? null : currentTariff,
          isLoading: false,
        });

        toast.success("Tariff deleted successfully");
        return true;
      } else {
        throw new Error(result.error?.message || "Failed to delete tariff");
      }
    } catch (error: any) {
      console.error("Error deleting tariff:", error);
      const errorMessage = error?.message || "Failed to delete tariff";
      set({
        error: errorMessage,
        isLoading: false,
      });
      toast.error(errorMessage);
      return false;
    }
  },

  // Bulk import tariffs
  bulkImportTariffs: async (data: BulkTariffImportRequest) => {
    set({ isLoading: true, error: null });

    try {
      const result = await tariffsApiClient.bulkImportTariffs(data);

      if (result.success && result.data) {
        // Refresh the list
        await get().fetchTariffs();
        set({ isLoading: false });

        const importResult = result.data;
        if (importResult.failed > 0) {
          toast.warning(
            `Import completed: ${importResult.success} successful, ${importResult.failed} failed`
          );
        } else {
          toast.success(
            `Successfully imported ${importResult.success} tariffs`
          );
        }

        return importResult;
      } else {
        throw new Error(result.error?.message || "Failed to import tariffs");
      }
    } catch (error: any) {
      console.error("Error importing tariffs:", error);
      const errorMessage = error?.message || "Failed to import tariffs";
      set({
        error: errorMessage,
        isLoading: false,
      });
      toast.error(errorMessage);
      return null;
    }
  },

  // Calculate tariff
  calculateTariff: async (data: TariffCalculationRequest) => {
    set({ isLoading: true, error: null });

    try {
      const result = await tariffsApiClient.calculateTariff(data);

      if (result.success && result.data) {
        set({
          calculationResult: result.data,
          isLoading: false,
        });
        return true;
      } else {
        throw new Error(
          result.error?.message || "No tariff found for this route"
        );
      }
    } catch (error: any) {
      console.error("Error calculating tariff:", error);
      const errorMessage = error?.message || "Failed to calculate tariff";
      set({
        error: errorMessage,
        isLoading: false,
        calculationResult: null,
      });
      toast.error(errorMessage);
      return false;
    }
  },

  // Fetch stats
  fetchStats: async () => {
    try {
      const result = await tariffsApiClient.getTariffStats();

      if (result.success && result.data) {
        set({ stats: result.data });
      }
    } catch (error) {
      console.error("Error fetching tariff stats:", error);
    }
  },

  // Fetch missing tariffs
  fetchMissingTariffs: async () => {
    try {
      const result = await tariffsApiClient.getMissingTariffs();

      if (result.success && result.data) {
        set({ missingTariffs: result.data });
      }
    } catch (error) {
      console.error("Error fetching missing tariffs:", error);
    }
  },

  // Validate route
  validateRoute: async (
    pickupCityId: string,
    destinationCityId: string,
    excludeId?: string
  ) => {
    try {
      const result = await tariffsApiClient.validateTariffRoute(
        pickupCityId,
        destinationCityId,
        excludeId
      );

      if (result.success && result.data) {
        if (result.data.exists) {
          toast.error("A tariff already exists for this route");
          return false;
        }
        return true;
      }
      return true;
    } catch (error) {
      console.error("Error validating route:", error);
      return true; // Allow on validation error
    }
  },

  // Duplicate tariff
  duplicateTariff: async (
    id: string,
    pickupCityId: string,
    destinationCityId: string
  ) => {
    set({ isLoading: true, error: null });

    try {
      const result = await tariffsApiClient.duplicateTariff(
        id,
        pickupCityId,
        destinationCityId
      );

      if (result.success && result.data) {
        await get().fetchTariffs();
        set({ isLoading: false });
        toast.success("Tariff duplicated successfully");
        return true;
      } else {
        throw new Error(result.error?.message || "Failed to duplicate tariff");
      }
    } catch (error: any) {
      console.error("Error duplicating tariff:", error);
      const errorMessage = error?.message || "Failed to duplicate tariff";
      set({
        error: errorMessage,
        isLoading: false,
      });
      toast.error(errorMessage);
      return false;
    }
  },

  // Filter actions
  setFilters: (newFilters: Partial<TariffFilters>) => {
    const { filters } = get();
    const updatedFilters = { ...filters, ...newFilters };

    // Reset to page 1 when filters change (except for page changes)
    if (!newFilters.page) {
      updatedFilters.page = 1;
    }

    set({ filters: updatedFilters });

    // Auto-fetch when filters change
    get().fetchTariffs();
  },

  resetFilters: () => {
    set({ filters: initialFilters });
    get().fetchTariffs();
  },

  // Utility actions
  setCurrentTariff: (tariff: Tariff | null) => {
    set({ currentTariff: tariff });
  },

  clearError: () => {
    set({ error: null });
  },

  clearCalculationResult: () => {
    set({ calculationResult: null });
  },
}));
-----------------------------------------------------------------------
--++--> lib/stores/parcels/zones.store.ts =======>
-----------------------------------------------------------------------
import { create } from "zustand";
import { persist } from "zustand/middleware";
import { zonesApiClient } from "@/lib/api/clients/parcels/zones.client";
import { citiesApiClient } from "@/lib/api/clients/parcels/cities.client";
import type {
  Zone,
  CreateZoneRequest,
  UpdateZoneRequest,
  ZoneFilters,
  ZoneStatistics,
  AvailableCity,
} from "@/lib/types/parcels/zones.types";
import { toast } from "sonner";
interface ZonesState {
  // Data state
  zones: Zone[];
  activeZones: Zone[];
  currentZone: Zone | null;
  availableCities: AvailableCity[];
  statistics: ZoneStatistics | null;

  // UI state
  loading: boolean;
  error: string | null;
  filters: ZoneFilters;
  selectedZones: string[];

  // Pagination
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };

  // Actions
  setFilters: (filters: Partial<ZoneFilters>) => void;
  clearFilters: () => void;
  setSelectedZones: (zoneIds: string[]) => void;
  clearSelection: () => void;
  setError: (error: string | null) => void;
  clearError: () => void;

  // API actions
  fetchZones: (filters?: ZoneFilters) => Promise<void>;
  fetchActiveZones: () => Promise<void>;
  fetchZoneById: (id: string) => Promise<Zone | null>;
  fetchAvailableCities: () => Promise<void>;
  fetchStatistics: () => Promise<void>;

  // CRUD operations
  createZone: (data: CreateZoneRequest) => Promise<Zone | null>;
  updateZone: (id: string, data: UpdateZoneRequest) => Promise<Zone | null>;
  deleteZone: (id: string) => Promise<boolean>;
  toggleZoneStatus: (id: string) => Promise<boolean>;

  // Zone cities management
  addCitiesToZone: (zoneId: string, cityIds: string[]) => Promise<boolean>;
  removeCitiesFromZone: (zoneId: string, cityIds: string[]) => Promise<boolean>;

  // Bulk operations
  bulkDeleteZones: (zoneIds: string[]) => Promise<boolean>;
  bulkToggleStatus: (zoneIds: string[]) => Promise<boolean>;

  // Export
  exportZones: (filters?: ZoneFilters) => Promise<string | null>;

  // Utility methods
  getZoneById: (id: string) => Zone | undefined;
  getZonesByStatus: (status: boolean) => Zone[];
  getZonesCount: () => { total: number; active: number; inactive: number };
  refreshData: () => Promise<void>;
}
const DEFAULT_FILTERS: ZoneFilters = {
  page: 1,
  limit: 10,
  search: "",
  status: undefined,
};
const DEFAULT_PAGINATION = {
  page: 1,
  limit: 10,
  total: 0,
  totalPages: 0,
  hasNext: false,
  hasPrev: false,
};
export const useZonesStore = create<ZonesState>()(
  persist(
    (set, get) => ({
      // Initial state
      zones: [],
      activeZones: [],
      currentZone: null,
      availableCities: [],
      statistics: null,
      loading: false,
      error: null,
      filters: DEFAULT_FILTERS,
      selectedZones: [],
      pagination: DEFAULT_PAGINATION,

      // Filter and selection actions
      setFilters: (newFilters) => {
        const currentFilters = get().filters;
        const updatedFilters = { ...currentFilters, ...newFilters };

        // Reset page when filters change (except page itself)
        if (Object.keys(newFilters).some((key) => key !== "page")) {
          updatedFilters.page = 1;
        }

        set({ filters: updatedFilters });
        get().fetchZones(updatedFilters);
      },

      clearFilters: () => {
        set({ filters: DEFAULT_FILTERS });
        get().fetchZones(DEFAULT_FILTERS);
      },

      setSelectedZones: (zoneIds) => set({ selectedZones: zoneIds }),

      clearSelection: () => set({ selectedZones: [] }),

      setError: (error) => set({ error }),

      clearError: () => set({ error: null }),

      // Fetch zones with filters
      fetchZones: async (filters) => {
        set({ loading: true, error: null });

        try {
          const filtersToUse = filters || get().filters;
          const response = await zonesApiClient.getZones(filtersToUse);

          if (response.data) {
            set({
              zones: response.data[0].data,
              pagination: response.data[0].meta,
              loading: false,
            });
          } else {
            throw new Error(response.error?.message || "Failed to fetch zones");
          }
        } catch (error: any) {
          console.error("Error fetching zones:", error);
          set({
            error: error.message || "Failed to fetch zones",
            loading: false,
          });
          toast.error("Failed to fetch zones");
        }
      },

      // Fetch active zones only
      fetchActiveZones: async () => {
        try {
          const response = await zonesApiClient.getActiveZones();

          if (response.success && response.data) {
            set({ activeZones: response.data });
          }
        } catch (error: any) {
          console.error("Error fetching active zones:", error);
          toast.error("Failed to fetch active zones");
        }
      },

      // Fetch single zone
      fetchZoneById: async (id) => {
        set({ loading: true, error: null });

        try {
          const response = await zonesApiClient.getZoneById(id);

          if (response.success && response.data) {
            set({
              currentZone: response.data,
              loading: false,
            });
            return response.data;
          } else {
            throw new Error(response.error?.message || "Zone not found");
          }
        } catch (error: any) {
          console.error("Error fetching zone:", error);
          set({
            error: error.message || "Failed to fetch zone",
            loading: false,
            currentZone: null,
          });
          toast.error("Failed to fetch zone details");
          return null;
        }
      },

      // Fetch available cities for zone assignment
      fetchAvailableCities: async () => {
        try {
          const response = await citiesApiClient.getCities({
            page: 1,
            limit: 100,
            status: true,
          });

          if (response.success && response.data) {
            set({ availableCities: response.data.data });
          }
        } catch (error: any) {
          console.error("Error fetching available cities:", error);
          toast.error("Failed to fetch cities");
        }
      },

      // Fetch statistics
      fetchStatistics: async () => {
        try {
          const response = await zonesApiClient.getZoneStatistics();

          if (response.success && response.data) {
            set({ statistics: response.data });
          }
        } catch (error: any) {
          console.error("Error fetching zone statistics:", error);
        }
      },

      // Create zone
      createZone: async (data) => {
        set({ loading: true, error: null });

        try {
          const response = await zonesApiClient.createZone(data);

          if (response.success && response.data) {
            // Add to zones list
            const currentZones = get().zones;
            set({
              zones: [response.data, ...currentZones],
              loading: false,
            });

            // Update active zones if the new zone is active
            if (response.data.status) {
              get().fetchActiveZones();
            }

            // Update statistics
            get().fetchStatistics();

            toast.success("Zone created successfully");
            return response.data;
          } else {
            throw new Error(response.error?.message || "Failed to create zone");
          }
        } catch (error: any) {
          console.error("Error creating zone:", error);
          set({
            error: error.message || "Failed to create zone",
            loading: false,
          });
          toast.error(error.message || "Failed to create zone");
          return null;
        }
      },

      // Update zone
      updateZone: async (id, data) => {
        set({ loading: true, error: null });

        try {
          const response = await zonesApiClient.updateZone(id, data);

          if (response.success && response.data) {
            // Update in zones list
            const currentZones = get().zones;
            const updatedZones = currentZones.map((zone) =>
              zone.id === id ? response.data : zone
            );

            set({
              zones: updatedZones,
              currentZone: response.data,
              loading: false,
            });

            // Refresh active zones
            get().fetchActiveZones();

            // Update statistics
            get().fetchStatistics();

            toast.success("Zone updated successfully");
            return response.data;
          } else {
            throw new Error(response.error?.message || "Failed to update zone");
          }
        } catch (error: any) {
          console.error("Error updating zone:", error);
          set({
            error: error.message || "Failed to update zone",
            loading: false,
          });
          toast.error(error.message || "Failed to update zone");
          return null;
        }
      },

      // Delete zone
      deleteZone: async (id) => {
        try {
          const response = await zonesApiClient.deleteZone(id);

          if (response.success) {
            // Remove from zones list
            const currentZones = get().zones;
            const updatedZones = currentZones.filter((zone) => zone.id !== id);

            set({
              zones: updatedZones,
              currentZone: null,
            });

            // Update selected zones if needed
            const selectedZones = get().selectedZones;
            if (selectedZones.includes(id)) {
              set({
                selectedZones: selectedZones.filter((zoneId) => zoneId !== id),
              });
            }

            // Refresh active zones and statistics
            get().fetchActiveZones();
            get().fetchStatistics();

            toast.success("Zone deleted successfully");
            return true;
          } else {
            throw new Error(response.error?.message || "Failed to delete zone");
          }
        } catch (error: any) {
          console.error("Error deleting zone:", error);
          toast.error(error.message || "Failed to delete zone");
          return false;
        }
      },

      // Toggle zone status
      toggleZoneStatus: async (id) => {
        try {
          const response = await zonesApiClient.toggleZoneStatus(id);

          if (response.success && response.data) {
            // Update in zones list
            const currentZones = get().zones;
            const updatedZones = currentZones.map((zone) =>
              zone.id === id ? response.data : zone
            );

            set({ zones: updatedZones });

            // Refresh active zones
            get().fetchActiveZones();

            toast.success(
              `Zone ${
                response.data.status ? "activated" : "deactivated"
              } successfully`
            );
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to toggle zone status"
            );
          }
        } catch (error: any) {
          console.error("Error toggling zone status:", error);
          toast.error(error.message || "Failed to toggle zone status");
          return false;
        }
      },

      // Add cities to zone
      addCitiesToZone: async (zoneId, cityIds) => {
        try {
          const response = await zonesApiClient.addCitiesToZone(
            zoneId,
            cityIds
          );

          if (response.success && response.data) {
            // Update current zone if it matches
            const currentZone = get().currentZone;
            if (currentZone?.id === zoneId) {
              set({ currentZone: response.data });
            }

            toast.success("Cities added to zone successfully");
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to add cities to zone"
            );
          }
        } catch (error: any) {
          console.error("Error adding cities to zone:", error);
          toast.error(error.message || "Failed to add cities to zone");
          return false;
        }
      },

      // Remove cities from zone
      removeCitiesFromZone: async (zoneId, cityIds) => {
        try {
          const response = await zonesApiClient.removeCitiesFromZone(
            zoneId,
            cityIds
          );

          if (response.success && response.data) {
            // Update current zone if it matches
            const currentZone = get().currentZone;
            if (currentZone?.id === zoneId) {
              set({ currentZone: response.data });
            }

            toast.success("Cities removed from zone successfully");
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to remove cities from zone"
            );
          }
        } catch (error: any) {
          console.error("Error removing cities from zone:", error);
          toast.error(error.message || "Failed to remove cities from zone");
          return false;
        }
      },

      // Bulk delete zones
      bulkDeleteZones: async (zoneIds) => {
        try {
          const response = await zonesApiClient.bulkDeleteZones(zoneIds);

          if (response.success) {
            // Remove deleted zones from list
            const currentZones = get().zones;
            const remainingZones = currentZones.filter(
              (zone) => !zoneIds.includes(zone.id)
            );

            set({
              zones: remainingZones,
              selectedZones: [],
            });

            // Refresh data
            get().fetchActiveZones();
            get().fetchStatistics();

            toast.success(
              `Successfully deleted ${
                response.data?.successful || zoneIds.length
              } zone(s)`
            );

            if (response.data?.failed && response.data.failed.length > 0) {
              toast.warning(
                `Failed to delete ${response.data.failed.length} zone(s)`
              );
            }

            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to delete zones"
            );
          }
        } catch (error: any) {
          console.error("Error bulk deleting zones:", error);
          toast.error(error.message || "Failed to delete zones");
          return false;
        }
      },

      // Bulk toggle status
      bulkToggleStatus: async (zoneIds) => {
        try {
          const response = await zonesApiClient.bulkToggleStatus(zoneIds);

          if (response.success) {
            // Refresh zones to get updated statuses
            await get().fetchZones();

            set({ selectedZones: [] });

            toast.success(
              `Successfully updated ${
                response.data?.successful || zoneIds.length
              } zone(s)`
            );

            if (response.data?.failed && response.data.failed.length > 0) {
              toast.warning(
                `Failed to update ${response.data.failed.length} zone(s)`
              );
            }

            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to update zones"
            );
          }
        } catch (error: any) {
          console.error("Error bulk toggling zone status:", error);
          toast.error(error.message || "Failed to update zones");
          return false;
        }
      },

      // Export zones
      // Export zones - FIXED VERSION
      exportZones: async (filters) => {
        set({ loading: true, error: null });

        try {
          const filtersToUse = filters || get().filters;

          // Send the request with the correct structure
          const result = await zonesApiClient.exportZones({
            page: filtersToUse.page || 1,
            limit: filtersToUse.limit || 1000,
            search: filtersToUse.search || "",
            status: filtersToUse.status,
          });

          if (result.success && result.data) {
            set({ loading: false });
            toast.success(
              `Exported ${result.data.totalRecords} zones successfully`
            );
            return result.data.downloadUrl;
          } else {
            throw new Error(result.error?.message || "Failed to export zones");
          }
        } catch (error: any) {
          console.error("Error exporting zones:", error);
          const errorMessage = error?.message || "Failed to export zones";
          set({
            error: errorMessage,
            loading: false,
          });
          toast.error(errorMessage);
          return null;
        }
      },

      // Utility methods
      getZoneById: (id) => {
        return get().zones.find((zone) => zone.id === id);
      },

      getZonesByStatus: (status) => {
        return get().zones.filter((zone) => zone.status === status);
      },

      getZonesCount: () => {
        const zones = get().zones;
        return {
          total: zones.length,
          active: zones.filter((zone) => zone.status).length,
          inactive: zones.filter((zone) => !zone.status).length,
        };
      },

      // Refresh all data
      refreshData: async () => {
        const promises = [
          get().fetchZones(),
          get().fetchActiveZones(),
          get().fetchStatistics(),
          get().fetchAvailableCities(),
        ];

        await Promise.allSettled(promises);
      },
    }),
    {
      name: "zones-store",
      partialize: (state) => ({
        filters: state.filters,
        selectedZones: state.selectedZones,
      }),
      version: 1,
    }
  )
);
-----------------------------------------------------------------------
Types folders:
-----------------------------------------------------------------------
--++--> lib/types/parcels/cities.types.ts =======>
-----------------------------------------------------------------------
export interface City {
  id: string;
  tenantId: string;
  ref: string;
  name: string;
  zone: string;
  pickupCity: boolean;
  status: boolean;
  createdAt: string;
  updatedAt: string;
  createdBy: string | null;
  updatedBy: string | null;
  _count?: {
    pickupTariffs: number;
    destinationTariffs: number;
    zones: number;
  };
}
export interface CreateCityRequest {
  ref: string;
  name: string;
  zone: string;
  pickupCity: boolean;
  status?: boolean;
}
export interface UpdateCityRequest {
  ref?: string;
  name?: string;
  zone?: string;
  pickupCity?: boolean;
  status?: boolean;
}
export interface CitiesFilters {
  page?: number;
  limit?: number;
  search?: string;
  ref?: string;
  zone?: string;
  pickupCity?: boolean;
  status?: boolean;
}
export interface ZoneStats {
  zone: string;
  count: number;
}
export interface CitiesPaginatedResponse {
  data: City[];
  meta: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
}
-----------------------------------------------------------------------
Providers Folder:
-----------------------------------------------------------------------
--++--> providers/auth.provider.tsx =======>
-----------------------------------------------------------------------
"use client";
import React, { useEffect, useState, useCallback, useRef } from "react";
import { useRouter, usePathname } from "next/navigation";
import { useAuthStore } from "@/lib/stores/auth/auth.store";
import { useTenantStore } from "@/lib/stores/auth/tenant.store";
import { getTenantFromUrl } from "@/lib/utils/tenant.utils";
import { toast } from "sonner";
interface AuthProviderProps {
  children: React.ReactNode;
}
// Constants
const THROTTLE_DELAY = 500;
const SESSION_CHECK_INTERVAL = 60 * 1000; // 1 minute
const SESSION_WARNING_TIME = 5 * 60 * 1000; // 5 minutes
const ACTIVITY_THRESHOLD = 5 * 60 * 1000; // 5 minutes
const ONLINE_RECHECK_DELAY = 2000;
const PUBLIC_ROUTES = ["/auth", "/"];
const LIMITED_ROUTES = [
  "/dashboard",
  "/profile",
  "/settings",
  "/validation-status",
];
const ACCOUNT_STATUS_MESSAGES = {
  PENDING: "Your account is pending admin approval.",
  REJECTED: "Your account has been rejected. Please contact support.",
  SUSPENDED: "Your account has been suspended. Please contact support.",
} as const;
const REQUIREMENT_MESSAGES = {
  "Admin approval required": "Your account is pending admin approval.",
  "Complete profile information": "Please complete your profile information.",
  "Profile validation by admin": "Your profile is being validated by an admin.",
} as const;
export default function AuthProvider({ children }: AuthProviderProps) {
  const [isInitialized, setIsInitialized] = useState(false);
  const initializationRef = useRef(false);
  const timersRef = useRef<{
    eventThrottle?: NodeJS.Timeout;
    sessionCheck?: NodeJS.Timeout;
    routeValidation?: NodeJS.Timeout;
  }>({});

  const router = useRouter();
  const pathname = usePathname();

  const {
    checkAuth,
    isAuthenticated,
    logout,
    user,
    isInitialized: authInitialized,
    isCheckingAuth,
    accountStatus,
    accessLevel,
    requirements,
    updateAccountStatus,
    isAccountBlocked,
    needsProfileCompletion,
    needsValidation,
  } = useAuthStore();

  const { fetchCurrentTenant, currentTenant } = useTenantStore();

  // Cleanup timers utility
  const cleanupTimers = useCallback(() => {
    Object.values(timersRef.current).forEach((timer) => {
      if (timer) clearTimeout(timer);
    });
    timersRef.current = {};
  }, []);

  // Route access validation
  const validateRouteAccess = useCallback(() => {
    if (!isAuthenticated || !user || !pathname) return true;

    // Skip validation for public routes
    if (PUBLIC_ROUTES.some((route) => pathname.startsWith(route))) {
      return true;
    }

    // Check blocked account
    if (isAccountBlocked()) {
      const message =
        ACCOUNT_STATUS_MESSAGES[
          accountStatus as keyof typeof ACCOUNT_STATUS_MESSAGES
        ] || "Access denied.";
      toast.error(message);
      router.replace("/auth/login");
      return false;
    }

    // Handle profile completion requirement
    if (needsProfileCompletion()) {
      if (
        !pathname.includes("/profile/complete") &&
        !pathname.includes("/auth")
      ) {
        toast.info("Please complete your profile to continue.");
        router.replace("/profile/complete");
        return false;
      }
      return true;
    }

    // Handle validation requirement
    if (needsValidation()) {
      const isLimitedRoute = LIMITED_ROUTES.some((route) =>
        pathname.startsWith(route)
      );
      if (!isLimitedRoute && !pathname.includes("/auth")) {
        toast.warning(
          "This feature requires profile validation. You have limited access until validation is complete."
        );
        router.replace("/dashboard");
        return false;
      }
    }

    return true;
  }, [
    isAuthenticated,
    user,
    pathname,
    accountStatus,
    isAccountBlocked,
    needsProfileCompletion,
    needsValidation,
    router,
  ]);

  // Initialize auth and tenant context
  const initializeAuth = useCallback(async () => {
    if (initializationRef.current) return;
    initializationRef.current = true;

    try {
      // Set tenant context
      const tenantId = getTenantFromUrl();
      if (tenantId) {
        localStorage.setItem("utl_tenant_id", tenantId);
      } else {
        console.warn("No tenant ID found in URL");
      }

      // Check authentication if needed
      if (!authInitialized && !isCheckingAuth) {
        await checkAuth();
      }

      // Get fresh auth state and fetch additional data if authenticated
      const authState = useAuthStore.getState();
      if (authState.isAuthenticated && authState.user) {
        const promises = [];

        // Update account status
        promises.push(
          updateAccountStatus().catch((error) => {
            console.warn("Failed to fetch account status:", error);
          })
        );

        // Fetch tenant data if not loaded
        if (!currentTenant) {
          promises.push(
            fetchCurrentTenant().catch((error) => {
              console.warn("Failed to fetch tenant data:", error);
            })
          );
        }

        // Execute in parallel, don't block on failures
        await Promise.allSettled(promises);
      }
    } catch (error) {
      console.error("Auth initialization failed:", error);

      // Handle specific errors with appropriate user feedback
      if (error instanceof Error) {
        if (error.message.includes("tenant")) {
          toast.error("Invalid tenant. Please check your URL.");
          router.replace("/auth/login");
        } else if (error.message.includes("network")) {
          toast.error("Network error. Please check your connection.");
        }
      }
    } finally {
      setIsInitialized(true);
    }
  }, [
    checkAuth,
    fetchCurrentTenant,
    authInitialized,
    currentTenant,
    isCheckingAuth,
    updateAccountStatus,
    router,
  ]);

  // Session monitoring setup
  const setupSessionMonitoring = useCallback(() => {
    if (!isAuthenticated) return;

    const sessionCheckTimer = setInterval(() => {
      const state = useAuthStore.getState();

      if (
        !state.isAuthenticated ||
        state.isCheckingAuth ||
        state.isRefreshing
      ) {
        return;
      }

      // Check session expiry
      if (state.isSessionExpired()) {
        toast.error("Your session has expired. Please sign in again.");
        logout();
        return;
      }

      // Session timeout warning
      const timeUntilExpiry = state.getTimeUntilExpiry();
      if (
        timeUntilExpiry <= SESSION_WARNING_TIME &&
        !state.sessionTimeoutWarning
      ) {
        state.setSessionTimeoutWarning(true);
        toast.warning("Your session will expire soon. Please save your work.", {
          duration: 10000,
          action: {
            label: "Extend Session",
            onClick: () => {
              state.extendSession().catch(console.error);
              state.setSessionTimeoutWarning(false);
            },
          },
        });
      }
    }, SESSION_CHECK_INTERVAL);

    timersRef.current.sessionCheck = sessionCheckTimer;
  }, [isAuthenticated, logout]);

  // Cross-tab communication handlers
  const handleStorageChange = useCallback(
    (e: StorageEvent) => {
      if (timersRef.current.eventThrottle) {
        clearTimeout(timersRef.current.eventThrottle);
      }

      timersRef.current.eventThrottle = setTimeout(() => {
        const state = useAuthStore.getState();

        switch (e.key) {
          case "auth_logout":
            if (e.newValue && state.isAuthenticated) {
              toast.info("You have been logged out in another tab.");
              logout();
            }
            break;
          case "auth_login":
            if (e.newValue && !state.isAuthenticated) {
              toast.info("You have been logged in from another tab.");
              window.location.reload();
            }
            break;
          case "auth_token":
            if (e.newValue && !state.isAuthenticated) {
              checkAuth().catch(console.error);
            }
            break;
        }
      }, THROTTLE_DELAY);
    },
    [logout, checkAuth]
  );

  const handleVisibilityChange = useCallback(() => {
    if (document.hidden || !isAuthenticated || !user) return;

    const state = useAuthStore.getState();
    if (state.isCheckingAuth || state.isRefreshing) return;

    state.updateLastActivity();

    // Check account status if user has been away
    const timeSinceActivity = Date.now() - state.lastActivity;
    if (timeSinceActivity > ACTIVITY_THRESHOLD) {
      updateAccountStatus().catch(console.error);
    }
  }, [isAuthenticated, user, updateAccountStatus]);

  const handleOnline = useCallback(() => {
    if (!isAuthenticated || !user) return;

    const state = useAuthStore.getState();
    if (state.isCheckingAuth || state.isRefreshing) return;

    setTimeout(() => {
      const currentState = useAuthStore.getState();
      if (!currentState.isCheckingAuth && !currentState.isRefreshing) {
        Promise.allSettled([checkAuth(), updateAccountStatus()]).catch(
          console.error
        );
      }
    }, ONLINE_RECHECK_DELAY);
  }, [isAuthenticated, user, checkAuth, updateAccountStatus]);

  const handleOffline = useCallback(() => {
    toast.warning("You're offline. Some features may not work properly.");
  }, []);

  // Main initialization effect
  useEffect(() => {
    if (isInitialized || initializationRef.current) return;
    initializeAuth();
  }, [initializeAuth, isInitialized]);

  // Route validation effect
  useEffect(() => {
    if (!isInitialized || isCheckingAuth) return;

    if (timersRef.current.routeValidation) {
      clearTimeout(timersRef.current.routeValidation);
    }

    timersRef.current.routeValidation = setTimeout(() => {
      validateRouteAccess();
    }, 100);

    return () => {
      if (timersRef.current.routeValidation) {
        clearTimeout(timersRef.current.routeValidation);
      }
    };
  }, [
    isInitialized,
    isCheckingAuth,
    pathname,
    isAuthenticated,
    accountStatus,
    accessLevel,
    validateRouteAccess,
  ]);

  // Event listeners and session monitoring
  useEffect(() => {
    if (!isInitialized) return;

    // Add event listeners
    window.addEventListener("storage", handleStorageChange);
    document.addEventListener("visibilitychange", handleVisibilityChange, {
      passive: true,
    });
    window.addEventListener("online", handleOnline, { passive: true });
    window.addEventListener("offline", handleOffline, { passive: true });

    // Setup session monitoring
    setupSessionMonitoring();

    return () => {
      // Cleanup event listeners
      window.removeEventListener("storage", handleStorageChange);
      document.removeEventListener("visibilitychange", handleVisibilityChange);
      window.removeEventListener("online", handleOnline);
      window.removeEventListener("offline", handleOffline);

      // Cleanup timers
      cleanupTimers();
    };
  }, [
    isInitialized,
    handleStorageChange,
    handleVisibilityChange,
    handleOnline,
    handleOffline,
    setupSessionMonitoring,
    cleanupTimers,
  ]);

  // Requirements notifications
  useEffect(() => {
    if (!isInitialized || !isAuthenticated || !requirements.length) return;

    // Show only the first unhandled requirement to avoid toast spam
    const firstRequirement =
      requirements[0] as keyof typeof REQUIREMENT_MESSAGES;
    const message = REQUIREMENT_MESSAGES[firstRequirement];

    if (message) {
      toast.info(message, { duration: 10000 });
    }
  }, [isInitialized, isAuthenticated, requirements]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      cleanupTimers();
      initializationRef.current = false;
    };
  }, [cleanupTimers]);

  return <>{children}</>;
}
-----------------------------------------------------------------------
--++--> middleware.ts =======>
-----------------------------------------------------------------------
import createMiddleware from "next-intl/middleware";
import { NextRequest, NextResponse } from "next/server";
import { locales } from "@/config";
// Types
type AccountStatus =
  | "PENDING"
  | "INACTIVE"
  | "PENDING_VALIDATION"
  | "ACTIVE"
  | "REJECTED"
  | "SUSPENDED";
type ValidationStatus = "PENDING" | "VALIDATED" | "REJECTED";
type AccessLevel = "NO_ACCESS" | "PROFILE_ONLY" | "LIMITED" | "FULL";
interface TokenPayload {
  sub: string;
  email: string;
  roleId: string;
  userType: string;
  tenantId: string;
  exp: number;
  iat: number;
}
interface UserSession {
  userId: string;
  email: string;
  userType: string;
  accountStatus: AccountStatus;
  validationStatus: ValidationStatus;
  profileCompleted: boolean;
  isActive: boolean;
  tenantId: string;
}
interface TenantInfo {
  id: string;
  domain: string;
  name: string;
}
// Constants
const ROUTE_PATTERNS = {
  public: new Set(["/", "/about", "/contact", "/terms", "/privacy"]),
  auth: new Set([
    "/auth/login",
    "/auth/register",
    "/auth/forgot-password",
    "/auth/reset-password",
  ]),
  profileOnly: new Set(["/profile/complete", "/profile/edit"]),
  limited: new Set([
    "/dashboard",
    "/profile",
    "/settings/profile",
    "/notifications",
    "/validation-status",
    "/upload-documents",
  ]),
  fullAccess: new Set([
    "/users",
    "/roles",
    "/analytics",
    "/settings/admin",
    "/reports",
    "/management",
  ]),
  validatedOnly: new Set([
    "/parcels",
    "/invoices",
    "/claims",
    "/marketplace",
    "/parcels",
    "/transactions",
  ]),
} as const;
const LOCALE_REGEX = /^\/([a-z]{2})(?=\/|$)/;
const BEARER_PREFIX = "Bearer ";
// Security headers
const SECURITY_HEADERS = {
  "x-frame-options": "DENY",
  "x-content-type-options": "nosniff",
  "referrer-policy": "origin-when-cross-origin",
  "x-xss-protection": "1; mode=block",
} as const;
// Cache for user data and tenant info
const userCache = new Map<string, { data: UserSession; expiry: number }>();
const tenantCache = new Map<string, { data: TenantInfo; expiry: number }>();
const CACHE_DURATION = 2 * 60 * 1000; // 2 minutes
// Logging utility
const log = (level: "INFO" | "WARN" | "ERROR", message: string, data?: any) => {
  const timestamp = new Date().toISOString();
  const logMessage = `[MIDDLEWARE ${level}] ${timestamp}: ${message}`;

  if (data) {
    console.log(logMessage, data);
  } else {
    console.log(logMessage);
  }
};
// Core functions
const removeLocalePrefix = (pathname: string): string =>
  pathname.replace(LOCALE_REGEX, "") || "/";
const getLocaleFromPath = (pathname: string): string =>
  pathname.match(LOCALE_REGEX)?.[1] || "en";
const isRouteInCategory = (pathname: string, routes: Set<string>): boolean => {
  const routeWithoutLocale = removeLocalePrefix(pathname);
  if (routes.has(routeWithoutLocale)) return true;
  for (const route of Array.from(routes)) {
    if (routeWithoutLocale.startsWith(route + "/")) return true;
  }
  return false;
};
const getAuthToken = (request: NextRequest): string | null => {
  const cookieToken = request.cookies.get("auth_token")?.value;
  if (cookieToken) return cookieToken;
  const authHeader = request.headers.get("authorization");
  return authHeader?.startsWith(BEARER_PREFIX)
    ? authHeader.slice(BEARER_PREFIX.length)
    : null;
};
const decodeJWTPayload = (token: string): TokenPayload | null => {
  try {
    const [, payload] = token.split(".");
    if (!payload) return null;
    return JSON.parse(atob(payload));
  } catch {
    return null;
  }
};
const isTokenValid = (payload: TokenPayload): boolean => {
  const now = Math.floor(Date.now() / 1000);
  return payload.exp > now;
};
// Get tenant ID based on environment
const getTenantId = async (request: NextRequest): Promise<string | null> => {
  const isDev = process.env.NODE_ENV === "development";
  const url = new URL(request.url);

  log("INFO", `Getting tenant ID for environment: ${process.env.NODE_ENV}`, {
    isDev,
    hostname: url.hostname,
    searchParams: Object.fromEntries(url.searchParams),
  });

  if (isDev) {
    // Development: Check URL param first, then environment variable
    const tenantFromUrl = url.searchParams.get("tenant");
    if (tenantFromUrl) {
      log("INFO", "Using tenant from URL parameter", { tenant: tenantFromUrl });
      return tenantFromUrl;
    }

    const devTenantId = process.env.NEXT_PUBLIC_DEV_TENANT_ID;
    if (devTenantId) {
      log("INFO", "Using tenant from environment variable", {
        tenant: devTenantId,
      });
      return devTenantId;
    }

    log("WARN", "No tenant ID found in development mode");
    return null;
  }

  // Production: Get tenant by domain
  const domain = url.hostname;
  const cacheKey = `tenant_${domain}`;
  const cached = tenantCache.get(cacheKey);

  if (cached && cached.expiry > Date.now()) {
    log("INFO", "Using cached tenant info", {
      tenantId: cached.data.id,
      domain,
    });
    return cached.data.id;
  }

  try {
    const backendUrl =
      process.env.NEXT_PUBLIC_AUTH_SERVICE_URL || "http://localhost:3001";
    const tenantApiUrl = `${backendUrl}/api/tenants/by-domain/${domain}`;

    log("INFO", "Fetching tenant by domain", { domain, apiUrl: tenantApiUrl });

    const response = await fetch(tenantApiUrl, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
      },
      signal: AbortSignal.timeout(3000),
    });

    if (!response.ok) {
      log("ERROR", "Failed to fetch tenant by domain", {
        status: response.status,
        statusText: response.statusText,
        domain,
      });
      return null;
    }

    const result = await response.json();

    if (result.success && result.data) {
      const tenantInfo: TenantInfo = {
        id: result.data.id,
        domain: result.data.domain,
        name: result.data.name,
      };

      // Cache tenant info
      tenantCache.set(cacheKey, {
        data: tenantInfo,
        expiry: Date.now() + CACHE_DURATION,
      });

      log("INFO", "Successfully fetched tenant by domain", {
        tenantId: tenantInfo.id,
        tenantName: tenantInfo.name,
        domain,
      });

      return tenantInfo.id;
    }

    log("WARN", "Invalid tenant API response", { response: result });
    return null;
  } catch (error: any) {
    log("ERROR", "Error fetching tenant by domain", {
      error: error.message,
      domain,
    });
    return null;
  }
};
// Get real user data from your API with tenant context
const fetchUserData = async (
  userId: string,
  token: string,
  tenantId: string
): Promise<UserSession | null> => {
  const cacheKey = `${tenantId}_${userId}`;
  const cached = userCache.get(cacheKey);

  if (cached && cached.expiry > Date.now()) {
    log("INFO", "Using cached user data", { userId, tenantId });
    return cached.data;
  }

  try {
    const baseUrl =
      process.env.NEXT_PUBLIC_AUTH_SERVICE_URL || "http://localhost:3001";
    const apiUrl = `${baseUrl}/api/auth/profile`;

    log("INFO", "Fetching user data from API", {
      userId,
      tenantId,
      apiUrl,
      hasToken: !!token,
    });

    const response = await fetch(apiUrl, {
      method: "GET",
      headers: {
        Authorization: `Bearer ${token}`,
        "Content-Type": "application/json",
        "X-Tenant-ID": tenantId,
      },
      signal: AbortSignal.timeout(2500),
    });

    if (!response.ok) {
      log("ERROR", "Failed to fetch user data", {
        status: response.status,
        statusText: response.statusText,
        userId,
        tenantId,
      });
      return null;
    }

    const result = await response.json();

    if (!result.success || !result.data) {
      log("WARN", "Invalid user API response", {
        response: result,
        userId,
        tenantId,
      });
      return null;
    }

    const user = result.data;
    const userSession: UserSession = {
      userId: user.id || userId,
      email: user.email,
      userType: user.userType,
      accountStatus: user.accountStatus || "PENDING",
      validationStatus: user.validationStatus || "PENDING",
      profileCompleted: user.profileCompleted || false,
      isActive: user.isActive || false,
      tenantId: user.tenantId || tenantId,
    };

    // Cache for 2 minutes
    userCache.set(cacheKey, {
      data: userSession,
      expiry: Date.now() + CACHE_DURATION,
    });

    log("INFO", "Successfully fetched user data", {
      userId: userSession.userId,
      userType: userSession.userType,
      accountStatus: userSession.accountStatus,
      validationStatus: userSession.validationStatus,
      tenantId: userSession.tenantId,
    });

    return userSession;
  } catch (error: any) {
    log("ERROR", "Error fetching user data", {
      error: error.message,
      userId,
      tenantId,
    });
    return null;
  }
};
const getAccessLevel = (user: UserSession): AccessLevel => {
  const accessLevel = (() => {
    switch (user.accountStatus) {
      case "PENDING":
      case "REJECTED":
      case "SUSPENDED":
        return "NO_ACCESS";
      case "INACTIVE":
        return "PROFILE_ONLY";
      case "PENDING_VALIDATION":
        return "LIMITED";
      case "ACTIVE":
        return user.validationStatus === "VALIDATED" ? "FULL" : "LIMITED";
      default:
        return "NO_ACCESS";
    }
  })();

  log("INFO", "Calculated access level", {
    userId: user.userId,
    userType: user.userType,
    accountStatus: user.accountStatus,
    validationStatus: user.validationStatus,
    accessLevel,
  });

  return accessLevel;
};
const checkRouteAccess = (pathname: string, user: UserSession | null) => {
  const locale = getLocaleFromPath(pathname);
  const routeWithoutLocale = removeLocalePrefix(pathname);

  log("INFO", "Checking route access", {
    pathname,
    routeWithoutLocale,
    locale,
    hasUser: !!user,
    userType: user?.userType,
    accountStatus: user?.accountStatus,
  });

  // Public routes
  if (isRouteInCategory(pathname, ROUTE_PATTERNS.public)) {
    log("INFO", "Route access granted - public route", { pathname });
    return { allowed: true };
  }

  // Auth routes
  if (isRouteInCategory(pathname, ROUTE_PATTERNS.auth)) {
    if (user) {
      log("INFO", "Redirecting authenticated user from auth route", {
        pathname,
        userId: user.userId,
      });
      return { allowed: false, redirectTo: `/${locale}/dashboard` };
    }
    log("INFO", "Route access granted - auth route for unauthenticated user", {
      pathname,
    });
    return { allowed: true };
  }

  // Require authentication
  if (!user) {
    log("INFO", "Route access denied - authentication required", { pathname });
    return { allowed: false, redirectTo: `/${locale}/auth/login` };
  }

  const accessLevel = getAccessLevel(user);

  // No access
  if (accessLevel === "NO_ACCESS") {
    log("WARN", "Route access denied - no access level", {
      pathname,
      userId: user.userId,
      accountStatus: user.accountStatus,
    });
    return { allowed: false, redirectTo: `/${locale}/auth/login` };
  }

  // Profile-only access
  if (accessLevel === "PROFILE_ONLY") {
    const allowed = isRouteInCategory(pathname, ROUTE_PATTERNS.profileOnly);
    log(
      "INFO",
      `Route access ${allowed ? "granted" : "denied"} - profile only`,
      {
        pathname,
        userId: user.userId,
        accessLevel,
      }
    );
    return allowed
      ? { allowed: true }
      : { allowed: false, redirectTo: `/${locale}/profile/complete` };
  }

  // Limited access
  if (accessLevel === "LIMITED") {
    if (
      isRouteInCategory(pathname, ROUTE_PATTERNS.profileOnly) ||
      isRouteInCategory(pathname, ROUTE_PATTERNS.limited)
    ) {
      log("INFO", "Route access granted - limited access allowed", {
        pathname,
        userId: user.userId,
      });
      return { allowed: true };
    }

    if (isRouteInCategory(pathname, ROUTE_PATTERNS.fullAccess)) {
      log("WARN", "Route access denied - full access required", {
        pathname,
        userId: user.userId,
        accessLevel,
      });
      return { allowed: false, redirectTo: `/${locale}/dashboard` };
    }

    if (
      user.validationStatus !== "VALIDATED" &&
      isRouteInCategory(pathname, ROUTE_PATTERNS.validatedOnly)
    ) {
      log("WARN", "Route access denied - validation required", {
        pathname,
        userId: user.userId,
        validationStatus: user.validationStatus,
      });
      return { allowed: false, redirectTo: `/${locale}/dashboard` };
    }

    log("INFO", "Route access granted - limited access default", {
      pathname,
      userId: user.userId,
    });
    return { allowed: true };
  }

  // Full access
  log("INFO", "Route access granted - full access", {
    pathname,
    userId: user.userId,
    accessLevel,
  });
  return { allowed: true };
};
export default async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;
  const startTime = Date.now();

  log("INFO", "=== MIDDLEWARE START ===", {
    pathname,
    method: request.method,
    userAgent: request.headers.get("user-agent")?.slice(0, 100),
  });

  // Handle i18n first
  const i18nMiddleware = createMiddleware({
    locales,
    defaultLocale: "en",
  });
  const i18nResponse = i18nMiddleware(request);

  if (i18nResponse?.status >= 300 && i18nResponse.status < 400) {
    log("INFO", "I18n redirect triggered", {
      status: i18nResponse.status,
      location: i18nResponse.headers.get("location"),
    });
    return i18nResponse;
  }

  // Get tenant ID
  const tenantId = await getTenantId(request);
  if (!tenantId) {
    log("ERROR", "No tenant ID found - blocking request", { pathname });
    return NextResponse.json({ error: "Tenant not found" }, { status: 400 });
  }

  // Get and validate token
  const token = getAuthToken(request);
  let userSession: UserSession | null = null;

  if (token) {
    log("INFO", "Token found, validating...", { hasToken: true });
    const payload = decodeJWTPayload(token);

    if (payload && isTokenValid(payload)) {
      log("INFO", "Token is valid, fetching user data...", {
        userId: payload.sub,
        userType: payload.userType,
        tenantId: payload.tenantId,
      });

      // Fetch real user data from API with tenant context
      userSession = await fetchUserData(payload.sub, token, tenantId);
    } else {
      log("WARN", "Invalid or expired token", { hasPayload: !!payload });
    }
  } else {
    log("INFO", "No token found", { pathname });
  }

  // Check access
  const { allowed, redirectTo } = checkRouteAccess(pathname, userSession);

  if (!allowed && redirectTo) {
    log("INFO", "Access denied - redirecting", {
      from: pathname,
      to: redirectTo,
      userId: userSession?.userId,
    });
    return NextResponse.redirect(new URL(redirectTo, request.url));
  }

  // Add headers
  const headers = new Headers(i18nResponse?.headers);
  Object.entries(SECURITY_HEADERS).forEach(([key, value]) => {
    headers.set(key, value);
  });

  // Add tenant and user context headers
  headers.set("x-tenant-id", tenantId);

  if (userSession) {
    headers.set("x-user-id", userSession.userId);
    headers.set("x-user-type", userSession.userType);
    headers.set("x-account-status", userSession.accountStatus);
    headers.set("x-validation-status", userSession.validationStatus);
  }

  const executionTime = Date.now() - startTime;
  log("INFO", "=== MIDDLEWARE END ===", {
    pathname,
    allowed,
    executionTime: `${executionTime}ms`,
    tenantId,
    userId: userSession?.userId,
    userType: userSession?.userType,
    accessLevel: userSession ? getAccessLevel(userSession) : "NO_USER",
  });

  return new NextResponse(i18nResponse?.body, {
    status: i18nResponse?.status,
    statusText: i18nResponse?.statusText,
    headers,
  });
}
export const config = {
  matcher: ["/((?!api|_next/static|_next/image|favicon.ico|images|icons).*)"],
};
===============================================================================================================
# WORKFLOW DES COMMANDES
===============================================================================================================
## ÉTAPE 1 : CRÉATION DE COLIS

**Vue Client (Seller)**
Cette étape permet au client (seller) de créer un nouveau colis en renseignant toutes les informations nécessaires à la livraison.

### 1. Accès au formulaire de création
- Le client navigue vers : Gestion des colis > Nouveau Colis
- Le système affiche le formulaire de création de colis

### 2. Saisie des informations obligatoires
Le client renseigne les champs suivants :

**Informations destinataire :**
- Destinataire* (obligatoire) : Nom du destinataire
- Téléphone* (obligatoire) : Numéro de téléphone du destinataire
- Ville* (obligatoire) : Ville de livraison (sélection via liste déroulante)
- Adresse* (obligatoire) : Adresse complète de livraison

**Informations colis :**
- Code suivi (facultatif) : Code de suivi personnalisé
- Marchandise (facultatif) : produit (sélection via liste déroulante)
- Quantité (facultatif) : Nombre d'articles
- Prix* (obligatoire) : Montant de la commande
- Commentaire (facultatif) : Informations complémentaires (autre téléphone, date de livraison souhaitée, etc.)

**Options spéciales :**
- Interdit d'ouvrir le colis : Case à cocher
- Colis à remplacer : Case à cocher
- Colis de Stock : Case à cocher

**Actions disponibles**
- Enregistrer : Valide et crée le colis
- Reset : Remet à zéro tous les champs du formulaire

### 3. Vue client - Suivi des colis créés
**Accès :** Menu Gestion des colis > Colis pour ramassage

Après la création d'un colis, le client peut consulter ses colis en attente de ramassage dans une interface dédiée.

**Informations affichées dans le tableau :**
- Code d'envoi : Identifiant unique du colis (ex: BSK0925539432LE)
- Destinataire : Nom du destinataire
- Statut : Badge coloré indiquant l'état actuel
  - "Nouveau Colis" : colis créé, en attente de traitement
  - "Attente De Ramassage" : colis prêt pour collecte
- Date de création : Date et heure de création du colis
- Prix : Montant de la commande (en DH)
- Téléphone : Numéro du destinataire
- Ville : Ville de destination
- Bon de livraison : Référence du bon associé (ex: BL-280225-0192950-16-161)
- Actions : Boutons d'actions disponibles (icône information, icône update et icône delete)

**NB:** icône update et icône delete si le status de colis est "Nouveau colis"
**Icône information :** Accès aux détails via le bouton d'actions

### Vue administrateur - Supervision des colis
**Accès :** Menu Colis

**Informations affichées dans le tableau de bord :**
- Code d'envoi : Identifiant unique du colis
- Date d'expédition : Date de création du colis
- Téléphone : Numéro du destinataire
- Nom du magasin : Nom du client (seller)
- État : Statut actuel du colis (Non paye, paye, facture)
- Statut : Badge coloré indiquant l'état
- Ville : Ville de destination
- Prix : Montant de la commande
- Actions : Boutons d'actions disponibles pour chaque colis

**Actions disponibles par colis :**
L'administrateur dispose d'un menu d'actions contextuel pour chaque colis avec les options suivantes :
- 📄 Détails du suivi : Consultation de l'historique complet du colis
- ℹ️ Information du colis : Affichage des détails de la commande
- ✏️ Modifier le colis : Édition des informations du colis
- ✏️ Change Ville : Modification de la ville de destination
- 👤 Change Vendeur : Réassignation du vendeur/client
- ⚠️ Réinitialiser ce colis : Remise à zéro du statut du colis
- ⚠️ Relance ce colis : Relancement du processus de traitement

## ÉTAPE 2 : CRÉATION DES BONS DE LIVRAISON

Cette étape correspond à la réception physique des colis à l'agence et à la génération automatique des bons de livraison. Le système utilise la technologie de scan de codes-barres pour traiter les colis et mettre à jour automatiquement leur statut selon la zone géographique.

### 1. Accès à l'interface de scan
- L'agent navigue vers : Menu > Bons de livraison
- Clic sur le bouton "Code Bar Scanner" dans la barre d'outils

### 2. Interface de scan
L'interface propose deux méthodes de scan :
- **Scan manuel ou douchette :** Champ de saisie "CLIC ICI AVANT LE SCAN" pour saisie manuelle ou par douchette le code
- **Scan caméra :** Bouton "📷 Utiliser Camera" pour scan automatique via webcam/caméra mobile (scan qr code or barcode)

### 3. Traitement automatique du scan
Une fois le code-barres scanné ou saisi :
- Le système identifie automatiquement le colis
- Génère un bon de livraison avec référence unique
- Met à jour le statut selon la logique géographique

### 4. Logique de changement de statut

**Cas 1 : Destination dans la même zone que l'agence**
- Condition : Ville de destination = Zone de l'agence de ramassage
- Nouveau statut : "Reçu"
- Action : Le colis reste dans l'agence pour livraison locale

**Cas 2 : Destination dans une zone différente**
- Condition : Ville de destination ≠ Zone de l'agence de ramassage
- Nouveau statut : "Ramassé"
- Action : Le colis doit être transféré vers l'agence de destination

### 4. Interface de gestion des bons de livraison
Vue tableau des bons créés :
- Référence: Code unique du bon (BL-XXXXXX-XXX)
- Client
- Date de création: Date et heure de création du bon
- Date de réception
- Statut
- Colis: Nombre de colis dans le bon
- Total: Montant total en DH
- Actions:
  - 👁 Détails du bon : Consultation détaillée du bon de livraison
  - ✅ Bon bien reçu : Confirmation de réception du bon
  - 📄 Voir en PDF : Génération et téléchargement du bon au format PDF
  - 🏷 Voir les étiquettes : Affichage/impression des étiquettes de colis

## CRÉATION DE BONS DE LIVRAISON (INTERFACE CLIENT)

Cette fonctionnalité permet au client (seller) de créer ses propres bons de livraison (au cas où il ne va pas se déplacer à l'agence) en sélectionnant les colis qu'il souhaite regrouper.

### 1. Accès à l'interface de création
- Le client navigue vers : Menu > Bons de livraison
- La page affiche la liste des bons existants
- Clic sur le bouton "+ Ajouter Bon de livraison"
- Une deuxième page s'affiche:
  - Indicateur de nombre de colis éligibles pour création d'un bon
  - Bouton principal : "+ Créer bon de livraison"

### 2. Création de bons de livraison
- Clic sur ce bouton pour accéder à l'interface détaillée de sélection des colis
- Une fois le bouton "Créer bon de livraison" cliqué, le système affiche l'interface complète avec :

**Liste des nouveaux colis disponibles:** Tableau des colis éligibles pour ajout au bon :
- Code d'envoi: Identifiant unique du colis
- Destinataire: Nom du destinataire
- Date de création: Date de création du colis
- Prix: Montant en DH
- Ville: Ville de destination
- Actions: Bouton "+" pour ajouter le colis et Case à cocher pour sélection multiple et Bouton "Ajouter" (en bas) : Ajouter tous les colis sélectionnés

**Liste des colis ajoutés au bon:** Section qui affiche les colis sélectionnés pour le bon en cours de création.
- Vide initialement : "Aucun enregistrement disponible" / "Aucune entrées correspondants trouvés"
- Après ajout : Liste des colis inclus dans le bon

**Tickets et Bon de livraison - Obtenir en PDF** Trois options de génération disponibles :
- Génération du premier type de ticket (Première image)
- Génération de deuxième type de ticket (deuxième image)
- Génération de bon de livraison (troisieme image)

### 3. Vue tableau des bons de livraison
Après création, les bons apparaissent dans le tableau principal :
- Référence
- Date de création
- Statut
- Colis
- Actions

## CRÉATION DES BONS DE DISTRIBUTION

Cette étape permet à l'administrateur d'affecter les colis aux livreurs en créant des bons de distribution. Le processus implique la sélection d'une zone géographique, l'assignation d'un livreur spécifique, puis la sélection des colis à distribuer soit manuellement soit par scan.

### 1. Accès à l'interface de distribution
- L'administrateur navigue vers : Menu > Bons de distribution
- Clic sur le bouton "+ Ajouter Bon De Distribution"
- **Sélection de la zone:**
  - Liste déroulante des zones disponibles
  - Affichage du nombre de colis en attente par zone
- **Sélection du livreur:**
  - Liste déroulante des livreurs disponibles pour la zone sélectionnée

### 2. Création du bon et sélection des colis
Une fois le bouton "Créer" cliqué, le système affiche l'interface de sélection des colis :

**Liste des nouveaux colis disponibles:** Tableau des colis éligibles pour distribution dans la zone sélectionnée
- Code d'envoi
- Client
- Date de réception
- Ville
- Livreur
- Adresse
- Commentaire
- Prix
- Statut
- Actions: (Boutons d'ajout et sélection + Case à cocher)

**Liste des colis ajoutés au bon :** Affiche les colis sélectionnés pour le bon de distribution en cours

**Interface de scan pour retrait de colis:**
- Champ de scan : "CLIC ICI AVANT LE SCAN"
- Scan caméra : Bouton "📷 Utiliser Camera" (scan qr code or barcode)
- Fonctionnalité : Permet de retirer des colis du bon par scan

### 3. Vue tableau des bons de distribution créés
Une fois créés, les bons apparaissent dans le tableau principal des bons de distribution :
- Référence
- Date de création
- Date d'Enregistrement
- Zone
- Livreur
- Statut
- Colis
- Actions:
  - 📄 Détails du bon : Consultation détaillée
  - 🗑 Supprimer le bon : Suppression du bon
  - ✏️ Modifier le bon : Édition des paramètres
  - 📄 Voir en PDF : Génération du document
  - 📊 Export Excel : Export des données

### 3. Logique de changement de statut après distribution

**Cas 1 : Distribution dans la même zone (livraison locale)**
- Condition : Ville de destination = Zone de ramassage/agence
- Changement de statut : "Reçu" → "En distribution"
- Action : Le colis passe directement en phase de livraison finale
- Workflow : Colis → Bon de livraison→ Bon de distribution → Livraison directe

**Cas 2 : Distribution vers une zone différente (transfert inter-agences)**
- Condition : Ville de destination ≠ Zone de ramassage/agence
- Étape intermédiaire : Création d'un "Bon d'envoi" (à détailler)
- Action : Le colis doit être transféré vers l'agence de la zone de destination
- Workflow : Colis → Bon de livraison→ Bon d'envoi ( Transfert → a l l'agence destination )→ Bon de distribution → Livraison

## CRÉATION DES BONS D'ENVOI

Cette étape gère les colis qui doivent être transférés vers d'autres zones géographiques. Lorsqu'un colis à une destination différente de la zone de ramassage, il passe par un bon d'envoi avant d'être acheminé vers l'agence de destination appropriée.

### 1. Accès à l'interface de création
- L'administrateur navigue vers : Menu > Bons d'envoi
- Clic sur le bouton "+ Ajouter Bon D'envoi ( Zone )"
- **Sélection de la zone de destination**
  - Liste déroulante des zones de destination disponibles
  - Sélection de la zone vers laquelle transférer les colis

### 2. Création du bon et sélection des colis
**Liste des nouveaux colis disponibles :** Tableau des colis éligibles pour transfert vers la zone sélectionnée
- Code d'envoi
- Client
- Date de ramassage
- Prix
- Ville
- Actions: (Boutons d'ajout et Case à cocher)

**Liste des colis ajoutés au bon :** Section "LIST DES COLIS AJOUTÉS" Affiche les colis sélectionnés pour le bon d'envoi
- Toutes les elements de liste de colis disponible + la colonne scanned (indicateur de scan)

**Interface de scan :**
- Champ de scan : "CLIC ICI AVANT LE SCAN"
- Scan caméra : Bouton "📷 Utiliser Camera" (scan qr code or barcode)
- Fonctionnalité : Retrait de colis du bon par scan

### 3. Vue tableau des bons d'envoi créés
Une fois créés, les bons d'envoi apparaissent dans le tableau principal :
- Référence
- Date de création
- Date de réception
- Zone
- Statut
- Colis
- Actions:
  - 👁 Détails du bon : Consultation détaillée du bon d'envoi
  - ✅ Bon bien reçu :
  - ✏️ Modifier le bon : Édition des paramètres du bon d'envoi
  - 📄 Voir en PDF : Génération et téléchargement du bon au format PDF
  - 📊 Export Excel : Export des données du bon vers Excel

### 4. Changement de statut des colis
**Transition automatique :** Une fois les colis ajoutés au bon d'envoi et le bon finalisé :
- Statut précédent : "Ramassé"
- Nouveau statut : "Expédié"
- Action : Les colis sont prêts pour transfert physique vers l'agence de destination

### 5. Workflow de transfert inter-agences
- **Agence source :** Création du bon d'envoi (statut "Ramasse")
- **Expédition :** Colis passent au statut "Expédié"
- **Transport :** Acheminement physique vers agence de destination
- **Agence destination :** Réception et scan des colis
- **Suite du processus :** Création de bons de distribution locaux

## GESTION DES BONS DE PAIEMENT

Le module de bons de paiement gère la comptabilité et les règlements financiers dans le système. Il se divise en deux catégories principales : les paiements aux livreurs individuels et les paiements aux modérateurs de zone pour les transferts inter-agences.

- **Bons de paiement pour livreur :** Règlement des livreurs individuels
- **Bons de paiement pour zone :** Comptabilité avec les modérateurs de zone

## BONS DE PAIEMENT POUR LIVREUR

Cette fonctionnalité permet de créer et gérer les paiements destinés aux livreurs individuels pour les livraisons effectuées dans leur zone d'intervention.

### 1. Accès à l'interface
- Navigation : Menu > Bons de paiement > Pour livreur
- Clic sur "+ Ajouter Bon Pour Livreur"

### 2. Création de bon de paiement pour livreur
- **Sélectionner la zone:** Liste déroulante avec statistiques (Affichage du nombre de livraisons réussies et échecs)
- **Sélection du livreur:** Liste déroulante des livreurs avec statistiques individuelles (Affichage du nombre de livraisons réussies et échecs)
- **Création et configuration du bon:**

**Liste des nouveaux colis:** Tableau des colis livrés éligibles au paiement :
- Code d'envoi
- Client
- Téléphone
- Date de livraison
- Statut
- Ville
- Prix
- Frais
- Total
- Actions:
  - Détails du suivi : Historique complet
  - Information du colis : Détails de la commande
  - Modifier le colis : Édition des informations
  - Change Ville : Modification destination
  - Change Vendeur : Réassignation vendeur
  - Colis non livré : Marquage échec livraison
  - Changer le prix : Ajustement montant
  - Remboursement : Gestion des retours

**Section "AUTRES FRAIS"** Interface pour ajouter des frais supplémentaires :
- Désignation : Description du frais
- Quantité
- Prix unitaire
- Total

### 3. Vue tableau des bons de paiement
Interface principale des bons créés :
- Référence
- Date de création
- Date Changement de statuts
- Zone
- Livreur
- Portefeuille
- Screen
- Statut
- Colis (Nb)
- Total

### 4. Cycle de vie des bons de paiement
Changement de statut se fait en 3 étapes

**1. Attente de paiement**
- Bon créé avec les colis livrés
- En attente de traitement financier

**2. Encore de traitement**
- Paiement en cours de traitement
- Vérifications comptables en cours

**3. Payé**
- Paiement effectué au livreur
- Clôture comptable du bon

Lors du passage au statut "Payé", une popup s'affiche avec :
- Champ Virement : Montant du virement
- Champ Cash : Montant en espèces
- Bouton "Payé" : Confirmation finale du paiement

## BONS DE PAIEMENT POUR ZONE

Cette fonctionnalité gère la comptabilité avec les modérateurs de zone pour les transferts inter-agences. Elle permet de régler financièrement les zones qui ont reçu et traité des colis provenant d'autres agences.

### 1. Accès à l'interface
- Navigation : Menu > Bons de paiement > Pour zone
- Clic sur "+ Ajouter Bon Pour Zone"

### 2. Sélection de la zone

### 3. Création et configuration du bon
**Liste des nouveaux colis:** Tableau des colis livrés dans la zone éligibles au paiement
- Code d'envoi
- Client
- Téléphone
- Date de livraison
- Statut
- Ville
- Prix
- Frais
- Total

**Liste des colis ajoutés:**
- Code d'envoi
- Client
- Téléphone
- Date de livraison
- Statut
- Ville
- Prix
- Frais
- Total

### 4. Vue tableau des bons de paiement pour zone
Interface principale des bons créés :
- Référence
- Date de création
- Date Changement de statuts
- Zone
- Statut
- Colis
- Total

### 5. Gestion des statuts de paiement
Cycle de vie des bons de paiement pour zone :

**1. Attente de paiement**
- Bon créé pour la zone
- En attente de traitement comptable

**2. En cours de traitement**
- Paiement en cours de validation
- Vérifications inter-agences

**3. Payé**
- Règlement effectué à la zone
- Clôture comptable du transfert

## GESTION DES BONS DE RETOUR

### Bons de retour pour livreur

**Table contents :**
- Référence
- Date de création
- Livreur
- Type
- Statut
- Colis
- Actions

*Exemple :*
BRL-240925-0126910-76-133 | 2025-09-24 13:20 | Youness RBT | Demande | Incomplet | 0 | 22 | 2 | update/delete

**Créer Bons de retour for livreur:**
- Sélection le livreur
- Select LISTE DES COLIS DEMANDE DE RETOUR
- Create Bons de retour

### Bons de retour pour zone

**Table contents :**
- Référence
- Date de création
- Date de réception
- Ville
- Statut
- Colis
- Actions

*Exemple :*
BRV-170925-0126750-79-V | 2025-09-17 13:51 | 2025-09-17 16:03 | HUB CASABLANCA | Reçu | 3 | details/voir/delete
(youness bousaou ali housni)

**Créer Bons de retour for zone:**
- Sélection la zone
- List des colis ajoutés
- Create Bons de retour

### Bons de retour pour client (customer)

**Table contents :**
- Référence
- Date de création
- Date de réception
- Nom du magasin
- Statut
- Colis
- Actions

*Exemple :*
BRC-160925-0126540-77-138 | 2025-09-16 17:33 | 2025-09-17 09:36 | Metalivraison - (546) | Reçu | 1Nouveau | 6 | details/voir/export
(milad settaoui milad settaoui)

**Créer Bons de retour for customer:**
- Sélection le client
- Ajouter liste des colis returne
- create Bons de retour for customer
===============================================================================================================
Nest js backend Parcels-Service:
===============================================================================================================
--++--> prisma/schema.prisma =======>
-----------------------------------------------------------------------
generator client {
  provider = "prisma-client-js"
}
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}
// ========================================
// CORE REFERENCE DATA
// These models define the foundational data for the delivery system
// ========================================
/**
 * City Model
 * Represents cities where packages can be picked up or delivered
 * Supports multi-tenant architecture with soft deletes
 */
model City {
  id         String  @id @default(cuid()) // Unique identifier using CUID
  tenantId   String // Multi-tenant support - isolates data per organization
  ref        String // Business reference code (e.g., "CAS" for Casablanca)
  name       String // Display name of the city
  zone       String? // Optional zone grouping for logistics
  pickupCity Boolean @default(false) // Whether this city accepts package pickups
  status     Boolean @default(true) // Active/inactive flag for business operations

  // Soft delete pattern - allows data recovery and maintains referential integrity
  isDeleted Boolean   @default(false) // Soft delete flag
  deletedAt DateTime? // Timestamp when deleted
  deletedBy String? // User who performed the deletion

  // Audit trail - tracks data changes for compliance and debugging
  createdAt DateTime @default(now()) // Record creation timestamp
  updatedAt DateTime @updatedAt // Auto-updated on record changes
  createdBy String? // User who created the record
  updatedBy String? // User who last updated the record

  // Relations - Define how cities connect to other entities
  pickupTariffs        Tariff[]       @relation("PickupCity") // Tariffs where this city is pickup
  destinationTariffs   Tariff[]       @relation("DestinationCity") // Tariffs where this city is destination
  zones                ZoneCity[] // Many-to-many relationship with zones
  parcelsAsPickup      Parcel[]       @relation("PickupCity") // Parcels picked up from this city
  parcelsAsDestination Parcel[]       @relation("DestinationCity") // Parcels delivered to this city
  deliverySlips        DeliverySlip[] // Delivery slips for this city

  // Optimized indexes for common query patterns
  @@unique([tenantId, ref, isDeleted]) // Ensures unique business codes per tenant
  @@index([tenantId, isDeleted, status]) // Fast tenant + active city queries
  @@index([tenantId, isDeleted, pickupCity]) // Quick pickup city filtering
  @@index([tenantId, zone]) // Zone-based queries within tenant
  @@index([name]) // City name searches
  @@map("cities") // Custom table name
}
/**
 * PickupCity Model
 * Specialized reference for pickup locations/hubs
 * Separate from regular cities for operational flexibility
 */
model PickupCity {
  id       String  @id @default(cuid())
  tenantId String // Multi-tenant isolation
  ref      String // Business reference (e.g., "CAS_HUB")
  name     String // Display name (e.g., "HUB CASABLANCA")
  status   Boolean @default(true) // Active status

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations
  tariffs Tariff[] @relation("PickupCityRef") // Optional tariff reference

  // Indexes and constraints
  @@unique([tenantId, ref, isDeleted]) // Unique pickup city refs per tenant
  @@index([tenantId, isDeleted, status]) // Active pickup cities per tenant
  @@map("pickup_cities")
}
/**
 * Tariff Model
 * Defines pricing and delivery terms between city pairs
 * Core business logic for cost calculation
 */
model Tariff {
  id                String  @id @default(cuid())
  tenantId          String // Multi-tenant support
  pickupCityId      String // Source city for package
  destinationCityId String // Destination city for package
  deliveryPrice     Decimal @db.Decimal(10, 2) // Standard delivery fee (precise decimal for money)
  returnPrice       Decimal @default(0) @db.Decimal(10, 2) // Fee for returning undelivered packages
  refusalPrice      Decimal @default(0) @db.Decimal(10, 2) // Fee for refused packages
  deliveryDelay     Int     @db.SmallInt // Expected delivery time in days

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations
  pickupCity      City        @relation("PickupCity", fields: [pickupCityId], references: [id])
  destinationCity City        @relation("DestinationCity", fields: [destinationCityId], references: [id])
  pickupCityRef   PickupCity? @relation("PickupCityRef", fields: [pickupCityRefId], references: [id])
  pickupCityRefId String? // Optional reference to pickup city hub
  parcels         Parcel[] // Parcels using this tariff

  // Optimized indexes for route-based pricing queries
  @@unique([tenantId, pickupCityId, destinationCityId, isDeleted]) // Unique routes per tenant
  @@index([tenantId, isDeleted]) // Tenant-wide tariff queries
  @@index([pickupCityId, destinationCityId]) // Fast route-based lookups
  @@map("tariffs")
}
/**
 * Zone Model
 * Logical grouping of cities for operational management
 * Used for organizing delivery routes and staff assignments
 */
model Zone {
  id       String  @id @default(cuid())
  tenantId String // Multi-tenant support
  name     String // Zone name (e.g., "HUB CASABLANCA")
  status   Boolean @default(true) // Active status

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations - Zones coordinate multiple operational processes
  cities              ZoneCity[] // Cities within this zone
  distributionSlips   DistributionSlip[] // Distribution assignments for this zone
  shippingSlips       ShippingSlip[] // Inter-zone shipments to this zone
  returnSlipsForZone  ReturnSlip[]       @relation("ReturnSlipZone") // Returns processed by zone
  paymentSlipsForZone PaymentSlip[]      @relation("PaymentSlipZone") // Payments processed by zone

  // Indexes for zone-based operations
  @@unique([tenantId, name, isDeleted]) // Unique zone names per tenant
  @@index([tenantId, isDeleted, status]) // Active zones per tenant
  @@map("zones")
}
/**
 * ZoneCity Junction Table
 * Many-to-many relationship between zones and cities
 * Allows flexible city-to-zone assignments
 */
model ZoneCity {
  zoneId String // Reference to zone
  cityId String // Reference to city

  // Relations with cascade delete - if zone/city deleted, remove assignment
  zone Zone @relation(fields: [zoneId], references: [id], onDelete: Cascade)
  city City @relation(fields: [cityId], references: [id], onDelete: Cascade)

  @@id([zoneId, cityId]) // Composite primary key - more efficient than separate ID
  @@map("zone_cities")
}
/**
 * ParcelStatus Model
 * Defines the workflow states an parcel can be in
 * Core to tracking package lifecycle
 */
model ParcelStatus {
  id       String  @id @default(cuid())
  tenantId String // Multi-tenant support
  code     String  @db.VarChar(50) // Business code (e.g., "NEW_PACKAGE", "DELIVERED")
  name     String  @db.VarChar(100) // Display name (e.g., "Nouveau Colis", "Livré")
  color    String  @db.VarChar(7) // Hex color for UI display (#FF0000)
  isLocked Boolean @default(false) // Whether status can be manually changed
  status   Boolean @default(true) // Active status

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations
  parcels               Parcel[] // Parcels in this status
  parcelStatusHistories ParcelStatusHistory[] // Status change history

  // Constraints and indexes
  @@unique([tenantId, code, isDeleted]) // Unique status codes per tenant
  @@unique([tenantId, color, isDeleted]) // Unique colors per tenant (UI requirement)
  @@index([tenantId, isDeleted, status]) // Active statuses per tenant
  @@map("parcel_statuses")
}
// ========================================
// PARCELS CORE
// The heart of the delivery system - manages package parcels
// ========================================
/**
 * Parcel Model
 * Central entity representing a package delivery request
 * Contains all information needed for pickup, delivery, and payment
 */
model Parcel {
  id       String @id @default(cuid())
  tenantId String // Multi-tenant support
  userId   String // Seller/client who created the parcel
  code     String @unique @db.VarChar(50) // Unique business code (e.g., BSK0925539432LE)

  // Customer information - who receives the package
  recipientName    String  @db.VarChar(200) // Customer name
  recipientPhone   String  @db.VarChar(20) // Primary contact number
  recipientAddress String  @db.Text // Full delivery address
  alternativePhone String? @db.VarChar(20) // Backup contact number

  // Location - pickup and delivery cities
  pickupCityId      String // Where package is collected
  destinationCityId String // Where package is delivered

  // Package details - what's being delivered
  trackingCode String? @db.VarChar(100) // Custom tracking code from seller
  productName  String? @db.VarChar(200) // Product description
  quantity     Int?    @default(1) @db.SmallInt // Number of items
  price        Decimal @db.Decimal(12, 2) // COD amount (Cash on Delivery value)
  comment      String? @db.Text // Special delivery instructions

  // Package handling options - business rules
  cannotOpen Boolean @default(false) // Package cannot be opened for inspection
  canReplace Boolean @default(false) // Can substitute with different item
  isStock    Boolean @default(false) // Is this a stock/inventory item

  // Status and workflow tracking
  parcelStatusId   String // Current status reference
  parcelStatusCode String        @db.VarChar(50) // Current status code (for fast queries)
  paymentStatus    PaymentStatus @default(PENDING) // Payment processing state

  // Pricing - calculated from tariff, stored for historical accuracy
  deliveryPrice Decimal @db.Decimal(10, 2) // Standard delivery fee
  returnPrice   Decimal @default(0) @db.Decimal(10, 2) // Return fee if undelivered
  refusalPrice  Decimal @default(0) @db.Decimal(10, 2) // Refusal fee if rejected
  deliveryDelay Int     @db.SmallInt // Expected delivery days
  tariffId      String? // Reference to tariff used for pricing

  // Delivery tracking - operational data
  deliveryAttempts Int       @default(0) @db.SmallInt // How many delivery attempts made
  lastAttemptDate  DateTime? // When last delivery was attempted
  deliveredAt      DateTime? // When successfully delivered
  deliveredBy      String? // ID of delivery person who completed

  // Return/Refusal tracking - handling failed deliveries
  returnedAt    DateTime? // When package was returned to sender
  returnReason  String?   @db.Text // Why package was returned
  refusedAt     DateTime? // When package was refused by recipient
  refusalReason String?   @db.Text // Why package was refused

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations - how parcels connect to other system components
  pickupCity      City         @relation("PickupCity", fields: [pickupCityId], references: [id])
  destinationCity City         @relation("DestinationCity", fields: [destinationCityId], references: [id])
  parcelStatus    ParcelStatus @relation(fields: [parcelStatusId], references: [id])
  tariff          Tariff?      @relation(fields: [tariffId], references: [id])

  // Status change history for audit trail
  statusHistory ParcelStatusHistory[]

  // Slip associations - tracking through various operational documents
  deliverySlipItems     DeliverySlipItem[] // When parcel is collected from sender
  distributionSlipItems DistributionSlipItem[] // When parcel is assigned for delivery
  shippingSlipItems     ShippingSlipItem[] // When parcel is shipped between zones
  returnSlipItems       ReturnSlipItem[] // When parcel is returned to sender
  paymentSlipItems      PaymentSlipItem[] // When payment is processed

  // Optimized indexes for common query patterns
  @@index([tenantId, isDeleted]) // Basic tenant filtering
  @@index([tenantId, userId, isDeleted]) // Parcels by user
  @@index([tenantId, parcelStatusCode, isDeleted]) // Parcels by status
  @@index([tenantId, paymentStatus, isDeleted]) // Parcels by payment status
  @@index([tenantId, createdAt, isDeleted]) // Time-based queries within tenant
  @@index([recipientPhone, tenantId]) // Customer phone lookup
  @@index([pickupCityId, destinationCityId]) // Route-based queries
  @@index([deliveredAt]) // Delivered parcels analytics
  @@map("parcels")
}
/**
 * ParcelStatusHistory Model
 * Tracks all status changes for an parcel
 * Provides complete audit trail of parcel lifecycle
 */
model ParcelStatusHistory {
  id             String   @id @default(cuid())
  parcelId       String // Reference to the parcel
  parcelStatusId String // Reference to the status
  statusCode     String   @db.VarChar(50) // Status code for fast queries
  comment        String?  @db.Text // Optional comment about the change
  changedBy      String? // User who made the change
  changedAt      DateTime @default(now()) // When the change occurred

  // Relations with cascade delete - if parcel deleted, remove history
  parcel       Parcel       @relation(fields: [parcelId], references: [id], onDelete: Cascade)
  parcelStatus ParcelStatus @relation(fields: [parcelStatusId], references: [id])

  // Optimized indexes for history queries
  @@index([parcelId, changedAt]) // Parcel history timeline
  @@index([statusCode, changedAt]) // Status-based reporting and analytics
  @@map("parcel_status_history")
}
// ========================================
// DELIVERY SLIPS (Bons de livraison)
// Documents for tracking package collection from senders
// ========================================
/**
 * DeliverySlip Model
 * Represents a collection document for packages from senders
 * Groups multiple parcels for efficient pickup operations
 */
model DeliverySlip {
  id        String  @id @default(cuid())
  tenantId  String // Multi-tenant support
  userId    String // Client/seller who created the slip
  reference String  @unique @db.VarChar(50) // Business reference (BL-XXXXXX-XXX)
  cityId    String? // City where packages are collected

  status DeliverySlipStatus @default(PENDING) // Processing status

  // Reception tracking - when packages are actually collected
  receivedAt DateTime? // When collection was completed
  receivedBy String? // Staff member who performed collection

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations
  city  City?              @relation(fields: [cityId], references: [id])
  items DeliverySlipItem[] // Individual parcels on this slip

  // Optimized indexes for operational queries
  @@index([tenantId, userId, isDeleted]) // Slips by client
  @@index([tenantId, status, isDeleted]) // Slips by processing status
  @@index([tenantId, createdAt, isDeleted]) // Time-based slip queries
  @@map("delivery_slips")
}
/**
 * DeliverySlipItem Model
 * Junction table linking parcels to delivery slips
 * Tracks scanning/processing of individual packages
 */
model DeliverySlipItem {
  deliverySlipId String // Reference to delivery slip
  parcelId       String // Reference to parcel
  scanned        Boolean   @default(false) // Whether package was scanned/processed
  scannedAt      DateTime? // When scanning occurred
  scannedBy      String? // Who performed the scan

  // Relations with cascade delete
  deliverySlip DeliverySlip @relation(fields: [deliverySlipId], references: [id], onDelete: Cascade)
  parcel       Parcel       @relation(fields: [parcelId], references: [id])

  @@id([deliverySlipId, parcelId]) // Composite primary key - efficient and prevents duplicates
  @@index([parcelId]) // Reverse lookup - find slips for an parcel
  @@map("delivery_slip_items")
}
// ========================================
// SHIPPING SLIPS (Bons d'envoi)
// Documents for inter-zone package transfers
// ========================================
/**
 * ShippingSlip Model
 * Manages transfer of packages between different zones/hubs
 * Critical for multi-location delivery networks
 */
model ShippingSlip {
  id                String @id @default(cuid())
  tenantId          String // Multi-tenant support
  reference         String @unique @db.VarChar(50) // Business reference (BE-XXXXXX-XXX)
  destinationZoneId String // Zone receiving the packages

  status ShippingSlipStatus @default(PENDING) // Transfer status

  // Shipping process tracking
  shippedAt  DateTime? // When packages left origin
  shippedBy  String? // Who sent the packages
  receivedAt DateTime? // When packages arrived at destination
  receivedBy String? // Who received the packages

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations
  destinationZone Zone               @relation(fields: [destinationZoneId], references: [id])
  items           ShippingSlipItem[] // Individual parcels being shipped

  // Optimized indexes for logistics queries
  @@index([tenantId, status, isDeleted]) // Slips by status
  @@index([tenantId, createdAt, isDeleted]) // Time-based queries
  @@index([destinationZoneId, status]) // Zone-specific shipping status
  @@map("shipping_slips")
}
/**
 * ShippingSlipItem Model
 * Links individual parcels to shipping slips
 * Tracks package movement between zones
 */
model ShippingSlipItem {
  shippingSlipId String // Reference to shipping slip
  parcelId       String // Reference to parcel being shipped
  scanned        Boolean   @default(false) // Whether package was scanned for shipping
  scannedAt      DateTime? // When scan occurred
  scannedBy      String? // Who performed the scan

  // Relations with cascade delete
  shippingSlip ShippingSlip @relation(fields: [shippingSlipId], references: [id], onDelete: Cascade)
  parcel       Parcel       @relation(fields: [parcelId], references: [id])

  @@id([shippingSlipId, parcelId]) // Composite primary key
  @@index([parcelId]) // Reverse lookup capability
  @@map("shipping_slip_items")
}
// ========================================
// DISTRIBUTION SLIPS (Bons de distribution)
// Documents for assigning packages to delivery personnel
// ========================================
/**
 * DistributionSlip Model
 * Assigns packages to delivery personnel for final delivery
 * Core document for last-mile delivery operations
 */
model DistributionSlip {
  id               String  @id @default(cuid())
  tenantId         String // Multi-tenant support
  reference        String  @unique @db.VarChar(50) // Business reference (BD-XXXXXX-XXX)
  zoneId           String // Zone where delivery occurs
  deliveryPersonId String? // Assigned delivery person

  status DistributionSlipStatus @default(PENDING) // Assignment status

  // Assignment tracking
  assignedAt DateTime? // When assigned to delivery person
  assignedBy String? // Who made the assignment

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations
  zone  Zone                   @relation(fields: [zoneId], references: [id])
  items DistributionSlipItem[] // Parcels assigned for delivery

  // Optimized indexes for delivery management
  @@index([tenantId, status, isDeleted]) // Slips by status
  @@index([tenantId, createdAt, isDeleted]) // Time-based queries
  @@index([zoneId, status]) // Zone-specific distribution status
  @@index([deliveryPersonId, status]) // Person-specific assignments
  @@map("distribution_slips")
}
/**
 * DistributionSlipItem Model
 * Links parcels to distribution assignments
 * Tracks individual package assignments to delivery staff
 */
model DistributionSlipItem {
  distributionSlipId String // Reference to distribution slip
  parcelId           String // Reference to parcel for delivery
  scanned            Boolean   @default(false) // Whether assignment was scanned/confirmed
  scannedAt          DateTime? // When scan occurred
  scannedBy          String? // Who performed the scan

  // Relations with cascade delete
  distributionSlip DistributionSlip @relation(fields: [distributionSlipId], references: [id], onDelete: Cascade)
  parcel           Parcel           @relation(fields: [parcelId], references: [id])

  @@id([distributionSlipId, parcelId]) // Composite primary key
  @@index([parcelId]) // Reverse lookup capability
  @@map("distribution_slip_items")
}
// ========================================
// RETURN SLIPS (Bons de retour)
// Documents for handling undelivered packages
// ========================================
/**
 * ReturnSlip Model
 * Manages packages that couldn't be delivered and need to be returned
 * Supports different return types: from drivers, zones, or back to customers
 */
model ReturnSlip {
  id        String         @id @default(cuid())
  tenantId  String // Multi-tenant support
  reference String         @unique @db.VarChar(50) // Business reference (BRL/BRV/BRC-XXXXXX-XXX)
  type      ReturnSlipType // Type of return (DRIVER/ZONE/CUSTOMER)

  // Type-specific associations - polymorphic relationship pattern
  deliveryPersonId String? // For DRIVER type - returns from delivery staff
  zoneId           String? // For ZONE type - returns from operational zones
  customerId       String? // For CUSTOMER type - returns to specific customers
  customerName     String? @db.VarChar(200) // Display name for customer returns

  status ReturnSlipStatus @default(PENDING) // Processing status

  // Processing workflow tracking
  processedAt DateTime? // When return processing started
  processedBy String? // Who initiated processing
  receivedAt  DateTime? // When returned packages were received
  receivedBy  String? // Who received the returned packages

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations
  zone  Zone?            @relation("ReturnSlipZone", fields: [zoneId], references: [id])
  items ReturnSlipItem[] // Individual parcels being returned

  // Optimized indexes for return management
  @@index([tenantId, type, isDeleted]) // Returns by type
  @@index([tenantId, status, isDeleted]) // Returns by processing status
  @@index([tenantId, createdAt, isDeleted]) // Time-based return queries
  @@index([deliveryPersonId, status]) // Driver-specific returns
  @@index([zoneId, status]) // Zone-specific returns
  @@index([customerId]) // Customer-specific returns
  @@map("return_slips")
}
/**
 * ReturnSlipItem Model
 * Links individual parcels to return slips
 * Captures return reasons and processing details
 */
model ReturnSlipItem {
  returnSlipId String // Reference to return slip
  parcelId     String // Reference to parcel being returned
  returnReason String?   @db.Text // Detailed reason for return
  scanned      Boolean   @default(false) // Whether return was scanned/processed
  scannedAt    DateTime? // When scan occurred
  scannedBy    String? // Who performed the scan

  // Relations with cascade delete
  returnSlip ReturnSlip @relation(fields: [returnSlipId], references: [id], onDelete: Cascade)
  parcel     Parcel     @relation(fields: [parcelId], references: [id])

  @@id([returnSlipId, parcelId]) // Composite primary key
  @@index([parcelId]) // Reverse lookup capability
  @@map("return_slip_items")
}
// ========================================
// PAYMENT SLIPS (Bons de paiement)
// Documents for processing delivery payments and fees
// ========================================
/**
 * PaymentSlip Model
 * Manages payment collection and distribution for delivery services
 * Handles payments to delivery personnel and zone operations
 */
model PaymentSlip {
  id        String          @id @default(cuid())
  tenantId  String // Multi-tenant support
  reference String          @unique @db.VarChar(50) // Business reference (BPL/BPV-XXXXXX-XXX)
  type      PaymentSlipType // Payment type (DRIVER/ZONE)

  // Type-specific associations
  deliveryPersonId String? // For DRIVER type - payments to delivery staff
  zoneId           String? // For ZONE type - payments to zone operations

  // Payment amount breakdown - using Decimal for financial precision
  totalAmount    Decimal @default(0) @db.Decimal(12, 2) // Total payment amount
  cashAmount     Decimal @default(0) @db.Decimal(12, 2) // Cash component
  transferAmount Decimal @default(0) @db.Decimal(12, 2) // Bank transfer component
  additionalFees Decimal @default(0) @db.Decimal(12, 2) // Extra fees and charges

  status PaymentSlipStatus @default(PENDING) // Payment processing status

  // Payment workflow tracking
  processedAt DateTime? // When payment processing started
  processedBy String? // Who initiated processing
  paidAt      DateTime? // When payment was completed
  paidBy      String? // Who completed the payment

  // Additional information
  notes String? @db.Text // Payment notes and comments

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations
  zone            Zone?                      @relation("PaymentSlipZone", fields: [zoneId], references: [id])
  items           PaymentSlipItem[] // Individual parcel payments
  additionalItems PaymentSlipAdditionalFee[] // Extra fees and charges

  // Optimized indexes for financial queries
  @@index([tenantId, type, isDeleted]) // Payments by type
  @@index([tenantId, status, isDeleted]) // Payments by status
  @@index([tenantId, createdAt, isDeleted]) // Time-based payment queries
  @@index([deliveryPersonId, status]) // Driver-specific payments
  @@index([zoneId, status]) // Zone-specific payments
  @@map("payment_slips")
}
/**
 * PaymentSlipItem Model
 * Links individual parcel payments to payment slips
 * Tracks specific fees for each parcel (delivery, return, refusal)
 */
model PaymentSlipItem {
  paymentSlipId String // Reference to payment slip
  parcelId      String // Reference to parcel
  feeType       String  @db.VarChar(20) // Type of fee (DELIVERY, RETURN, REFUSAL)
  amount        Decimal @db.Decimal(10, 2) // Payment amount for this parcel/fee

  // Relations with cascade delete
  paymentSlip PaymentSlip @relation(fields: [paymentSlipId], references: [id], onDelete: Cascade)
  parcel      Parcel      @relation(fields: [parcelId], references: [id])

  @@id([paymentSlipId, parcelId, feeType]) // Composite primary key - prevents duplicate fee types per parcel
  @@index([parcelId]) // Reverse lookup capability
  @@map("payment_slip_items")
}
/**
 * PaymentSlipAdditionalFee Model
 * Handles extra fees and charges not tied to specific parcels
 * Examples: fuel costs, equipment rental, bonus payments
 */
model PaymentSlipAdditionalFee {
  id            String  @id @default(cuid())
  paymentSlipId String // Reference to payment slip
  description   String  @db.VarChar(200) // Fee description
  quantity      Int     @default(1) @db.SmallInt // Quantity for unit-based fees
  unitPrice     Decimal @db.Decimal(10, 2) // Price per unit
  totalPrice    Decimal @db.Decimal(10, 2) // Total fee amount (quantity × unit price)

  // Relations with cascade delete
  paymentSlip PaymentSlip @relation(fields: [paymentSlipId], references: [id], onDelete: Cascade)

  @@index([paymentSlipId]) // Payment slip lookup
  @@map("payment_slip_additional_fees")
}
// ========================================
// ENUMS
// Define the possible values for status and type fields
// ========================================
/**
 * PaymentStatus Enum
 * Tracks the payment lifecycle for parcels
 */
enum PaymentStatus {
  PENDING // Payment not yet received
  PAID // Payment has been received
  INVOICED // Invoice has been generated
}
/**
 * DeliverySlipStatus Enum
 * Tracks the collection process status
 */
enum DeliverySlipStatus {
  PENDING // Created but packages not yet collected
  RECEIVED // Packages have been collected and processed
  CANCELLED // Collection was cancelled
}
/**
 * ShippingSlipStatus Enum
 * Tracks inter-zone transfer status
 */
enum ShippingSlipStatus {
  PENDING // Created but not yet shipped
  SHIPPED // Packages have been sent to destination
  RECEIVED // Packages received at destination zone
  CANCELLED // Shipment was cancelled
}
/**
 * DistributionSlipStatus Enum
 * Tracks delivery assignment status
 */
enum DistributionSlipStatus {
  PENDING // Created but not yet assigned to delivery person
  ASSIGNED // Assigned to delivery person for delivery
  COMPLETED // All packages have been delivered
  CANCELLED // Distribution assignment was cancelled
}
/**
 * ReturnSlipType Enum
 * Defines different types of return processes
 */
enum ReturnSlipType {
  DRIVER // Return from delivery driver to hub (BRL - Bon de Retour Livreur)
  ZONE // Return from zone to central hub (BRV - Bon de Retour Ville)
  CUSTOMER // Return to customer/sender (BRC - Bon de Retour Client)
}
/**
 * ReturnSlipStatus Enum
 * Tracks return processing status
 */
enum ReturnSlipStatus {
  PENDING // Created but processing not started
  INCOMPLETE // Partially processed - some items handled
  RECEIVED // All items have been processed and received
  CANCELLED // Return process was cancelled
}
/**
 * PaymentSlipType Enum
 * Defines different payment slip types
 */
enum PaymentSlipType {
  DRIVER // Payment to delivery driver (BPL - Bon de Paiement Livreur)
  ZONE // Payment to zone operations (BPV - Bon de Paiement Ville)
}
/**
 * PaymentSlipStatus Enum
 * Tracks payment processing workflow
 */
enum PaymentSlipStatus {
  PENDING // Created but processing not started
  IN_PROCESSING // Payment is being processed
  AWAITING_PAYMENT // Waiting for actual payment to be made
  VERIFIED // Payment has been verified
  PAID // Payment completed successfully
  CANCELLED // Payment was cancelled
}
-----------------------------------------------------------------------
--++--> prisma/seed.ts =======>
-----------------------------------------------------------------------
import { PrismaClient } from '@prisma/client';
import { Decimal } from '@prisma/client/runtime/library';
const prisma = new PrismaClient();
/**
 * Reset Database Function
 * Clears all data in reverse dependency parcel to avoid foreign key constraints
 */
async function resetDatabase() {
  console.log('🗑️ Resetting parcels database...');

  // Delete in reverse parcel of dependencies to avoid foreign key constraint errors
  await prisma.paymentSlipAdditionalFee.deleteMany({});
  await prisma.paymentSlipItem.deleteMany({});
  await prisma.paymentSlip.deleteMany({});

  await prisma.returnSlipItem.deleteMany({});
  await prisma.returnSlip.deleteMany({});

  await prisma.distributionSlipItem.deleteMany({});
  await prisma.distributionSlip.deleteMany({});

  await prisma.shippingSlipItem.deleteMany({});
  await prisma.shippingSlip.deleteMany({});

  await prisma.deliverySlipItem.deleteMany({});
  await prisma.deliverySlip.deleteMany({});

  await prisma.parcelStatusHistory.deleteMany({});
  await prisma.parcel.deleteMany({});

  await prisma.tariff.deleteMany({});
  await prisma.parcelStatus.deleteMany({});
  await prisma.zoneCity.deleteMany({});
  await prisma.zone.deleteMany({});
  await prisma.pickupCity.deleteMany({});
  await prisma.city.deleteMany({});

  console.log('✅ Database reset completed');
}
async function main() {
  console.log('🌱 Starting Parcels service seed...');

  // Reset database - comment out if you want to preserve existing data
  await resetDatabase();

  // Multi-tenant configuration
  const tenantId = 'cmfo1utdj00005820owl4mluk';
  const adminUserId = 'cmfo1utlp000g5820u6jov7rw';

  console.log(`📋 Seeding data for tenant: ${tenantId}`);

  // ========================================
  // 1. CREATE CITIES
  // ========================================

  const cities = await Promise.all([
    // Major pickup cities - can accept packages for collection
    prisma.city.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'CAS',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'CAS',
        name: 'Casablanca',
        zone: 'Zone A',
        pickupCity: true, // Can accept pickups
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.city.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'RAB',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'RAB',
        name: 'Rabat',
        zone: 'Zone A',
        pickupCity: true,
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.city.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'MAR',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'MAR',
        name: 'Marrakech',
        zone: 'Zone B',
        pickupCity: true,
        status: true,
        createdBy: adminUserId,
      },
    }),

    // Delivery-only cities - cannot accept pickups
    prisma.city.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'FEZ',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'FEZ',
        name: 'Fez',
        zone: 'Zone B',
        pickupCity: false, // Delivery only
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.city.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'TAN',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'TAN',
        name: 'Tangier',
        zone: 'Zone C',
        pickupCity: false,
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.city.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'AGA',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'AGA',
        name: 'Agadir',
        zone: 'Zone C',
        pickupCity: false,
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.city.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'SALE',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'SALE',
        name: 'Salé',
        zone: 'Zone A',
        pickupCity: false,
        status: true,
        createdBy: adminUserId,
      },
    }),
  ]);

  console.log(`✅ Created ${cities.length} cities`);

  // ========================================
  // 2. CREATE PICKUP CITIES (HUBS)
  // ========================================

  const pickupCities = await Promise.all([
    prisma.pickupCity.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'CAS_HUB',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'CAS_HUB',
        name: 'HUB CASABLANCA',
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.pickupCity.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'RAB_HUB',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'RAB_HUB',
        name: 'HUB RABAT',
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.pickupCity.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'MAR_HUB',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'MAR_HUB',
        name: 'HUB MARRAKECH',
        status: true,
        createdBy: adminUserId,
      },
    }),
  ]);

  console.log(`✅ Created ${pickupCities.length} pickup cities`);

  // ========================================
  // 3. CREATE ZONES
  // ========================================

  const zones = await Promise.all([
    prisma.zone.upsert({
      where: {
        tenantId_name_isDeleted: {
          tenantId,
          name: 'HUB CASABLANCA',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        name: 'HUB CASABLANCA',
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.zone.upsert({
      where: {
        tenantId_name_isDeleted: {
          tenantId,
          name: 'HUB RABAT',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        name: 'HUB RABAT',
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.zone.upsert({
      where: {
        tenantId_name_isDeleted: {
          tenantId,
          name: 'HUB MARRAKECH',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        name: 'HUB MARRAKECH',
        status: true,
        createdBy: adminUserId,
      },
    }),
  ]);

  console.log(`✅ Created ${zones.length} zones`);

  // ========================================
  // 4. ASSIGN CITIES TO ZONES
  // ========================================

  // Get city and zone references for assignments
  const casablancaCity = cities.find((c) => c.ref === 'CAS');
  const rabatCity = cities.find((c) => c.ref === 'RAB');
  const saleCity = cities.find((c) => c.ref === 'SALE');
  const fezCity = cities.find((c) => c.ref === 'FEZ');
  const marrakechCity = cities.find((c) => c.ref === 'MAR');
  const tangierCity = cities.find((c) => c.ref === 'TAN');
  const agadirCity = cities.find((c) => c.ref === 'AGA');

  const casablancaZone = zones.find((z) => z.name === 'HUB CASABLANCA');
  const rabatZone = zones.find((z) => z.name === 'HUB RABAT');
  const marrakechZone = zones.find((z) => z.name === 'HUB MARRAKECH');

  // Create zone-city assignments
  const zoneAssignments = [];

  // Casablanca Zone
  if (casablancaCity && casablancaZone) {
    zoneAssignments.push(
      prisma.zoneCity.upsert({
        where: {
          zoneId_cityId: {
            zoneId: casablancaZone.id,
            cityId: casablancaCity.id,
          },
        },
        update: {},
        create: {
          zoneId: casablancaZone.id,
          cityId: casablancaCity.id,
        },
      }),
    );
  }

  // Rabat Zone (includes Rabat and Salé)
  if (rabatCity && saleCity && rabatZone) {
    zoneAssignments.push(
      prisma.zoneCity.upsert({
        where: {
          zoneId_cityId: {
            zoneId: rabatZone.id,
            cityId: rabatCity.id,
          },
        },
        update: {},
        create: {
          zoneId: rabatZone.id,
          cityId: rabatCity.id,
        },
      }),
      prisma.zoneCity.upsert({
        where: {
          zoneId_cityId: {
            zoneId: rabatZone.id,
            cityId: saleCity.id,
          },
        },
        update: {},
        create: {
          zoneId: rabatZone.id,
          cityId: saleCity.id,
        },
      }),
    );
  }

  // Marrakech Zone (includes Marrakech, Fez, Tangier, Agadir)
  if (marrakechCity && fezCity && tangierCity && agadirCity && marrakechZone) {
    zoneAssignments.push(
      prisma.zoneCity.upsert({
        where: {
          zoneId_cityId: {
            zoneId: marrakechZone.id,
            cityId: marrakechCity.id,
          },
        },
        update: {},
        create: {
          zoneId: marrakechZone.id,
          cityId: marrakechCity.id,
        },
      }),
      prisma.zoneCity.upsert({
        where: {
          zoneId_cityId: {
            zoneId: marrakechZone.id,
            cityId: fezCity.id,
          },
        },
        update: {},
        create: {
          zoneId: marrakechZone.id,
          cityId: fezCity.id,
        },
      }),
      prisma.zoneCity.upsert({
        where: {
          zoneId_cityId: {
            zoneId: marrakechZone.id,
            cityId: tangierCity.id,
          },
        },
        update: {},
        create: {
          zoneId: marrakechZone.id,
          cityId: tangierCity.id,
        },
      }),
      prisma.zoneCity.upsert({
        where: {
          zoneId_cityId: {
            zoneId: marrakechZone.id,
            cityId: agadirCity.id,
          },
        },
        update: {},
        create: {
          zoneId: marrakechZone.id,
          cityId: agadirCity.id,
        },
      }),
    );
  }

  await Promise.all(zoneAssignments);
  console.log(`✅ Created zone-city assignments`);

  // ========================================
  // 5. CREATE PARCEL STATUSES
  // ========================================

  const parcelStatuses = await Promise.all([
    // Initial parcel status
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'NEW_PACKAGE',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'NEW_PACKAGE',
        name: 'Nouveau Colis',
        color: '#3B82F6', // Blue
        isLocked: true, // System-managed status
        status: true,
        createdBy: adminUserId,
      },
    }),

    // Collection and processing statuses
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'RECEIVED',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'RECEIVED',
        name: 'Reçu',
        color: '#10B981', // Emerald
        isLocked: false,
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'COLLECTED',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'COLLECTED',
        name: 'Ramassé',
        color: '#8B5CF6', // Purple
        isLocked: false,
        status: true,
        createdBy: adminUserId,
      },
    }),

    // Shipping and transfer statuses
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'DISPATCHED',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'DISPATCHED',
        name: 'Expédié',
        color: '#F59E0B', // Amber
        isLocked: false,
        status: true,
        createdBy: adminUserId,
      },
    }),

    // Distribution and delivery statuses
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'PUT_IN_DISTRIBUTION',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'PUT_IN_DISTRIBUTION',
        name: 'Mis en distribution',
        color: '#06B6D4', // Cyan
        isLocked: false,
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'OUT_FOR_DELIVERY',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'OUT_FOR_DELIVERY',
        name: 'En cours de livraison',
        color: '#F97316', // Orange
        isLocked: false,
        status: true,
        createdBy: adminUserId,
      },
    }),

    // Final delivery statuses
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'DELIVERED',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'DELIVERED',
        name: 'Livré',
        color: '#22C55E', // Green
        isLocked: true, // System-managed status
        status: true,
        createdBy: adminUserId,
      },
    }),

    // Return and refusal statuses
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'RETURNED',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'RETURNED',
        name: 'Retourné',
        color: '#EF4444', // Red
        isLocked: true, // System-managed status
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'REFUSED',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'REFUSED',
        name: 'Refusé',
        color: '#DC2626', // Red-600
        isLocked: false,
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'CANCELLED',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'CANCELLED',
        name: 'Annulé',
        color: '#6B7280', // Gray
        isLocked: false,
        status: true,
        createdBy: adminUserId,
      },
    }),
  ]);

  console.log(`✅ Created ${parcelStatuses.length} parcel statuses`);

  // ========================================
  // 6. CREATE TARIFFS (PRICING ROUTES)
  // ========================================

  if (
    casablancaCity &&
    rabatCity &&
    fezCity &&
    marrakechCity &&
    tangierCity &&
    agadirCity
  ) {
    const tariffs = await Promise.all([
      // From Casablanca to other cities
      prisma.tariff.upsert({
        where: {
          tenantId_pickupCityId_destinationCityId_isDeleted: {
            tenantId,
            pickupCityId: casablancaCity.id,
            destinationCityId: rabatCity.id,
            isDeleted: false,
          },
        },
        update: {},
        create: {
          tenantId,
          pickupCityId: casablancaCity.id,
          destinationCityId: rabatCity.id,
          deliveryPrice: new Decimal('25.00'), // Using Decimal for precision
          returnPrice: new Decimal('20.00'),
          refusalPrice: new Decimal('15.00'),
          deliveryDelay: 1,
          createdBy: adminUserId,
        },
      }),
      prisma.tariff.upsert({
        where: {
          tenantId_pickupCityId_destinationCityId_isDeleted: {
            tenantId,
            pickupCityId: casablancaCity.id,
            destinationCityId: fezCity.id,
            isDeleted: false,
          },
        },
        update: {},
        create: {
          tenantId,
          pickupCityId: casablancaCity.id,
          destinationCityId: fezCity.id,
          deliveryPrice: new Decimal('40.00'),
          returnPrice: new Decimal('35.00'),
          refusalPrice: new Decimal('25.00'),
          deliveryDelay: 2,
          createdBy: adminUserId,
        },
      }),
      prisma.tariff.upsert({
        where: {
          tenantId_pickupCityId_destinationCityId_isDeleted: {
            tenantId,
            pickupCityId: casablancaCity.id,
            destinationCityId: marrakechCity.id,
            isDeleted: false,
          },
        },
        update: {},
        create: {
          tenantId,
          pickupCityId: casablancaCity.id,
          destinationCityId: marrakechCity.id,
          deliveryPrice: new Decimal('35.00'),
          returnPrice: new Decimal('30.00'),
          refusalPrice: new Decimal('20.00'),
          deliveryDelay: 2,
          createdBy: adminUserId,
        },
      }),
      prisma.tariff.upsert({
        where: {
          tenantId_pickupCityId_destinationCityId_isDeleted: {
            tenantId,
            pickupCityId: casablancaCity.id,
            destinationCityId: tangierCity.id,
            isDeleted: false,
          },
        },
        update: {},
        create: {
          tenantId,
          pickupCityId: casablancaCity.id,
          destinationCityId: tangierCity.id,
          deliveryPrice: new Decimal('45.00'),
          returnPrice: new Decimal('40.00'),
          refusalPrice: new Decimal('30.00'),
          deliveryDelay: 3,
          createdBy: adminUserId,
        },
      }),
      prisma.tariff.upsert({
        where: {
          tenantId_pickupCityId_destinationCityId_isDeleted: {
            tenantId,
            pickupCityId: casablancaCity.id,
            destinationCityId: agadirCity.id,
            isDeleted: false,
          },
        },
        update: {},
        create: {
          tenantId,
          pickupCityId: casablancaCity.id,
          destinationCityId: agadirCity.id,
          deliveryPrice: new Decimal('50.00'),
          returnPrice: new Decimal('45.00'),
          refusalPrice: new Decimal('35.00'),
          deliveryDelay: 3,
          createdBy: adminUserId,
        },
      }),

      // From Rabat to other cities
      prisma.tariff.upsert({
        where: {
          tenantId_pickupCityId_destinationCityId_isDeleted: {
            tenantId,
            pickupCityId: rabatCity.id,
            destinationCityId: casablancaCity.id,
            isDeleted: false,
          },
        },
        update: {},
        create: {
          tenantId,
          pickupCityId: rabatCity.id,
          destinationCityId: casablancaCity.id,
          deliveryPrice: new Decimal('25.00'),
          returnPrice: new Decimal('20.00'),
          refusalPrice: new Decimal('15.00'),
          deliveryDelay: 1,
          createdBy: adminUserId,
        },
      }),

      // From Marrakech to other cities
      prisma.tariff.upsert({
        where: {
          tenantId_pickupCityId_destinationCityId_isDeleted: {
            tenantId,
            pickupCityId: marrakechCity.id,
            destinationCityId: casablancaCity.id,
            isDeleted: false,
          },
        },
        update: {},
        create: {
          tenantId,
          pickupCityId: marrakechCity.id,
          destinationCityId: casablancaCity.id,
          deliveryPrice: new Decimal('35.00'),
          returnPrice: new Decimal('30.00'),
          refusalPrice: new Decimal('20.00'),
          deliveryDelay: 2,
          createdBy: adminUserId,
        },
      }),
    ]);

    console.log(`✅ Created ${tariffs.length} tariff routes`);
  }

  // ========================================
  // 7. CREATE SAMPLE PARCELS
  // ========================================

  const newPackageStatus = parcelStatuses.find((s) => s.code === 'NEW_PACKAGE');

  if (newPackageStatus && casablancaCity && rabatCity && marrakechCity) {
    // Get tariffs for sample parcels
    const casaToRabatTariff = await prisma.tariff.findFirst({
      where: {
        tenantId,
        pickupCityId: casablancaCity.id,
        destinationCityId: rabatCity.id,
        isDeleted: false,
      },
    });

    const casaToMarrakechTariff = await prisma.tariff.findFirst({
      where: {
        tenantId,
        pickupCityId: casablancaCity.id,
        destinationCityId: marrakechCity.id,
        isDeleted: false,
      },
    });

    const sampleParcels = [];

    if (casaToRabatTariff) {
      sampleParcels.push(
        prisma.parcel.create({
          data: {
            tenantId,
            userId: adminUserId,
            code: 'BSK0925539432LE',
            recipientName: 'Ahmed Benjelloun',
            recipientPhone: '+212661234567',
            recipientAddress: '123 Avenue Mohammed V, Agdal, Rabat',
            alternativePhone: '+212537123456',
            pickupCityId: casablancaCity.id,
            destinationCityId: rabatCity.id,
            productName: 'Smartphone Case Premium',
            quantity: 1,
            price: new Decimal('350.00'),
            comment: 'Appeler avant livraison - Livraison après 14h',
            parcelStatusId: newPackageStatus.id,
            parcelStatusCode: newPackageStatus.code,
            deliveryPrice: casaToRabatTariff.deliveryPrice,
            returnPrice: casaToRabatTariff.returnPrice,
            refusalPrice: casaToRabatTariff.refusalPrice,
            deliveryDelay: casaToRabatTariff.deliveryDelay,
            tariffId: casaToRabatTariff.id,
            createdBy: adminUserId,
          },
        }),
        prisma.parcel.create({
          data: {
            tenantId,
            userId: adminUserId,
            code: 'BSK0925539433LE',
            recipientName: 'Fatima El Mansouri',
            recipientPhone: '+212662345678',
            recipientAddress: '456 Rue Hassan II, Centre-ville, Rabat',
            pickupCityId: casablancaCity.id,
            destinationCityId: rabatCity.id,
            productName: 'Laptop Charger Dell',
            quantity: 1,
            price: new Decimal('450.00'),
            parcelStatusId: newPackageStatus.id,
            parcelStatusCode: newPackageStatus.code,
            deliveryPrice: casaToRabatTariff.deliveryPrice,
            returnPrice: casaToRabatTariff.returnPrice,
            refusalPrice: casaToRabatTariff.refusalPrice,
            deliveryDelay: casaToRabatTariff.deliveryDelay,
            tariffId: casaToRabatTariff.id,
            createdBy: adminUserId,
          },
        }),
      );
    }

    if (casaToMarrakechTariff) {
      sampleParcels.push(
        prisma.parcel.create({
          data: {
            tenantId,
            userId: adminUserId,
            code: 'BSK0925539434LE',
            recipientName: 'Youssef Benali',
            recipientPhone: '+212663456789',
            recipientAddress: '789 Avenue Mohammed VI, Gueliz, Marrakech',
            pickupCityId: casablancaCity.id,
            destinationCityId: marrakechCity.id,
            productName: 'Wireless Headphones',
            quantity: 2,
            price: new Decimal('680.00'),
            comment: 'Fragile - Manipuler avec précaution',
            cannotOpen: true, // Special handling
            parcelStatusId: newPackageStatus.id,
            parcelStatusCode: newPackageStatus.code,
            deliveryPrice: casaToMarrakechTariff.deliveryPrice,
            returnPrice: casaToMarrakechTariff.returnPrice,
            refusalPrice: casaToMarrakechTariff.refusalPrice,
            deliveryDelay: casaToMarrakechTariff.deliveryDelay,
            tariffId: casaToMarrakechTariff.id,
            createdBy: adminUserId,
          },
        }),
      );
    }

    const createdParcels = await Promise.all(sampleParcels);
    console.log(`✅ Created ${createdParcels.length} sample parcels`);

    // Create status history for each parcel
    const statusHistories = createdParcels.map((parcel) =>
      prisma.parcelStatusHistory.create({
        data: {
          parcelId: parcel.id,
          parcelStatusId: newPackageStatus.id,
          statusCode: newPackageStatus.code,
          comment: 'Parcel created successfully',
          changedBy: adminUserId,
        },
      }),
    );

    await Promise.all(statusHistories);
    console.log(
      `✅ Created status history for ${statusHistories.length} parcels`,
    );
  }

  // ========================================
  // COMPLETION SUMMARY
  // ========================================

  console.log('\n🎉 Parcels service seed completed successfully!');
  console.log('\n📋 Created Data Summary:');
  console.log(`Tenant ID: ${tenantId}`);
  console.log(`Cities: ${cities.length}`);
  console.log(`Pickup Cities: ${pickupCities.length}`);
  console.log(`Zones: ${zones.length}`);
  console.log(`Parcel Statuses: ${parcelStatuses.length}`);

  const totalTariffs = await prisma.tariff.count({
    where: { tenantId, isDeleted: false },
  });
  const totalParcels = await prisma.parcel.count({
    where: { tenantId, isDeleted: false },
  });

  console.log(`Tariff Routes: ${totalTariffs}`);
  console.log(`Sample Parcels: ${totalParcels}`);

  console.log('\n✅ Database seeding completed - Ready for testing!');
}
// Execute the seeding process
main()
  .catch((e) => {
    console.error('❌ Parcels seed failed:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
-----------------------------------------------------------------------
--++--> src/modules/delivery-slips/dto/parcel.dto.ts =======>
-----------------------------------------------------------------------
import {
  IsString,
  IsArray,
  IsOptional,
  IsEnum,
  IsBoolean,
  IsNotEmpty,
  ArrayNotEmpty,
  MaxLength,
  IsDateString,
} from 'class-validator';
import { Transform, Type } from 'class-transformer';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { PaginationDto } from '../../../common/dto/pagination.dto';
export enum DeliverySlipStatus {
  PENDING = 'PENDING',
  RECEIVED = 'RECEIVED',
  CANCELLED = 'CANCELLED',
}
export class CreateDeliverySlipDto {
  @ApiPropertyOptional({
    example: 'cuid123',
    description: 'City ID where packages are collected (optional)',
  })
  @IsOptional()
  @IsString()
  cityId?: string;

  @ApiPropertyOptional({
    example: ['cuid1', 'cuid2', 'cuid3'],
    description: 'Array of parcel IDs to include in this delivery slip',
  })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  parcelIds?: string[];

  @ApiPropertyOptional({
    example: 'Morning pickup route - Zone A',
    description: 'Additional notes for the delivery slip',
  })
  @IsOptional()
  @IsString()
  @MaxLength(500)
  notes?: string;

  @ApiPropertyOptional({
    example: true,
    description: 'Create slip and immediately mark as received',
    default: false,
  })
  @IsOptional()
  @IsBoolean()
  autoReceive?: boolean = false;
}
export class UpdateDeliverySlipDto {
  @ApiPropertyOptional({
    example: 'cuid123',
    description: 'Update city ID',
  })
  @IsOptional()
  @IsString()
  cityId?: string;

  @ApiPropertyOptional({
    example: 'Updated notes for delivery slip',
    description: 'Update notes',
  })
  @IsOptional()
  @IsString()
  @MaxLength(500)
  notes?: string;

  @ApiPropertyOptional({
    enum: DeliverySlipStatus,
    example: DeliverySlipStatus.RECEIVED,
    description: 'Update slip status',
  })
  @IsOptional()
  @IsEnum(DeliverySlipStatus)
  status?: DeliverySlipStatus;
}
export class DeliverySlipQueryDto extends PaginationDto {
  @ApiPropertyOptional({
    example: 'BL-280225-0192950',
    description: 'Search by reference or customer info',
  })
  @IsOptional()
  @IsString()
  search?: string;

  @ApiPropertyOptional({
    enum: DeliverySlipStatus,
    example: DeliverySlipStatus.PENDING,
    description: 'Filter by slip status',
  })
  @IsOptional()
  @IsEnum(DeliverySlipStatus)
  status?: DeliverySlipStatus;

  @ApiPropertyOptional({
    example: 'cuid123',
    description: 'Filter by city ID',
  })
  @IsOptional()
  @IsString()
  cityId?: string;

  @ApiPropertyOptional({
    example: 'cuid456',
    description: 'Filter by creator user ID',
  })
  @IsOptional()
  @IsString()
  userId?: string;

  @ApiPropertyOptional({
    example: '2024-01-01',
    description: 'Filter by start date',
  })
  @IsOptional()
  @IsDateString()
  startDate?: string;

  @ApiPropertyOptional({
    example: '2024-01-31',
    description: 'Filter by end date',
  })
  @IsOptional()
  @IsDateString()
  endDate?: string;

  @ApiPropertyOptional({
    example: 'createdAt',
    description: 'Sort field',
    default: 'createdAt',
  })
  @IsOptional()
  @IsString()
  sortBy?: string = 'createdAt';

  @ApiPropertyOptional({
    example: 'desc',
    description: 'Sort direction',
    default: 'desc',
  })
  @IsOptional()
  @IsString()
  sortParcel?: 'asc' | 'desc' = 'desc';
}
export class AddParcelsToSlipDto {
  @ApiProperty({
    example: ['cuid1', 'cuid2'],
    description: 'Array of parcel IDs to add',
  })
  @IsArray()
  @ArrayNotEmpty()
  @IsString({ each: true })
  parcelIds: string[];

  @ApiPropertyOptional({
    example: 'Added via scanner',
    description: 'Comment for the addition',
  })
  @IsOptional()
  @IsString()
  @MaxLength(200)
  comment?: string;

  @ApiPropertyOptional({
    example: true,
    description: 'Mark parcels as scanned immediately',
    default: true,
  })
  @IsOptional()
  @IsBoolean()
  markAsScanned?: boolean = true;
}
export class RemoveParcelsFromSlipDto {
  @ApiProperty({
    example: ['cuid1', 'cuid2'],
    description: 'Array of parcel IDs to remove',
  })
  @IsArray()
  @ArrayNotEmpty()
  @IsString({ each: true })
  parcelIds: string[];

  @ApiPropertyOptional({
    example: 'Removed due to address issue',
    description: 'Reason for removal',
  })
  @IsOptional()
  @IsString()
  @MaxLength(200)
  reason?: string;
}
export class ReceiveSlipDto {
  @ApiPropertyOptional({
    example: 'All packages received and verified',
    description: 'Reception notes',
  })
  @IsOptional()
  @IsString()
  @MaxLength(500)
  notes?: string;

  @ApiPropertyOptional({
    example: ['cuid1', 'cuid2'],
    description: 'Specific parcel IDs to mark as received (if not all)',
  })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  parcelIds?: string[];

  @ApiPropertyOptional({
    example: true,
    description: 'Force reception even if not all parcels are scanned',
    default: false,
  })
  @IsOptional()
  @IsBoolean()
  forceReceive?: boolean = false;
}
export class DeliverySlipResponseDto {
  @ApiProperty()
  id: string;

  @ApiProperty()
  tenantId: string;

  @ApiProperty()
  userId: string;

  @ApiProperty()
  reference: string;

  @ApiPropertyOptional()
  cityId?: string;

  @ApiProperty()
  status: DeliverySlipStatus;

  @ApiPropertyOptional()
  receivedAt?: Date;

  @ApiPropertyOptional()
  receivedBy?: string;

  @ApiPropertyOptional()
  notes?: string;

  @ApiProperty()
  createdAt: Date;

  @ApiProperty()
  updatedAt: Date;

  @ApiPropertyOptional()
  createdBy?: string;

  @ApiPropertyOptional()
  updatedBy?: string;

  // Relations
  @ApiPropertyOptional()
  city?: {
    id: string;
    name: string;
    ref: string;
  };

  @ApiPropertyOptional()
  creator?: {
    id: string;
    name: string;
    email: string;
  };

  @ApiProperty()
  items: DeliverySlipItemResponseDto[];

  @ApiProperty()
  summary: {
    totalParcels: number;
    scannedParcels: number;
    unscannedParcels: number;
    totalValue: number;
  };
}
export class DeliverySlipItemResponseDto {
  @ApiProperty()
  deliverySlipId: string;

  @ApiProperty()
  parcelId: string;

  @ApiProperty()
  scanned: boolean;

  @ApiPropertyOptional()
  scannedAt?: Date;

  @ApiPropertyOptional()
  scannedBy?: string;

  // Parcel details
  @ApiProperty()
  parcel: {
    id: string;
    code: string;
    recipientName: string;
    recipientPhone: string;
    destinationCity: string;
    price: number;
    statusCode: string;
    statusName: string;
  };
}
export class DeliverySlipStatsDto {
  @ApiProperty()
  totalSlips: number;

  @ApiProperty()
  pendingSlips: number;

  @ApiProperty()
  receivedSlips: number;

  @ApiProperty()
  cancelledSlips: number;

  @ApiProperty()
  totalParcelsInSlips: number;

  @ApiProperty()
  totalValueInSlips: number;

  @ApiProperty()
  averageParcelsPerSlip: number;

  @ApiProperty()
  recentActivity: Array<{
    date: string;
    slipsCreated: number;
    slipsReceived: number;
  }>;

  @ApiProperty()
  topCities: Array<{
    cityName: string;
    slipCount: number;
    parcelCount: number;
  }>;
}
export class BulkSlipActionDto {
  @ApiProperty({
    example: ['cuid1', 'cuid2'],
    description: 'Array of delivery slip IDs',
  })
  @IsArray()
  @ArrayNotEmpty()
  @IsString({ each: true })
  slipIds: string[];

  @ApiProperty({
    example: 'RECEIVE',
    description: 'Action to perform (RECEIVE, CANCEL, DELETE)',
  })
  @IsString()
  @IsNotEmpty()
  action: string;

  @ApiPropertyOptional({
    example: 'Bulk reception of morning slips',
    description: 'Comment for the bulk action',
  })
  @IsOptional()
  @IsString()
  comment?: string;
}
-----------------------------------------------------------------------
--++--> src/modules/delivery-slips/delivery-slips.controller.ts =======>
-----------------------------------------------------------------------
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiParam,
  ApiBearerAuth,
  ApiBadRequestResponse,
  ApiNotFoundResponse,
  ApiForbiddenResponse,
  ApiConflictResponse,
} from '@nestjs/swagger';
import { DeliverySlipsService } from './delivery-slips.service';
import {
  CreateDeliverySlipDto,
  UpdateDeliverySlipDto,
  DeliverySlipQueryDto,
  AddParcelsToSlipDto,
  RemoveParcelsFromSlipDto,
  ReceiveSlipDto,
  DeliverySlipResponseDto,
  DeliverySlipStatsDto,
  BulkSlipActionDto,
} from './dto/delivery-slip.dto';
import { PaginatedResult } from '../../common/dto/pagination.dto';
import { GlobalAuth, CurrentTenant, CurrentUser } from '@network-saas/auth-lib';
import { ParseCuidPipe } from '../../common/pipes/parse-cuid.pipe';
@ApiTags('delivery-slips')
@ApiBearerAuth()
@Controller('delivery-slips')
export class DeliverySlipsController {
  constructor(private readonly deliverySlipsService: DeliverySlipsService) {}

  @Post()
  @GlobalAuth('delivery_slips:create')
  @ApiOperation({
    summary: 'Create delivery slip',
    description:
      'Create a new delivery slip for parcel collection. Sellers can only create for their parcels.',
  })
  @ApiResponse({
    status: 201,
    description: 'Delivery slip created successfully',
    type: DeliverySlipResponseDto,
  })
  @ApiBadRequestResponse({
    description: 'Invalid parcels or city provided',
  })
  @ApiForbiddenResponse({
    description: 'Sellers can only create slips for their own parcels',
  })
  async create(
    @Body() createDto: CreateDeliverySlipDto,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<DeliverySlipResponseDto> {
    return this.deliverySlipsService.create(
      createDto,
      tenantId,
      user.id,
      user.userType,
    );
  }

  @Get()
  @GlobalAuth('delivery_slips:read')
  @ApiOperation({
    summary: 'Get delivery slips',
    description:
      'Retrieve delivery slips with filtering. Sellers only see their own slips.',
  })
  @ApiResponse({
    status: 200,
    description: 'Delivery slips retrieved successfully',
    type: PaginatedResult<DeliverySlipResponseDto>,
  })
  async findAll(
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
    @Query() query: DeliverySlipQueryDto,
  ): Promise<PaginatedResult<DeliverySlipResponseDto>> {
    return this.deliverySlipsService.findAll(
      tenantId,
      query,
      user.id,
      user.userType,
    );
  }

  @Get('available-parcels')
  @GlobalAuth('delivery_slips:create')
  @ApiOperation({
    summary: 'Get available parcels',
    description:
      'Get parcels that can be added to delivery slips (NEW_PACKAGE status, not in other slips)',
  })
  @ApiResponse({
    status: 200,
    description: 'Available parcels retrieved successfully',
    schema: {
      type: 'array',
      items: {
        type: 'object',
        properties: {
          id: { type: 'string' },
          code: { type: 'string' },
          recipientName: { type: 'string' },
          recipientPhone: { type: 'string' },
          price: { type: 'number' },
          createdAt: { type: 'string', format: 'date-time' },
          pickupCity: { type: 'object' },
          destinationCity: { type: 'object' },
        },
      },
    },
  })
  async getAvailableParcels(
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
    @Query('cityId') cityId?: string,
  ): Promise<any[]> {
    return this.deliverySlipsService.getAvailableParcels(
      tenantId,
      user.id,
      user.userType,
      cityId,
    );
  }

  @Get('statistics')
  @GlobalAuth('delivery_slips:read')
  @ApiOperation({
    summary: 'Get delivery slip statistics',
    description: 'Get comprehensive statistics about delivery slips',
  })
  @ApiResponse({
    status: 200,
    description: 'Statistics retrieved successfully',
    type: DeliverySlipStatsDto,
  })
  async getStatistics(
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<DeliverySlipStatsDto> {
    return this.deliverySlipsService.getStatistics(
      tenantId,
      user.id,
      user.userType,
    );
  }

  @Post('bulk-action')
  @GlobalAuth('delivery_slips:update')
  @ApiOperation({
    summary: 'Bulk actions on delivery slips',
    description:
      'Perform bulk actions (RECEIVE, CANCEL, DELETE) on multiple delivery slips',
  })
  @ApiResponse({
    status: 200,
    description: 'Bulk action completed',
    schema: {
      type: 'object',
      properties: {
        success: { type: 'number' },
        failed: { type: 'number' },
        errors: { type: 'array', items: { type: 'string' } },
      },
    },
  })
  async bulkAction(
    @Body() bulkActionDto: BulkSlipActionDto,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<{ success: number; failed: number; errors: string[] }> {
    return this.deliverySlipsService.bulkAction(
      bulkActionDto,
      tenantId,
      user.id,
    );
  }

  @Get(':id')
  @GlobalAuth('delivery_slips:read')
  @ApiOperation({
    summary: 'Get delivery slip by ID',
    description: 'Retrieve a specific delivery slip with all details and items',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Delivery slip ID' })
  @ApiResponse({
    status: 200,
    description: 'Delivery slip retrieved successfully',
    type: DeliverySlipResponseDto,
  })
  @ApiNotFoundResponse({ description: 'Delivery slip not found' })
  @ApiForbiddenResponse({
    description: 'Cannot access delivery slip created by other users',
  })
  async findOne(
    @Param('id', ParseCuidPipe) id: string,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<DeliverySlipResponseDto> {
    return this.deliverySlipsService.findOne(
      id,
      tenantId,
      user.id,
      user.userType,
    );
  }

  @Get(':id/pdf')
  @GlobalAuth('delivery_slips:read')
  @ApiOperation({
    summary: 'Download delivery slip PDF',
    description: 'Generate and download delivery slip as PDF document',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Delivery slip ID' })
  @ApiResponse({
    status: 200,
    description: 'PDF generated successfully',
    schema: {
      type: 'string',
      format: 'binary',
    },
    headers: {
      'Content-Type': {
        description: 'application/pdf',
        schema: { type: 'string' },
      },
      'Content-Disposition': {
        description: 'attachment; filename="delivery-slip-{reference}.pdf"',
        schema: { type: 'string' },
      },
    },
  })
  async downloadPdf(
    @Param('id', ParseCuidPipe) id: string,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<any> {
    // This would generate and return a PDF
    // For now, return a placeholder response
    return { message: 'PDF generation - to be implemented' };
  }

  @Get(':id/labels')
  @GlobalAuth('delivery_slips:read')
  @ApiOperation({
    summary: 'Download parcel labels',
    description:
      'Generate and download shipping labels for all parcels in the delivery slip',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Delivery slip ID' })
  @ApiResponse({
    status: 200,
    description: 'Labels generated successfully',
    schema: {
      type: 'string',
      format: 'binary',
    },
  })
  async downloadLabels(
    @Param('id', ParseCuidPipe) id: string,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<any> {
    // This would generate shipping labels
    return { message: 'Label generation - to be implemented' };
  }

  @Patch(':id')
  @GlobalAuth('delivery_slips:update')
  @ApiOperation({
    summary: 'Update delivery slip',
    description: 'Update delivery slip details (only for pending slips)',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Delivery slip ID' })
  @ApiResponse({
    status: 200,
    description: 'Delivery slip updated successfully',
    type: DeliverySlipResponseDto,
  })
  @ApiNotFoundResponse({ description: 'Delivery slip not found' })
  @ApiBadRequestResponse({
    description: 'Cannot update received delivery slip',
  })
  @ApiForbiddenResponse({
    description: 'Can only update your own delivery slips',
  })
  async update(
    @Param('id', ParseCuidPipe) id: string,
    @Body() updateDto: UpdateDeliverySlipDto,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<DeliverySlipResponseDto> {
    return this.deliverySlipsService.update(
      id,
      updateDto,
      tenantId,
      user.id,
      user.userType,
    );
  }

  @Post(':id/add-parcels')
  @GlobalAuth('delivery_slips:update')
  @ApiOperation({
    summary: 'Add parcels to delivery slip',
    description:
      'Add parcels to an existing delivery slip (scanner integration)',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Delivery slip ID' })
  @ApiResponse({
    status: 200,
    description: 'Parcels added successfully',
    type: DeliverySlipResponseDto,
  })
  @ApiBadRequestResponse({ description: 'Invalid parcels or slip status' })
  @ApiConflictResponse({ description: 'Some parcels already in other slips' })
  async addParcels(
    @Param('id', ParseCuidPipe) id: string,
    @Body() addParcelsDto: AddParcelsToSlipDto,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<DeliverySlipResponseDto> {
    return this.deliverySlipsService.addParcels(
      id,
      addParcelsDto,
      tenantId,
      user.id,
      user.userType,
    );
  }

  @Post(':id/remove-parcels')
  @GlobalAuth('delivery_slips:update')
  @ApiOperation({
    summary: 'Remove parcels from delivery slip',
    description: 'Remove parcels from delivery slip and reset their status',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Delivery slip ID' })
  @ApiResponse({
    status: 200,
    description: 'Parcels removed successfully',
    type: DeliverySlipResponseDto,
  })
  @ApiBadRequestResponse({ description: 'Cannot remove from received slip' })
  async removeParcels(
    @Param('id', ParseCuidPipe) id: string,
    @Body() removeParcelsDto: RemoveParcelsFromSlipDto,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<DeliverySlipResponseDto> {
    return this.deliverySlipsService.removeParcels(
      id,
      removeParcelsDto,
      tenantId,
      user.id,
      user.userType,
    );
  }

  @Post(':id/receive')
  @GlobalAuth('delivery_slips:receive')
  @ApiOperation({
    summary: 'Mark delivery slip as received',
    description: 'Mark delivery slip as received (all packages collected)',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Delivery slip ID' })
  @ApiResponse({
    status: 200,
    description: 'Delivery slip marked as received',
    type: DeliverySlipResponseDto,
  })
  @ApiBadRequestResponse({
    description: 'Slip not in pending status or has unscanned parcels',
  })
  async receiveSlip(
    @Param('id', ParseCuidPipe) id: string,
    @Body() receiveDto: ReceiveSlipDto,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<DeliverySlipResponseDto> {
    return this.deliverySlipsService.receiveSlip(
      id,
      receiveDto,
      tenantId,
      user.id,
    );
  }

  @Post(':id/scan/:parcelCode')
  @GlobalAuth('delivery_slips:scan')
  @ApiOperation({
    summary: 'Scan parcel into delivery slip',
    description:
      'Scan an parcel directly into this delivery slip (scanner integration)',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Delivery slip ID' })
  @ApiParam({
    name: 'parcelCode',
    type: 'string',
    description: 'Parcel code to scan',
  })
  @ApiResponse({
    status: 200,
    description: 'Parcel scanned successfully',
    schema: {
      type: 'object',
      properties: {
        success: { type: 'boolean' },
        message: { type: 'string' },
        parcelDetails: { type: 'object' },
      },
    },
  })
  async scanParcel(
    @Param('id', ParseCuidPipe) id: string,
    @Param('parcelCode') parcelCode: string,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<any> {
    // This integrates with the scanner service
    // Implementation would call scanner service with slip context
    return {
      success: true,
      message: 'Scanner integration - to be implemented',
      parcelDetails: {},
    };
  }

  @Get(':id/barcode')
  @GlobalAuth('delivery_slips:read')
  @ApiOperation({
    summary: 'Get delivery slip barcode',
    description: 'Generate barcode for the delivery slip for scanning',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Delivery slip ID' })
  @ApiResponse({
    status: 200,
    description: 'Barcode generated successfully',
    schema: {
      type: 'object',
      properties: {
        reference: { type: 'string' },
        barcodeData: { type: 'string' },
        barcodeImage: { type: 'string' },
        qrCodeImage: { type: 'string' },
      },
    },
  })
  async getBarcode(
    @Param('id', ParseCuidPipe) id: string,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<any> {
    const deliverySlip = await this.deliverySlipsService.findOne(
      id,
      tenantId,
      user.id,
      user.userType,
    );

    return {
      reference: deliverySlip.reference,
      barcodeData: deliverySlip.reference,
      // These would be generated by a barcode library
      barcodeImage: `data:image/png;base64,${deliverySlip.reference}`, // Placeholder
      qrCodeImage: `data:image/png;base64,QR${deliverySlip.reference}`, // Placeholder
    };
  }

  @Delete(':id')
  @GlobalAuth('delivery_slips:delete')
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({
    summary: 'Delete delivery slip',
    description:
      'Soft delete delivery slip (only pending slips, resets parcel statuses)',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Delivery slip ID' })
  @ApiResponse({
    status: 204,
    description: 'Delivery slip deleted successfully',
  })
  @ApiNotFoundResponse({ description: 'Delivery slip not found' })
  @ApiBadRequestResponse({
    description: 'Can only delete pending delivery slips',
  })
  async remove(
    @Param('id', ParseCuidPipe) id: string,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<void> {
    await this.deliverySlipsService.remove(id, tenantId, user.id);
  }
}
-----------------------------------------------------------------------
--++--> src/modules/delivery-slips/delivery-slips.module.ts =======>
-----------------------------------------------------------------------
import { Module } from '@nestjs/common';
import { DeliverySlipsService } from './delivery-slips.service';
import { DeliverySlipsController } from './delivery-slips.controller';
import { PrismaModule } from '../../shared/services/prisma/prisma.module';
import { RedisModule } from '../../shared/services/redis/redis.module';
@Module({
  imports: [PrismaModule, RedisModule],
  controllers: [DeliverySlipsController],
  providers: [DeliverySlipsService],
  exports: [DeliverySlipsService],
})
export class DeliverySlipsModule {}
-----------------------------------------------------------------------
--++--> src/modules/delivery-slips/services/delivery-slips.service.ts =======>
-----------------------------------------------------------------------
import {
  Injectable,
  NotFoundException,
  BadRequestException,
  ConflictException,
  Logger,
  ForbiddenException,
} from '@nestjs/common';
import { PrismaService } from '../../shared/services/prisma/prisma.service';
import { RedisService } from '../../shared/services/redis/redis.service';
import {
  CreateDeliverySlipDto,
  UpdateDeliverySlipDto,
  DeliverySlipQueryDto,
  AddParcelsToSlipDto,
  RemoveParcelsFromSlipDto,
  ReceiveSlipDto,
  DeliverySlipResponseDto,
  DeliverySlipStatsDto,
  BulkSlipActionDto,
  DeliverySlipStatus,
} from './dto/delivery-slip.dto';
import { PaginatedResult } from '../../common/dto/pagination.dto';
@Injectable()
export class DeliverySlipsService {
  private readonly logger = new Logger(DeliverySlipsService.name);

  constructor(
    private prisma: PrismaService,
    private redis: RedisService,
  ) {}

  /**
   * Create a new delivery slip
   * Can be created by sellers for their parcels or by admins for any parcels
   */
  async create(
    createDto: CreateDeliverySlipDto,
    tenantId: string,
    userId: string,
    userType: string,
  ): Promise<DeliverySlipResponseDto> {
    // Generate unique reference
    const reference = await this.generateSlipReference(tenantId);

    // If parcelIds are provided, validate them
    let validParcelIds: string[] = [];
    if (createDto.parcelIds && createDto.parcelIds.length > 0) {
      validParcelIds = await this.validateParcelsForSlip(
        createDto.parcelIds,
        tenantId,
        userId,
        userType,
      );
    }

    // Validate city if provided
    if (createDto.cityId) {
      await this.validateCity(createDto.cityId, tenantId);
    }

    // Create the delivery slip
    const deliverySlip = await this.prisma.deliverySlip.create({
      data: {
        tenantId,
        userId,
        reference,
        cityId: createDto.cityId,
        status: DeliverySlipStatus.PENDING,
        createdBy: userId,
      },
    });

    // Add parcels to the slip if provided
    if (validParcelIds.length > 0) {
      await this.addParcelsToSlipInternal(
        deliverySlip.id,
        validParcelIds,
        userId,
        createDto.autoReceive || false,
      );

      // If autoReceive is true, mark slip as received
      if (createDto.autoReceive) {
        await this.receiveSlipInternal(
          deliverySlip.id,
          userId,
          'Auto-received on creation',
        );
      }
    }

    // Clear cache
    await this.clearCache(tenantId);

    this.logger.log(
      `Created delivery slip ${reference} with ${validParcelIds.length} parcels for tenant ${tenantId}`,
    );

    return this.findOne(deliverySlip.id, tenantId);
  }

  /**
   * Get delivery slips with filtering and pagination
   */
  async findAll(
    tenantId: string,
    query: DeliverySlipQueryDto,
    userId?: string,
    userType?: string,
  ): Promise<PaginatedResult<DeliverySlipResponseDto>> {
    const {
      page = 1,
      limit = 10,
      search,
      status,
      cityId,
      userId: filterUserId,
      startDate,
      endDate,
      sortBy = 'createdAt',
      sortParcel = 'desc',
    } = query;

    const skip = (page - 1) * limit;

    // Build where clause
    const where: any = {
      tenantId,
      isDeleted: false,
    };

    // If user is SELLER, only show their own delivery slips
    if (userType === 'SELLER') {
      where.userId = userId;
    } else if (filterUserId) {
      where.userId = filterUserId;
    }

    if (search) {
      where.OR = [
        { reference: { contains: search, mode: 'insensitive' } },
        {
          items: {
            some: {
              parcel: {
                OR: [
                  { code: { contains: search, mode: 'insensitive' } },
                  { recipientName: { contains: search, mode: 'insensitive' } },
                  { recipientPhone: { contains: search, mode: 'insensitive' } },
                ],
              },
            },
          },
        },
      ];
    }

    if (status) {
      where.status = status;
    }

    if (cityId) {
      where.cityId = cityId;
    }

    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) {
        where.createdAt.gte = new Date(startDate);
      }
      if (endDate) {
        where.createdAt.lte = new Date(endDate + 'T23:59:59.999Z');
      }
    }

    // Get total count
    const total = await this.prisma.deliverySlip.count({ where });

    // Get delivery slips
    const deliverySlips = await this.prisma.deliverySlip.findMany({
      where,
      skip,
      take: limit,
      orderBy: { [sortBy]: sortParcel },
      include: this.getSlipIncludes(),
    });

    const data = deliverySlips.map((slip) => this.mapToResponseDto(slip));

    return new PaginatedResult(data, page, limit, total);
  }

  /**
   * Get single delivery slip by ID
   */
  async findOne(
    id: string,
    tenantId: string,
    userId?: string,
    userType?: string,
  ): Promise<DeliverySlipResponseDto> {
    const deliverySlip = await this.prisma.deliverySlip.findFirst({
      where: {
        id,
        tenantId,
        isDeleted: false,
      },
      include: this.getSlipIncludes(),
    });

    if (!deliverySlip) {
      throw new NotFoundException('Delivery slip not found');
    }

    // Check access permissions
    if (userType === 'SELLER' && deliverySlip.userId !== userId) {
      throw new ForbiddenException('You can only view your own delivery slips');
    }

    return this.mapToResponseDto(deliverySlip);
  }

  /**
   * Update delivery slip
   */
  async update(
    id: string,
    updateDto: UpdateDeliverySlipDto,
    tenantId: string,
    userId: string,
    userType: string,
  ): Promise<DeliverySlipResponseDto> {
    const existing = await this.prisma.deliverySlip.findFirst({
      where: { id, tenantId, isDeleted: false },
    });

    if (!existing) {
      throw new NotFoundException('Delivery slip not found');
    }

    // Check permissions
    if (userType === 'SELLER' && existing.userId !== userId) {
      throw new ForbiddenException(
        'You can only update your own delivery slips',
      );
    }

    // Check if slip can be updated
    if (existing.status === DeliverySlipStatus.RECEIVED) {
      throw new BadRequestException('Cannot update received delivery slip');
    }

    // Validate city if being updated
    if (updateDto.cityId) {
      await this.validateCity(updateDto.cityId, tenantId);
    }

    const updated = await this.prisma.deliverySlip.update({
      where: { id },
      data: {
        ...updateDto,
        updatedBy: userId,
      },
    });

    await this.clearCache(tenantId);

    this.logger.log(
      `Updated delivery slip ${existing.reference} for tenant ${tenantId}`,
    );

    return this.findOne(id, tenantId);
  }

  /**
   * Add parcels to delivery slip
   */
  async addParcels(
    id: string,
    addParcelsDto: AddParcelsToSlipDto,
    tenantId: string,
    userId: string,
    userType: string,
  ): Promise<DeliverySlipResponseDto> {
    const deliverySlip = await this.prisma.deliverySlip.findFirst({
      where: { id, tenantId, isDeleted: false },
    });

    if (!deliverySlip) {
      throw new NotFoundException('Delivery slip not found');
    }

    // Check permissions
    if (userType === 'SELLER' && deliverySlip.userId !== userId) {
      throw new ForbiddenException(
        'You can only modify your own delivery slips',
      );
    }

    // Check if slip can be modified
    if (deliverySlip.status !== DeliverySlipStatus.PENDING) {
      throw new BadRequestException(
        'Can only add parcels to pending delivery slips',
      );
    }

    // Validate and add parcels
    const validParcelIds = await this.validateParcelsForSlip(
      addParcelsDto.parcelIds,
      tenantId,
      userId,
      userType,
    );

    await this.addParcelsToSlipInternal(
      id,
      validParcelIds,
      userId,
      addParcelsDto.markAsScanned || true,
      addParcelsDto.comment,
    );

    await this.clearCache(tenantId);

    this.logger.log(
      `Added ${validParcelIds.length} parcels to delivery slip ${deliverySlip.reference}`,
    );

    return this.findOne(id, tenantId);
  }

  /**
   * Remove parcels from delivery slip
   */
  async removeParcels(
    id: string,
    removeParcelsDto: RemoveParcelsFromSlipDto,
    tenantId: string,
    userId: string,
    userType: string,
  ): Promise<DeliverySlipResponseDto> {
    const deliverySlip = await this.prisma.deliverySlip.findFirst({
      where: { id, tenantId, isDeleted: false },
    });

    if (!deliverySlip) {
      throw new NotFoundException('Delivery slip not found');
    }

    // Check permissions
    if (userType === 'SELLER' && deliverySlip.userId !== userId) {
      throw new ForbiddenException(
        'You can only modify your own delivery slips',
      );
    }

    // Check if slip can be modified
    if (deliverySlip.status !== DeliverySlipStatus.PENDING) {
      throw new BadRequestException(
        'Can only remove parcels from pending delivery slips',
      );
    }

    // Remove parcels from slip
    await this.prisma.deliverySlipItem.deleteMany({
      where: {
        deliverySlipId: id,
        parcelId: { in: removeParcelsDto.parcelIds },
      },
    });

    // Reset parcel statuses back to NEW_PACKAGE
    const newPackageStatus = await this.prisma.parcelStatus.findFirst({
      where: { tenantId, code: 'NEW_PACKAGE', isDeleted: false },
    });

    if (newPackageStatus) {
      await this.prisma.parcel.updateMany({
        where: { id: { in: removeParcelsDto.parcelIds } },
        data: {
          parcelStatusId: newPackageStatus.id,
          parcelStatusCode: newPackageStatus.code,
          updatedBy: userId,
        },
      });

      // Create status history entries
      for (const parcelId of removeParcelsDto.parcelIds) {
        await this.prisma.parcelStatusHistory.create({
          data: {
            parcelId,
            parcelStatusId: newPackageStatus.id,
            statusCode: newPackageStatus.code,
            comment: `Removed from delivery slip: ${removeParcelsDto.reason || 'No reason provided'}`,
            changedBy: userId,
          },
        });
      }
    }

    await this.clearCache(tenantId);

    this.logger.log(
      `Removed ${removeParcelsDto.parcelIds.length} parcels from delivery slip ${deliverySlip.reference}`,
    );

    return this.findOne(id, tenantId);
  }

  /**
   * Mark delivery slip as received
   */
  async receiveSlip(
    id: string,
    receiveDto: ReceiveSlipDto,
    tenantId: string,
    userId: string,
  ): Promise<DeliverySlipResponseDto> {
    const deliverySlip = await this.prisma.deliverySlip.findFirst({
      where: { id, tenantId, isDeleted: false },
      include: { items: true },
    });

    if (!deliverySlip) {
      throw new NotFoundException('Delivery slip not found');
    }

    if (deliverySlip.status !== DeliverySlipStatus.PENDING) {
      throw new BadRequestException('Delivery slip is not in pending status');
    }

    // Check if all items are scanned (unless forced)
    if (!receiveDto.forceReceive) {
      const unscannedItems = deliverySlip.items.filter((item) => !item.scanned);
      if (unscannedItems.length > 0) {
        throw new BadRequestException(
          `Cannot receive slip: ${unscannedItems.length} parcels are not scanned. Use forceReceive=true to override.`,
        );
      }
    }

    await this.receiveSlipInternal(id, userId, receiveDto.notes);
    await this.clearCache(tenantId);

    this.logger.log(
      `Received delivery slip ${deliverySlip.reference} for tenant ${tenantId}`,
    );

    return this.findOne(id, tenantId);
  }

  /**
   * Get available parcels for delivery slips
   */
  async getAvailableParcels(
    tenantId: string,
    userId?: string,
    userType?: string,
    cityId?: string,
  ): Promise<any[]> {
    const where: any = {
      tenantId,
      isDeleted: false,
      parcelStatusCode: 'NEW_PACKAGE', // Only new packages can be added to delivery slips
      deliverySlipItems: { none: {} }, // Not already in a delivery slip
    };

    // Sellers can only see their own parcels
    if (userType === 'SELLER') {
      where.userId = userId;
    }

    // Filter by city if provided
    if (cityId) {
      where.pickupCityId = cityId;
    }

    const parcels = await this.prisma.parcel.findMany({
      where,
      select: {
        id: true,
        code: true,
        recipientName: true,
        recipientPhone: true,
        price: true,
        createdAt: true,
        pickupCity: {
          select: { id: true, name: true, ref: true },
        },
        destinationCity: {
          select: { id: true, name: true, ref: true },
        },
      },
      orderBy: { createdAt: 'desc' },
      take: 100, // Limit for performance
    });

    return parcels.map((parcel) => ({
      ...parcel,
      price: Number(parcel.price),
    }));
  }

  /**
   * Get delivery slip statistics
   */
  async getStatistics(
    tenantId: string,
    userId?: string,
    userType?: string,
  ): Promise<DeliverySlipStatsDto> {
    const cached = await this.redis.getTenantCache(
      tenantId,
      `delivery-slips-stats:${userId || 'all'}`,
    );
    if (cached) {
      return JSON.parse(cached);
    }

    const baseWhere: any = { tenantId, isDeleted: false };
    if (userType === 'SELLER') {
      baseWhere.userId = userId;
    }

    // Replace the Promise.all section around line 530-560

    const [
      totalSlips,
      statusCounts,
      parcelCount,
      parcelValues,
      recentActivity,
      topCities,
    ] = await Promise.all([
      // Total slips count
      this.prisma.deliverySlip.count({ where: baseWhere }),

      // Count by status
      this.prisma.deliverySlip.groupBy({
        by: ['status'],
        where: baseWhere,
        _count: true,
      }),

      // Count of parcels in delivery slips
      this.prisma.deliverySlipItem.count({
        where: {
          deliverySlip: baseWhere,
        },
      }),

      // Get all parcels to calculate total value
      this.prisma.deliverySlipItem.findMany({
        where: {
          deliverySlip: baseWhere,
        },
        include: {
          parcel: {
            select: { price: true },
          },
        },
      }),

      // Recent activity (last 7 days)
      this.getRecentActivity(tenantId, userId, userType),

      // Top cities
      this.getTopCities(tenantId, userId, userType),
    ]);

    // Calculate total value
    const totalValue = parcelValues.reduce(
      (sum, item) => sum + Number(item.parcel.price),
      0,
    );

    // Process status counts
    const statusMap = statusCounts.reduce(
      (acc, item) => {
        acc[item.status] = item._count;
        return acc;
      },
      {} as Record<string, number>,
    );

    const stats: DeliverySlipStatsDto = {
      totalSlips,
      pendingSlips: statusMap[DeliverySlipStatus.PENDING] || 0,
      receivedSlips: statusMap[DeliverySlipStatus.RECEIVED] || 0,
      cancelledSlips: statusMap[DeliverySlipStatus.CANCELLED] || 0,
      totalParcelsInSlips: parcelCount,
      totalValueInSlips: totalValue,
      averageParcelsPerSlip: totalSlips > 0 ? parcelCount / totalSlips : 0,
      recentActivity,
      topCities,
    };

    // Cache for 30 minutes
    await this.redis.setTenantCache(
      tenantId,
      `delivery-slips-stats:${userId || 'all'}`,
      JSON.stringify(stats),
      1800,
    );

    return stats;
  }

  /**
   * Bulk actions on delivery slips
   */
  async bulkAction(
    bulkActionDto: BulkSlipActionDto,
    tenantId: string,
    userId: string,
  ): Promise<{ success: number; failed: number; errors: string[] }> {
    const { slipIds, action, comment } = bulkActionDto;
    const errors: string[] = [];
    let success = 0;
    let failed = 0;

    for (const slipId of slipIds) {
      try {
        switch (action.toUpperCase()) {
          case 'RECEIVE':
            await this.receiveSlip(
              slipId,
              { notes: comment },
              tenantId,
              userId,
            );
            break;
          case 'CANCEL':
            await this.update(
              slipId,
              { status: DeliverySlipStatus.CANCELLED },
              tenantId,
              userId,
              'ADMIN',
            );
            break;
          case 'DELETE':
            await this.remove(slipId, tenantId, userId);
            break;
          default:
            throw new BadRequestException(`Unknown action: ${action}`);
        }
        success++;
      } catch (error) {
        failed++;
        errors.push(`Slip ${slipId}: ${error.message}`);
      }
    }

    return { success, failed, errors };
  }

  /**
   * Soft delete delivery slip
   */
  async remove(id: string, tenantId: string, userId: string): Promise<void> {
    const existing = await this.prisma.deliverySlip.findFirst({
      where: { id, tenantId, isDeleted: false },
    });

    if (!existing) {
      throw new NotFoundException('Delivery slip not found');
    }

    // Can only delete pending slips
    if (existing.status !== DeliverySlipStatus.PENDING) {
      throw new BadRequestException('Can only delete pending delivery slips');
    }

    // Remove all items first and reset parcel statuses
    const items = await this.prisma.deliverySlipItem.findMany({
      where: { deliverySlipId: id },
      select: { parcelId: true },
    });

    if (items.length > 0) {
      const parcelIds = items.map((item) => item.parcelId);
      const newPackageStatus = await this.prisma.parcelStatus.findFirst({
        where: { tenantId, code: 'NEW_PACKAGE', isDeleted: false },
      });

      if (newPackageStatus) {
        await this.prisma.parcel.updateMany({
          where: { id: { in: parcelIds } },
          data: {
            parcelStatusId: newPackageStatus.id,
            parcelStatusCode: newPackageStatus.code,
          },
        });
      }
    }

    // Soft delete
    await this.prisma.deliverySlip.update({
      where: { id },
      data: {
        isDeleted: true,
        deletedAt: new Date(),
        deletedBy: userId,
      },
    });

    await this.clearCache(tenantId);

    this.logger.log(
      `Deleted delivery slip ${existing.reference} for tenant ${tenantId}`,
    );
  }

  // Private helper methods

  private async generateSlipReference(tenantId: string): Promise<string> {
    const date = new Date();
    const year = date.getFullYear().toString().slice(-2);
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');

    // Get daily counter
    const counterKey = `delivery-slip-counter:${tenantId}:${year}${month}${day}`;
    const counter = await this.redis.incr(counterKey);
    await this.redis.expire(counterKey, 86400); // Expire after 1 day

    const randomSuffix = Math.random().toString(10).substring(2, 5);

    return `BL-${day}${month}${year}-${String(counter).padStart(7, '0')}-${randomSuffix}`;
  }

  private async validateCity(cityId: string, tenantId: string): Promise<void> {
    const city = await this.prisma.city.findFirst({
      where: {
        id: cityId,
        tenantId,
        isDeleted: false,
        status: true,
      },
    });

    if (!city) {
      throw new BadRequestException('Invalid or inactive city');
    }
  }

  private async validateParcelsForSlip(
    parcelIds: string[],
    tenantId: string,
    userId: string,
    userType: string,
  ): Promise<string[]> {
    const where: any = {
      id: { in: parcelIds },
      tenantId,
      isDeleted: false,
      parcelStatusCode: 'NEW_PACKAGE',
      deliverySlipItems: { none: {} }, // Not already in a delivery slip
    };

    // Sellers can only add their own parcels
    if (userType === 'SELLER') {
      where.userId = userId;
    }

    const validParcels = await this.prisma.parcel.findMany({
      where,
      select: { id: true, code: true },
    });

    if (validParcels.length !== parcelIds.length) {
      const validIds = validParcels.map((o) => o.id);
      const invalidIds = parcelIds.filter((id) => !validIds.includes(id));
      throw new BadRequestException(
        `Some parcels are invalid or cannot be added: ${invalidIds.length} out of ${parcelIds.length}`,
      );
    }

    return validParcels.map((o) => o.id);
  }

  private async addParcelsToSlipInternal(
    slipId: string,
    parcelIds: string[],
    userId: string,
    markAsScanned: boolean = false,
    comment?: string,
  ): Promise<void> {
    // Add items to slip
    await this.prisma.deliverySlipItem.createMany({
      data: parcelIds.map((parcelId) => ({
        deliverySlipId: slipId,
        parcelId,
        scanned: markAsScanned,
        scannedAt: markAsScanned ? new Date() : null,
        scannedBy: markAsScanned ? userId : null,
      })),
      skipDuplicates: true,
    });

    // If parcels are being scanned/received, update their status
    if (markAsScanned) {
      // Determine if pickup city = destination city for status logic
      const parcels = await this.prisma.parcel.findMany({
        where: { id: { in: parcelIds } },
        include: {
          pickupCity: true,
          destinationCity: true,
        },
      });

      for (const parcel of parcels) {
        // If same city, status becomes "RECEIVED", if different city, status becomes "COLLECTED"
        const isSameCity = parcel.pickupCityId === parcel.destinationCityId;
        const newStatusCode = isSameCity ? 'RECEIVED' : 'COLLECTED';

        const newStatus = await this.prisma.parcelStatus.findFirst({
          where: { code: newStatusCode, isDeleted: false },
        });

        if (newStatus) {
          await this.prisma.parcel.update({
            where: { id: parcel.id },
            data: {
              parcelStatusId: newStatus.id,
              parcelStatusCode: newStatus.code,
              updatedBy: userId,
            },
          });

          // Create status history
          await this.prisma.parcelStatusHistory.create({
            data: {
              parcelId: parcel.id,
              parcelStatusId: newStatus.id,
              statusCode: newStatus.code,
              comment: comment || 'Added to delivery slip and scanned',
              changedBy: userId,
            },
          });
        }
      }
    }
  }

  private async receiveSlipInternal(
    slipId: string,
    userId: string,
    notes?: string,
  ): Promise<void> {
    await this.prisma.deliverySlip.update({
      where: { id: slipId },
      data: {
        status: DeliverySlipStatus.RECEIVED,
        receivedAt: new Date(),
        receivedBy: userId,
        updatedBy: userId,
      },
    });

    // Mark all unscanned items as scanned
    await this.prisma.deliverySlipItem.updateMany({
      where: {
        deliverySlipId: slipId,
        scanned: false,
      },
      data: {
        scanned: true,
        scannedAt: new Date(),
        scannedBy: userId,
      },
    });
  }

  private async getRecentActivity(
    tenantId: string,
    userId?: string,
    userType?: string,
  ): Promise<any[]> {
    const baseWhere: any = { tenantId, isDeleted: false };
    if (userType === 'SELLER') {
      baseWhere.userId = userId;
    }

    // Get data for last 7 days
    const sevenDaysAgo = new Date();
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

    const activity = await this.prisma.deliverySlip.groupBy({
      by: ['createdAt', 'status'],
      where: {
        ...baseWhere,
        createdAt: { gte: sevenDaysAgo },
      },
      _count: true,
    });

    // Process into daily stats
    const dailyStats = new Map<
      string,
      { slipsCreated: number; slipsReceived: number }
    >();

    for (let i = 0; i < 7; i++) {
      const date = new Date();
      date.setDate(date.getDate() - i);
      const dateStr = date.toISOString().split('T')[0];
      dailyStats.set(dateStr, { slipsCreated: 0, slipsReceived: 0 });
    }

    activity.forEach((item) => {
      const dateStr = item.createdAt.toISOString().split('T')[0];
      const stats = dailyStats.get(dateStr) || {
        slipsCreated: 0,
        slipsReceived: 0,
      };

      stats.slipsCreated += item._count;
      if (item.status === DeliverySlipStatus.RECEIVED) {
        stats.slipsReceived += item._count;
      }

      dailyStats.set(dateStr, stats);
    });

    return Array.from(dailyStats.entries()).map(([date, stats]) => ({
      date,
      ...stats,
    }));
  }

  private async getTopCities(
    tenantId: string,
    userId?: string,
    userType?: string,
  ): Promise<any[]> {
    const baseWhere: any = { tenantId, isDeleted: false };
    if (userType === 'SELLER') {
      baseWhere.userId = userId;
    }

    const cityStats = await this.prisma.deliverySlip.groupBy({
      by: ['cityId'],
      where: baseWhere,
      _count: true,
      orderBy: { _count: { cityId: 'desc' } },
      take: 5,
    });

    // Get city names
    const cityIds = cityStats
      .map((stat) => stat.cityId)
      .filter(Boolean) as string[];
    const cities = await this.prisma.city.findMany({
      where: { id: { in: cityIds } },
      select: { id: true, name: true },
    });

    return cityStats.map((stat) => {
      const city = cities.find((c) => c.id === stat.cityId);
      return {
        cityName: city?.name || 'Unknown',
        slipCount: stat._count,
        parcelCount: 0, // This would need additional query
      };
    });
  }

  private getSlipIncludes() {
    return {
      city: {
        select: { id: true, name: true, ref: true },
      },
      items: {
        include: {
          parcel: {
            select: {
              id: true,
              code: true,
              recipientName: true,
              recipientPhone: true,
              price: true,
              parcelStatusCode: true,
              parcelStatus: {
                select: { name: true, color: true },
              },
              destinationCity: {
                select: { name: true },
              },
            },
          },
        },
      },
    };
  }

  private mapToResponseDto(slip: any): DeliverySlipResponseDto {
    const totalParcels = slip.items?.length || 0;
    const scannedParcels =
      slip.items?.filter((item: any) => item.scanned).length || 0;
    const totalValue =
      slip.items?.reduce(
        (sum: number, item: any) => sum + Number(item.parcel.price),
        0,
      ) || 0;

    return {
      id: slip.id,
      tenantId: slip.tenantId,
      userId: slip.userId,
      reference: slip.reference,
      cityId: slip.cityId,
      status: slip.status,
      receivedAt: slip.receivedAt,
      receivedBy: slip.receivedBy,
      notes: slip.notes,
      createdAt: slip.createdAt,
      updatedAt: slip.updatedAt,
      createdBy: slip.createdBy,
      updatedBy: slip.updatedBy,
      city: slip.city,
      creator: slip.creator,
      items:
        slip.items?.map((item: any) => ({
          deliverySlipId: item.deliverySlipId,
          parcelId: item.parcelId,
          scanned: item.scanned,
          scannedAt: item.scannedAt,
          scannedBy: item.scannedBy,
          parcel: {
            id: item.parcel.id,
            code: item.parcel.code,
            recipientName: item.parcel.recipientName,
            recipientPhone: item.parcel.recipientPhone,
            destinationCity: item.parcel.destinationCity.name,
            price: Number(item.parcel.price),
            statusCode: item.parcel.parcelStatusCode,
            statusName: item.parcel.parcelStatus.name,
          },
        })) || [],
      summary: {
        totalParcels,
        scannedParcels,
        unscannedParcels: totalParcels - scannedParcels,
        totalValue,
      },
    };
  }

  private async clearCache(tenantId: string): Promise<void> {
    const keys = [
      'delivery-slips',
      'delivery-slips-stats:all',
      'available-parcels',
    ];

    for (const key of keys) {
      await this.redis.delTenantCache(tenantId, key);
    }

    // Clear user-specific caches using the new Redis methods
    const userKeys = await this.redis.keys(
      `tenant:${tenantId}:delivery-slips-stats:*`,
    );
    if (userKeys.length > 0) {
      await this.redis.delMultiple(userKeys);
    }
  }
}
-----------------------------------------------------------------------
--++--> src/modules/scanner/dto/scanner.dto.ts =======>
-----------------------------------------------------------------------
import {
  IsString,
  IsArray,
  IsOptional,
  IsEnum,
  IsBoolean,
  IsNotEmpty,
  ArrayNotEmpty,
  MaxLength,
} from 'class-validator';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
export enum ScannerAction {
  ADD_TO_SLIP = 'ADD_TO_SLIP',
  REMOVE_FROM_SLIP = 'REMOVE_FROM_SLIP',
  CHANGE_STATUS = 'CHANGE_STATUS',
  VERIFY_PACKAGE = 'VERIFY_PACKAGE',
  ASSIGN_TO_DELIVERY = 'ASSIGN_TO_DELIVERY',
}
export enum SlipType {
  DELIVERY_SLIP = 'DELIVERY_SLIP',
  SHIPPING_SLIP = 'SHIPPING_SLIP',
  DISTRIBUTION_SLIP = 'DISTRIBUTION_SLIP',
  RETURN_SLIP = 'RETURN_SLIP',
  PAYMENT_SLIP = 'PAYMENT_SLIP',
}
export class SingleScanDto {
  @ApiProperty({
    example: 'BSK0925539432LE',
    description: 'Parcel code or barcode to scan',
  })
  @IsString()
  @IsNotEmpty()
  @MaxLength(100)
  code: string;

  @ApiProperty({
    enum: ScannerAction,
    example: ScannerAction.ADD_TO_SLIP,
    description: 'Action to perform with the scanned code',
  })
  @IsEnum(ScannerAction)
  action: ScannerAction;

  @ApiPropertyOptional({
    enum: SlipType,
    example: SlipType.DELIVERY_SLIP,
    description:
      'Type of slip being worked with (required for slip operations)',
  })
  @IsOptional()
  @IsEnum(SlipType)
  slipType?: SlipType;

  @ApiPropertyOptional({
    example: 'cuid123',
    description: 'Slip ID (required for slip operations)',
  })
  @IsOptional()
  @IsString()
  slipId?: string;

  @ApiPropertyOptional({
    example: 'Package successfully added to delivery slip',
    description: 'Optional comment for the scan operation',
  })
  @IsOptional()
  @IsString()
  @MaxLength(500)
  comment?: string;

  @ApiPropertyOptional({
    example: 'DELIVERED',
    description: 'New status code (required for status change actions)',
  })
  @IsOptional()
  @IsString()
  newStatusCode?: string;

  @ApiPropertyOptional({
    example: 'cuid456',
    description: 'Delivery person ID (required for assignment actions)',
  })
  @IsOptional()
  @IsString()
  deliveryPersonId?: string;
}
export class BulkScanDto {
  @ApiProperty({
    example: ['BSK0925539432LE', 'BSK0925539433LE'],
    description: 'Array of parcel codes to scan',
  })
  @IsArray()
  @ArrayNotEmpty()
  @IsString({ each: true })
  codes: string[];

  @ApiProperty({
    enum: ScannerAction,
    example: ScannerAction.ADD_TO_SLIP,
    description: 'Action to perform on all scanned codes',
  })
  @IsEnum(ScannerAction)
  action: ScannerAction;

  @ApiPropertyOptional({
    enum: SlipType,
    example: SlipType.DELIVERY_SLIP,
    description: 'Type of slip being worked with',
  })
  @IsOptional()
  @IsEnum(SlipType)
  slipType?: SlipType;

  @ApiPropertyOptional({
    example: 'cuid123',
    description: 'Slip ID for bulk operations',
  })
  @IsOptional()
  @IsString()
  slipId?: string;

  @ApiPropertyOptional({
    example: 'Bulk scan operation from mobile scanner',
    description: 'Comment for the bulk operation',
  })
  @IsOptional()
  @IsString()
  @MaxLength(500)
  comment?: string;

  @ApiPropertyOptional({
    example: 'DELIVERED',
    description: 'New status code for bulk status changes',
  })
  @IsOptional()
  @IsString()
  newStatusCode?: string;

  @ApiPropertyOptional({
    example: 'cuid456',
    description: 'Delivery person ID for bulk assignments',
  })
  @IsOptional()
  @IsString()
  deliveryPersonId?: string;
}
export class ValidateCodeDto {
  @ApiProperty({
    example: 'BSK0925539432LE',
    description: 'Code to validate',
  })
  @IsString()
  @IsNotEmpty()
  @MaxLength(100)
  code: string;

  @ApiPropertyOptional({
    enum: SlipType,
    example: SlipType.DELIVERY_SLIP,
    description: 'Expected slip type context',
  })
  @IsOptional()
  @IsEnum(SlipType)
  expectedSlipType?: SlipType;

  @ApiPropertyOptional({
    example: 'cuid123',
    description: 'Slip ID for context validation',
  })
  @IsOptional()
  @IsString()
  slipId?: string;
}
export class ScanResultDto {
  @ApiProperty({
    example: true,
    description: 'Whether the scan was successful',
  })
  success: boolean;

  @ApiProperty({
    example: 'BSK0925539432LE',
    description: 'The scanned code',
  })
  code: string;

  @ApiProperty({
    enum: ScannerAction,
    example: ScannerAction.ADD_TO_SLIP,
    description: 'Action that was performed',
  })
  action: ScannerAction;

  @ApiPropertyOptional({
    example: 'Package successfully added to delivery slip',
    description: 'Result message',
  })
  message?: string;

  @ApiPropertyOptional({
    example: 'Parcel not found',
    description: 'Error message if scan failed',
  })
  error?: string;

  @ApiPropertyOptional({
    description: 'Parcel details if found',
    type: 'object',
    properties: {
      id: { type: 'string' },
      code: { type: 'string' },
      recipientName: { type: 'string' },
      recipientPhone: { type: 'string' },
      statusCode: { type: 'string' },
      statusName: { type: 'string' },
      destinationCity: { type: 'string' },
      price: { type: 'number' },
    },
  })
  parcelDetails?: {
    id: string;
    code: string;
    recipientName: string;
    recipientPhone: string;
    statusCode: string;
    statusName: string;
    destinationCity: string;
    price: number;
  };

  @ApiPropertyOptional({
    example: '2024-01-15T10:30:00Z',
    description: 'Timestamp when scan was performed',
  })
  scannedAt?: Date;
}
export class BulkScanResultDto {
  @ApiProperty({
    example: 5,
    description: 'Number of successful scans',
  })
  successful: number;

  @ApiProperty({
    example: 2,
    description: 'Number of failed scans',
  })
  failed: number;

  @ApiProperty({
    example: 7,
    description: 'Total number of codes processed',
  })
  total: number;

  @ApiProperty({
    type: [ScanResultDto],
    description: 'Detailed results for each scan',
  })
  results: ScanResultDto[];

  @ApiProperty({
    example: [
      'BSK0925539434LE: Parcel not found',
      'BSK0925539435LE: Invalid status',
    ],
    description: 'List of errors encountered',
  })
  errors: string[];

  @ApiProperty({
    example: '2024-01-15T10:30:00Z',
    description: 'When the bulk operation started',
  })
  processedAt: Date;
}
export class CodeValidationDto {
  @ApiProperty({
    example: true,
    description: 'Whether the code is valid',
  })
  isValid: boolean;

  @ApiProperty({
    example: 'BSK0925539432LE',
    description: 'The validated code',
  })
  code: string;

  @ApiProperty({
    example: 'PARCEL',
    description: 'Type of code (PARCEL, SLIP, etc.)',
  })
  codeType: string;

  @ApiPropertyOptional({
    example: 'Valid parcel code',
    description: 'Validation message',
  })
  message?: string;

  @ApiPropertyOptional({
    example: 'Parcel not found',
    description: 'Error message if invalid',
  })
  error?: string;

  @ApiPropertyOptional({
    description: 'Entity details if code is valid',
    type: 'object',
  })
  entityDetails?: any;

  @ApiPropertyOptional({
    type: [String],
    example: [ScannerAction.ADD_TO_SLIP, ScannerAction.CHANGE_STATUS],
    description: 'Available actions for this code',
  })
  availableActions?: ScannerAction[];
}
export class ScannerSessionDto {
  @ApiProperty({
    example: 'cuid123',
    description: 'Session ID for tracking continuous scanning',
  })
  sessionId: string;

  @ApiProperty({
    enum: SlipType,
    example: SlipType.DELIVERY_SLIP,
    description: 'Type of slip being processed in this session',
  })
  slipType: SlipType;

  @ApiPropertyOptional({
    example: 'cuid456',
    description: 'Slip ID being worked on',
  })
  slipId?: string;

  @ApiProperty({
    example: 15,
    description: 'Number of items scanned in this session',
  })
  itemsScanned: number;

  @ApiProperty({
    example: 2,
    description: 'Number of errors in this session',
  })
  errorsCount: number;

  @ApiProperty({
    example: '2024-01-15T10:30:00Z',
    description: 'When the session started',
  })
  startedAt: Date;

  @ApiPropertyOptional({
    example: '2024-01-15T11:00:00Z',
    description: 'When the session ended',
  })
  endedAt?: Date;

  @ApiProperty({
    example: true,
    description: 'Whether the session is currently active',
  })
  isActive: boolean;
}
export class StartScanSessionDto {
  @ApiProperty({
    enum: SlipType,
    example: SlipType.DELIVERY_SLIP,
    description: 'Type of slip to work with in this session',
  })
  @IsEnum(SlipType)
  slipType: SlipType;

  @ApiPropertyOptional({
    example: 'cuid123',
    description: 'Existing slip ID to work with',
  })
  @IsOptional()
  @IsString()
  slipId?: string;

  @ApiPropertyOptional({
    example: 'Mobile scanner session for morning pickup',
    description: 'Session description or notes',
  })
  @IsOptional()
  @IsString()
  @MaxLength(200)
  description?: string;
}
-----------------------------------------------------------------------
--++--> src/modules/scanner/scanner.controller.ts =======>
-----------------------------------------------------------------------
import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  Delete,
  Query,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiParam,
  ApiBearerAuth,
  ApiBadRequestResponse,
  ApiNotFoundResponse,
} from '@nestjs/swagger';
import { ScannerService } from './scanner.service';
import {
  SingleScanDto,
  BulkScanDto,
  ValidateCodeDto,
  ScanResultDto,
  BulkScanResultDto,
  CodeValidationDto,
  ScannerSessionDto,
  StartScanSessionDto,
} from './dto/scanner.dto';
import { GlobalAuth, CurrentTenant, CurrentUser } from '@network-saas/auth-lib';
import { ParseCuidPipe } from '../../common/pipes/parse-cuid.pipe';
@ApiTags('scanner')
@ApiBearerAuth()
@Controller('scanner')
export class ScannerController {
  constructor(private readonly scannerService: ScannerService) {}

  @Post('scan')
  @GlobalAuth('scanner:use')
  @ApiOperation({
    summary: 'Single scan operation',
    description:
      'Perform a single barcode/QR code scan operation with specified action',
  })
  @ApiResponse({
    status: 200,
    description: 'Scan operation completed',
    type: ScanResultDto,
  })
  @ApiBadRequestResponse({
    description: 'Invalid scan parameters or unsupported action',
  })
  async singleScan(
    @Body() scanDto: SingleScanDto,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<ScanResultDto> {
    return this.scannerService.singleScan(scanDto, tenantId, user.id);
  }

  @Post('bulk-scan')
  @GlobalAuth('scanner:bulk_scan')
  @ApiOperation({
    summary: 'Bulk scan operation',
    description:
      'Perform bulk scanning operations on multiple codes simultaneously',
  })
  @ApiResponse({
    status: 200,
    description: 'Bulk scan operation completed',
    type: BulkScanResultDto,
  })
  @ApiBadRequestResponse({
    description: 'Invalid bulk scan parameters',
  })
  async bulkScan(
    @Body() bulkScanDto: BulkScanDto,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<BulkScanResultDto> {
    return this.scannerService.bulkScan(bulkScanDto, tenantId, user.id);
  }

  @Post('validate')
  @GlobalAuth('scanner:use')
  @ApiOperation({
    summary: 'Validate code',
    description:
      'Validate a barcode/QR code and get available actions without performing any operation',
  })
  @ApiResponse({
    status: 200,
    description: 'Code validation completed',
    type: CodeValidationDto,
  })
  async validateCode(
    @Body() validateDto: ValidateCodeDto,
    @CurrentTenant() tenantId: string,
  ): Promise<CodeValidationDto> {
    return this.scannerService.validateCode(validateDto, tenantId);
  }

  @Get('validate/:code')
  @GlobalAuth('scanner:use')
  @ApiOperation({
    summary: 'Quick validate code',
    description: 'Quick validation of a code via URL parameter',
  })
  @ApiParam({
    name: 'code',
    description: 'Code to validate',
    example: 'BSK0925539432LE',
  })
  @ApiResponse({
    status: 200,
    description: 'Code validation completed',
    type: CodeValidationDto,
  })
  async quickValidateCode(
    @Param('code') code: string,
    @CurrentTenant() tenantId: string,
  ): Promise<CodeValidationDto> {
    return this.scannerService.validateCode({ code }, tenantId);
  }

  @Post('session/start')
  @GlobalAuth('scanner:use')
  @ApiOperation({
    summary: 'Start scanning session',
    description: 'Start a new scanning session for continuous operations',
  })
  @ApiResponse({
    status: 201,
    description: 'Scanning session started successfully',
    type: ScannerSessionDto,
  })
  async startScanSession(
    @Body() sessionDto: StartScanSessionDto,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<ScannerSessionDto> {
    return this.scannerService.startScanSession(sessionDto, tenantId, user.id);
  }

  @Get('session/:sessionId')
  @GlobalAuth('scanner:use')
  @ApiOperation({
    summary: 'Get scanning session',
    description: 'Get details of an active or completed scanning session',
  })
  @ApiParam({
    name: 'sessionId',
    description: 'Scanning session ID',
    example: 'scan_1640995200000_abc123',
  })
  @ApiResponse({
    status: 200,
    description: 'Scanning session details retrieved',
    type: ScannerSessionDto,
  })
  @ApiNotFoundResponse({
    description: 'Scanning session not found',
  })
  async getScanSession(
    @Param('sessionId') sessionId: string,
    @CurrentTenant() tenantId: string,
  ): Promise<ScannerSessionDto | null> {
    return this.scannerService.getScanSession(sessionId, tenantId);
  }

  @Delete('session/:sessionId')
  @GlobalAuth('scanner:use')
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({
    summary: 'End scanning session',
    description: 'End an active scanning session',
  })
  @ApiParam({
    name: 'sessionId',
    description: 'Scanning session ID to end',
    example: 'scan_1640995200000_abc123',
  })
  @ApiResponse({
    status: 204,
    description: 'Scanning session ended successfully',
  })
  async endScanSession(
    @Param('sessionId') sessionId: string,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<void> {
    await this.scannerService.endScanSession(sessionId, tenantId, user.id);
  }

  @Post('camera-scan')
  @GlobalAuth('scanner:camera')
  @ApiOperation({
    summary: 'Camera scan operation',
    description: 'Perform scanning using camera input (mobile/webcam)',
  })
  @ApiResponse({
    status: 200,
    description: 'Camera scan completed',
    type: ScanResultDto,
  })
  async cameraScan(
    @Body() scanDto: SingleScanDto,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<ScanResultDto> {
    // Camera scan is essentially the same as regular scan but with different permission
    return this.scannerService.singleScan(scanDto, tenantId, user.id);
  }

  @Get('stats')
  @GlobalAuth('scanner:use')
  @ApiOperation({
    summary: 'Get scanner statistics',
    description: 'Get scanning statistics for the current user or system',
  })
  @ApiResponse({
    status: 200,
    description: 'Scanner statistics retrieved',
    schema: {
      type: 'object',
      properties: {
        totalScansToday: { type: 'number' },
        successfulScansToday: { type: 'number' },
        failedScansToday: { type: 'number' },
        totalScansThisWeek: { type: 'number' },
        averageScansPerSession: { type: 'number' },
        topScannedActions: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              action: { type: 'string' },
              count: { type: 'number' },
            },
          },
        },
        recentSessions: {
          type: 'array',
          items: { $ref: '#/components/schemas/ScannerSessionDto' },
        },
      },
    },
  })
  async getScannerStats(
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
    @Query('global') global?: boolean,
  ): Promise<any> {
    // This would be implemented to show scanning statistics
    // For now, return mock data structure
    return {
      totalScansToday: 156,
      successfulScansToday: 148,
      failedScansToday: 8,
      totalScansThisWeek: 892,
      averageScansPerSession: 24,
      topScannedActions: [
        { action: 'ADD_TO_SLIP', count: 89 },
        { action: 'CHANGE_STATUS', count: 45 },
        { action: 'VERIFY_PACKAGE', count: 22 },
      ],
      recentSessions: [],
    };
  }

  @Get('history')
  @GlobalAuth('scanner:use')
  @ApiOperation({
    summary: 'Get scan history',
    description: 'Get recent scanning history for the current user',
  })
  @ApiResponse({
    status: 200,
    description: 'Scan history retrieved',
    schema: {
      type: 'object',
      properties: {
        scans: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              code: { type: 'string' },
              action: { type: 'string' },
              success: { type: 'boolean' },
              timestamp: { type: 'string', format: 'date-time' },
              parcelDetails: { type: 'object' },
            },
          },
        },
        pagination: {
          type: 'object',
          properties: {
            page: { type: 'number' },
            limit: { type: 'number' },
            total: { type: 'number' },
          },
        },
      },
    },
  })
  async getScanHistory(
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
    @Query('page') page: number = 1,
    @Query('limit') limit: number = 50,
  ): Promise<any> {
    // This would be implemented to show recent scan history
    // For now, return empty structure
    return {
      scans: [],
      pagination: {
        page,
        limit,
        total: 0,
      },
    };
  }
}
-----------------------------------------------------------------------
--++--> src/modules/scanner/scanner.module.ts =======>
-----------------------------------------------------------------------
import { Module } from '@nestjs/common';
import { ScannerService } from './scanner.service';
import { ScannerController } from './scanner.controller';
import { PrismaModule } from '../../shared/services/prisma/prisma.module';
import { RedisModule } from '../../shared/services/redis/redis.module';
@Module({
  imports: [PrismaModule, RedisModule],
  controllers: [ScannerController],
  providers: [ScannerService],
  exports: [ScannerService],
})
export class ScannerModule {}
-----------------------------------------------------------------------
--++--> src/modules/scanner/scanner.service.ts =======>
-----------------------------------------------------------------------
import {
  Injectable,
  NotFoundException,
  BadRequestException,
  Logger,
  ConflictException,
} from '@nestjs/common';
import { PrismaService } from '../../shared/services/prisma/prisma.service';
import { RedisService } from '../../shared/services/redis/redis.service';
import {
  SingleScanDto,
  BulkScanDto,
  ValidateCodeDto,
  ScanResultDto,
  BulkScanResultDto,
  CodeValidationDto,
  ScannerSessionDto,
  StartScanSessionDto,
  ScannerAction,
  SlipType,
} from './dto/scanner.dto';
@Injectable()
export class ScannerService {
  private readonly logger = new Logger(ScannerService.name);

  constructor(
    private prisma: PrismaService,
    private redis: RedisService,
  ) {}

  /**
   * Perform a single scan operation
   */
  async singleScan(
    scanDto: SingleScanDto,
    tenantId: string,
    userId: string,
  ): Promise<ScanResultDto> {
    const {
      code,
      action,
      slipType,
      slipId,
      comment,
      newStatusCode,
      deliveryPersonId,
    } = scanDto;

    try {
      // First validate the code
      const validation = await this.validateCode(
        { code, expectedSlipType: slipType, slipId },
        tenantId,
      );

      if (!validation.isValid) {
        return {
          success: false,
          code,
          action,
          error: validation.error,
        };
      }

      // Get parcel details
      const parcel = await this.getorderByCode(code, tenantId);
      if (!parcel) {
        return {
          success: false,
          code,
          action,
          error: 'Parcel not found',
        };
      }

      // Perform the requested action
      let result: ScanResultDto;
      switch (action) {
        case ScannerAction.ADD_TO_SLIP:
          result = await this.addParcelToSlip(
            parcel,
            slipType!,
            slipId!,
            userId,
            code,
            action,
            comment,
          );
          break;
        case ScannerAction.REMOVE_FROM_SLIP:
          result = await this.removeParcelFromSlip(
            parcel,
            slipType!,
            slipId!,
            userId,
            code,
            action,
            comment,
          );
          break;
        case ScannerAction.CHANGE_STATUS:
          result = await this.changeParcelStatus(
            parcel,
            newStatusCode!,
            userId,
            code,
            action,
            comment,
          );
          break;
        case ScannerAction.VERIFY_PACKAGE:
          result = await this.verifyPackage(
            parcel,
            userId,
            code,
            action,
            comment,
          );
          break;
        case ScannerAction.ASSIGN_TO_DELIVERY:
          result = await this.assignToDeliveryPerson(
            parcel,
            deliveryPersonId!,
            userId,
            code,
            action,
            comment,
          );
          break;
        default:
          throw new BadRequestException(`Unsupported action: ${action}`);
      }

      // Log scan operation
      await this.logScanOperation(
        code,
        action,
        result.success,
        tenantId,
        userId,
        result.error,
      );

      return {
        ...result,
        code,
        action,
        scannedAt: new Date(),
        parcelDetails: {
          id: parcel.id,
          code: parcel.code,
          recipientName: parcel.recipientName,
          recipientPhone: parcel.recipientPhone,
          statusCode: parcel.parcelStatusCode,
          statusName: parcel.parcelStatus.name,
          destinationCity: parcel.destinationCity.name,
          price: Number(parcel.price),
        },
      };
    } catch (error) {
      this.logger.error(`Scan operation failed for code ${code}:`, error);

      return {
        success: false,
        code,
        action,
        error: error.message,
        scannedAt: new Date(),
      };
    }
  }

  /**
   * Perform bulk scan operations
   */
  async bulkScan(
    bulkScanDto: BulkScanDto,
    tenantId: string,
    userId: string,
  ): Promise<BulkScanResultDto> {
    const {
      codes,
      action,
      slipType,
      slipId,
      comment,
      newStatusCode,
      deliveryPersonId,
    } = bulkScanDto;

    const results: ScanResultDto[] = [];
    const errors: string[] = [];
    let successful = 0;
    let failed = 0;

    this.logger.log(`Starting bulk scan operation for ${codes.length} codes`);

    // Process each code
    for (const code of codes) {
      try {
        const singleScanDto: SingleScanDto = {
          code,
          action,
          slipType,
          slipId,
          comment,
          newStatusCode,
          deliveryPersonId,
        };

        const result = await this.singleScan(singleScanDto, tenantId, userId);
        results.push(result);

        if (result.success) {
          successful++;
        } else {
          failed++;
          errors.push(`${code}: ${result.error}`);
        }
      } catch (error) {
        failed++;
        errors.push(`${code}: ${error.message}`);
        results.push({
          success: false,
          code,
          action,
          error: error.message,
          scannedAt: new Date(),
        });
      }
    }

    const bulkResult: BulkScanResultDto = {
      successful,
      failed,
      total: codes.length,
      results,
      errors,
      processedAt: new Date(),
    };

    // Log bulk operation summary
    this.logger.log(
      `Bulk scan completed: ${successful} successful, ${failed} failed out of ${codes.length} codes`,
    );

    return bulkResult;
  }

  /**
   * Validate a code before scanning
   */
  async validateCode(
    validateDto: ValidateCodeDto,
    tenantId: string,
  ): Promise<CodeValidationDto> {
    const { code, expectedSlipType, slipId } = validateDto;

    try {
      // Check if it's an parcel code
      const parcel = await this.getorderByCode(code, tenantId);

      if (parcel) {
        const availableActions = this.getAvailableActionsForParcel(
          parcel,
          expectedSlipType,
        );

        return {
          isValid: true,
          code,
          codeType: 'PARCEL',
          message: 'Valid parcel code',
          entityDetails: {
            id: parcel.id,
            code: parcel.code,
            recipientName: parcel.recipientName,
            statusCode: parcel.parcelStatusCode,
            statusName: parcel.parcelStatus.name,
          },
          availableActions,
        };
      }

      // Check if it's a slip code (delivery slip, shipping slip, etc.)
      const slip = await this.getSlipByCode(code, tenantId);
      if (slip) {
        return {
          isValid: true,
          code,
          codeType: 'SLIP',
          message: 'Valid slip code',
          entityDetails: slip,
          availableActions: [ScannerAction.VERIFY_PACKAGE],
        };
      }

      // Code not found
      return {
        isValid: false,
        code,
        codeType: 'UNKNOWN',
        error: 'Code not found in system',
      };
    } catch (error) {
      this.logger.error(`Code validation failed for ${code}:`, error);
      return {
        isValid: false,
        code,
        codeType: 'ERROR',
        error: error.message,
      };
    }
  }

  /**
   * Start a scanning session for continuous operations
   */
  async startScanSession(
    sessionDto: StartScanSessionDto,
    tenantId: string,
    userId: string,
  ): Promise<ScannerSessionDto> {
    const sessionId = this.generateSessionId();

    const session: ScannerSessionDto = {
      sessionId,
      slipType: sessionDto.slipType,
      slipId: sessionDto.slipId,
      itemsScanned: 0,
      errorsCount: 0,
      startedAt: new Date(),
      isActive: true,
    };

    // Store session in Redis with 4 hour expiry
    await this.redis.setTenantCache(
      tenantId,
      `scan-session:${sessionId}`,
      JSON.stringify({ ...session, userId }),
      14400, // 4 hours
    );

    this.logger.log(`Started scan session ${sessionId} for user ${userId}`);

    return session;
  }

  /**
   * Get active scan session
   */
  async getScanSession(
    sessionId: string,
    tenantId: string,
  ): Promise<ScannerSessionDto | null> {
    const cached = await this.redis.getTenantCache(
      tenantId,
      `scan-session:${sessionId}`,
    );

    if (!cached) {
      return null;
    }

    const session = JSON.parse(cached);
    return {
      sessionId: session.sessionId,
      slipType: session.slipType,
      slipId: session.slipId,
      itemsScanned: session.itemsScanned,
      errorsCount: session.errorsCount,
      startedAt: new Date(session.startedAt),
      endedAt: session.endedAt ? new Date(session.endedAt) : undefined,
      isActive: session.isActive,
    };
  }

  /**
   * End a scanning session
   */
  async endScanSession(
    sessionId: string,
    tenantId: string,
    userId: string,
  ): Promise<void> {
    const session = await this.getScanSession(sessionId, tenantId);

    if (session) {
      session.isActive = false;
      session.endedAt = new Date();

      await this.redis.setTenantCache(
        tenantId,
        `scan-session:${sessionId}`,
        JSON.stringify({ ...session, userId }),
        86400, // Keep for 24 hours after ending
      );

      this.logger.log(`Ended scan session ${sessionId} for user ${userId}`);
    }
  }

  // Private helper methods

  private async getorderByCode(
    code: string,
    tenantId: string,
  ): Promise<any | null> {
    return this.prisma.parcel.findFirst({
      where: {
        OR: [{ code: code }, { trackingCode: code }],
        tenantId,
        isDeleted: false,
      },
      include: {
        parcelStatus: {
          select: { id: true, code: true, name: true, color: true },
        },
        destinationCity: {
          select: { id: true, name: true, ref: true },
        },
        pickupCity: {
          select: { id: true, name: true, ref: true },
        },
      },
    });
  }

  private async getSlipByCode(
    code: string,
    tenantId: string,
  ): Promise<any | null> {
    // Check delivery slips
    let slip = await this.prisma.deliverySlip.findFirst({
      where: { reference: code, tenantId, isDeleted: false },
    });
    if (slip) return { ...slip, type: 'DELIVERY_SLIP' };

    // Check shipping slips - cast to any to avoid type mismatch
    slip = (await this.prisma.shippingSlip.findFirst({
      where: { reference: code, tenantId, isDeleted: false },
    })) as any;
    if (slip) return { ...slip, type: 'SHIPPING_SLIP' };

    // Check distribution slips - cast to any to avoid type mismatch
    slip = (await this.prisma.distributionSlip.findFirst({
      where: { reference: code, tenantId, isDeleted: false },
    })) as any;
    if (slip) return { ...slip, type: 'DISTRIBUTION_SLIP' };

    return null;
  }

  private getAvailableActionsForParcel(
    parcel: any,
    expectedSlipType?: SlipType,
  ): ScannerAction[] {
    const actions: ScannerAction[] = [ScannerAction.VERIFY_PACKAGE];
    const status = parcel.parcelStatusCode;

    // Add actions based on parcel status and expected slip type
    if (
      expectedSlipType === SlipType.DELIVERY_SLIP &&
      status === 'NEW_PACKAGE'
    ) {
      actions.push(ScannerAction.ADD_TO_SLIP);
    }

    if (expectedSlipType === SlipType.SHIPPING_SLIP && status === 'COLLECTED') {
      actions.push(ScannerAction.ADD_TO_SLIP);
    }

    if (
      expectedSlipType === SlipType.DISTRIBUTION_SLIP &&
      ['RECEIVED', 'DISPATCHED'].includes(status)
    ) {
      actions.push(ScannerAction.ADD_TO_SLIP, ScannerAction.ASSIGN_TO_DELIVERY);
    }

    if (
      expectedSlipType === SlipType.RETURN_SLIP &&
      ['OUT_FOR_DELIVERY', 'DELIVERY_FAILED'].includes(status)
    ) {
      actions.push(ScannerAction.ADD_TO_SLIP);
    }

    // Always allow status changes for valid transitions
    actions.push(ScannerAction.CHANGE_STATUS);

    return actions;
  }

  // Update the private methods to accept and return code/action parameters

  private async addParcelToSlip(
    parcel: any,
    slipType: SlipType,
    slipId: string,
    userId: string,
    code: string,
    action: ScannerAction,
    comment?: string,
  ): Promise<ScanResultDto> {
    try {
      switch (slipType) {
        case SlipType.DELIVERY_SLIP:
          await this.addToDeliverySlip(parcel.id, slipId, userId);
          await this.updateParcelStatus(parcel.id, 'RECEIVED', userId, comment);
          return {
            success: true,
            code,
            action,
            message: 'Parcel added to delivery slip successfully',
          };

        case SlipType.SHIPPING_SLIP:
          await this.addToShippingSlip(parcel.id, slipId, userId);
          await this.updateParcelStatus(
            parcel.id,
            'DISPATCHED',
            userId,
            comment,
          );
          return {
            success: true,
            code,
            action,
            message: 'Parcel added to shipping slip successfully',
          };

        case SlipType.DISTRIBUTION_SLIP:
          await this.addToDistributionSlip(parcel.id, slipId, userId);
          await this.updateParcelStatus(
            parcel.id,
            'PUT_IN_DISTRIBUTION',
            userId,
            comment,
          );
          return {
            success: true,
            code,
            action,
            message: 'Parcel added to distribution slip successfully',
          };

        case SlipType.RETURN_SLIP:
          await this.addToReturnSlip(parcel.id, slipId, userId);
          return {
            success: true,
            code,
            action,
            message: 'Parcel added to return slip successfully',
          };

        default:
          throw new BadRequestException(`Unsupported slip type: ${slipType}`);
      }
    } catch (error) {
      this.logger.error(
        `Failed to add parcel ${parcel.code} to ${slipType}:`,
        error,
      );
      return { success: false, code, action, error: error.message };
    }
  }

  private async removeParcelFromSlip(
    parcel: any,
    slipType: SlipType,
    slipId: string,
    userId: string,
    code: string,
    action: ScannerAction,
    comment?: string,
  ): Promise<ScanResultDto> {
    try {
      switch (slipType) {
        case SlipType.DELIVERY_SLIP:
          await this.removeFromDeliverySlip(parcel.id, slipId);
          return {
            success: true,
            code,
            action,
            message: 'Parcel removed from delivery slip successfully',
          };

        case SlipType.SHIPPING_SLIP:
          await this.removeFromShippingSlip(parcel.id, slipId);
          return {
            success: true,
            code,
            action,
            message: 'Parcel removed from shipping slip successfully',
          };

        case SlipType.DISTRIBUTION_SLIP:
          await this.removeFromDistributionSlip(parcel.id, slipId);
          return {
            success: true,
            code,
            action,
            message: 'Parcel removed from distribution slip successfully',
          };

        case SlipType.RETURN_SLIP:
          await this.removeFromReturnSlip(parcel.id, slipId);
          return {
            success: true,
            code,
            action,
            message: 'Parcel removed from return slip successfully',
          };

        default:
          throw new BadRequestException(`Unsupported slip type: ${slipType}`);
      }
    } catch (error) {
      this.logger.error(
        `Failed to remove parcel ${parcel.code} from ${slipType}:`,
        error,
      );
      return { success: false, code, action, error: error.message };
    }
  }

  private async changeParcelStatus(
    parcel: any,
    newStatusCode: string,
    userId: string,
    code: string,
    action: ScannerAction,
    comment?: string,
  ): Promise<ScanResultDto> {
    try {
      await this.updateParcelStatus(parcel.id, newStatusCode, userId, comment);
      return {
        success: true,
        code,
        action,
        message: `Parcel status changed to ${newStatusCode} successfully`,
      };
    } catch (error) {
      return { success: false, code, action, error: error.message };
    }
  }

  private async verifyPackage(
    parcel: any,
    userId: string,
    code: string,
    action: ScannerAction,
    comment?: string,
  ): Promise<ScanResultDto> {
    // Just verify that the package exists and return details
    return {
      success: true,
      code,
      action,
      message: 'Package verified successfully',
    };
  }

  private async assignToDeliveryPerson(
    parcel: any,
    deliveryPersonId: string,
    userId: string,
    code: string,
    action: ScannerAction,
    comment?: string,
  ): Promise<ScanResultDto> {
    try {
      // This would be implemented when we have delivery person management
      return {
        success: true,
        code,
        action,
        message: 'Parcel assigned to delivery person successfully',
      };
    } catch (error) {
      return { success: false, code, action, error: error.message };
    }
  }

  // Slip manipulation methods
  private async addToDeliverySlip(
    parcelId: string,
    slipId: string,
    userId: string,
  ): Promise<void> {
    // Check if already exists
    const existing = await this.prisma.deliverySlipItem.findUnique({
      where: {
        deliverySlipId_parcelId: {
          deliverySlipId: slipId,
          parcelId,
        },
      },
    });

    if (existing) {
      throw new ConflictException('Parcel already in delivery slip');
    }

    await this.prisma.deliverySlipItem.create({
      data: {
        deliverySlipId: slipId,
        parcelId,
        scanned: true,
        scannedAt: new Date(),
        scannedBy: userId,
      },
    });
  }

  private async removeFromDeliverySlip(
    parcelId: string,
    slipId: string,
  ): Promise<void> {
    await this.prisma.deliverySlipItem.delete({
      where: {
        deliverySlipId_parcelId: {
          deliverySlipId: slipId,
          parcelId,
        },
      },
    });
  }

  private async addToShippingSlip(
    parcelId: string,
    slipId: string,
    userId: string,
  ): Promise<void> {
    const existing = await this.prisma.shippingSlipItem.findUnique({
      where: {
        shippingSlipId_parcelId: {
          shippingSlipId: slipId,
          parcelId,
        },
      },
    });

    if (existing) {
      throw new ConflictException('Parcel already in shipping slip');
    }

    await this.prisma.shippingSlipItem.create({
      data: {
        shippingSlipId: slipId,
        parcelId,
        scanned: true,
        scannedAt: new Date(),
        scannedBy: userId,
      },
    });
  }

  private async removeFromShippingSlip(
    parcelId: string,
    slipId: string,
  ): Promise<void> {
    await this.prisma.shippingSlipItem.delete({
      where: {
        shippingSlipId_parcelId: {
          shippingSlipId: slipId,
          parcelId,
        },
      },
    });
  }

  private async addToDistributionSlip(
    parcelId: string,
    slipId: string,
    userId: string,
  ): Promise<void> {
    const existing = await this.prisma.distributionSlipItem.findUnique({
      where: {
        distributionSlipId_parcelId: {
          distributionSlipId: slipId,
          parcelId,
        },
      },
    });

    if (existing) {
      throw new ConflictException('Parcel already in distribution slip');
    }

    await this.prisma.distributionSlipItem.create({
      data: {
        distributionSlipId: slipId,
        parcelId,
        scanned: true,
        scannedAt: new Date(),
        scannedBy: userId,
      },
    });
  }

  private async removeFromDistributionSlip(
    parcelId: string,
    slipId: string,
  ): Promise<void> {
    await this.prisma.distributionSlipItem.delete({
      where: {
        distributionSlipId_parcelId: {
          distributionSlipId: slipId,
          parcelId,
        },
      },
    });
  }

  private async addToReturnSlip(
    parcelId: string,
    slipId: string,
    userId: string,
  ): Promise<void> {
    const existing = await this.prisma.returnSlipItem.findUnique({
      where: {
        returnSlipId_parcelId: {
          returnSlipId: slipId,
          parcelId,
        },
      },
    });

    if (existing) {
      throw new ConflictException('Parcel already in return slip');
    }

    await this.prisma.returnSlipItem.create({
      data: {
        returnSlipId: slipId,
        parcelId,
        scanned: true,
        scannedAt: new Date(),
        scannedBy: userId,
      },
    });
  }

  private async removeFromReturnSlip(
    parcelId: string,
    slipId: string,
  ): Promise<void> {
    await this.prisma.returnSlipItem.delete({
      where: {
        returnSlipId_parcelId: {
          returnSlipId: slipId,
          parcelId,
        },
      },
    });
  }

  private async updateParcelStatus(
    parcelId: string,
    newStatusCode: string,
    userId: string,
    comment?: string,
  ): Promise<void> {
    // Get the new status
    const newStatus = await this.prisma.parcelStatus.findFirst({
      where: {
        code: newStatusCode,
        isDeleted: false,
        status: true,
      },
    });

    if (!newStatus) {
      throw new BadRequestException(`Invalid status code: ${newStatusCode}`);
    }

    // Update parcel
    await this.prisma.parcel.update({
      where: { id: parcelId },
      data: {
        parcelStatusId: newStatus.id,
        parcelStatusCode: newStatus.code,
        updatedBy: userId,
      },
    });

    // Create history entry
    await this.prisma.parcelStatusHistory.create({
      data: {
        parcelId,
        parcelStatusId: newStatus.id,
        statusCode: newStatus.code,
        comment: comment || 'Status changed via scanner',
        changedBy: userId,
      },
    });
  }

  private async logScanOperation(
    code: string,
    action: ScannerAction,
    success: boolean,
    tenantId: string,
    userId: string,
    error?: string,
  ): Promise<void> {
    // You might want to create a separate ScanLog table for this
    // For now, just log to application logs
    this.logger.log(
      `Scan: ${code} | Action: ${action} | Success: ${success} | User: ${userId}${error ? ` | Error: ${error}` : ''}`,
    );
  }

  private generateSessionId(): string {
    return `scan_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;
  }
}
===============================================================================================================
===============================================================================================================
The Subject is :
- READ ALL THIS PROMPT I GIVE YOU.
- I Create A new parcels-service in my nest js project.
- So i want you help me and give me delivery-slips module in front with all pages and crud pages,
And all component and lib and store we will need to create this module in front.
_ Give me each file with page location.
===============================================================================================================
===============================================================================================================