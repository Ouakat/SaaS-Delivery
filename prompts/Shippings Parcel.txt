===============================================================================================================
My Next js front project structure:
===============================================================================================================
App Folder :
-----------------------------------------------------------------------
--++--> app/[locale]/(protected)/dashboard/page.tsx
--++--> app/[locale]/(protected)/profile/page.tsx
--++--> app/[locale]/(protected)/roles/page.tsx
-----------------------------------------------------------------------
--++--> app/[locale]/(protected)/delivery-slips/page.tsx =======>
-----------------------------------------------------------------------
"use client";
import React, { useEffect, useState, useCallback } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Icon } from "@/components/ui/icon";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Badge } from "@/components/ui/badge";
import { Input } from "@/components/ui/input";
import { Link } from "@/i18n/routing";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { DeliverySlipsTable } from "@/components/delivery-slips/delivery-slips-table";
import { DeliverySlipsStats } from "@/components/delivery-slips/delivery-slips-stats";
import { BulkActionsBar } from "@/components/delivery-slips/bulk-actions-bar";
import { useDeliverySlipsStore } from "@/lib/stores/parcels/delivery-slips.store";
import { useCitiesStore } from "@/lib/stores/parcels/cities.store";
import { useAuthStore } from "@/lib/stores/auth/auth.store";
import { ProtectedRoute } from "@/components/route/protected-route";
import { PARCELS_PERMISSIONS } from "@/lib/constants/parcels";
import { DeliverySlipStatus } from "@/lib/types/parcels/delivery-slips.types";
import { toast } from "sonner";
const DeliverySlipsPageContent = () => {
  const { hasPermission, user } = useAuthStore();
  const {
    deliverySlips,
    pagination,
    filters,
    statistics,
    selectedSlipIds,
    isLoading,
    error,
    setFilters,
    clearFilters,
    fetchDeliverySlips,
    fetchStatistics,
    clearSelectedSlipIds,
    exportDeliverySlips,
    resetState,
  } = useDeliverySlipsStore();

  const { cities, fetchCities } = useCitiesStore();

  const [showStats, setShowStats] = useState(false);
  const [searchTerm, setSearchTerm] = useState(filters.search || "");
  const [isExporting, setIsExporting] = useState(false);

  // Check permissions
  const canReadSlips = hasPermission(PARCELS_PERMISSIONS.DELIVERY_SLIPS_READ);
  const canCreateSlips = hasPermission(
    PARCELS_PERMISSIONS.DELIVERY_SLIPS_CREATE
  );
  const canUpdateSlips = hasPermission(
    PARCELS_PERMISSIONS.DELIVERY_SLIPS_UPDATE
  );
  const canDeleteSlips = hasPermission(
    PARCELS_PERMISSIONS.DELIVERY_SLIPS_DELETE
  );
  const canBulkActions = hasPermission(PARCELS_PERMISSIONS.DELIVERY_SLIPS_BULK);
  const canScanSlips = hasPermission(PARCELS_PERMISSIONS.DELIVERY_SLIPS_SCAN);

  // Initialize data
  useEffect(() => {
    if (canReadSlips) {
      fetchDeliverySlips();
      fetchCities();
      if (user?.userType !== "SELLER") {
        fetchStatistics();
      }
    }

    // Cleanup on unmount
    return () => {
      resetState();
    };
  }, [
    canReadSlips,
    fetchDeliverySlips,
    fetchCities,
    fetchStatistics,
    user?.userType,
    resetState,
  ]);

  // Handle search with debouncing
  const handleSearchChange = useCallback(
    (value: string) => {
      setSearchTerm(value);
      const timeoutId = setTimeout(() => {
        setFilters({ search: value, page: 1 });
      }, 500);
      return () => clearTimeout(timeoutId);
    },
    [setFilters]
  );

  // Handle status filter change
  const handleStatusFilter = (status: string) => {
    setFilters({
      status: status === "all" ? undefined : (status as DeliverySlipStatus),
      page: 1,
    });
  };

  // Handle city filter change
  const handleCityFilter = (cityId: string) => {
    setFilters({
      cityId: cityId === "all" ? undefined : cityId,
      page: 1,
    });
  };

  // Handle date range filters
  const handleDateRangeFilter = (range: string) => {
    const today = new Date();
    let startDate: string | undefined;
    let endDate: string | undefined;

    switch (range) {
      case "today":
        startDate = today.toISOString().split("T")[0];
        endDate = startDate;
        break;
      case "week":
        const weekAgo = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000);
        startDate = weekAgo.toISOString().split("T")[0];
        endDate = today.toISOString().split("T")[0];
        break;
      case "month":
        const monthAgo = new Date(today.getTime() - 30 * 24 * 60 * 60 * 1000);
        startDate = monthAgo.toISOString().split("T")[0];
        endDate = today.toISOString().split("T")[0];
        break;
      default:
        startDate = undefined;
        endDate = undefined;
    }

    setFilters({ startDate, endDate, page: 1 });
  };

  // Handle export
  const handleExport = async () => {
    setIsExporting(true);
    try {
      await exportDeliverySlips(filters);
      // Toast is already shown in the store
    } catch (error) {
      // Error toast is already shown in the store
    } finally {
      setIsExporting(false);
    }
  };

  // Handle pagination
  const handlePageChange = (page: number) => {
    setFilters({ page });
  };

  // Handle clear all filters
  const handleClearAllFilters = () => {
    setSearchTerm("");
    clearFilters();
  };

  if (!canReadSlips) {
    return (
      <div className="space-y-6">
        <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
          <div>
            <h1 className="text-2xl font-bold text-default-900">
              Delivery Slips
            </h1>
            <p className="text-default-600">
              Manage package collection documents
            </p>
          </div>
        </div>

        <Alert color="destructive">
          <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
          <AlertDescription>
            You don't have permission to access delivery slips. Please contact
            your administrator.
          </AlertDescription>
        </Alert>
      </div>
    );
  }

  const activeFiltersCount = Object.values({
    search: filters.search,
    status: filters.status,
    cityId: filters.cityId,
    startDate: filters.startDate,
    endDate: filters.endDate,
  }).filter(Boolean).length;

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
        <div>
          <h1 className="text-2xl font-bold text-default-900">
            Delivery Slips
          </h1>
          <p className="text-default-600">
            Manage package collection documents and track pickup operations
          </p>
          {pagination.total > 0 && (
            <div className="flex items-center gap-4 mt-2 text-sm text-default-500">
              <span>Total: {pagination.total} slips</span>
              {selectedSlipIds.length > 0 && (
                <span>Selected: {selectedSlipIds.length}</span>
              )}
            </div>
          )}
        </div>

        <div className="flex items-center gap-2">
          {statistics && user?.userType !== "SELLER" && (
            <Button
              variant="outline"
              size="md"
              onClick={() => setShowStats(!showStats)}
            >
              <Icon icon="heroicons:chart-bar" className="w-4 h-4 mr-2" />
              {showStats ? "Hide" : "Show"} Stats
            </Button>
          )}

          {canCreateSlips && (
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button>
                  <Icon icon="heroicons:plus" className="w-4 h-4 mr-2" />
                  Create
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end">
                <DropdownMenuItem asChild>
                  <Link href="/delivery-slips/create">
                    <Icon
                      icon="heroicons:document-plus"
                      className="mr-2 h-4 w-4"
                    />
                    New Delivery Slip
                  </Link>
                </DropdownMenuItem>
                {canScanSlips && (
                  <>
                    <DropdownMenuSeparator />
                    <DropdownMenuItem asChild>
                      <Link href="/delivery-slips/scan">
                        <Icon
                          icon="heroicons:qr-code"
                          className="mr-2 h-4 w-4"
                        />
                        Scanner Interface
                      </Link>
                    </DropdownMenuItem>
                  </>
                )}
                {canBulkActions && (
                  <DropdownMenuItem asChild>
                    <Link href="/delivery-slips/bulk-receive">
                      <Icon
                        icon="heroicons:check-circle"
                        className="mr-2 h-4 w-4"
                      />
                      Bulk Receive
                    </Link>
                  </DropdownMenuItem>
                )}
              </DropdownMenuContent>
            </DropdownMenu>
          )}
        </div>
      </div>

      {/* Statistics */}
      {showStats && statistics && (
        <DeliverySlipsStats statistics={statistics} />
      )}

      {/* Error Alert */}
      {error && (
        <Alert color="destructive">
          <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      {/* Filters and Actions */}
      <Card>
        <CardHeader>
          <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
            <CardTitle className="flex items-center gap-2">
              All Delivery Slips
              {activeFiltersCount > 0 && (
                <Badge color="secondary" className="ml-2">
                  {activeFiltersCount} filter
                  {activeFiltersCount !== 1 ? "s" : ""} active
                </Badge>
              )}
            </CardTitle>
            <div className="flex items-center gap-2">
              <Button
                variant="outline"
                size="md"
                onClick={handleExport}
                disabled={isExporting}
              >
                {isExporting ? (
                  <Icon
                    icon="heroicons:arrow-path"
                    className="w-4 h-4 mr-2 animate-spin"
                  />
                ) : (
                  <Icon
                    icon="heroicons:document-arrow-down"
                    className="w-4 h-4 mr-2"
                  />
                )}
                Export
              </Button>
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button variant="outline" size="md">
                    <Icon icon="heroicons:funnel" className="w-4 h-4 mr-2" />
                    Filters
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end">
                  <DropdownMenuItem
                    onClick={() => handleDateRangeFilter("today")}
                  >
                    <Icon icon="heroicons:calendar" className="mr-2 h-4 w-4" />
                    Today
                  </DropdownMenuItem>
                  <DropdownMenuItem
                    onClick={() => handleDateRangeFilter("week")}
                  >
                    <Icon icon="heroicons:calendar" className="mr-2 h-4 w-4" />
                    Last 7 days
                  </DropdownMenuItem>
                  <DropdownMenuItem
                    onClick={() => handleDateRangeFilter("month")}
                  >
                    <Icon icon="heroicons:calendar" className="mr-2 h-4 w-4" />
                    Last 30 days
                  </DropdownMenuItem>
                  <DropdownMenuSeparator />
                  <DropdownMenuItem onClick={handleClearAllFilters}>
                    <Icon icon="heroicons:x-mark" className="mr-2 h-4 w-4" />
                    Clear All Filters
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            </div>
          </div>
        </CardHeader>
        <CardContent className="space-y-4">
          {/* Search and Filter Controls */}
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
            {/* Search */}
            <div className="lg:col-span-2">
              <Input
                placeholder="Search by reference, customer name, or phone..."
                value={searchTerm}
                onChange={(e) => handleSearchChange(e.target.value)}
                className="w-full"
              />
            </div>

            {/* Status Filter */}
            <div>
              <Select
                value={filters.status || "all"}
                onValueChange={handleStatusFilter}
              >
                <SelectTrigger>
                  <SelectValue placeholder="All Status" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">All Status</SelectItem>
                  <SelectItem value={DeliverySlipStatus.PENDING}>
                    <div className="flex items-center gap-2">
                      <div className="w-2 h-2 rounded-full bg-yellow-500" />
                      Pending
                    </div>
                  </SelectItem>
                  <SelectItem value={DeliverySlipStatus.RECEIVED}>
                    <div className="flex items-center gap-2">
                      <div className="w-2 h-2 rounded-full bg-green-500" />
                      Received
                    </div>
                  </SelectItem>
                  <SelectItem value={DeliverySlipStatus.CANCELLED}>
                    <div className="flex items-center gap-2">
                      <div className="w-2 h-2 rounded-full bg-red-500" />
                      Cancelled
                    </div>
                  </SelectItem>
                </SelectContent>
              </Select>
            </div>

            {/* City Filter */}
            <div>
              <Select
                value={filters.cityId || "all"}
                onValueChange={handleCityFilter}
              >
                <SelectTrigger>
                  <SelectValue placeholder="All Cities" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">All Cities</SelectItem>
                  <SelectItem value="none">No City</SelectItem>
                  {cities
                    .filter((city) => city.pickupCity && city.status)
                    .map((city) => (
                      <SelectItem key={city.id} value={city.id}>
                        {city.name} ({city.ref})
                      </SelectItem>
                    ))}
                </SelectContent>
              </Select>
            </div>
          </div>

          {/* Active Filters */}
          {activeFiltersCount > 0 && (
            <div className="flex items-center gap-2 flex-wrap">
              <span className="text-sm text-muted-foreground">
                Active filters:
              </span>
              {filters.search && (
                <Badge color="secondary" className="gap-1">
                  Search: {filters.search}
                  <button
                    onClick={() => {
                      setSearchTerm("");
                      setFilters({ search: "", page: 1 });
                    }}
                    className="ml-1 hover:bg-gray-200 rounded-full p-0.5"
                  >
                    <Icon icon="heroicons:x-mark" className="w-3 h-3" />
                  </button>
                </Badge>
              )}
              {filters.status && (
                <Badge color="secondary" className="gap-1">
                  Status: {filters.status}
                  <button
                    onClick={() => setFilters({ status: undefined, page: 1 })}
                    className="ml-1 hover:bg-gray-200 rounded-full p-0.5"
                  >
                    <Icon icon="heroicons:x-mark" className="w-3 h-3" />
                  </button>
                </Badge>
              )}
              {filters.cityId && (
                <Badge color="secondary" className="gap-1">
                  City:{" "}
                  {cities.find((c) => c.id === filters.cityId)?.name ||
                    "Unknown"}
                  <button
                    onClick={() => setFilters({ cityId: undefined, page: 1 })}
                    className="ml-1 hover:bg-gray-200 rounded-full p-0.5"
                  >
                    <Icon icon="heroicons:x-mark" className="w-3 h-3" />
                  </button>
                </Badge>
              )}
              {(filters.startDate || filters.endDate) && (
                <Badge color="secondary" className="gap-1">
                  Date Range
                  <button
                    onClick={() =>
                      setFilters({
                        startDate: undefined,
                        endDate: undefined,
                        page: 1,
                      })
                    }
                    className="ml-1 hover:bg-gray-200 rounded-full p-0.5"
                  >
                    <Icon icon="heroicons:x-mark" className="w-3 h-3" />
                  </button>
                </Badge>
              )}
              <Button
                variant="ghost"
                size="sm"
                onClick={handleClearAllFilters}
                className="h-6 px-2 text-xs"
              >
                Clear all
              </Button>
            </div>
          )}

          {/* Bulk Actions */}
          {selectedSlipIds.length > 0 && canBulkActions && (
            <BulkActionsBar
              selectedCount={selectedSlipIds.length}
              onClearSelection={clearSelectedSlipIds}
            />
          )}
        </CardContent>
      </Card>

      {/* Delivery Slips Table */}
      <Card>
        <CardContent className="p-0">
          <DeliverySlipsTable
            deliverySlips={deliverySlips}
            pagination={pagination}
            isLoading={isLoading}
            onPageChange={handlePageChange}
            canUpdate={canUpdateSlips}
            canDelete={canDeleteSlips}
            canBulkActions={canBulkActions}
          />
        </CardContent>
      </Card>

      {/* Quick Actions Card */}
      {canCreateSlips && (
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Icon icon="heroicons:bolt" className="w-5 h-5" />
              Quick Actions
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
              <Link href="/delivery-slips/create">
                <Button variant="outline" className="w-full h-auto p-4">
                  <div className="flex flex-col items-center gap-2">
                    <Icon icon="heroicons:plus-circle" className="w-8 h-8" />
                    <span>Create New Slip</span>
                    <span className="text-xs text-muted-foreground">
                      Start new collection
                    </span>
                  </div>
                </Button>
              </Link>

              {canScanSlips && (
                <Link href="/delivery-slips/scan">
                  <Button variant="outline" className="w-full h-auto p-4">
                    <div className="flex flex-col items-center gap-2">
                      <Icon icon="heroicons:qr-code" className="w-8 h-8" />
                      <span>Scan Parcels</span>
                      <span className="text-xs text-muted-foreground">
                        Use barcode scanner
                      </span>
                    </div>
                  </Button>
                </Link>
              )}

              {canBulkActions && (
                <Link href="/delivery-slips/bulk-receive">
                  <Button variant="outline" className="w-full h-auto p-4">
                    <div className="flex flex-col items-center gap-2">
                      <Icon icon="heroicons:check-circle" className="w-8 h-8" />
                      <span>Bulk Receive</span>
                      <span className="text-xs text-muted-foreground">
                        Process multiple slips
                      </span>
                    </div>
                  </Button>
                </Link>
              )}

              <Button
                variant="outline"
                className="w-full h-auto p-4"
                onClick={handleExport}
                disabled={isExporting}
              >
                <div className="flex flex-col items-center gap-2">
                  <Icon
                    icon="heroicons:document-arrow-down"
                    className="w-8 h-8"
                  />
                  <span>Export Data</span>
                  <span className="text-xs text-muted-foreground">
                    Download as Excel
                  </span>
                </div>
              </Button>
            </div>
          </CardContent>
        </Card>
      )}

      {/* Empty State */}
      {!isLoading && deliverySlips.length === 0 && (
        <Card>
          <CardContent className="p-8 text-center">
            <div className="space-y-4">
              <Icon
                icon="heroicons:document-text"
                className="w-16 h-16 text-muted-foreground mx-auto"
              />
              <div>
                <h3 className="font-medium text-default-900">
                  No delivery slips found
                </h3>
                <p className="text-sm text-muted-foreground mt-1">
                  {activeFiltersCount > 0
                    ? "Try adjusting your filters or search terms"
                    : "Get started by creating your first delivery slip"}
                </p>
              </div>
              {canCreateSlips && activeFiltersCount === 0 && (
                <div className="flex flex-col sm:flex-row gap-2 justify-center">
                  <Link href="/delivery-slips/create">
                    <Button>
                      <Icon icon="heroicons:plus" className="w-4 h-4 mr-2" />
                      Create First Delivery Slip
                    </Button>
                  </Link>
                  {canScanSlips && (
                    <Link href="/delivery-slips/scan">
                      <Button variant="outline">
                        <Icon
                          icon="heroicons:qr-code"
                          className="w-4 h-4 mr-2"
                        />
                        Open Scanner
                      </Button>
                    </Link>
                  )}
                </div>
              )}
              {activeFiltersCount > 0 && (
                <Button variant="outline" onClick={handleClearAllFilters}>
                  <Icon icon="heroicons:x-mark" className="w-4 h-4 mr-2" />
                  Clear All Filters
                </Button>
              )}
            </div>
          </CardContent>
        </Card>
      )}
    </div>
  );
};
// Main component wrapped with ProtectedRoute
const DeliverySlipsPage = () => {
  return (
    <ProtectedRoute
      requiredPermissions={[PARCELS_PERMISSIONS.DELIVERY_SLIPS_READ]}
      requiredAccessLevel="LIMITED"
      allowedAccountStatuses={["ACTIVE"]}
    >
      <DeliverySlipsPageContent />
    </ProtectedRoute>
  );
};
export default DeliverySlipsPage;
-----------------------------------------------------------------------
--++--> app/[locale]/(protected)/delivery-slips/[id]/page.tsx =======>
-----------------------------------------------------------------------
"use client";
import React, { useState, useEffect } from "react";
import { useRouter, useParams } from "next/navigation";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Icon } from "@/components/ui/icon";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";
import { Alert, AlertDescription } from "@/components/ui/alert";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Link } from "@/i18n/routing";
import { ProtectedRoute } from "@/components/route/protected-route";
import { PARCELS_PERMISSIONS } from "@/lib/constants/parcels";
import { useDeliverySlipsStore } from "@/lib/stores/parcels/delivery-slips.store";
import { useAuthStore } from "@/lib/stores/auth/auth.store";
import { DeliverySlipStatus } from "@/lib/types/parcels/delivery-slips.types";
import { toast } from "sonner";
// Status configurations
const statusConfig = {
  [DeliverySlipStatus.PENDING]: {
    label: "Pending",
    color: "bg-yellow-100 text-yellow-800",
    icon: "heroicons:clock",
  },
  [DeliverySlipStatus.RECEIVED]: {
    label: "Received",
    color: "bg-green-100 text-green-800",
    icon: "heroicons:check-circle",
  },
  [DeliverySlipStatus.CANCELLED]: {
    label: "Cancelled",
    color: "bg-red-100 text-red-800",
    icon: "heroicons:x-circle",
  },
};
const formatDate = (dateString: string, format: "short" | "long" = "short") => {
  const date = new Date(dateString);
  if (format === "short") {
    return date.toLocaleDateString("en-US", {
      month: "short",
      day: "2-digit",
      year: "numeric",
    });
  }
  return date.toLocaleDateString("en-US", {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  });
};
const DeliverySlipDetailsPage = () => {
  const router = useRouter();
  const params = useParams();
  const slipId = params?.id as string;
  const { hasPermission, user } = useAuthStore();

  const {
    currentDeliverySlip,
    fetchDeliverySlipById,
    updateDeliverySlip,
    deleteDeliverySlip,
    receiveSlip,
    downloadSlipPdf,
    downloadSlipLabels,
    getSlipBarcode,
    isLoading,
    isUpdating,
    isDeleting,
    error,
  } = useDeliverySlipsStore();

  const [deleteDialog, setDeleteDialog] = useState(false);
  const [receiveDialog, setReceiveDialog] = useState(false);
  const [barcodeData, setBarcodeData] = useState<any>(null);
  const [showBarcode, setShowBarcode] = useState(false);

  const canUpdate = hasPermission(PARCELS_PERMISSIONS.DELIVERY_SLIPS_UPDATE);
  const canDelete = hasPermission(PARCELS_PERMISSIONS.DELIVERY_SLIPS_DELETE);
  const canReceive = hasPermission(PARCELS_PERMISSIONS.DELIVERY_SLIPS_RECEIVE);

  // Fetch slip data
  useEffect(() => {
    if (slipId) {
      fetchDeliverySlipById(slipId);
    }
  }, [slipId, fetchDeliverySlipById]);

  // Handle slip actions
  const handleReceiveSlip = async () => {
    if (!currentDeliverySlip) return;

    const success = await receiveSlip(currentDeliverySlip.id, {
      notes: "Slip received via details page",
    });

    if (success) {
      setReceiveDialog(false);
      toast.success("Delivery slip marked as received");
    }
  };

  const handleDeleteSlip = async () => {
    if (!currentDeliverySlip) return;

    const success = await deleteDeliverySlip(currentDeliverySlip.id);

    if (success) {
      setDeleteDialog(false);
      toast.success("Delivery slip deleted successfully");
      router.push("/delivery-slips");
    }
  };

  const handleDownloadPdf = async () => {
    if (!currentDeliverySlip) return;
    await downloadSlipPdf(currentDeliverySlip.id);
  };

  const handleDownloadLabels = async () => {
    if (!currentDeliverySlip) return;
    await downloadSlipLabels(currentDeliverySlip.id);
  };

  const handleShowBarcode = async () => {
    if (!currentDeliverySlip) return;

    if (!barcodeData) {
      const data = await getSlipBarcode(currentDeliverySlip.id);
      setBarcodeData(data);
    }
    setShowBarcode(true);
  };

  if (isLoading) {
    return (
      <ProtectedRoute
        requiredPermissions={[PARCELS_PERMISSIONS.DELIVERY_SLIPS_READ]}
        requiredAccessLevel="LIMITED"
      >
        <div className="container mx-auto py-6">
          <Card>
            <CardContent className="p-8">
              <div className="flex items-center justify-center space-x-2">
                <Icon
                  icon="heroicons:arrow-path"
                  className="w-5 h-5 animate-spin"
                />
                <span>Loading delivery slip details...</span>
              </div>
            </CardContent>
          </Card>
        </div>
      </ProtectedRoute>
    );
  }

  if (!currentDeliverySlip || error) {
    return (
      <ProtectedRoute
        requiredPermissions={[PARCELS_PERMISSIONS.DELIVERY_SLIPS_READ]}
        requiredAccessLevel="LIMITED"
      >
        <div className="container mx-auto py-8">
          <Alert color="destructive">
            <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
            <AlertDescription>
              {error || "Delivery slip not found or has been deleted."}
            </AlertDescription>
          </Alert>
        </div>
      </ProtectedRoute>
    );
  }

  const statusInfo = statusConfig[currentDeliverySlip.status];
  const canModify = currentDeliverySlip.status === DeliverySlipStatus.PENDING;

  return (
    <ProtectedRoute
      requiredPermissions={[PARCELS_PERMISSIONS.DELIVERY_SLIPS_READ]}
      requiredAccessLevel="LIMITED"
    >
      <div className="container mx-auto py-6 space-y-6">
        {/* Header */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-4">
            <div>
              <div className="flex items-center gap-2">
                <h1 className="text-3xl font-bold text-default-900">
                  {currentDeliverySlip.reference}
                </h1>
                <Badge className={statusInfo.color}>
                  <Icon icon={statusInfo.icon} className="w-3 h-3 mr-1" />
                  {statusInfo.label}
                </Badge>
              </div>
              <p className="text-lg text-default-600">Delivery Slip Details</p>
              <div className="flex items-center gap-4 mt-2 text-sm text-default-500">
                <span>
                  Created: {formatDate(currentDeliverySlip.createdAt)}
                </span>
                {currentDeliverySlip.receivedAt && (
                  <span>
                    Received: {formatDate(currentDeliverySlip.receivedAt)}
                  </span>
                )}
              </div>
            </div>
          </div>

          <div className="flex items-center gap-2">
            {/* Actions Dropdown */}
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button disabled={isUpdating || isDeleting}>
                  <Icon
                    icon="heroicons:ellipsis-horizontal"
                    className="w-4 h-4 mr-2"
                  />
                  Actions
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end">
                {canUpdate && canModify && (
                  <DropdownMenuItem asChild>
                    <Link
                      href={`/delivery-slips/${currentDeliverySlip.id}/edit`}
                    >
                      <Icon
                        icon="heroicons:pencil-square"
                        className="mr-2 h-4 w-4"
                      />
                      Edit Slip
                    </Link>
                  </DropdownMenuItem>
                )}

                {canReceive && canModify && (
                  <>
                    <DropdownMenuSeparator />
                    <DropdownMenuItem onClick={() => setReceiveDialog(true)}>
                      <Icon
                        icon="heroicons:check"
                        className="mr-2 h-4 w-4 text-green-600"
                      />
                      Mark as Received
                    </DropdownMenuItem>
                  </>
                )}

                <DropdownMenuSeparator />
                <DropdownMenuItem onClick={handleDownloadPdf}>
                  <Icon
                    icon="heroicons:document-arrow-down"
                    className="mr-2 h-4 w-4"
                  />
                  Download PDF
                </DropdownMenuItem>

                <DropdownMenuItem onClick={handleDownloadLabels}>
                  <Icon icon="heroicons:tag" className="mr-2 h-4 w-4" />
                  Download Labels
                </DropdownMenuItem>

                <DropdownMenuItem onClick={handleShowBarcode}>
                  <Icon icon="heroicons:qr-code" className="mr-2 h-4 w-4" />
                  Show Barcode
                </DropdownMenuItem>

                {canDelete && canModify && (
                  <>
                    <DropdownMenuSeparator />
                    <DropdownMenuItem
                      className="text-red-600 focus:text-red-600"
                      onClick={() => setDeleteDialog(true)}
                    >
                      <Icon icon="heroicons:trash" className="mr-2 h-4 w-4" />
                      Delete Slip
                    </DropdownMenuItem>
                  </>
                )}
              </DropdownMenuContent>
            </DropdownMenu>

            <Link href="/delivery-slips">
              <Button variant="outline">
                <Icon icon="heroicons:arrow-left" className="w-4 h-4 mr-2" />
                Back to Delivery Slips
              </Button>
            </Link>
          </div>
        </div>

        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          {/* Main Content */}
          <div className="lg:col-span-2 space-y-6">
            {/* Slip Information */}
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:document-text" className="w-5 h-5" />
                  Slip Information
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <h4 className="font-medium text-default-900">Reference</h4>
                    <p className="text-default-600 font-mono">
                      {currentDeliverySlip.reference}
                    </p>
                  </div>
                  <div>
                    <h4 className="font-medium text-default-900">Status</h4>
                    <Badge className={statusInfo.color}>
                      <Icon icon={statusInfo.icon} className="w-3 h-3 mr-1" />
                      {statusInfo.label}
                    </Badge>
                  </div>
                  <div>
                    <h4 className="font-medium text-default-900">
                      Collection City
                    </h4>
                    <p className="text-default-600">
                      {currentDeliverySlip.city?.name || "Not specified"}
                    </p>
                  </div>
                  <div>
                    <h4 className="font-medium text-default-900">
                      Total Parcels
                    </h4>
                    <p className="text-default-600">
                      {currentDeliverySlip.summary.totalParcels}
                    </p>
                  </div>
                  <div>
                    <h4 className="font-medium text-default-900">
                      Scanned Parcels
                    </h4>
                    <p className="text-default-600">
                      {currentDeliverySlip.summary.scannedParcels} /{" "}
                      {currentDeliverySlip.summary.totalParcels}
                    </p>
                  </div>
                  <div>
                    <h4 className="font-medium text-default-900">
                      Total Value
                    </h4>
                    <p className="text-default-600">
                      {currentDeliverySlip.summary.totalValue.toFixed(2)} DH
                    </p>
                  </div>
                </div>

                {currentDeliverySlip.notes && (
                  <div>
                    <h4 className="font-medium text-default-900">Notes</h4>
                    <p className="text-default-600">
                      {currentDeliverySlip.notes}
                    </p>
                  </div>
                )}
              </CardContent>
            </Card>

            {/* Parcels List */}
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:cube" className="w-5 h-5" />
                  Parcels ({currentDeliverySlip.items.length})
                </CardTitle>
              </CardHeader>
              <CardContent className="p-0">
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead>Parcel Code</TableHead>
                      <TableHead>Recipient</TableHead>
                      <TableHead>Destination</TableHead>
                      <TableHead>Price</TableHead>
                      <TableHead>Status</TableHead>
                      <TableHead>Scanned</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {currentDeliverySlip.items.map((item) => (
                      <TableRow key={item.parcelId}>
                        <TableCell>
                          <code className="text-sm font-medium">
                            {item.parcel.code}
                          </code>
                        </TableCell>
                        <TableCell>
                          <div>
                            <div className="font-medium">
                              {item.parcel.recipientName}
                            </div>
                            <div className="text-sm text-muted-foreground">
                              {item.parcel.recipientPhone}
                            </div>
                          </div>
                        </TableCell>
                        <TableCell>{item.parcel.destinationCity}</TableCell>
                        <TableCell>
                          <Badge color="primary">
                            {item.parcel.price.toFixed(2)} DH
                          </Badge>
                        </TableCell>
                        <TableCell>
                          <Badge color="secondary">
                            {item.parcel.statusName}
                          </Badge>
                        </TableCell>
                        <TableCell>
                          {item.scanned ? (
                            <div className="flex items-center gap-1 text-green-600">
                              <Icon
                                icon="heroicons:check-circle"
                                className="w-4 h-4"
                              />
                              <span className="text-sm">
                                {item.scannedAt
                                  ? formatDate(item.scannedAt.toString())
                                  : "Scanned"}
                              </span>
                            </div>
                          ) : (
                            <div className="flex items-center gap-1 text-yellow-600">
                              <Icon
                                icon="heroicons:clock"
                                className="w-4 h-4"
                              />
                              <span className="text-sm">Pending</span>
                            </div>
                          )}
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </CardContent>
            </Card>
          </div>

          {/* Sidebar */}
          <div className="space-y-6">
            {/* Summary */}
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon
                    icon="heroicons:clipboard-document-list"
                    className="w-5 h-5"
                  />
                  Summary
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="space-y-3">
                  <div className="flex justify-between">
                    <span className="text-sm text-muted-foreground">
                      Total Parcels:
                    </span>
                    <span className="font-medium">
                      {currentDeliverySlip.summary.totalParcels}
                    </span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-sm text-muted-foreground">
                      Scanned:
                    </span>
                    <span className="font-medium text-green-600">
                      {currentDeliverySlip.summary.scannedParcels}
                    </span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-sm text-muted-foreground">
                      Pending:
                    </span>
                    <span className="font-medium text-yellow-600">
                      {currentDeliverySlip.summary.unscannedParcels}
                    </span>
                  </div>
                  <div className="flex justify-between border-t pt-3">
                    <span className="text-sm text-muted-foreground">
                      Total Value:
                    </span>
                    <span className="font-medium">
                      {currentDeliverySlip.summary.totalValue.toFixed(2)} DH
                    </span>
                  </div>
                </div>

                {/* Progress Bar */}
                <div className="space-y-2">
                  <div className="flex justify-between text-sm">
                    <span>Scan Progress</span>
                    <span>
                      {Math.round(
                        (currentDeliverySlip.summary.scannedParcels /
                          currentDeliverySlip.summary.totalParcels) *
                          100
                      )}
                      %
                    </span>
                  </div>
                  <div className="w-full bg-gray-200 rounded-full h-2">
                    <div
                      className="bg-primary h-2 rounded-full"
                      style={{
                        width: `${
                          (currentDeliverySlip.summary.scannedParcels /
                            currentDeliverySlip.summary.totalParcels) *
                          100
                        }%`,
                      }}
                    />
                  </div>
                </div>
              </CardContent>
            </Card>

            {/* Timeline */}
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:clock" className="w-5 h-5" />
                  Timeline
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="space-y-4">
                  <div className="flex items-start gap-3">
                    <div className="w-2 h-2 bg-blue-500 rounded-full mt-2" />
                    <div>
                      <p className="text-sm font-medium">Created</p>
                      <p className="text-xs text-muted-foreground">
                        {formatDate(currentDeliverySlip.createdAt, "long")}
                      </p>
                      {currentDeliverySlip.createdBy && (
                        <p className="text-xs text-muted-foreground">
                          by {currentDeliverySlip.createdBy}
                        </p>
                      )}
                    </div>
                  </div>

                  {currentDeliverySlip.receivedAt && (
                    <div className="flex items-start gap-3">
                      <div className="w-2 h-2 bg-green-500 rounded-full mt-2" />
                      <div>
                        <p className="text-sm font-medium">Received</p>
                        <p className="text-xs text-muted-foreground">
                          {formatDate(currentDeliverySlip.receivedAt, "long")}
                        </p>
                        {currentDeliverySlip.receivedBy && (
                          <p className="text-xs text-muted-foreground">
                            by {currentDeliverySlip.receivedBy}
                          </p>
                        )}
                      </div>
                    </div>
                  )}
                </div>
              </CardContent>
            </Card>

            {/* Quick Actions */}
            {canModify && (
              <Card>
                <CardHeader>
                  <CardTitle className="flex items-center gap-2">
                    <Icon icon="heroicons:bolt" className="w-5 h-5" />
                    Quick Actions
                  </CardTitle>
                </CardHeader>
                <CardContent className="space-y-2">
                  {canReceive && (
                    <Button
                      className="w-full"
                      onClick={() => setReceiveDialog(true)}
                      disabled={isUpdating}
                    >
                      <Icon icon="heroicons:check" className="w-4 h-4 mr-2" />
                      Mark as Received
                    </Button>
                  )}

                  {canUpdate && (
                    <Link
                      href={`/delivery-slips/${currentDeliverySlip.id}/edit`}
                    >
                      <Button variant="outline" className="w-full">
                        <Icon
                          icon="heroicons:pencil"
                          className="w-4 h-4 mr-2"
                        />
                        Edit Slip
                      </Button>
                    </Link>
                  )}

                  <Link href={`/delivery-slips/${currentDeliverySlip.id}/scan`}>
                    <Button variant="outline" className="w-full">
                      <Icon icon="heroicons:qr-code" className="w-4 h-4 mr-2" />
                      Scan Parcels
                    </Button>
                  </Link>
                </CardContent>
              </Card>
            )}
          </div>
        </div>

        {/* Receive Confirmation Dialog */}
        <AlertDialog open={receiveDialog} onOpenChange={setReceiveDialog}>
          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>Mark as Received</AlertDialogTitle>
              <AlertDialogDescription>
                Are you sure you want to mark this delivery slip as received?
                This will update the status of all parcels in the slip.
                {currentDeliverySlip.summary.unscannedParcels > 0 && (
                  <div className="mt-2 p-2 bg-yellow-50 border border-yellow-200 rounded">
                    <p className="text-sm text-yellow-800">
                      Note: {currentDeliverySlip.summary.unscannedParcels}{" "}
                      parcels have not been scanned yet.
                    </p>
                  </div>
                )}
              </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
              <AlertDialogCancel>Cancel</AlertDialogCancel>
              <AlertDialogAction
                onClick={handleReceiveSlip}
                disabled={isUpdating}
              >
                {isUpdating && (
                  <Icon
                    icon="heroicons:arrow-path"
                    className="mr-2 h-4 w-4 animate-spin"
                  />
                )}
                Mark as Received
              </AlertDialogAction>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>

        {/* Delete Confirmation Dialog */}
        <AlertDialog open={deleteDialog} onOpenChange={setDeleteDialog}>
          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>Delete Delivery Slip</AlertDialogTitle>
              <AlertDialogDescription>
                Are you sure you want to delete this delivery slip? This action
                cannot be undone and will reset all parcels back to
                "NEW_PACKAGE" status.
              </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
              <AlertDialogCancel>Cancel</AlertDialogCancel>
              <AlertDialogAction
                onClick={handleDeleteSlip}
                disabled={isDeleting}
                className="bg-red-600 text-white hover:bg-red-700"
              >
                {isDeleting && (
                  <Icon
                    icon="heroicons:arrow-path"
                    className="mr-2 h-4 w-4 animate-spin"
                  />
                )}
                Delete Slip
              </AlertDialogAction>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>

        {/* Barcode Dialog */}
        <AlertDialog open={showBarcode} onOpenChange={setShowBarcode}>
          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>Delivery Slip Barcode</AlertDialogTitle>
              <AlertDialogDescription>
                Scan this barcode to quickly access this delivery slip
              </AlertDialogDescription>
            </AlertDialogHeader>
            <div className="flex flex-col items-center space-y-4 py-4">
              {barcodeData && (
                <>
                  <div className="text-center">
                    <p className="font-mono text-lg">{barcodeData.reference}</p>
                  </div>
                  <div className="bg-white p-4 rounded border">
                    {/* Here you would render the actual barcode/QR code */}
                    <div className="w-48 h-48 bg-gray-100 flex items-center justify-center">
                      <Icon
                        icon="heroicons:qr-code"
                        className="w-24 h-24 text-gray-400"
                      />
                    </div>
                  </div>
                </>
              )}
            </div>
            <AlertDialogFooter>
              <AlertDialogCancel>Close</AlertDialogCancel>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>
      </div>
    </ProtectedRoute>
  );
};
export default DeliverySlipDetailsPage;
-----------------------------------------------------------------------
--++--> app/[locale]/(protected)/delivery-slips/[id]/edit/page.tsx =======>
-----------------------------------------------------------------------
"use client";
import React, { useState, useEffect } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { useRouter, useParams } from "next/navigation";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Badge } from "@/components/ui/badge";
import { Icon } from "@/components/ui/icon";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Checkbox } from "@/components/ui/checkbox";
import { Link } from "@/i18n/routing";
import { useDeliverySlipsStore } from "@/lib/stores/parcels/delivery-slips.store";
import { useCitiesStore } from "@/lib/stores/parcels/cities.store";
import { useAuthStore } from "@/lib/stores/auth/auth.store";
import { ProtectedRoute } from "@/components/route/protected-route";
import { PARCELS_PERMISSIONS } from "@/lib/constants/parcels";
import { DeliverySlipStatus } from "@/lib/types/parcels/delivery-slips.types";
import { toast } from "sonner";
import { cn } from "@/lib/utils/ui.utils";
// Form schema for editing delivery slip
const editDeliverySlipSchema = z.object({
  cityId: z.string().optional(),
  notes: z.string().max(500).optional(),
  status: z.nativeEnum(DeliverySlipStatus).optional(),
});
type EditDeliverySlipFormData = z.infer<typeof editDeliverySlipSchema>;
const EditDeliverySlipPageContent = () => {
  const router = useRouter();
  const params = useParams();
  const slipId = params?.id as string;

  const { hasPermission, user } = useAuthStore();
  const {
    currentDeliverySlip,
    fetchDeliverySlipById,
    updateDeliverySlip,
    addParcelsToSlip,
    removeParcelsFromSlip,
    fetchAvailableParcels,
    availableParcels,
    isUpdating,
    isLoading,
    error,
  } = useDeliverySlipsStore();
  const { cities, fetchCities } = useCitiesStore();

  const [selectedNewParcels, setSelectedNewParcels] = useState<string[]>([]);
  const [parcelsToRemove, setParcelsToRemove] = useState<string[]>([]);
  const [searchTerm, setSearchTerm] = useState("");

  // Check permissions
  const canUpdateSlips = hasPermission(
    PARCELS_PERMISSIONS.DELIVERY_SLIPS_UPDATE
  );

  const {
    register,
    handleSubmit,
    watch,
    setValue,
    formState: { errors, isDirty },
    reset,
  } = useForm<EditDeliverySlipFormData>({
    resolver: zodResolver(editDeliverySlipSchema),
  });

  const watchedStatus = watch("status");

  // Initialize data
  useEffect(() => {
    if (canUpdateSlips && slipId) {
      fetchDeliverySlipById(slipId);
      fetchCities();
      fetchAvailableParcels();
    }
  }, [
    canUpdateSlips,
    slipId,
    fetchDeliverySlipById,
    fetchCities,
    fetchAvailableParcels,
  ]);

  // Populate form when delivery slip is loaded
  useEffect(() => {
    if (currentDeliverySlip) {
      reset({
        cityId: currentDeliverySlip.cityId || undefined,
        notes: currentDeliverySlip.notes || "",
        status: currentDeliverySlip.status,
      });
    }
  }, [currentDeliverySlip, reset]);

  const canModify = currentDeliverySlip?.status === DeliverySlipStatus.PENDING;

  const handleParcelSelection = (parcelId: string, checked: boolean) => {
    if (checked) {
      setSelectedNewParcels((prev) => [...prev, parcelId]);
    } else {
      setSelectedNewParcels((prev) => prev.filter((id) => id !== parcelId));
    }
  };

  const handleRemoveParcel = (parcelId: string, checked: boolean) => {
    if (checked) {
      setParcelsToRemove((prev) => [...prev, parcelId]);
    } else {
      setParcelsToRemove((prev) => prev.filter((id) => id !== parcelId));
    }
  };

  const handleAddParcels = async () => {
    if (!currentDeliverySlip || selectedNewParcels.length === 0) return;

    const success = await addParcelsToSlip(currentDeliverySlip.id, {
      parcelIds: selectedNewParcels,
      markAsScanned: true,
      comment: "Added via edit page",
    });

    if (success) {
      setSelectedNewParcels([]);
      fetchAvailableParcels();
      toast.success("Parcels added successfully");
    }
  };

  const handleRemoveParcels = async () => {
    if (!currentDeliverySlip || parcelsToRemove.length === 0) return;

    const success = await removeParcelsFromSlip(currentDeliverySlip.id, {
      parcelIds: parcelsToRemove,
      reason: "Removed via edit page",
    });

    if (success) {
      setParcelsToRemove([]);
      toast.success("Parcels removed successfully");
    }
  };

  // Filter available parcels
  const filteredAvailableParcels = availableParcels.filter(
    (parcel) =>
      parcel.code.toLowerCase().includes(searchTerm.toLowerCase()) ||
      parcel.recipientName.toLowerCase().includes(searchTerm.toLowerCase()) ||
      parcel.recipientPhone.includes(searchTerm)
  );

  const onSubmit = async (data: EditDeliverySlipFormData) => {
    if (!currentDeliverySlip) return;

    const updatedSlip = await updateDeliverySlip(currentDeliverySlip.id, data);

    if (updatedSlip) {
      toast.success("Delivery slip updated successfully");
      router.push(`/delivery-slips/${currentDeliverySlip.id}`);
    }
  };

  if (!canUpdateSlips) {
    return (
      <div className="container mx-auto py-8">
        <Alert color="destructive">
          <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
          <AlertDescription>
            You don't have permission to edit delivery slips. Please contact
            your administrator.
          </AlertDescription>
        </Alert>
      </div>
    );
  }

  if (isLoading) {
    return (
      <div className="container mx-auto py-6">
        <Card>
          <CardContent className="p-8">
            <div className="flex items-center justify-center space-x-2">
              <Icon
                icon="heroicons:arrow-path"
                className="w-5 h-5 animate-spin"
              />
              <span>Loading delivery slip...</span>
            </div>
          </CardContent>
        </Card>
      </div>
    );
  }

  if (!currentDeliverySlip || error) {
    return (
      <div className="container mx-auto py-8">
        <Alert color="destructive">
          <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
          <AlertDescription>
            {error || "Delivery slip not found or has been deleted."}
          </AlertDescription>
        </Alert>
      </div>
    );
  }

  return (
    <div className="container mx-auto py-6 space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-default-900">
            Edit Delivery Slip
          </h1>
          <p className="text-default-600">
            {currentDeliverySlip.reference} • {currentDeliverySlip.status}
          </p>
        </div>
        <div className="flex items-center gap-2">
          <Link href={`/delivery-slips/${currentDeliverySlip.id}`}>
            <Button variant="outline">
              <Icon icon="heroicons:eye" className="w-4 h-4 mr-2" />
              View Details
            </Button>
          </Link>
          <Link href="/delivery-slips">
            <Button variant="outline">
              <Icon icon="heroicons:arrow-left" className="w-4 h-4 mr-2" />
              Back to List
            </Button>
          </Link>
        </div>
      </div>

      {/* Status Warning */}
      {!canModify && (
        <Alert color="warning">
          <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
          <AlertDescription>
            This delivery slip has status "{currentDeliverySlip.status}" and
            cannot be modified. Only pending slips can be edited.
          </AlertDescription>
        </Alert>
      )}

      {/* Error Alert */}
      {error && (
        <Alert color="destructive">
          <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Main Form */}
        <div className="lg:col-span-2 space-y-6">
          {/* Basic Information */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon icon="heroicons:document-text" className="w-5 h-5" />
                Basic Information
              </CardTitle>
            </CardHeader>
            <CardContent>
              <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
                {/* City Selection */}
                <div className="space-y-2">
                  <Label htmlFor="cityId">Collection City</Label>
                  <Select
                    value={watch("cityId") || ""}
                    onValueChange={(value) =>
                      setValue("cityId", value || undefined)
                    }
                    disabled={!canModify}
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="Select collection city" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="none">No specific city</SelectItem>
                      {cities
                        .filter((city) => city.pickupCity && city.status)
                        .map((city) => (
                          <SelectItem key={city.id} value={city.id}>
                            {city.name} ({city.ref})
                          </SelectItem>
                        ))}
                    </SelectContent>
                  </Select>
                </div>

                {/* Status Selection (Admin only) */}
                {user?.userType !== "SELLER" && (
                  <div className="space-y-2">
                    <Label htmlFor="status">Status</Label>
                    <Select
                      value={watchedStatus}
                      onValueChange={(value) =>
                        setValue("status", value as DeliverySlipStatus)
                      }
                      disabled={!canModify}
                    >
                      <SelectTrigger>
                        <SelectValue placeholder="Select status" />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value={DeliverySlipStatus.PENDING}>
                          Pending
                        </SelectItem>
                        <SelectItem value={DeliverySlipStatus.RECEIVED}>
                          Received
                        </SelectItem>
                        <SelectItem value={DeliverySlipStatus.CANCELLED}>
                          Cancelled
                        </SelectItem>
                      </SelectContent>
                    </Select>
                  </div>
                )}

                {/* Notes */}
                <div className="space-y-2">
                  <Label htmlFor="notes">Notes</Label>
                  <Textarea
                    id="notes"
                    {...register("notes")}
                    placeholder="Add any special instructions or notes..."
                    rows={3}
                    disabled={!canModify}
                  />
                  {errors.notes && (
                    <p className="text-xs text-destructive">
                      {errors.notes.message}
                    </p>
                  )}
                </div>

                {/* Submit Button */}
                <div className="flex gap-2">
                  <Button
                    type="submit"
                    disabled={isUpdating || !isDirty || !canModify}
                  >
                    {isUpdating && (
                      <Icon
                        icon="heroicons:arrow-path"
                        className="mr-2 h-4 w-4 animate-spin"
                      />
                    )}
                    Update Slip
                  </Button>
                  <Button
                    type="button"
                    variant="outline"
                    onClick={() => reset()}
                    disabled={isUpdating || !isDirty}
                  >
                    Reset Changes
                  </Button>
                </div>
              </form>
            </CardContent>
          </Card>

          {/* Current Parcels */}
          <Card>
            <CardHeader>
              <div className="flex items-center justify-between">
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:cube" className="w-5 h-5" />
                  Current Parcels ({currentDeliverySlip.items.length})
                </CardTitle>
                {canModify && parcelsToRemove.length > 0 && (
                  <Button
                    size="sm"
                    color="destructive"
                    onClick={handleRemoveParcels}
                    disabled={isUpdating}
                  >
                    Remove Selected ({parcelsToRemove.length})
                  </Button>
                )}
              </div>
            </CardHeader>
            <CardContent className="space-y-2">
              {currentDeliverySlip.items.map((item) => (
                <div
                  key={item.parcelId}
                  className={cn(
                    "flex items-center space-x-3 p-3 border rounded-lg",
                    parcelsToRemove.includes(item.parcelId)
                      ? "bg-red-50 border-red-200"
                      : "hover:bg-muted/50"
                  )}
                >
                  {canModify && (
                    <Checkbox
                      checked={parcelsToRemove.includes(item.parcelId)}
                      onCheckedChange={(checked) =>
                        handleRemoveParcel(item.parcelId, checked as boolean)
                      }
                    />
                  )}
                  <div className="flex-1 min-w-0">
                    <div className="flex items-center gap-2">
                      <code className="text-sm font-medium">
                        {item.parcel.code}
                      </code>
                      <Badge color="primary" className="text-xs">
                        {item.parcel.price.toFixed(2)} DH
                      </Badge>
                      {item.scanned && (
                        <Badge color="secondary" className="text-xs">
                          Scanned
                        </Badge>
                      )}
                    </div>
                    <div className="text-sm text-muted-foreground">
                      {item.parcel.recipientName} • {item.parcel.recipientPhone}
                    </div>
                    <div className="text-xs text-muted-foreground">
                      To: {item.parcel.destinationCity}
                    </div>
                  </div>
                </div>
              ))}
            </CardContent>
          </Card>

          {/* Add New Parcels */}
          {canModify && (
            <Card>
              <CardHeader>
                <div className="flex items-center justify-between">
                  <CardTitle className="flex items-center gap-2">
                    <Icon icon="heroicons:plus-circle" className="w-5 h-5" />
                    Add Parcels
                  </CardTitle>
                  {selectedNewParcels.length > 0 && (
                    <Button
                      size="sm"
                      onClick={handleAddParcels}
                      disabled={isUpdating}
                    >
                      Add Selected ({selectedNewParcels.length})
                    </Button>
                  )}
                </div>
              </CardHeader>
              <CardContent className="space-y-4">
                {/* Search */}
                <Input
                  placeholder="Search available parcels..."
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                />

                {/* Available Parcels */}
                <div className="space-y-2 max-h-64 overflow-y-auto">
                  {filteredAvailableParcels.length === 0 ? (
                    <div className="text-center py-8">
                      <Icon
                        icon="heroicons:inbox"
                        className="w-12 h-12 text-muted-foreground mx-auto mb-4"
                      />
                      <p className="text-muted-foreground">
                        No available parcels found
                      </p>
                    </div>
                  ) : (
                    filteredAvailableParcels.map((parcel) => (
                      <div
                        key={parcel.id}
                        className={cn(
                          "flex items-center space-x-3 p-3 border rounded-lg",
                          selectedNewParcels.includes(parcel.id)
                            ? "bg-primary/5 border-primary"
                            : "hover:bg-muted/50"
                        )}
                      >
                        <Checkbox
                          checked={selectedNewParcels.includes(parcel.id)}
                          onCheckedChange={(checked) =>
                            handleParcelSelection(parcel.id, checked as boolean)
                          }
                        />
                        <div className="flex-1 min-w-0">
                          <div className="flex items-center gap-2">
                            <code className="text-sm font-medium">
                              {parcel.code}
                            </code>
                            <Badge color="primary" className="text-xs">
                              {Number(parcel.price).toFixed(2)} DH
                            </Badge>
                          </div>
                          <div className="text-sm text-muted-foreground">
                            {parcel.recipientName} • {parcel.recipientPhone}
                          </div>
                          <div className="text-xs text-muted-foreground">
                            {parcel.pickupCity.name} →{" "}
                            {parcel.destinationCity.name}
                          </div>
                        </div>
                      </div>
                    ))
                  )}
                </div>
              </CardContent>
            </Card>
          )}
        </div>

        {/* Sidebar */}
        <div className="space-y-6">
          {/* Current Summary */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon
                  icon="heroicons:clipboard-document-list"
                  className="w-5 h-5"
                />
                Current Summary
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="space-y-2">
                <div className="flex justify-between text-sm">
                  <span>Total parcels:</span>
                  <span className="font-medium">
                    {currentDeliverySlip.summary.totalParcels}
                  </span>
                </div>
                <div className="flex justify-between text-sm">
                  <span>Scanned parcels:</span>
                  <span className="font-medium">
                    {currentDeliverySlip.summary.scannedParcels}
                  </span>
                </div>
                <div className="flex justify-between text-sm">
                  <span>Total value:</span>
                  <span className="font-medium">
                    {currentDeliverySlip.summary.totalValue.toFixed(2)} DH
                  </span>
                </div>
                <div className="flex justify-between text-sm">
                  <span>Status:</span>
                  <Badge color="primary">{currentDeliverySlip.status}</Badge>
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Quick Actions */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon icon="heroicons:bolt" className="w-5 h-5" />
                Quick Actions
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-2">
              <Link href={`/delivery-slips/${currentDeliverySlip.id}/scan`}>
                <Button variant="outline" className="w-full">
                  <Icon icon="heroicons:qr-code" className="w-4 h-4 mr-2" />
                  Scan Parcels
                </Button>
              </Link>

              <Link href={`/delivery-slips/${currentDeliverySlip.id}`}>
                <Button variant="outline" className="w-full">
                  <Icon icon="heroicons:eye" className="w-4 h-4 mr-2" />
                  View Details
                </Button>
              </Link>

              {canModify && (
                <Button
                  variant="outline"
                  className="w-full"
                  onClick={() => {
                    const confirmed = window.confirm(
                      "Are you sure you want to cancel this delivery slip?"
                    );
                    if (confirmed) {
                      setValue("status", DeliverySlipStatus.CANCELLED);
                      handleSubmit(onSubmit)();
                    }
                  }}
                >
                  <Icon icon="heroicons:x-circle" className="w-4 h-4 mr-2" />
                  Cancel Slip
                </Button>
              )}
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
};
// Main component wrapped with ProtectedRoute
const EditDeliverySlipPage = () => {
  return (
    <ProtectedRoute
      requiredPermissions={[PARCELS_PERMISSIONS.DELIVERY_SLIPS_UPDATE]}
      requiredAccessLevel="LIMITED"
      allowedAccountStatuses={["ACTIVE"]}
    >
      <EditDeliverySlipPageContent />
    </ProtectedRoute>
  );
};
export default EditDeliverySlipPage;
-----------------------------------------------------------------------
--++--> app/[locale]/(protected)/delivery-slips/[id]/scan/page.tsx =======>
-----------------------------------------------------------------------
"use client";
import React, { useState, useEffect, useRef } from "react";
import { useRouter, useParams } from "next/navigation";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Badge } from "@/components/ui/badge";
import { Icon } from "@/components/ui/icon";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Link } from "@/i18n/routing";
import { useDeliverySlipsStore } from "@/lib/stores/parcels/delivery-slips.store";
import { useAuthStore } from "@/lib/stores/auth/auth.store";
import { ProtectedRoute } from "@/components/route/protected-route";
import { PARCELS_PERMISSIONS } from "@/lib/constants/parcels";
import { DeliverySlipStatus } from "@/lib/types/parcels/delivery-slips.types";
import { toast } from "sonner";
import { cn } from "@/lib/utils/ui.utils";
interface ScanResult {
  success: boolean;
  code: string;
  timestamp: Date;
  message?: string;
  error?: string;
}
const ScanSpecificSlipPageContent = () => {
  const router = useRouter();
  const params = useParams();
  const slipId = params?.id as string;

  const { hasPermission } = useAuthStore();
  const {
    currentDeliverySlip,
    fetchDeliverySlipById,
    addParcelsToSlip,
    isLoading,
    error,
  } = useDeliverySlipsStore();

  const [scanInput, setScanInput] = useState("");
  const [scanResults, setScanResults] = useState<ScanResult[]>([]);
  const [isScanning, setIsScanning] = useState(false);
  const [sessionStats, setSessionStats] = useState({
    totalScans: 0,
    successfulScans: 0,
    failedScans: 0,
    startTime: new Date(),
  });

  const scanInputRef = useRef<HTMLInputElement>(null);

  const canScanSlips = hasPermission(PARCELS_PERMISSIONS.DELIVERY_SLIPS_SCAN);

  // Load delivery slip data
  useEffect(() => {
    if (canScanSlips && slipId) {
      fetchDeliverySlipById(slipId);
    }
  }, [canScanSlips, slipId, fetchDeliverySlipById]);

  // Auto-focus scan input
  useEffect(() => {
    const focusInput = () => {
      if (scanInputRef.current) {
        scanInputRef.current.focus();
      }
    };

    focusInput();
    const interval = setInterval(focusInput, 1000);
    return () => clearInterval(interval);
  }, []);

  const processScan = async (code: string) => {
    if (!code.trim() || !currentDeliverySlip) return;

    // Check if already scanned
    if (scanResults.some((result) => result.code === code)) {
      toast.warning("This parcel has already been scanned");
      return;
    }

    setIsScanning(true);

    try {
      const success = await addParcelsToSlip(currentDeliverySlip.id, {
        parcelIds: [code], // This might need adjustment based on your API
        markAsScanned: true,
        comment: "Scanned via dedicated slip scanner",
      });

      const result: ScanResult = {
        success,
        code,
        timestamp: new Date(),
        message: success ? "Parcel added successfully" : "Failed to add parcel",
        error: success ? undefined : "Parcel not found or invalid",
      };

      setScanResults((prev) => [result, ...prev]);
      setSessionStats((prev) => ({
        ...prev,
        totalScans: prev.totalScans + 1,
        successfulScans: success
          ? prev.successfulScans + 1
          : prev.successfulScans,
        failedScans: !success ? prev.failedScans + 1 : prev.failedScans,
      }));

      if (success) {
        toast.success(`Parcel ${code} scanned successfully`);
        // Refresh slip data
        fetchDeliverySlipById(currentDeliverySlip.id);
      } else {
        toast.error(`Failed to scan parcel ${code}`);
      }
    } catch (error) {
      const result: ScanResult = {
        success: false,
        code,
        timestamp: new Date(),
        error: error instanceof Error ? error.message : "Unknown error",
      };

      setScanResults((prev) => [result, ...prev]);
      setSessionStats((prev) => ({
        ...prev,
        totalScans: prev.totalScans + 1,
        failedScans: prev.failedScans + 1,
      }));

      toast.error(`Error scanning ${code}: ${result.error}`);
    } finally {
      setIsScanning(false);
      setScanInput("");
    }
  };

  const handleManualScan = (e: React.FormEvent) => {
    e.preventDefault();
    if (scanInput.trim()) {
      processScan(scanInput.trim());
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === "Enter") {
      e.preventDefault();
      if (scanInput.trim()) {
        processScan(scanInput.trim());
      }
    }
  };

  const clearSession = () => {
    setScanResults([]);
    setSessionStats({
      totalScans: 0,
      successfulScans: 0,
      failedScans: 0,
      startTime: new Date(),
    });
    setScanInput("");
  };

  if (!canScanSlips) {
    return (
      <div className="container mx-auto py-8">
        <Alert color="destructive">
          <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
          <AlertDescription>
            You don't have permission to scan delivery slips. Please contact
            your administrator.
          </AlertDescription>
        </Alert>
      </div>
    );
  }

  if (isLoading) {
    return (
      <div className="container mx-auto py-6">
        <Card>
          <CardContent className="p-8">
            <div className="flex items-center justify-center space-x-2">
              <Icon
                icon="heroicons:arrow-path"
                className="w-5 h-5 animate-spin"
              />
              <span>Loading delivery slip...</span>
            </div>
          </CardContent>
        </Card>
      </div>
    );
  }

  if (!currentDeliverySlip || error) {
    return (
      <div className="container mx-auto py-8">
        <Alert color="destructive">
          <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
          <AlertDescription>
            {error || "Delivery slip not found or has been deleted."}
          </AlertDescription>
        </Alert>
      </div>
    );
  }

  const canModify = currentDeliverySlip.status === DeliverySlipStatus.PENDING;

  return (
    <div className="container mx-auto py-6 space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-default-900">Scan Parcels</h1>
          <p className="text-default-600">
            {currentDeliverySlip.reference} • Scan parcels into this delivery
            slip
          </p>
        </div>
        <div className="flex items-center gap-2">
          <Link href={`/delivery-slips/${currentDeliverySlip.id}`}>
            <Button variant="outline">
              <Icon icon="heroicons:eye" className="w-4 h-4 mr-2" />
              View Details
            </Button>
          </Link>
          <Link href="/delivery-slips">
            <Button variant="outline">
              <Icon icon="heroicons:arrow-left" className="w-4 h-4 mr-2" />
              Back to List
            </Button>
          </Link>
        </div>
      </div>

      {/* Status Warning */}
      {!canModify && (
        <Alert color="warning">
          <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
          <AlertDescription>
            This delivery slip has status "{currentDeliverySlip.status}" and
            cannot be modified. Only pending slips can be scanned.
          </AlertDescription>
        </Alert>
      )}

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Main Scanner */}
        <div className="lg:col-span-2 space-y-6">
          {/* Slip Information */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon icon="heroicons:document-text" className="w-5 h-5" />
                Delivery Slip Information
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <Label className="text-sm font-medium">Reference</Label>
                  <p className="font-mono">{currentDeliverySlip.reference}</p>
                </div>
                <div>
                  <Label className="text-sm font-medium">Status</Label>
                  <Badge color="secondary">{currentDeliverySlip.status}</Badge>
                </div>
                <div>
                  <Label className="text-sm font-medium">Total Parcels</Label>
                  <p>{currentDeliverySlip.summary.totalParcels}</p>
                </div>
                <div>
                  <Label className="text-sm font-medium">Scanned Parcels</Label>
                  <p className="text-green-600">
                    {currentDeliverySlip.summary.scannedParcels} /{" "}
                    {currentDeliverySlip.summary.totalParcels}
                  </p>
                </div>
              </div>

              {/* Progress Bar */}
              <div className="space-y-2">
                <div className="flex justify-between text-sm">
                  <span>Scan Progress</span>
                  <span>
                    {Math.round(
                      (currentDeliverySlip.summary.scannedParcels /
                        currentDeliverySlip.summary.totalParcels) *
                        100
                    )}
                    %
                  </span>
                </div>
                <div className="w-full bg-gray-200 rounded-full h-2">
                  <div
                    className="bg-primary h-2 rounded-full"
                    style={{
                      width: `${
                        (currentDeliverySlip.summary.scannedParcels /
                          currentDeliverySlip.summary.totalParcels) *
                        100
                      }%`,
                    }}
                  />
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Scanner Interface */}
          {canModify && (
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:qr-code" className="w-5 h-5" />
                  Scanner Interface
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="space-y-2">
                  <Label>Scan or enter parcel code:</Label>
                  <form onSubmit={handleManualScan} className="flex gap-2">
                    <Input
                      ref={scanInputRef}
                      value={scanInput}
                      onChange={(e) => setScanInput(e.target.value)}
                      onKeyPress={handleKeyPress}
                      placeholder="Click here before scanning or type parcel code..."
                      className="flex-1 font-mono"
                      disabled={isScanning}
                      autoComplete="off"
                    />
                    <Button
                      type="submit"
                      disabled={!scanInput.trim() || isScanning}
                    >
                      {isScanning ? (
                        <Icon
                          icon="heroicons:arrow-path"
                          className="w-4 h-4 animate-spin"
                        />
                      ) : (
                        <Icon icon="heroicons:plus" className="w-4 h-4" />
                      )}
                    </Button>
                  </form>
                </div>

                {/* Instructions */}
                <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
                  <h4 className="font-medium text-blue-900 mb-2">
                    Scanning Instructions:
                  </h4>
                  <ul className="text-sm text-blue-800 space-y-1">
                    <li>• Click in the input field above before scanning</li>
                    <li>• Use a barcode scanner to scan parcel codes</li>
                    <li>• Press Enter or click + to manually add codes</li>
                    <li>• Each successful scan adds the parcel to this slip</li>
                  </ul>
                </div>
              </CardContent>
            </Card>
          )}

          {/* Scan Results */}
          {scanResults.length > 0 && (
            <Card>
              <CardHeader>
                <div className="flex items-center justify-between">
                  <CardTitle className="flex items-center gap-2">
                    <Icon icon="heroicons:list-bullet" className="w-5 h-5" />
                    Scan Results ({scanResults.length})
                  </CardTitle>
                  <Button size="sm" variant="outline" onClick={clearSession}>
                    <Icon icon="heroicons:trash" className="w-4 h-4 mr-2" />
                    Clear Session
                  </Button>
                </div>
              </CardHeader>
              <CardContent>
                <div className="space-y-2 max-h-64 overflow-y-auto">
                  {scanResults.map((result, index) => (
                    <div
                      key={index}
                      className={cn(
                        "flex items-center justify-between p-3 border rounded-lg",
                        result.success
                          ? "bg-green-50 border-green-200"
                          : "bg-red-50 border-red-200"
                      )}
                    >
                      <div className="flex items-center gap-3">
                        <Icon
                          icon={
                            result.success
                              ? "heroicons:check-circle"
                              : "heroicons:x-circle"
                          }
                          className={cn(
                            "w-5 h-5",
                            result.success ? "text-green-600" : "text-red-600"
                          )}
                        />
                        <div>
                          <code className="text-sm font-medium">
                            {result.code}
                          </code>
                          <div className="text-xs text-muted-foreground">
                            {result.timestamp.toLocaleTimeString()}
                          </div>
                        </div>
                      </div>
                      <div className="text-xs">
                        {result.success ? result.message : result.error}
                      </div>
                    </div>
                  ))}
                </div>
              </CardContent>
            </Card>
          )}

          {/* Current Parcels */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon icon="heroicons:cube" className="w-5 h-5" />
                Current Parcels ({currentDeliverySlip.items.length})
              </CardTitle>
            </CardHeader>
            <CardContent>
              <div className="space-y-2 max-h-64 overflow-y-auto">
                {currentDeliverySlip.items.length === 0 ? (
                  <div className="text-center py-8">
                    <Icon
                      icon="heroicons:inbox"
                      className="w-12 h-12 text-muted-foreground mx-auto mb-4"
                    />
                    <p className="text-muted-foreground">
                      No parcels in this delivery slip yet
                    </p>
                  </div>
                ) : (
                  currentDeliverySlip.items.map((item) => (
                    <div
                      key={item.parcelId}
                      className="flex items-center justify-between p-3 border rounded-lg"
                    >
                      <div className="flex items-center gap-3">
                        {item.scanned ? (
                          <Icon
                            icon="heroicons:check-circle"
                            className="w-5 h-5 text-green-600"
                          />
                        ) : (
                          <Icon
                            icon="heroicons:clock"
                            className="w-5 h-5 text-yellow-600"
                          />
                        )}
                        <div>
                          <code className="text-sm font-medium">
                            {item.parcel.code}
                          </code>
                          <div className="text-xs text-muted-foreground">
                            {item.parcel.recipientName} •{" "}
                            {item.parcel.recipientPhone}
                          </div>
                        </div>
                      </div>
                      <div className="text-right">
                        <Badge color="primary" className="text-xs">
                          {item.parcel.price.toFixed(2)} DH
                        </Badge>
                        <div className="text-xs text-muted-foreground">
                          To: {item.parcel.destinationCity}
                        </div>
                      </div>
                    </div>
                  ))
                )}
              </div>
            </CardContent>
          </Card>
        </div>

        {/* Sidebar */}
        <div className="space-y-6">
          {/* Session Stats */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon icon="heroicons:chart-bar" className="w-5 h-5" />
                Session Statistics
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="space-y-3">
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Total scans:
                  </span>
                  <span className="font-medium">{sessionStats.totalScans}</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Successful:
                  </span>
                  <span className="font-medium text-green-600">
                    {sessionStats.successfulScans}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">Failed:</span>
                  <span className="font-medium text-red-600">
                    {sessionStats.failedScans}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Success rate:
                  </span>
                  <span className="font-medium">
                    {sessionStats.totalScans > 0
                      ? Math.round(
                          (sessionStats.successfulScans /
                            sessionStats.totalScans) *
                            100
                        )
                      : 0}
                    %
                  </span>
                </div>
                <div className="flex justify-between text-xs border-t pt-2">
                  <span className="text-muted-foreground">
                    Session started:
                  </span>
                  <span>{sessionStats.startTime.toLocaleTimeString()}</span>
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Slip Summary */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon
                  icon="heroicons:clipboard-document-list"
                  className="w-5 h-5"
                />
                Slip Summary
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="space-y-3">
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Reference:
                  </span>
                  <code className="text-sm font-medium">
                    {currentDeliverySlip.reference}
                  </code>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">Status:</span>
                  <Badge color="secondary">{currentDeliverySlip.status}</Badge>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">City:</span>
                  <span className="text-sm">
                    {currentDeliverySlip.city?.name || "Not specified"}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Total value:
                  </span>
                  <span className="font-medium">
                    {currentDeliverySlip.summary.totalValue.toFixed(2)} DH
                  </span>
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Quick Actions */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon icon="heroicons:bolt" className="w-5 h-5" />
                Quick Actions
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-2">
              <Link href={`/delivery-slips/${currentDeliverySlip.id}`}>
                <Button variant="outline" className="w-full">
                  <Icon icon="heroicons:eye" className="w-4 h-4 mr-2" />
                  View Slip Details
                </Button>
              </Link>

              {canModify && (
                <Link href={`/delivery-slips/${currentDeliverySlip.id}/edit`}>
                  <Button variant="outline" className="w-full">
                    <Icon icon="heroicons:pencil" className="w-4 h-4 mr-2" />
                    Edit Slip
                  </Button>
                </Link>
              )}

              <Link href="/delivery-slips/scan">
                <Button variant="outline" className="w-full">
                  <Icon icon="heroicons:qr-code" className="w-4 h-4 mr-2" />
                  General Scanner
                </Button>
              </Link>

              <Link href="/delivery-slips">
                <Button variant="outline" className="w-full">
                  <Icon icon="heroicons:list-bullet" className="w-4 h-4 mr-2" />
                  All Delivery Slips
                </Button>
              </Link>

              {canModify &&
                currentDeliverySlip.summary.unscannedParcels === 0 && (
                  <Button
                    className="w-full"
                    onClick={() => {
                      // Quick receive action
                      router.push(
                        `/delivery-slips/${currentDeliverySlip.id}?action=receive`
                      );
                    }}
                  >
                    <Icon icon="heroicons:check" className="w-4 h-4 mr-2" />
                    Mark as Received
                  </Button>
                )}
            </CardContent>
          </Card>

          {/* Help */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon
                  icon="heroicons:question-mark-circle"
                  className="w-5 h-5"
                />
                Scanning Tips
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-3">
              <div className="text-sm space-y-2">
                <p className="font-medium">For best results:</p>
                <ul className="text-muted-foreground space-y-1 text-xs">
                  <li>• Keep the input field focused</li>
                  <li>• Scan codes one at a time</li>
                  <li>• Wait for confirmation before next scan</li>
                  <li>• Check scan results for any errors</li>
                </ul>
              </div>
              <div className="text-sm space-y-2">
                <p className="font-medium">Troubleshooting:</p>
                <ul className="text-muted-foreground space-y-1 text-xs">
                  <li>• Ensure parcels are not already in other slips</li>
                  <li>• Verify parcel codes are correct</li>
                  <li>• Contact support for persistent issues</li>
                </ul>
              </div>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
};
// Main component wrapped with ProtectedRoute
const ScanSpecificSlipPage = () => {
  return (
    <ProtectedRoute
      requiredPermissions={[PARCELS_PERMISSIONS.DELIVERY_SLIPS_SCAN]}
      requiredAccessLevel="LIMITED"
      allowedAccountStatuses={["ACTIVE"]}
    >
      <ScanSpecificSlipPageContent />
    </ProtectedRoute>
  );
};
export default ScanSpecificSlipPage;
-----------------------------------------------------------------------
--++--> app/[locale]/(protected)/delivery-slips/create/page.tsx =======>
-----------------------------------------------------------------------
"use client";
import React, { useState, useEffect } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { useRouter } from "next/navigation";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";
import { Badge } from "@/components/ui/badge";
import { Icon } from "@/components/ui/icon";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Checkbox } from "@/components/ui/checkbox";
import { Link } from "@/i18n/routing";
import { useDeliverySlipsStore } from "@/lib/stores/parcels/delivery-slips.store";
import { useCitiesStore } from "@/lib/stores/parcels/cities.store";
import { useAuthStore } from "@/lib/stores/auth/auth.store";
import { ProtectedRoute } from "@/components/route/protected-route";
import { PARCELS_PERMISSIONS } from "@/lib/constants/parcels";
import { toast } from "sonner";
import { cn } from "@/lib/utils/ui.utils";
// Form schema for creating delivery slip
const createDeliverySlipSchema = z.object({
  cityId: z.string().optional(),
  parcelIds: z.array(z.string()).optional(),
  notes: z.string().max(500).optional(),
  autoReceive: z.boolean().default(false),
});
type CreateDeliverySlipFormData = z.infer<typeof createDeliverySlipSchema>;
const CreateDeliverySlipPageContent = () => {
  const router = useRouter();
  const { hasPermission, user } = useAuthStore();
  const {
    createDeliverySlip,
    fetchAvailableParcels,
    availableParcels,
    isCreating,
    error,
  } = useDeliverySlipsStore();
  const { cities, fetchCities } = useCitiesStore();

  const [selectedParcels, setSelectedParcels] = useState<string[]>([]);
  const [selectedCity, setSelectedCity] = useState<string>("");
  const [searchTerm, setSearchTerm] = useState("");

  // Check permissions
  const canCreateSlips = hasPermission(
    PARCELS_PERMISSIONS.DELIVERY_SLIPS_CREATE
  );

  const {
    register,
    handleSubmit,
    watch,
    setValue,
    formState: { errors, isDirty },
    reset,
  } = useForm<CreateDeliverySlipFormData>({
    resolver: zodResolver(createDeliverySlipSchema),
    defaultValues: {
      autoReceive: false,
      parcelIds: [],
    },
  });

  const watchedCityId = watch("cityId");
  const watchedAutoReceive = watch("autoReceive");

  // Initialize data
  useEffect(() => {
    if (canCreateSlips) {
      fetchCities();
      fetchAvailableParcels();
    }
  }, [canCreateSlips, fetchCities, fetchAvailableParcels]);

  // Update available parcels when city filter changes
  useEffect(() => {
    if (selectedCity) {
      fetchAvailableParcels(selectedCity);
    } else {
      fetchAvailableParcels();
    }
  }, [selectedCity, fetchAvailableParcels]);

  // Update form when parcels selection changes
  useEffect(() => {
    setValue("parcelIds", selectedParcels, { shouldDirty: true });
  }, [selectedParcels, setValue]);

  const handleParcelSelection = (parcelId: string, checked: boolean) => {
    if (checked) {
      setSelectedParcels((prev) => [...prev, parcelId]);
    } else {
      setSelectedParcels((prev) => prev.filter((id) => id !== parcelId));
    }
  };

  const handleSelectAll = (checked: boolean) => {
    if (checked) {
      const allParcelIds = filteredParcels.map((parcel) => parcel.id);
      setSelectedParcels(allParcelIds);
    } else {
      setSelectedParcels([]);
    }
  };

  const handleCityFilter = (cityId: string) => {
    setSelectedCity(cityId === "all" ? "" : cityId);
  };

  // Filter parcels based on search term
  const filteredParcels = availableParcels.filter(
    (parcel) =>
      parcel.code.toLowerCase().includes(searchTerm.toLowerCase()) ||
      parcel.recipientName.toLowerCase().includes(searchTerm.toLowerCase()) ||
      parcel.recipientPhone.includes(searchTerm)
  );

  const onSubmit = async (data: CreateDeliverySlipFormData) => {
    if (!canCreateSlips) {
      toast.error("You don't have permission to create delivery slips");
      return;
    }

    const deliverySlip = await createDeliverySlip({
      cityId: data.cityId,
      parcelIds: selectedParcels,
      notes: data.notes,
      autoReceive: data.autoReceive,
    });

    if (deliverySlip) {
      toast.success("Delivery slip created successfully");
      router.push(`/delivery-slips/${deliverySlip.id}`);
    }
  };

  if (!canCreateSlips) {
    return (
      <div className="container mx-auto py-8">
        <Alert color="destructive">
          <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
          <AlertDescription>
            You don't have permission to create delivery slips. Please contact
            your administrator.
          </AlertDescription>
        </Alert>
      </div>
    );
  }

  const totalValue = filteredParcels
    .filter((parcel) => selectedParcels.includes(parcel.id))
    .reduce((sum, parcel) => sum + Number(parcel.price), 0);

  return (
    <div className="container mx-auto py-6 space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-default-900">
            Create Delivery Slip
          </h1>
          <p className="text-default-600">
            Create a new delivery slip to group parcels for collection
          </p>
        </div>
        <Link href="/delivery-slips">
          <Button variant="outline">
            <Icon icon="heroicons:arrow-left" className="w-4 h-4 mr-2" />
            Back to Delivery Slips
          </Button>
        </Link>
      </div>

      {/* Error Alert */}
      {error && (
        <Alert color="destructive">
          <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Main Form */}
        <div className="lg:col-span-2 space-y-6">
          {/* Basic Information */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon icon="heroicons:document-text" className="w-5 h-5" />
                Basic Information
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              {/* City Selection */}
              <div className="space-y-2">
                <Label htmlFor="cityId">Collection City (Optional)</Label>
                <Select
                  value={watchedCityId || ""}
                  onValueChange={(value) =>
                    setValue("cityId", value || undefined)
                  }
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Select collection city" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="none">No specific city</SelectItem>
                    {cities
                      .filter((city) => city.pickupCity && city.status)
                      .map((city) => (
                        <SelectItem key={city.id} value={city.id}>
                          {city.name} ({city.ref})
                        </SelectItem>
                      ))}
                  </SelectContent>
                </Select>
              </div>

              {/* Notes */}
              <div className="space-y-2">
                <Label htmlFor="notes">Notes (Optional)</Label>
                <Textarea
                  id="notes"
                  {...register("notes")}
                  placeholder="Add any special instructions or notes..."
                  rows={3}
                />
                {errors.notes && (
                  <p className="text-xs text-destructive">
                    {errors.notes.message}
                  </p>
                )}
              </div>

              {/* Auto-receive option */}
              <div className="flex items-center justify-between p-4 border rounded-lg">
                <div className="space-y-0.5">
                  <Label>Auto-receive slip</Label>
                  <p className="text-xs text-muted-foreground">
                    Automatically mark this slip as received upon creation
                  </p>
                </div>
                <Switch
                  {...register("autoReceive")}
                  checked={watchedAutoReceive}
                  onCheckedChange={(checked) =>
                    setValue("autoReceive", checked)
                  }
                />
              </div>
            </CardContent>
          </Card>

          {/* Parcel Selection */}
          <Card>
            <CardHeader>
              <div className="flex items-center justify-between">
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:cube" className="w-5 h-5" />
                  Select Parcels
                </CardTitle>
                <Badge color="primary">{selectedParcels.length} selected</Badge>
              </div>
            </CardHeader>
            <CardContent className="space-y-4">
              {/* Filters */}
              <div className="flex flex-col sm:flex-row gap-4">
                <div className="flex-1">
                  <Input
                    placeholder="Search by code, recipient name, or phone..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                  />
                </div>
                <div>
                  <Select
                    value={selectedCity || "all"}
                    onValueChange={handleCityFilter}
                  >
                    <SelectTrigger className="w-[200px]">
                      <SelectValue placeholder="Filter by pickup city" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">All cities</SelectItem>
                      {cities
                        .filter((city) => city.pickupCity && city.status)
                        .map((city) => (
                          <SelectItem key={city.id} value={city.id}>
                            {city.name}
                          </SelectItem>
                        ))}
                    </SelectContent>
                  </Select>
                </div>
              </div>

              {/* Select All */}
              {filteredParcels.length > 0 && (
                <div className="flex items-center space-x-2 p-3 bg-muted rounded-lg">
                  <Checkbox
                    id="select-all"
                    checked={
                      filteredParcels.length > 0 &&
                      filteredParcels.every((parcel) =>
                        selectedParcels.includes(parcel.id)
                      )
                    }
                    onCheckedChange={handleSelectAll}
                  />
                  <Label htmlFor="select-all" className="text-sm font-medium">
                    Select all visible parcels ({filteredParcels.length})
                  </Label>
                </div>
              )}

              {/* Parcels List */}
              <div className="space-y-2 max-h-96 overflow-y-auto">
                {filteredParcels.length === 0 ? (
                  <div className="text-center py-8">
                    <Icon
                      icon="heroicons:inbox"
                      className="w-12 h-12 text-muted-foreground mx-auto mb-4"
                    />
                    <p className="text-muted-foreground">
                      {searchTerm || selectedCity
                        ? "No parcels match your filters"
                        : "No available parcels for delivery slips"}
                    </p>
                  </div>
                ) : (
                  filteredParcels.map((parcel) => (
                    <div
                      key={parcel.id}
                      className={cn(
                        "flex items-center space-x-3 p-3 border rounded-lg",
                        selectedParcels.includes(parcel.id)
                          ? "bg-primary/5 border-primary"
                          : "hover:bg-muted/50"
                      )}
                    >
                      <Checkbox
                        checked={selectedParcels.includes(parcel.id)}
                        onCheckedChange={(checked) =>
                          handleParcelSelection(parcel.id, checked as boolean)
                        }
                      />
                      <div className="flex-1 min-w-0">
                        <div className="flex items-center gap-2">
                          <code className="text-sm font-medium">
                            {parcel.code}
                          </code>
                          <Badge color="primary" className="text-xs">
                            {Number(parcel.price).toFixed(2)} DH
                          </Badge>
                        </div>
                        <div className="text-sm text-muted-foreground">
                          {parcel.recipientName} • {parcel.recipientPhone}
                        </div>
                        <div className="text-xs text-muted-foreground">
                          {parcel.pickupCity.name} →{" "}
                          {parcel.destinationCity.name}
                        </div>
                      </div>
                    </div>
                  ))
                )}
              </div>
            </CardContent>
          </Card>
        </div>

        {/* Sidebar */}
        <div className="space-y-6">
          {/* Summary */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon
                  icon="heroicons:clipboard-document-list"
                  className="w-5 h-5"
                />
                Summary
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="space-y-2">
                <div className="flex justify-between text-sm">
                  <span>Selected parcels:</span>
                  <span className="font-medium">{selectedParcels.length}</span>
                </div>
                <div className="flex justify-between text-sm">
                  <span>Total value:</span>
                  <span className="font-medium">
                    {totalValue.toFixed(2)} DH
                  </span>
                </div>
                <div className="flex justify-between text-sm">
                  <span>Collection city:</span>
                  <span className="font-medium">
                    {watchedCityId
                      ? cities.find((c) => c.id === watchedCityId)?.name ||
                        "Unknown"
                      : "Not specified"}
                  </span>
                </div>
                <div className="flex justify-between text-sm">
                  <span>Auto-receive:</span>
                  <span className="font-medium">
                    {watchedAutoReceive ? "Yes" : "No"}
                  </span>
                </div>
              </div>

              {watchedAutoReceive && (
                <Alert color="info" variant="soft">
                  <Icon
                    icon="heroicons:information-circle"
                    className="h-4 w-4"
                  />
                  <AlertDescription>
                    The slip will be automatically marked as received and
                    parcels will have their status updated.
                  </AlertDescription>
                </Alert>
              )}
            </CardContent>
          </Card>

          {/* Actions */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon icon="heroicons:cog-6-tooth" className="w-5 h-5" />
                Actions
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <Button
                onClick={handleSubmit(onSubmit)}
                disabled={isCreating || selectedParcels.length === 0}
                className="w-full"
              >
                {isCreating && (
                  <Icon
                    icon="heroicons:arrow-path"
                    className="mr-2 h-4 w-4 animate-spin"
                  />
                )}
                Create Delivery Slip
              </Button>

              <Button
                type="button"
                variant="outline"
                onClick={() => {
                  reset();
                  setSelectedParcels([]);
                  setSelectedCity("");
                  setSearchTerm("");
                }}
                disabled={isCreating || !isDirty}
                className="w-full"
              >
                Reset Form
              </Button>
            </CardContent>
          </Card>

          {/* Help */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon
                  icon="heroicons:question-mark-circle"
                  className="w-5 h-5"
                />
                Help
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-3">
              <div className="text-sm space-y-2">
                <p className="font-medium">What is a delivery slip?</p>
                <p className="text-muted-foreground">
                  A delivery slip groups multiple parcels for efficient pickup
                  operations. It serves as a collection document.
                </p>
              </div>
              <div className="text-sm space-y-2">
                <p className="font-medium">Parcel status changes:</p>
                <ul className="text-muted-foreground space-y-1">
                  <li>• Same city: NEW_PACKAGE → RECEIVED</li>
                  <li>• Different city: NEW_PACKAGE → COLLECTED</li>
                </ul>
              </div>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
};
// Main component wrapped with ProtectedRoute
const CreateDeliverySlipPage = () => {
  return (
    <ProtectedRoute
      requiredPermissions={[PARCELS_PERMISSIONS.DELIVERY_SLIPS_CREATE]}
      requiredAccessLevel="LIMITED"
      allowedAccountStatuses={["ACTIVE"]}
    >
      <CreateDeliverySlipPageContent />
    </ProtectedRoute>
  );
};
export default CreateDeliverySlipPage;
-----------------------------------------------------------------------
--++--> app/[locale]/(protected)/delivery-slips/bulk-receive/page.tsx =======>
-----------------------------------------------------------------------
"use client";
import React, { useState, useEffect } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Badge } from "@/components/ui/badge";
import { Icon } from "@/components/ui/icon";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Checkbox } from "@/components/ui/checkbox";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Link } from "@/i18n/routing";
import { useDeliverySlipsStore } from "@/lib/stores/parcels/delivery-slips.store";
import { useCitiesStore } from "@/lib/stores/parcels/cities.store";
import { useAuthStore } from "@/lib/stores/auth/auth.store";
import { ProtectedRoute } from "@/components/route/protected-route";
import { PARCELS_PERMISSIONS } from "@/lib/constants/parcels";
import { DeliverySlipStatus } from "@/lib/types/parcels/delivery-slips.types";
import { toast } from "sonner";
import { cn } from "@/lib/utils/ui.utils";
interface BulkReceiveData {
  slipIds: string[];
  notes: string;
  forceReceive: boolean;
}
const formatDate = (dateString: string) => {
  return new Date(dateString).toLocaleDateString("en-US", {
    month: "short",
    day: "2-digit",
    year: "numeric",
    hour: "2-digit",
    minute: "2-digit",
  });
};
const BulkReceiveDeliverySlipsPageContent = () => {
  const { hasPermission } = useAuthStore();
  const { deliverySlips, fetchDeliverySlips, bulkAction, isLoading, error } =
    useDeliverySlipsStore();
  const { cities, fetchCities } = useCitiesStore();

  const [selectedSlips, setSelectedSlips] = useState<string[]>([]);
  const [notes, setNotes] = useState("");
  const [forceReceive, setForceReceive] = useState(false);
  const [filterCity, setFilterCity] = useState<string>("all");
  const [searchTerm, setSearchTerm] = useState("");
  const [showConfirmDialog, setShowConfirmDialog] = useState(false);
  const [isProcessing, setIsProcessing] = useState(false);

  const canReceiveSlips = hasPermission(
    PARCELS_PERMISSIONS.DELIVERY_SLIPS_RECEIVE
  );
  const canBulkActions = hasPermission(PARCELS_PERMISSIONS.DELIVERY_SLIPS_BULK);

  // Load data on mount
  useEffect(() => {
    if (canReceiveSlips) {
      fetchDeliverySlips();
      fetchCities();
    }
  }, [canReceiveSlips, fetchDeliverySlips, fetchCities]);

  // Filter pending slips
  const pendingSlips = deliverySlips.filter(
    (slip) => slip.status === DeliverySlipStatus.PENDING
  );

  // Apply filters
  const filteredSlips = pendingSlips.filter((slip) => {
    const matchesSearch =
      slip.reference.toLowerCase().includes(searchTerm.toLowerCase()) ||
      slip.items.some(
        (item) =>
          item.parcel.recipientName
            .toLowerCase()
            .includes(searchTerm.toLowerCase()) ||
          item.parcel.recipientPhone.includes(searchTerm)
      );

    const matchesCity =
      filterCity === "all" ||
      slip.cityId === filterCity ||
      (!slip.cityId && filterCity === "none");

    return matchesSearch && matchesCity;
  });

  const handleSlipSelection = (slipId: string, checked: boolean) => {
    if (checked) {
      setSelectedSlips((prev) => [...prev, slipId]);
    } else {
      setSelectedSlips((prev) => prev.filter((id) => id !== slipId));
    }
  };

  const handleSelectAll = (checked: boolean) => {
    if (checked) {
      setSelectedSlips(filteredSlips.map((slip) => slip.id));
    } else {
      setSelectedSlips([]);
    }
  };

  const getSlipStats = () => {
    const selectedSlipData = filteredSlips.filter((slip) =>
      selectedSlips.includes(slip.id)
    );

    return {
      totalSlips: selectedSlipData.length,
      totalParcels: selectedSlipData.reduce(
        (sum, slip) => sum + slip.summary.totalParcels,
        0
      ),
      totalValue: selectedSlipData.reduce(
        (sum, slip) => sum + slip.summary.totalValue,
        0
      ),
      unscannedParcels: selectedSlipData.reduce(
        (sum, slip) => sum + slip.summary.unscannedParcels,
        0
      ),
    };
  };

  const handleBulkReceive = async () => {
    if (selectedSlips.length === 0) {
      toast.error("Please select at least one delivery slip");
      return;
    }

    setIsProcessing(true);

    try {
      const success = await bulkAction({
        slipIds: selectedSlips,
        action: "RECEIVE",
        comment: notes || "Bulk received via bulk receive page",
      });

      if (success) {
        toast.success(
          `Successfully processed ${selectedSlips.length} delivery slips`
        );
        setSelectedSlips([]);
        setNotes("");
        setShowConfirmDialog(false);
        // Refresh data
        fetchDeliverySlips();
      }
    } catch (error) {
      toast.error("Failed to process bulk receive operation");
    } finally {
      setIsProcessing(false);
    }
  };

  if (!canReceiveSlips || !canBulkActions) {
    return (
      <div className="container mx-auto py-8">
        <Alert color="destructive">
          <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
          <AlertDescription>
            You don't have permission to perform bulk receive operations. Please
            contact your administrator.
          </AlertDescription>
        </Alert>
      </div>
    );
  }

  const stats = getSlipStats();

  return (
    <div className="container mx-auto py-6 space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-default-900">
            Bulk Receive Delivery Slips
          </h1>
          <p className="text-default-600">
            Process multiple delivery slips for bulk receiving operations
          </p>
        </div>
        <Link href="/delivery-slips">
          <Button variant="outline">
            <Icon icon="heroicons:arrow-left" className="w-4 h-4 mr-2" />
            Back to Delivery Slips
          </Button>
        </Link>
      </div>

      {/* Error Alert */}
      {error && (
        <Alert color="destructive">
          <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Main Content */}
        <div className="lg:col-span-2 space-y-6">
          {/* Filters */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon icon="heroicons:funnel" className="w-5 h-5" />
                Filters & Search
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div className="space-y-2">
                  <Label>Search delivery slips:</Label>
                  <Input
                    placeholder="Search by reference, customer name, or phone..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                  />
                </div>
                <div className="space-y-2">
                  <Label>Filter by city:</Label>
                  <Select value={filterCity} onValueChange={setFilterCity}>
                    <SelectTrigger>
                      <SelectValue placeholder="All cities" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">All cities</SelectItem>
                      <SelectItem value="none">No city specified</SelectItem>
                      {cities
                        .filter((city) => city.pickupCity && city.status)
                        .map((city) => (
                          <SelectItem key={city.id} value={city.id}>
                            {city.name} ({city.ref})
                          </SelectItem>
                        ))}
                    </SelectContent>
                  </Select>
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Delivery Slips Selection */}
          <Card>
            <CardHeader>
              <div className="flex items-center justify-between">
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:document-text" className="w-5 h-5" />
                  Select Delivery Slips ({filteredSlips.length})
                </CardTitle>
                <div className="flex items-center gap-2">
                  {selectedSlips.length > 0 && (
                    <Badge color="secondary">
                      {selectedSlips.length} selected
                    </Badge>
                  )}
                  {filteredSlips.length > 0 && (
                    <Button
                      size="sm"
                      variant="outline"
                      onClick={() =>
                        handleSelectAll(
                          selectedSlips.length !== filteredSlips.length
                        )
                      }
                    >
                      {selectedSlips.length === filteredSlips.length
                        ? "Deselect All"
                        : "Select All"}
                    </Button>
                  )}
                </div>
              </div>
            </CardHeader>
            <CardContent>
              {filteredSlips.length === 0 ? (
                <div className="text-center py-8">
                  <Icon
                    icon="heroicons:document-text"
                    className="w-12 h-12 text-muted-foreground mx-auto mb-4"
                  />
                  <p className="text-muted-foreground">
                    {pendingSlips.length === 0
                      ? "No pending delivery slips found"
                      : "No delivery slips match your filters"}
                  </p>
                  {pendingSlips.length === 0 && (
                    <Link href="/delivery-slips/create">
                      <Button className="mt-4">
                        <Icon icon="heroicons:plus" className="w-4 h-4 mr-2" />
                        Create Delivery Slip
                      </Button>
                    </Link>
                  )}
                </div>
              ) : (
                <div className="overflow-x-auto">
                  <Table>
                    <TableHeader>
                      <TableRow>
                        <TableHead className="w-12">
                          <Checkbox
                            checked={
                              filteredSlips.length > 0 &&
                              selectedSlips.length === filteredSlips.length
                            }
                            onCheckedChange={handleSelectAll}
                          />
                        </TableHead>
                        <TableHead>Reference</TableHead>
                        <TableHead>Created</TableHead>
                        <TableHead>City</TableHead>
                        <TableHead>Parcels</TableHead>
                        <TableHead>Scanned</TableHead>
                        <TableHead>Value</TableHead>
                        <TableHead>Progress</TableHead>
                      </TableRow>
                    </TableHeader>
                    <TableBody>
                      {filteredSlips.map((slip) => (
                        <TableRow key={slip.id}>
                          <TableCell>
                            <Checkbox
                              checked={selectedSlips.includes(slip.id)}
                              onCheckedChange={(checked) =>
                                handleSlipSelection(slip.id, checked as boolean)
                              }
                            />
                          </TableCell>
                          <TableCell>
                            <div>
                              <code className="text-sm font-medium">
                                {slip.reference}
                              </code>
                              <Badge color="secondary" className="ml-2 text-xs">
                                {slip.status}
                              </Badge>
                            </div>
                          </TableCell>
                          <TableCell className="text-sm">
                            {formatDate(slip.createdAt)}
                          </TableCell>
                          <TableCell>
                            {slip.city ? (
                              <Badge color="primary" className="text-xs">
                                {slip.city.name}
                              </Badge>
                            ) : (
                              <span className="text-xs text-muted-foreground">
                                Not specified
                              </span>
                            )}
                          </TableCell>
                          <TableCell>
                            <div className="text-sm">
                              <span className="font-medium">
                                {slip.summary.totalParcels}
                              </span>
                              <span className="text-muted-foreground">
                                {" "}
                                total
                              </span>
                            </div>
                          </TableCell>
                          <TableCell>
                            <div className="text-sm">
                              <span className="font-medium text-green-600">
                                {slip.summary.scannedParcels}
                              </span>
                              {slip.summary.unscannedParcels > 0 && (
                                <span className="text-yellow-600">
                                  {" "}
                                  ({slip.summary.unscannedParcels} pending)
                                </span>
                              )}
                            </div>
                          </TableCell>
                          <TableCell>
                            <Badge color="primary" className="text-xs">
                              {slip.summary.totalValue.toFixed(2)} DH
                            </Badge>
                          </TableCell>
                          <TableCell>
                            <div className="flex items-center gap-2">
                              <div className="w-16 bg-gray-200 rounded-full h-2">
                                <div
                                  className="bg-primary h-2 rounded-full"
                                  style={{
                                    width: `${
                                      slip.summary.totalParcels > 0
                                        ? (slip.summary.scannedParcels /
                                            slip.summary.totalParcels) *
                                          100
                                        : 0
                                    }%`,
                                  }}
                                />
                              </div>
                              <span className="text-xs text-muted-foreground">
                                {slip.summary.totalParcels > 0
                                  ? Math.round(
                                      (slip.summary.scannedParcels /
                                        slip.summary.totalParcels) *
                                        100
                                    )
                                  : 0}
                                %
                              </span>
                            </div>
                          </TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </div>
              )}
            </CardContent>
          </Card>

          {/* Bulk Action Settings */}
          {selectedSlips.length > 0 && (
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:cog-6-tooth" className="w-5 h-5" />
                  Bulk Receive Settings
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="space-y-2">
                  <Label>Notes (Optional)</Label>
                  <Textarea
                    value={notes}
                    onChange={(e) => setNotes(e.target.value)}
                    placeholder="Add notes for this bulk receive operation..."
                    rows={3}
                  />
                </div>

                <div className="flex items-center justify-between p-4 border rounded-lg">
                  <div className="space-y-0.5">
                    <Label>Force receive</Label>
                    <p className="text-xs text-muted-foreground">
                      Force receive even if some parcels are not scanned
                    </p>
                  </div>
                  <Checkbox
                    checked={forceReceive}
                    onCheckedChange={setForceReceive}
                  />
                </div>

                {stats.unscannedParcels > 0 && !forceReceive && (
                  <Alert color="warning">
                    <Icon
                      icon="heroicons:exclamation-triangle"
                      className="h-4 w-4"
                    />
                    <AlertDescription>
                      {stats.unscannedParcels} parcels across selected slips
                      have not been scanned. Enable "Force receive" to proceed
                      anyway.
                    </AlertDescription>
                  </Alert>
                )}

                <div className="flex gap-2">
                  <Button
                    onClick={() => setShowConfirmDialog(true)}
                    disabled={
                      isProcessing ||
                      (stats.unscannedParcels > 0 && !forceReceive)
                    }
                    className="flex-1"
                  >
                    {isProcessing ? (
                      <Icon
                        icon="heroicons:arrow-path"
                        className="mr-2 h-4 w-4 animate-spin"
                      />
                    ) : (
                      <Icon icon="heroicons:check" className="mr-2 h-4 w-4" />
                    )}
                    Receive {selectedSlips.length} Slip
                    {selectedSlips.length !== 1 ? "s" : ""}
                  </Button>
                  <Button
                    variant="outline"
                    onClick={() => setSelectedSlips([])}
                    disabled={isProcessing}
                  >
                    Clear Selection
                  </Button>
                </div>
              </CardContent>
            </Card>
          )}
        </div>

        {/* Sidebar */}
        <div className="space-y-6">
          {/* Summary */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon
                  icon="heroicons:clipboard-document-list"
                  className="w-5 h-5"
                />
                Summary
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="space-y-3">
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Available slips:
                  </span>
                  <span className="font-medium">{pendingSlips.length}</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Filtered slips:
                  </span>
                  <span className="font-medium">{filteredSlips.length}</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Selected slips:
                  </span>
                  <span className="font-medium text-primary">
                    {selectedSlips.length}
                  </span>
                </div>

                {selectedSlips.length > 0 && (
                  <>
                    <div className="border-t pt-3 space-y-2">
                      <div className="flex justify-between">
                        <span className="text-sm text-muted-foreground">
                          Total parcels:
                        </span>
                        <span className="font-medium">
                          {stats.totalParcels}
                        </span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-sm text-muted-foreground">
                          Scanned parcels:
                        </span>
                        <span className="font-medium text-green-600">
                          {stats.totalParcels - stats.unscannedParcels}
                        </span>
                      </div>
                      {stats.unscannedParcels > 0 && (
                        <div className="flex justify-between">
                          <span className="text-sm text-muted-foreground">
                            Unscanned parcels:
                          </span>
                          <span className="font-medium text-yellow-600">
                            {stats.unscannedParcels}
                          </span>
                        </div>
                      )}
                      <div className="flex justify-between border-t pt-2">
                        <span className="text-sm text-muted-foreground">
                          Total value:
                        </span>
                        <span className="font-medium">
                          {stats.totalValue.toFixed(2)} DH
                        </span>
                      </div>
                    </div>
                  </>
                )}
              </div>
            </CardContent>
          </Card>

          {/* Quick Stats */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon icon="heroicons:chart-bar" className="w-5 h-5" />
                Quick Stats
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="grid grid-cols-2 gap-4">
                <div className="text-center p-3 bg-blue-50 rounded-lg">
                  <div className="text-2xl font-bold text-blue-600">
                    {pendingSlips.length}
                  </div>
                  <div className="text-xs text-blue-600">Pending</div>
                </div>
                <div className="text-center p-3 bg-green-50 rounded-lg">
                  <div className="text-2xl font-bold text-green-600">
                    {pendingSlips.reduce(
                      (sum, slip) => sum + slip.summary.totalParcels,
                      0
                    )}
                  </div>
                  <div className="text-xs text-green-600">Total Parcels</div>
                </div>
              </div>

              <div className="space-y-2">
                <div className="flex justify-between text-sm">
                  <span>Ready to receive:</span>
                  <span className="font-medium">
                    {
                      pendingSlips.filter(
                        (slip) => slip.summary.unscannedParcels === 0
                      ).length
                    }
                  </span>
                </div>
                <div className="flex justify-between text-sm">
                  <span>Need scanning:</span>
                  <span className="font-medium">
                    {
                      pendingSlips.filter(
                        (slip) => slip.summary.unscannedParcels > 0
                      ).length
                    }
                  </span>
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Quick Actions */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon icon="heroicons:bolt" className="w-5 h-5" />
                Quick Actions
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-2">
              <Link href="/delivery-slips/scan">
                <Button variant="outline" className="w-full">
                  <Icon icon="heroicons:qr-code" className="w-4 h-4 mr-2" />
                  Scanner Interface
                </Button>
              </Link>

              <Link href="/delivery-slips/create">
                <Button variant="outline" className="w-full">
                  <Icon icon="heroicons:plus" className="w-4 h-4 mr-2" />
                  Create New Slip
                </Button>
              </Link>

              <Link href="/delivery-slips">
                <Button variant="outline" className="w-full">
                  <Icon icon="heroicons:list-bullet" className="w-4 h-4 mr-2" />
                  All Delivery Slips
                </Button>
              </Link>

              <Button
                variant="outline"
                className="w-full"
                onClick={() => {
                  setSelectedSlips([]);
                  setSearchTerm("");
                  setFilterCity("all");
                  setNotes("");
                  setForceReceive(false);
                }}
              >
                <Icon icon="heroicons:arrow-path" className="w-4 h-4 mr-2" />
                Reset All Filters
              </Button>
            </CardContent>
          </Card>

          {/* Help */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon
                  icon="heroicons:question-mark-circle"
                  className="w-5 h-5"
                />
                Help
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-3">
              <div className="text-sm space-y-2">
                <p className="font-medium">Bulk Receive Process:</p>
                <ul className="text-muted-foreground space-y-1 text-xs">
                  <li>1. Filter and select delivery slips</li>
                  <li>2. Review unscanned parcels</li>
                  <li>3. Enable force receive if needed</li>
                  <li>4. Add notes and confirm operation</li>
                </ul>
              </div>
              <div className="text-sm space-y-2">
                <p className="font-medium">Best Practices:</p>
                <ul className="text-muted-foreground space-y-1 text-xs">
                  <li>• Scan all parcels before receiving</li>
                  <li>• Use force receive only when necessary</li>
                  <li>• Add meaningful notes for tracking</li>
                </ul>
              </div>
            </CardContent>
          </Card>
        </div>
      </div>

      {/* Confirmation Dialog */}
      <AlertDialog open={showConfirmDialog} onOpenChange={setShowConfirmDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Confirm Bulk Receive</AlertDialogTitle>
            <AlertDialogDescription>
              You are about to mark {selectedSlips.length} delivery slip
              {selectedSlips.length !== 1 ? "s" : ""} as received. This will
              affect {stats.totalParcels} parcel
              {stats.totalParcels !== 1 ? "s" : ""} with a total value of{" "}
              {stats.totalValue.toFixed(2)} DH.
              {stats.unscannedParcels > 0 && (
                <div className="mt-3 p-3 bg-yellow-50 border border-yellow-200 rounded">
                  <p className="text-sm text-yellow-800">
                    <strong>Warning:</strong> {stats.unscannedParcels} parcels
                    have not been scanned yet. They will be automatically marked
                    as scanned.
                  </p>
                </div>
              )}
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={isProcessing}>
              Cancel
            </AlertDialogCancel>
            <AlertDialogAction
              onClick={handleBulkReceive}
              disabled={isProcessing}
            >
              {isProcessing && (
                <Icon
                  icon="heroicons:arrow-path"
                  className="mr-2 h-4 w-4 animate-spin"
                />
              )}
              Confirm Receive
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
};
// Main component wrapped with ProtectedRoute
const BulkReceiveDeliverySlipsPage = () => {
  return (
    <ProtectedRoute
      requiredPermissions={[
        PARCELS_PERMISSIONS.DELIVERY_SLIPS_RECEIVE,
        PARCELS_PERMISSIONS.DELIVERY_SLIPS_BULK,
      ]}
      requiredAccessLevel="LIMITED"
      allowedAccountStatuses={["ACTIVE"]}
    >
      <BulkReceiveDeliverySlipsPageContent />
    </ProtectedRoute>
  );
};
export default BulkReceiveDeliverySlipsPage;
-----------------------------------------------------------------------
--++--> app/[locale]/(protected)/delivery-slips/scan/page.tsx =======>
-----------------------------------------------------------------------
"use client";
import React, { useState, useEffect, useRef } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Badge } from "@/components/ui/badge";
import { Icon } from "@/components/ui/icon";
import { Alert, AlertDescription } from "@/components/ui/alert";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from "@/components/ui/dialog";
import { Link } from "@/i18n/routing";
import { useDeliverySlipsStore } from "@/lib/stores/parcels/delivery-slips.store";
import { useAuthStore } from "@/lib/stores/auth/auth.store";
import { ProtectedRoute } from "@/components/route/protected-route";
import { PARCELS_PERMISSIONS } from "@/lib/constants/parcels";
import { DeliverySlipStatus } from "@/lib/types/parcels/delivery-slips.types";
import { toast } from "sonner";
import { cn } from "@/lib/utils/ui.utils";
interface ScanResult {
  success: boolean;
  code: string;
  parcelDetails?: any;
  message?: string;
  error?: string;
}
interface ScanSession {
  slipId: string | null;
  scannedCodes: string[];
  results: ScanResult[];
  startTime: Date;
}
const ScannerDeliverySlipsPageContent = () => {
  const { hasPermission } = useAuthStore();
  const {
    deliverySlips,
    currentDeliverySlip,
    fetchDeliverySlips,
    fetchDeliverySlipById,
    scanParcelIntoSlip,
    addParcelsToSlip,
  } = useDeliverySlipsStore();

  const [scanInput, setScanInput] = useState("");
  const [selectedSlipId, setSelectedSlipId] = useState<string>("");
  const [scanSession, setScanSession] = useState<ScanSession>({
    slipId: null,
    scannedCodes: [],
    results: [],
    startTime: new Date(),
  });
  const [isScanning, setIsScanning] = useState(false);
  const [showCamera, setShowCamera] = useState(false);
  const [cameraError, setCameraError] = useState<string>("");
  const [lastScanResult, setLastScanResult] = useState<ScanResult | null>(null);

  const scanInputRef = useRef<HTMLInputElement>(null);
  const videoRef = useRef<HTMLVideoElement>(null);
  const streamRef = useRef<MediaStream | null>(null);

  const canScanSlips = hasPermission(PARCELS_PERMISSIONS.DELIVERY_SLIPS_SCAN);

  // Load delivery slips on mount
  useEffect(() => {
    if (canScanSlips) {
      fetchDeliverySlips();
    }
  }, [canScanSlips, fetchDeliverySlips]);

  // Auto-focus scan input
  useEffect(() => {
    const focusInput = () => {
      if (scanInputRef.current && !showCamera) {
        scanInputRef.current.focus();
      }
    };

    focusInput();
    const interval = setInterval(focusInput, 1000);
    return () => clearInterval(interval);
  }, [showCamera, selectedSlipId]);

  // Load selected slip details
  useEffect(() => {
    if (selectedSlipId) {
      fetchDeliverySlipById(selectedSlipId);
      setScanSession((prev) => ({
        ...prev,
        slipId: selectedSlipId,
        startTime: new Date(),
      }));
    }
  }, [selectedSlipId, fetchDeliverySlipById]);

  const handleSlipSelection = (slipId: string) => {
    setSelectedSlipId(slipId);
    // Clear previous session data
    setScanSession({
      slipId,
      scannedCodes: [],
      results: [],
      startTime: new Date(),
    });
    setLastScanResult(null);
  };

  const processScan = async (code: string) => {
    if (!code.trim() || !selectedSlipId) return;

    // Check if already scanned
    if (scanSession.scannedCodes.includes(code)) {
      toast.warning("This parcel has already been scanned");
      return;
    }

    setIsScanning(true);

    try {
      // First, try to add the parcel to the slip
      const success = await addParcelsToSlip(selectedSlipId, {
        parcelIds: [code], // Assuming code can be used as ID or needs validation
        markAsScanned: true,
        comment: "Scanned via scanner interface",
      });

      const result: ScanResult = {
        success,
        code,
        message: success ? "Parcel added successfully" : "Failed to add parcel",
        error: success ? undefined : "Parcel not found or invalid",
      };

      // Update session
      setScanSession((prev) => ({
        ...prev,
        scannedCodes: [...prev.scannedCodes, code],
        results: [result, ...prev.results],
      }));

      setLastScanResult(result);

      if (success) {
        toast.success(`Parcel ${code} scanned successfully`);
        // Refresh slip data
        fetchDeliverySlipById(selectedSlipId);
      } else {
        toast.error(`Failed to scan parcel ${code}`);
      }
    } catch (error) {
      const result: ScanResult = {
        success: false,
        code,
        error: error instanceof Error ? error.message : "Unknown error",
      };

      setScanSession((prev) => ({
        ...prev,
        scannedCodes: [...prev.scannedCodes, code],
        results: [result, ...prev.results],
      }));

      setLastScanResult(result);
      toast.error(`Error scanning ${code}: ${result.error}`);
    } finally {
      setIsScanning(false);
      setScanInput("");
    }
  };

  const handleManualScan = (e: React.FormEvent) => {
    e.preventDefault();
    if (scanInput.trim()) {
      processScan(scanInput.trim());
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === "Enter") {
      e.preventDefault();
      if (scanInput.trim()) {
        processScan(scanInput.trim());
      }
    }
  };

  const startCamera = async () => {
    try {
      setCameraError("");
      const stream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: "environment", // Use back camera on mobile
          width: { ideal: 1280 },
          height: { ideal: 720 },
        },
      });

      if (videoRef.current) {
        videoRef.current.srcObject = stream;
        streamRef.current = stream;
      }
      setShowCamera(true);
    } catch (error) {
      console.error("Camera access error:", error);
      setCameraError("Unable to access camera. Please check permissions.");
      setShowCamera(false);
    }
  };

  const stopCamera = () => {
    if (streamRef.current) {
      streamRef.current.getTracks().forEach((track) => track.stop());
      streamRef.current = null;
    }
    setShowCamera(false);
  };

  const resetSession = () => {
    setScanSession({
      slipId: selectedSlipId,
      scannedCodes: [],
      results: [],
      startTime: new Date(),
    });
    setLastScanResult(null);
    setScanInput("");
  };

  if (!canScanSlips) {
    return (
      <div className="container mx-auto py-8">
        <Alert color="destructive">
          <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
          <AlertDescription>
            You don't have permission to scan delivery slips. Please contact
            your administrator.
          </AlertDescription>
        </Alert>
      </div>
    );
  }

  const pendingSlips = deliverySlips.filter(
    (slip) => slip.status === DeliverySlipStatus.PENDING
  );

  return (
    <div className="container mx-auto py-6 space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-default-900">
            Delivery Slip Scanner
          </h1>
          <p className="text-default-600">
            Scan parcels into delivery slips using barcode or QR codes
          </p>
        </div>
        <Link href="/delivery-slips">
          <Button variant="outline">
            <Icon icon="heroicons:arrow-left" className="w-4 h-4 mr-2" />
            Back to Delivery Slips
          </Button>
        </Link>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Main Scanner */}
        <div className="lg:col-span-2 space-y-6">
          {/* Slip Selection */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon icon="heroicons:document-text" className="w-5 h-5" />
                Select Delivery Slip
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="space-y-2">
                <Label>Choose delivery slip to scan into:</Label>
                <Select
                  value={selectedSlipId}
                  onValueChange={handleSlipSelection}
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Select a delivery slip" />
                  </SelectTrigger>
                  <SelectContent>
                    {pendingSlips.map((slip) => (
                      <SelectItem key={slip.id} value={slip.id}>
                        <div className="flex items-center gap-2">
                          <span>{slip.reference}</span>
                          <Badge color="primary" className="text-xs">
                            {slip.summary.totalParcels} parcels
                          </Badge>
                          {slip.city && (
                            <Badge color="secondary" className="text-xs">
                              {slip.city.name}
                            </Badge>
                          )}
                        </div>
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>

              {pendingSlips.length === 0 && (
                <Alert color="warning">
                  <Icon
                    icon="heroicons:exclamation-triangle"
                    className="h-4 w-4"
                  />
                  <AlertDescription>
                    No pending delivery slips found. Create a delivery slip
                    first.
                  </AlertDescription>
                </Alert>
              )}
            </CardContent>
          </Card>

          {/* Scanner Interface */}
          {selectedSlipId && (
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <Icon icon="heroicons:qr-code" className="w-5 h-5" />
                    Scanner Interface
                  </div>
                  <div className="flex gap-2">
                    {!showCamera && (
                      <Button size="sm" variant="outline" onClick={startCamera}>
                        <Icon
                          icon="heroicons:camera"
                          className="w-4 h-4 mr-2"
                        />
                        Use Camera
                      </Button>
                    )}
                    {scanSession.results.length > 0 && (
                      <Button
                        size="sm"
                        variant="outline"
                        onClick={resetSession}
                      >
                        <Icon
                          icon="heroicons:arrow-path"
                          className="w-4 h-4 mr-2"
                        />
                        Reset Session
                      </Button>
                    )}
                  </div>
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                {/* Manual Input */}
                <div className="space-y-2">
                  <Label>Manual scan or barcode input:</Label>
                  <form onSubmit={handleManualScan} className="flex gap-2">
                    <Input
                      ref={scanInputRef}
                      value={scanInput}
                      onChange={(e) => setScanInput(e.target.value)}
                      onKeyPress={handleKeyPress}
                      placeholder="Click here before scanning or type parcel code..."
                      className="flex-1 font-mono"
                      disabled={isScanning}
                      autoComplete="off"
                    />
                    <Button
                      type="submit"
                      disabled={!scanInput.trim() || isScanning}
                    >
                      {isScanning ? (
                        <Icon
                          icon="heroicons:arrow-path"
                          className="w-4 h-4 animate-spin"
                        />
                      ) : (
                        <Icon icon="heroicons:plus" className="w-4 h-4" />
                      )}
                    </Button>
                  </form>
                </div>

                {/* Last Scan Result */}
                {lastScanResult && (
                  <Alert
                    color={lastScanResult.success ? "success" : "destructive"}
                  >
                    <Icon
                      icon={
                        lastScanResult.success
                          ? "heroicons:check-circle"
                          : "heroicons:x-circle"
                      }
                      className="h-4 w-4"
                    />
                    <AlertDescription>
                      <strong>{lastScanResult.code}:</strong>{" "}
                      {lastScanResult.message || lastScanResult.error}
                    </AlertDescription>
                  </Alert>
                )}

                {/* Instructions */}
                <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
                  <h4 className="font-medium text-blue-900 mb-2">
                    Scanning Instructions:
                  </h4>
                  <ul className="text-sm text-blue-800 space-y-1">
                    <li>• Click in the input field above before scanning</li>
                    <li>• Use a barcode scanner/gun to scan parcel codes</li>
                    <li>• Or click &quot;Use Camera&quot; for mobile/webcam scanning</li>
                    <li>• Press Enter or click + to manually add codes</li>
                    <li>
                      • Scanned parcels will be automatically added to the slip
                    </li>
                  </ul>
                </div>
              </CardContent>
            </Card>
          )}

          {/* Scan Results */}
          {scanSession.results.length > 0 && (
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:list-bullet" className="w-5 h-5" />
                  Scan Results ({scanSession.results.length})
                </CardTitle>
              </CardHeader>
              <CardContent>
                <div className="space-y-2 max-h-64 overflow-y-auto">
                  {scanSession.results.map((result, index) => (
                    <div
                      key={index}
                      className={cn(
                        "flex items-center justify-between p-3 border rounded-lg",
                        result.success
                          ? "bg-green-50 border-green-200"
                          : "bg-red-50 border-red-200"
                      )}
                    >
                      <div className="flex items-center gap-3">
                        <Icon
                          icon={
                            result.success
                              ? "heroicons:check-circle"
                              : "heroicons:x-circle"
                          }
                          className={cn(
                            "w-5 h-5",
                            result.success ? "text-green-600" : "text-red-600"
                          )}
                        />
                        <div>
                          <code className="text-sm font-medium">
                            {result.code}
                          </code>
                          {result.parcelDetails && (
                            <div className="text-xs text-muted-foreground">
                              {result.parcelDetails.recipientName}
                            </div>
                          )}
                        </div>
                      </div>
                      <div className="text-xs text-muted-foreground">
                        {result.success ? result.message : result.error}
                      </div>
                    </div>
                  ))}
                </div>
              </CardContent>
            </Card>
          )}
        </div>

        {/* Sidebar */}
        <div className="space-y-6">
          {/* Current Slip Info */}
          {currentDeliverySlip && selectedSlipId === currentDeliverySlip.id && (
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:document-text" className="w-5 h-5" />
                  Current Slip
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="space-y-2">
                  <div className="flex justify-between text-sm">
                    <span>Reference:</span>
                    <code className="font-medium">
                      {currentDeliverySlip.reference}
                    </code>
                  </div>
                  <div className="flex justify-between text-sm">
                    <span>Total parcels:</span>
                    <span className="font-medium">
                      {currentDeliverySlip.summary.totalParcels}
                    </span>
                  </div>
                  <div className="flex justify-between text-sm">
                    <span>Scanned:</span>
                    <span className="font-medium text-green-600">
                      {currentDeliverySlip.summary.scannedParcels}
                    </span>
                  </div>
                  <div className="flex justify-between text-sm">
                    <span>Pending:</span>
                    <span className="font-medium text-yellow-600">
                      {currentDeliverySlip.summary.unscannedParcels}
                    </span>
                  </div>
                  <div className="flex justify-between text-sm border-t pt-2">
                    <span>Total value:</span>
                    <span className="font-medium">
                      {currentDeliverySlip.summary.totalValue.toFixed(2)} DH
                    </span>
                  </div>
                </div>

                {/* Progress */}
                <div className="space-y-2">
                  <div className="flex justify-between text-sm">
                    <span>Progress</span>
                    <span>
                      {Math.round(
                        (currentDeliverySlip.summary.scannedParcels /
                          currentDeliverySlip.summary.totalParcels) *
                          100
                      )}
                      %
                    </span>
                  </div>
                  <div className="w-full bg-gray-200 rounded-full h-2">
                    <div
                      className="bg-primary h-2 rounded-full"
                      style={{
                        width: `${
                          (currentDeliverySlip.summary.scannedParcels /
                            currentDeliverySlip.summary.totalParcels) *
                          100
                        }%`,
                      }}
                    />
                  </div>
                </div>
              </CardContent>
            </Card>
          )}

          {/* Session Stats */}
          {scanSession.results.length > 0 && (
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:chart-bar" className="w-5 h-5" />
                  Session Stats
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="space-y-2">
                  <div className="flex justify-between text-sm">
                    <span>Scans attempted:</span>
                    <span className="font-medium">
                      {scanSession.results.length}
                    </span>
                  </div>
                  <div className="flex justify-between text-sm">
                    <span>Successful:</span>
                    <span className="font-medium text-green-600">
                      {scanSession.results.filter((r) => r.success).length}
                    </span>
                  </div>
                  <div className="flex justify-between text-sm">
                    <span>Failed:</span>
                    <span className="font-medium text-red-600">
                      {scanSession.results.filter((r) => !r.success).length}
                    </span>
                  </div>
                  <div className="flex justify-between text-sm">
                    <span>Success rate:</span>
                    <span className="font-medium">
                      {scanSession.results.length > 0
                        ? Math.round(
                            (scanSession.results.filter((r) => r.success)
                              .length /
                              scanSession.results.length) *
                              100
                          )
                        : 0}
                      %
                    </span>
                  </div>
                </div>
              </CardContent>
            </Card>
          )}

          {/* Quick Actions */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon icon="heroicons:bolt" className="w-5 h-5" />
                Quick Actions
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-2">
              <Link href="/delivery-slips/create">
                <Button variant="outline" className="w-full">
                  <Icon icon="heroicons:plus" className="w-4 h-4 mr-2" />
                  Create New Slip
                </Button>
              </Link>

              {selectedSlipId && (
                <Link href={`/delivery-slips/${selectedSlipId}`}>
                  <Button variant="outline" className="w-full">
                    <Icon icon="heroicons:eye" className="w-4 h-4 mr-2" />
                    View Slip Details
                  </Button>
                </Link>
              )}

              <Link href="/delivery-slips">
                <Button variant="outline" className="w-full">
                  <Icon icon="heroicons:list-bullet" className="w-4 h-4 mr-2" />
                  All Delivery Slips
                </Button>
              </Link>
            </CardContent>
          </Card>
        </div>
      </div>

      {/* Camera Modal */}
      <Dialog open={showCamera} onOpenChange={stopCamera}>
        <DialogContent className="max-w-2xl">
          <DialogHeader>
            <DialogTitle>Camera Scanner</DialogTitle>
            <DialogDescription>
              Position the barcode or QR code within the camera frame
            </DialogDescription>
          </DialogHeader>
          <div className="space-y-4">
            {cameraError ? (
              <Alert color="destructive">
                <Icon
                  icon="heroicons:exclamation-triangle"
                  className="h-4 w-4"
                />
                <AlertDescription>{cameraError}</AlertDescription>
              </Alert>
            ) : (
              <div className="relative">
                <video
                  ref={videoRef}
                  autoPlay
                  playsInline
                  className="w-full h-64 bg-black rounded-lg"
                />
                {/* Overlay for scan area */}
                <div className="absolute inset-0 border-2 border-primary border-dashed rounded-lg opacity-50 pointer-events-none" />
              </div>
            )}
            <div className="flex justify-end gap-2">
              <Button variant="outline" onClick={stopCamera}>
                Close Camera
              </Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>
    </div>
  );
};
// Main component wrapped with ProtectedRoute
const ScannerDeliverySlipsPage = () => {
  return (
    <ProtectedRoute
      requiredPermissions={[PARCELS_PERMISSIONS.DELIVERY_SLIPS_SCAN]}
      requiredAccessLevel="LIMITED"
      allowedAccountStatuses={["ACTIVE"]}
    >
      <ScannerDeliverySlipsPageContent />
    </ProtectedRoute>
  );
};
export default ScannerDeliverySlipsPage;
-----------------------------------------------------------------------
--++--> app/[locale]/[...not-found]/page.tsx
--++--> app/[locale]/auth/forgot-password/page.tsx
--++--> app/[locale]/auth/login/page.tsx
--++--> app/[locale]/auth/register/page.tsx
--++--> app/[locale]/auth/reset-password/page.tsx
-----------------------------------------------------------------------
Components Folder:
-----------------------------------------------------------------------
--++--> components/route/protected-route.tsx =======>
-----------------------------------------------------------------------
"use client";
import { useEffect, useState, useRef, useMemo, useCallback } from "react";
import { useRouter, usePathname } from "next/navigation";
import { useAuthStore } from "@/lib/stores/auth/auth.store";
import { useTenantStore } from "@/lib/stores/auth/tenant.store";
import { toast } from "sonner";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Button } from "@/components/ui/button";
import {
  AlertCircle,
  Info,
  CheckCircle,
  Clock,
  Shield,
  UserX,
} from "lucide-react";
interface ProtectedRouteProps {
  children: React.ReactNode;
  requiredRoles?: string[];
  requiredPermissions?: string[];
  requiredUserTypes?: string[]; // Added this line
  requiredAccessLevel?: "NO_ACCESS" | "PROFILE_ONLY" | "LIMITED" | "FULL";
  allowedAccountStatuses?: string[];
  requireValidation?: boolean;
}
interface AccessResult {
  allowed: boolean;
  reason?: string;
  redirectTo?: string;
  showMessage?: boolean;
  messageType?: "info" | "warning" | "error";
}
// Constants
const ACCESS_LEVELS = ["NO_ACCESS", "PROFILE_ONLY", "LIMITED", "FULL"] as const;
const STATUS_CONFIGS = {
  PENDING: {
    icon: Clock,
    color: "text-blue-600",
    message:
      "Your account is pending admin approval. You'll receive an email notification once approved.",
    action: null,
  },
  INACTIVE: {
    icon: Info,
    color: "text-orange-600",
    message:
      "Please complete your profile information to activate your account.",
    action: { label: "Complete Profile", path: "/profile/complete" },
  },
  PENDING_VALIDATION: {
    icon: Shield,
    color: "text-yellow-600",
    message:
      "Your profile is under review. You have limited access until validation is complete.",
    action: null,
  },
  ACTIVE: {
    icon: CheckCircle,
    color: "text-green-600",
    message: "Your account is fully active and validated.",
    action: null,
  },
  REJECTED: {
    icon: UserX,
    color: "text-red-600",
    message:
      "Your account has been rejected. Please contact support for assistance.",
    action: { label: "Contact Support", path: "/contact" },
  },
  SUSPENDED: {
    icon: UserX,
    color: "text-red-600",
    message: "Your account has been suspended. Please contact support.",
    action: { label: "Contact Support", path: "/contact" },
  },
} as const;
const BLOCKED_REASONS = {
  PENDING: "Your account is pending admin approval",
  REJECTED: "Your account has been rejected. Please contact support",
  SUSPENDED: "Your account has been suspended. Please contact support",
} as const;
export function ProtectedRoute({
  children,
  requiredRoles = [],
  requiredPermissions = [],
  requiredUserTypes = [], // Added this line
  requiredAccessLevel,
  allowedAccountStatuses = [],
  requireValidation = false,
}: ProtectedRouteProps) {
  const router = useRouter();
  const pathname = usePathname();
  const [isInitialized, setIsInitialized] = useState(false);
  const [accessResult, setAccessResult] = useState<AccessResult>({
    allowed: false,
  });
  const initRef = useRef(false);
  const lastCheckRef = useRef<string>("");

  // Stable selectors to prevent unnecessary re-renders
  const isAuthenticated = useAuthStore((state) => state.isAuthenticated);
  const isLoading = useAuthStore((state) => state.isLoading);
  const user = useAuthStore((state) => state.user);
  const error = useAuthStore((state) => state.error);
  const isCheckingAuth = useAuthStore((state) => state.isCheckingAuth);
  const accountStatus = useAuthStore((state) => state.accountStatus);
  const validationStatus = useAuthStore((state) => state.validationStatus);
  const accessLevel = useAuthStore((state) => state.accessLevel);
  const requirements = useAuthStore((state) => state.requirements);
  const hasBlueCheckmark = useAuthStore((state) => state.hasBlueCheckmark);

  // Stable method references
  const checkAuth = useAuthStore((state) => state.checkAuth);
  const isAccountBlocked = useAuthStore((state) => state.isAccountBlocked);
  const needsProfileCompletion = useAuthStore(
    (state) => state.needsProfileCompletion
  );
  const needsValidation = useAuthStore((state) => state.needsValidation);
  const hasRole = useAuthStore((state) => state.hasRole);
  const hasAnyPermission = useAuthStore((state) => state.hasAnyPermission);
  const hasUserType = useAuthStore((state) => state.hasUserType); // Added this line

  const { fetchCurrentTenant, currentTenant } = useTenantStore();

  // Stable access check function with useCallback
  const checkAccess = useCallback((): AccessResult => {
    // Not authenticated
    if (!isAuthenticated || !user) {
      return {
        allowed: false,
        redirectTo: "/auth/login",
        reason: "Authentication required",
      };
    }

    // Account blocked scenarios
    if (isAccountBlocked()) {
      const status = accountStatus;
      const reason = status
        ? BLOCKED_REASONS[status as keyof typeof BLOCKED_REASONS]
        : "Access denied";
      const messageType = status === "PENDING" ? "info" : "error";

      return {
        allowed: false,
        redirectTo: "/auth/login",
        reason,
        showMessage: true,
        messageType,
      };
    }

    // Profile completion check
    if (needsProfileCompletion()) {
      if (
        pathname.includes("/profile/complete") ||
        pathname.includes("/auth")
      ) {
        return { allowed: true };
      }

      return {
        allowed: false,
        redirectTo: "/profile/complete",
        reason: "Please complete your profile to continue",
        showMessage: true,
        messageType: "info",
      };
    }

    // Access level check
    if (requiredAccessLevel) {
      const requiredIndex = ACCESS_LEVELS.indexOf(requiredAccessLevel);
      const currentIndex = ACCESS_LEVELS.indexOf(accessLevel || "NO_ACCESS");

      if (currentIndex < requiredIndex) {
        const isValidationRequired =
          requiredAccessLevel === "FULL" && needsValidation();
        const reason = isValidationRequired
          ? "This feature requires profile validation"
          : "Insufficient access level";

        return {
          allowed: false,
          redirectTo: "/dashboard",
          reason,
          showMessage: true,
          messageType: "warning",
        };
      }
    }

    // Account status check
    if (allowedAccountStatuses.length > 0 && accountStatus) {
      if (!allowedAccountStatuses.includes(accountStatus)) {
        return {
          allowed: false,
          redirectTo: "/dashboard",
          reason: "Your account status does not allow access to this feature",
          showMessage: true,
          messageType: "warning",
        };
      }
    }

    // Validation requirement check
    if (requireValidation && validationStatus !== "VALIDATED") {
      return {
        allowed: false,
        redirectTo: "/dashboard",
        reason: "This feature requires a validated account",
        showMessage: true,
        messageType: "warning",
      };
    }

    // User type check (Added this section)
    if (requiredUserTypes.length > 0) {
      const hasRequiredUserType = requiredUserTypes.some(
        (userType) => user.userType === userType
      );
      if (!hasRequiredUserType) {
        return {
          allowed: false,
          redirectTo: "/unauthorized",
          reason: "Access restricted to specific user types",
          showMessage: true,
          messageType: "error",
        };
      }
    }

    // Role check
    if (requiredRoles.length > 0) {
      const hasRequiredRole = requiredRoles.some((role) => hasRole(role));
      if (!hasRequiredRole) {
        return {
          allowed: false,
          redirectTo: "/unauthorized",
          reason: "Insufficient role permissions",
          showMessage: true,
          messageType: "error",
        };
      }
    }

    // Permission check
    if (requiredPermissions.length > 0) {
      const hasRequiredPermissions = hasAnyPermission(requiredPermissions);
      if (!hasRequiredPermissions) {
        return {
          allowed: false,
          redirectTo: "/unauthorized",
          reason: "Insufficient permissions",
          showMessage: true,
          messageType: "error",
        };
      }
    }

    return { allowed: true };
  }, [
    isAuthenticated,
    user,
    isAccountBlocked,
    accountStatus,
    needsProfileCompletion,
    pathname,
    accessLevel,
    requiredAccessLevel,
    needsValidation,
    allowedAccountStatuses,
    requireValidation,
    validationStatus,
    requiredUserTypes, // Added this line
    requiredRoles,
    hasRole,
    requiredPermissions,
    hasAnyPermission,
  ]);

  // Create a unique key for the current state to prevent unnecessary re-checks
  const stateKey = useMemo(() => {
    return [
      isAuthenticated,
      user?.id,
      user?.userType, // Added this line
      accountStatus,
      validationStatus,
      accessLevel,
      pathname,
      requiredAccessLevel,
      JSON.stringify(allowedAccountStatuses),
      requireValidation,
      JSON.stringify(requiredUserTypes), // Added this line
      JSON.stringify(requiredRoles),
      JSON.stringify(requiredPermissions),
    ].join("|");
  }, [
    isAuthenticated,
    user?.id,
    user?.userType, // Added this line
    accountStatus,
    validationStatus,
    accessLevel,
    pathname,
    requiredAccessLevel,
    allowedAccountStatuses,
    requireValidation,
    requiredUserTypes, // Added this line
    requiredRoles,
    requiredPermissions,
  ]);

  // Initialize authentication - only once
  useEffect(() => {
    if (initRef.current) return;
    initRef.current = true;

    const initialize = async () => {
      try {
        if (!isCheckingAuth) {
          await checkAuth();
        }

        // Fetch tenant data if authenticated and not loaded
        if (isAuthenticated && user && !currentTenant) {
          await fetchCurrentTenant().catch(console.error);
        }
      } catch (error) {
        console.error("Auth initialization failed:", error);
      } finally {
        setIsInitialized(true);
      }
    };

    initialize();
  }, []); // Empty dependency array - only run once

  // Check access when state changes
  useEffect(() => {
    if (!isInitialized || isLoading || isCheckingAuth) return;

    // Prevent unnecessary re-checks
    if (lastCheckRef.current === stateKey) return;
    lastCheckRef.current = stateKey;

    const result = checkAccess();
    setAccessResult(result);
  }, [isInitialized, isLoading, isCheckingAuth, stateKey, checkAccess]);

  // Handle redirects and messages - separate effect to prevent loops
  useEffect(() => {
    if (!isInitialized || isLoading || isCheckingAuth || accessResult.allowed) {
      return;
    }

    // Only show message and redirect if we have a valid access result
    if (accessResult.reason) {
      if (accessResult.showMessage) {
        const toastFn = {
          error: toast.error,
          warning: toast.warning,
          info: toast.info,
        }[accessResult.messageType || "info"];

        toastFn(accessResult.reason);
      }

      if (accessResult.redirectTo) {
        router.replace(accessResult.redirectTo);
      }
    }
  }, [
    accessResult.allowed,
    accessResult.reason,
    accessResult.redirectTo,
    accessResult.showMessage,
    accessResult.messageType,
    isInitialized,
    isLoading,
    isCheckingAuth,
    router,
  ]);

  // Loading state
  if (!isInitialized || isLoading || isCheckingAuth) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center space-y-4">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto" />
          <p className="text-muted-foreground">Initializing...</p>
        </div>
      </div>
    );
  }

  // Error state
  if (error) {
    return (
      <div className="flex items-center justify-center min-h-screen p-4">
        <div className="max-w-md w-full space-y-6 text-center">
          <Alert variant="outline">
            <AlertCircle className="h-4 w-4" />
            <AlertDescription>
              <div className="font-medium">Authentication Error</div>
              <div className="text-sm mt-1">{error}</div>
            </AlertDescription>
          </Alert>
          <Button
            onClick={() => {
              initRef.current = false;
              window.location.reload();
            }}
            className="w-full"
          >
            Retry
          </Button>
        </div>
      </div>
    );
  }

  // Access denied state
  if (!accessResult.allowed) {
    const statusConfig = accountStatus
      ? STATUS_CONFIGS[accountStatus as keyof typeof STATUS_CONFIGS]
      : null;

    const IconComponent = statusConfig?.icon || AlertCircle;

    return (
      <div className="flex items-center justify-center min-h-screen p-4">
        <div className="max-w-md w-full space-y-6 text-center">
          <div className="flex justify-center">
            <div className="rounded-full bg-default-100 p-3">
              <IconComponent
                className={`h-12 w-12 ${
                  statusConfig?.color || "text-gray-600"
                }`}
              />
            </div>
          </div>

          <div className="space-y-3">
            <h3 className="text-xl font-semibold text-default-900">
              Access Status
            </h3>
            <p className="text-sm text-default-600 leading-relaxed">
              {statusConfig?.message || accessResult.reason || "Access denied"}
            </p>

            {hasBlueCheckmark && (
              <div className="flex items-center justify-center gap-2 text-sm text-green-600">
                <CheckCircle className="h-4 w-4" />
                Verified Account
              </div>
            )}

            {requirements.length > 0 && (
              <div className="text-left">
                <div className="text-sm font-medium text-default-700 mb-2">
                  Requirements:
                </div>
                <ul className="text-xs text-default-600 space-y-1">
                  {requirements.map((req, index) => (
                    <li key={index} className="flex items-center gap-2">
                      <div className="w-1.5 h-1.5 rounded-full bg-default-400" />
                      {req}
                    </li>
                  ))}
                </ul>
              </div>
            )}
          </div>

          <div className="space-y-3">
            {statusConfig?.action && (
              <Button
                onClick={() => router.push(statusConfig.action!.path)}
                className="w-full"
              >
                {statusConfig.action.label}
              </Button>
            )}

            <Button
              variant="outline"
              onClick={() => router.push("/auth/login")}
              className="w-full"
            >
              Back to Login
            </Button>
          </div>

          {process.env.NODE_ENV === "development" && (
            <div className="mt-4 p-3 bg-muted rounded-lg text-xs text-left text-muted-foreground">
              <strong>Dev Info:</strong>
              <br />
              <strong>Account Status:</strong> {accountStatus}
              <br />
              <strong>Validation Status:</strong> {validationStatus}
              <br />
              <strong>Access Level:</strong> {accessLevel}
              <br />
              <strong>Required Access:</strong> {requiredAccessLevel || "Any"}
              <br />
              <strong>Required User Types:</strong>{" "}
              {requiredUserTypes.length > 0
                ? requiredUserTypes.join(", ")
                : "Any"}
              <br />
              <strong>Current User Type:</strong> {user?.userType || "None"}
              <br />
              <strong>Reason:</strong> {accessResult.reason}
            </div>
          )}
        </div>
      </div>
    );
  }

  return <>{children}</>;
}
-----------------------------------------------------------------------
--++--> components/users/bulk-actions-bar.tsx =======>
-----------------------------------------------------------------------
"use client";
import React, { useState } from "react";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Icon } from "@/components/ui/icon";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { useDeliverySlipsStore } from "@/lib/stores/parcels/delivery-slips.store";
import { toast } from "sonner";
interface BulkActionsBarProps {
  selectedCount: number;
  onClearSelection: () => void;
}
export const BulkActionsBar: React.FC<BulkActionsBarProps> = ({
  selectedCount,
  onClearSelection,
}) => {
  const { selectedSlipIds, bulkAction } = useDeliverySlipsStore();
  const [showReceiveDialog, setShowReceiveDialog] = useState(false);
  const [showCancelDialog, setShowCancelDialog] = useState(false);
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [isProcessing, setIsProcessing] = useState(false);

  const handleBulkReceive = async () => {
    setIsProcessing(true);
    try {
      const success = await bulkAction({
        slipIds: selectedSlipIds,
        action: "RECEIVE",
        comment: "Bulk received from table actions",
      });

      if (success) {
        setShowReceiveDialog(false);
        onClearSelection();
        toast.success(
          `Successfully received ${selectedSlipIds.length} delivery slips`
        );
      }
    } catch (error) {
      toast.error("Failed to receive delivery slips");
    } finally {
      setIsProcessing(false);
    }
  };

  const handleBulkCancel = async () => {
    setIsProcessing(true);
    try {
      const success = await bulkAction({
        slipIds: selectedSlipIds,
        action: "CANCEL",
        comment: "Bulk cancelled from table actions",
      });

      if (success) {
        setShowCancelDialog(false);
        onClearSelection();
        toast.success(
          `Successfully cancelled ${selectedSlipIds.length} delivery slips`
        );
      }
    } catch (error) {
      toast.error("Failed to cancel delivery slips");
    } finally {
      setIsProcessing(false);
    }
  };

  const handleBulkDelete = async () => {
    setIsProcessing(true);
    try {
      const success = await bulkAction({
        slipIds: selectedSlipIds,
        action: "DELETE",
        comment: "Bulk deleted from table actions",
      });

      if (success) {
        setShowDeleteDialog(false);
        onClearSelection();
        toast.success(
          `Successfully deleted ${selectedSlipIds.length} delivery slips`
        );
      }
    } catch (error) {
      toast.error("Failed to delete delivery slips");
    } finally {
      setIsProcessing(false);
    }
  };

  return (
    <>
      <div className="flex items-center justify-between p-3 bg-primary/5 border border-primary/20 rounded-lg">
        <div className="flex items-center gap-3">
          <Badge color="secondary" className="flex items-center gap-1">
            <Icon icon="heroicons:check-circle" className="w-3 h-3" />
            {selectedCount} selected
          </Badge>
          <span className="text-sm text-muted-foreground">
            Bulk actions available for selected delivery slips
          </span>
        </div>

        <div className="flex items-center gap-2">
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button size="sm" disabled={isProcessing}>
                <Icon
                  icon="heroicons:ellipsis-horizontal"
                  className="w-4 h-4 mr-2"
                />
                Bulk Actions
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              <DropdownMenuItem onClick={() => setShowReceiveDialog(true)}>
                <Icon
                  icon="heroicons:check"
                  className="mr-2 h-4 w-4 text-green-600"
                />
                Mark as Received
              </DropdownMenuItem>

              <DropdownMenuSeparator />

              <DropdownMenuItem onClick={() => setShowCancelDialog(true)}>
                <Icon
                  icon="heroicons:x-circle"
                  className="mr-2 h-4 w-4 text-yellow-600"
                />
                Cancel Slips
              </DropdownMenuItem>

              <DropdownMenuItem onClick={() => setShowDeleteDialog(true)}>
                <Icon
                  icon="heroicons:trash"
                  className="mr-2 h-4 w-4 text-red-600"
                />
                Delete Slips
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>

          <Button
            variant="outline"
            size="sm"
            onClick={onClearSelection}
            disabled={isProcessing}
          >
            Clear Selection
          </Button>
        </div>
      </div>

      {/* Bulk Receive Dialog */}
      <AlertDialog open={showReceiveDialog} onOpenChange={setShowReceiveDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Bulk Mark as Received</AlertDialogTitle>
            <AlertDialogDescription>
              Are you sure you want to mark {selectedCount} delivery slip
              {selectedCount !== 1 ? "s" : ""} as received? This will update the
              status of all parcels in these slips.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={isProcessing}>
              Cancel
            </AlertDialogCancel>
            <AlertDialogAction
              onClick={handleBulkReceive}
              disabled={isProcessing}
            >
              {isProcessing && (
                <Icon
                  icon="heroicons:arrow-path"
                  className="mr-2 h-4 w-4 animate-spin"
                />
              )}
              Mark as Received
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* Bulk Cancel Dialog */}
      <AlertDialog open={showCancelDialog} onOpenChange={setShowCancelDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Bulk Cancel Slips</AlertDialogTitle>
            <AlertDialogDescription>
              Are you sure you want to cancel {selectedCount} delivery slip
              {selectedCount !== 1 ? "s" : ""}? This action will change their
              status to cancelled.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={isProcessing}>
              Cancel
            </AlertDialogCancel>
            <AlertDialogAction
              onClick={handleBulkCancel}
              disabled={isProcessing}
              className="bg-yellow-600 text-white hover:bg-yellow-700"
            >
              {isProcessing && (
                <Icon
                  icon="heroicons:arrow-path"
                  className="mr-2 h-4 w-4 animate-spin"
                />
              )}
              Cancel Slips
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* Bulk Delete Dialog */}
      <AlertDialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Bulk Delete Slips</AlertDialogTitle>
            <AlertDialogDescription>
              Are you sure you want to delete {selectedCount} delivery slip
              {selectedCount !== 1 ? "s" : ""}? This action cannot be undone and
              will reset all parcels back to "NEW_PACKAGE" status.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={isProcessing}>
              Cancel
            </AlertDialogCancel>
            <AlertDialogAction
              onClick={handleBulkDelete}
              disabled={isProcessing}
              className="bg-red-600 text-white hover:bg-red-700"
            >
              {isProcessing && (
                <Icon
                  icon="heroicons:arrow-path"
                  className="mr-2 h-4 w-4 animate-spin"
                />
              )}
              Delete Slips
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
};
-----------------------------------------------------------------------
--++--> components/users/delivery-slips-stats.tsx =======>
-----------------------------------------------------------------------
"use client";
import React from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Icon } from "@/components/ui/icon";
import { DeliverySlipStats } from "@/lib/types/parcels/delivery-slips.types";
interface DeliverySlipsStatsProps {
  statistics: DeliverySlipStats;
}
export const DeliverySlipsStats: React.FC<DeliverySlipsStatsProps> = ({
  statistics,
}) => {
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
      {/* Total Slips */}
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Total Slips</CardTitle>
          <Icon
            icon="heroicons:document-text"
            className="h-4 w-4 text-muted-foreground"
          />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">{statistics.totalSlips}</div>
          <div className="text-xs text-muted-foreground mt-1">
            <span className="text-green-600">
              {statistics.receivedSlips} received
            </span>
            {" • "}
            <span className="text-yellow-600">
              {statistics.pendingSlips} pending
            </span>
            {statistics.cancelledSlips > 0 && (
              <>
                {" • "}
                <span className="text-red-600">
                  {statistics.cancelledSlips} cancelled
                </span>
              </>
            )}
          </div>
        </CardContent>
      </Card>

      {/* Total Parcels */}
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Total Parcels</CardTitle>
          <Icon
            icon="heroicons:cube"
            className="h-4 w-4 text-muted-foreground"
          />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">
            {statistics.totalParcelsInSlips}
          </div>
          <div className="text-xs text-muted-foreground mt-1">
            Avg {statistics.averageParcelsPerSlip.toFixed(1)} per slip
          </div>
        </CardContent>
      </Card>

      {/* Total Value */}
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Total Value</CardTitle>
          <Icon
            icon="heroicons:banknotes"
            className="h-4 w-4 text-muted-foreground"
          />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">
            {statistics.totalValueInSlips.toLocaleString()} DH
          </div>
          <div className="text-xs text-muted-foreground mt-1">
            All delivery slips
          </div>
        </CardContent>
      </Card>

      {/* Processing Rate */}
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Processing Rate</CardTitle>
          <Icon
            icon="heroicons:chart-bar"
            className="h-4 w-4 text-muted-foreground"
          />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">
            {statistics.totalSlips > 0
              ? Math.round(
                  (statistics.receivedSlips / statistics.totalSlips) * 100
                )
              : 0}
            %
          </div>
          <div className="text-xs text-muted-foreground mt-1">
            Slips received
          </div>
        </CardContent>
      </Card>

      {/* Recent Activity Chart */}
      {statistics.recentActivity.length > 0 && (
        <Card className="md:col-span-2">
          <CardHeader>
            <CardTitle className="text-sm font-medium flex items-center gap-2">
              <Icon icon="heroicons:chart-line" className="h-4 w-4" />
              Recent Activity (Last 7 Days)
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="space-y-2">
              {statistics.recentActivity.slice(0, 5).map((activity, index) => (
                <div
                  key={index}
                  className="flex items-center justify-between py-1"
                >
                  <div className="text-sm">
                    {new Date(activity.date).toLocaleDateString("en-US", {
                      month: "short",
                      day: "numeric",
                    })}
                  </div>
                  <div className="flex items-center gap-4 text-xs">
                    <div className="flex items-center gap-1">
                      <div className="w-2 h-2 bg-blue-500 rounded-full" />
                      <span>{activity.slipsCreated} created</span>
                    </div>
                    <div className="flex items-center gap-1">
                      <div className="w-2 h-2 bg-green-500 rounded-full" />
                      <span>{activity.slipsReceived} received</span>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </CardContent>
        </Card>
      )}

      {/* Top Cities */}
      {statistics.topCities.length > 0 && (
        <Card className="md:col-span-2">
          <CardHeader>
            <CardTitle className="text-sm font-medium flex items-center gap-2">
              <Icon icon="heroicons:map-pin" className="h-4 w-4" />
              Top Cities
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="space-y-2">
              {statistics.topCities.slice(0, 5).map((city, index) => (
                <div
                  key={index}
                  className="flex items-center justify-between py-1"
                >
                  <div className="flex items-center gap-2">
                    <Badge color="primary" className="text-xs">
                      #{index + 1}
                    </Badge>
                    <span className="text-sm">{city.cityName}</span>
                  </div>
                  <div className="text-xs text-muted-foreground">
                    {city.slipCount} slips • {city.parcelCount} parcels
                  </div>
                </div>
              ))}
            </div>
          </CardContent>
        </Card>
      )}
    </div>
  );
};
-----------------------------------------------------------------------
--++--> components/users/delivery-slips-table.tsx =======>
-----------------------------------------------------------------------
"use client";
import React from "react";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Checkbox } from "@/components/ui/checkbox";
import { Icon } from "@/components/ui/icon";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Link } from "@/i18n/routing";
import { useDeliverySlipsStore } from "@/lib/stores/parcels/delivery-slips.store";
import {
  DeliverySlip,
  DeliverySlipStatus,
} from "@/lib/types/parcels/delivery-slips.types";
import { cn } from "@/lib/utils/ui.utils";
interface DeliverySlipsTableProps {
  deliverySlips: DeliverySlip[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
  isLoading: boolean;
  onPageChange: (page: number) => void;
  canUpdate: boolean;
  canDelete: boolean;
  canBulkActions: boolean;
}
const statusConfig = {
  [DeliverySlipStatus.PENDING]: {
    label: "Pending",
    color: "bg-yellow-100 text-yellow-800",
    icon: "heroicons:clock",
  },
  [DeliverySlipStatus.RECEIVED]: {
    label: "Received",
    color: "bg-green-100 text-green-800",
    icon: "heroicons:check-circle",
  },
  [DeliverySlipStatus.CANCELLED]: {
    label: "Cancelled",
    color: "bg-red-100 text-red-800",
    icon: "heroicons:x-circle",
  },
};
const formatDate = (dateString: string) => {
  return new Date(dateString).toLocaleDateString("en-US", {
    month: "short",
    day: "2-digit",
    year: "numeric",
    hour: "2-digit",
    minute: "2-digit",
  });
};
export const DeliverySlipsTable: React.FC<DeliverySlipsTableProps> = ({
  deliverySlips,
  pagination,
  isLoading,
  onPageChange,
  canUpdate,
  canDelete,
  canBulkActions,
}) => {
  const {
    selectedSlipIds,
    setSelectedSlipIds,
    receiveSlip,
    deleteDeliverySlip,
  } = useDeliverySlipsStore();

  const handleSelectAll = (checked: boolean) => {
    if (checked) {
      setSelectedSlipIds(deliverySlips.map((slip) => slip.id));
    } else {
      setSelectedSlipIds([]);
    }
  };

  const handleSelectSlip = (slipId: string, checked: boolean) => {
    if (checked) {
      setSelectedSlipIds([...selectedSlipIds, slipId]);
    } else {
      setSelectedSlipIds(selectedSlipIds.filter((id) => id !== slipId));
    }
  };

  const handleReceiveSlip = async (slipId: string) => {
    await receiveSlip(slipId, {
      notes: "Marked as received from table action",
    });
  };

  const handleDeleteSlip = async (slipId: string) => {
    if (window.confirm("Are you sure you want to delete this delivery slip?")) {
      await deleteDeliverySlip(slipId);
    }
  };

  if (isLoading) {
    return (
      <div className="p-8">
        <div className="space-y-4">
          {[...Array(5)].map((_, i) => (
            <div key={i} className="h-12 bg-gray-100 rounded animate-pulse" />
          ))}
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-4">
      <div className="overflow-x-auto">
        <Table>
          <TableHeader>
            <TableRow>
              {canBulkActions && (
                <TableHead className="w-12">
                  <Checkbox
                    checked={
                      deliverySlips.length > 0 &&
                      selectedSlipIds.length === deliverySlips.length
                    }
                    onCheckedChange={handleSelectAll}
                  />
                </TableHead>
              )}
              <TableHead>Reference</TableHead>
              <TableHead>Status</TableHead>
              <TableHead>Created</TableHead>
              <TableHead>City</TableHead>
              <TableHead>Parcels</TableHead>
              <TableHead>Progress</TableHead>
              <TableHead>Value</TableHead>
              <TableHead className="text-right">Actions</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {deliverySlips.length === 0 ? (
              <TableRow>
                <TableCell
                  colSpan={canBulkActions ? 9 : 8}
                  className="text-center py-8"
                >
                  <div className="space-y-2">
                    <Icon
                      icon="heroicons:document-text"
                      className="w-12 h-12 text-muted-foreground mx-auto"
                    />
                    <p className="text-muted-foreground">
                      No delivery slips found
                    </p>
                  </div>
                </TableCell>
              </TableRow>
            ) : (
              deliverySlips.map((slip) => {
                const statusInfo = statusConfig[slip.status];
                const canModify = slip.status === DeliverySlipStatus.PENDING;
                const progressPercent =
                  slip.summary.totalParcels > 0
                    ? Math.round(
                        (slip.summary.scannedParcels /
                          slip.summary.totalParcels) *
                          100
                      )
                    : 0;

                return (
                  <TableRow key={slip.id}>
                    {canBulkActions && (
                      <TableCell>
                        <Checkbox
                          checked={selectedSlipIds.includes(slip.id)}
                          onCheckedChange={(checked) =>
                            handleSelectSlip(slip.id, checked as boolean)
                          }
                        />
                      </TableCell>
                    )}
                    <TableCell>
                      <Link
                        href={`/delivery-slips/${slip.id}`}
                        className="hover:underline"
                      >
                        <code className="text-sm font-medium text-primary">
                          {slip.reference}
                        </code>
                      </Link>
                    </TableCell>
                    <TableCell>
                      <Badge className={cn("text-xs", statusInfo.color)}>
                        <Icon icon={statusInfo.icon} className="w-3 h-3 mr-1" />
                        {statusInfo.label}
                      </Badge>
                    </TableCell>
                    <TableCell className="text-sm">
                      {formatDate(slip.createdAt)}
                    </TableCell>
                    <TableCell>
                      {slip.city ? (
                        <Badge color="primary" className="text-xs">
                          {slip.city.name}
                        </Badge>
                      ) : (
                        <span className="text-xs text-muted-foreground">
                          Not specified
                        </span>
                      )}
                    </TableCell>
                    <TableCell>
                      <div className="text-sm">
                        <span className="font-medium">
                          {slip.summary.totalParcels}
                        </span>
                        <span className="text-muted-foreground"> total</span>
                      </div>
                      {slip.summary.scannedParcels > 0 && (
                        <div className="text-xs text-green-600">
                          {slip.summary.scannedParcels} scanned
                        </div>
                      )}
                    </TableCell>
                    <TableCell>
                      <div className="flex items-center gap-2">
                        <div className="w-16 bg-gray-200 rounded-full h-1.5">
                          <div
                            className="bg-primary h-1.5 rounded-full"
                            style={{ width: `${progressPercent}%` }}
                          />
                        </div>
                        <span className="text-xs text-muted-foreground min-w-[35px]">
                          {progressPercent}%
                        </span>
                      </div>
                    </TableCell>
                    <TableCell>
                      <Badge color="primary" className="text-xs">
                        {slip.summary.totalValue.toFixed(2)} DH
                      </Badge>
                    </TableCell>
                    <TableCell className="text-right">
                      <DropdownMenu>
                        <DropdownMenuTrigger asChild>
                          <Button variant="ghost" size="sm">
                            <Icon
                              icon="heroicons:ellipsis-horizontal"
                              className="w-4 h-4"
                            />
                          </Button>
                        </DropdownMenuTrigger>
                        <DropdownMenuContent align="end">
                          <DropdownMenuItem asChild>
                            <Link href={`/delivery-slips/${slip.id}`}>
                              <Icon
                                icon="heroicons:eye"
                                className="mr-2 h-4 w-4"
                              />
                              View Details
                            </Link>
                          </DropdownMenuItem>

                          {canUpdate && canModify && (
                            <DropdownMenuItem asChild>
                              <Link href={`/delivery-slips/${slip.id}/edit`}>
                                <Icon
                                  icon="heroicons:pencil-square"
                                  className="mr-2 h-4 w-4"
                                />
                                Edit Slip
                              </Link>
                            </DropdownMenuItem>
                          )}

                          <DropdownMenuItem asChild>
                            <Link href={`/delivery-slips/${slip.id}/scan`}>
                              <Icon
                                icon="heroicons:qr-code"
                                className="mr-2 h-4 w-4"
                              />
                              Scan Parcels
                            </Link>
                          </DropdownMenuItem>

                          <DropdownMenuSeparator />

                          {canModify && (
                            <DropdownMenuItem
                              onClick={() => handleReceiveSlip(slip.id)}
                            >
                              <Icon
                                icon="heroicons:check"
                                className="mr-2 h-4 w-4 text-green-600"
                              />
                              Mark as Received
                            </DropdownMenuItem>
                          )}

                          <DropdownMenuItem>
                            <Icon
                              icon="heroicons:document-arrow-down"
                              className="mr-2 h-4 w-4"
                            />
                            Download PDF
                          </DropdownMenuItem>

                          <DropdownMenuItem>
                            <Icon
                              icon="heroicons:tag"
                              className="mr-2 h-4 w-4"
                            />
                            Download Labels
                          </DropdownMenuItem>

                          {canDelete && canModify && (
                            <>
                              <DropdownMenuSeparator />
                              <DropdownMenuItem
                                className="text-red-600 focus:text-red-600"
                                onClick={() => handleDeleteSlip(slip.id)}
                              >
                                <Icon
                                  icon="heroicons:trash"
                                  className="mr-2 h-4 w-4"
                                />
                                Delete Slip
                              </DropdownMenuItem>
                            </>
                          )}
                        </DropdownMenuContent>
                      </DropdownMenu>
                    </TableCell>
                  </TableRow>
                );
              })
            )}
          </TableBody>
        </Table>
      </div>

      {/* Pagination */}
      {pagination.totalPages > 1 && (
        <div className="flex items-center justify-between px-4 py-3 border-t">
          <div className="text-sm text-muted-foreground">
            Showing {(pagination.page - 1) * pagination.limit + 1} to{" "}
            {Math.min(pagination.page * pagination.limit, pagination.total)} of{" "}
            {pagination.total} results
          </div>
          <div className="flex items-center gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={() => onPageChange(pagination.page - 1)}
              disabled={!pagination.hasPrev}
            >
              <Icon icon="heroicons:chevron-left" className="w-4 h-4" />
              Previous
            </Button>

            <div className="flex items-center gap-1">
              {[...Array(Math.min(5, pagination.totalPages))].map((_, i) => {
                const pageNum = Math.max(
                  1,
                  Math.min(
                    pagination.page - 2 + i,
                    pagination.totalPages - 4 + i
                  )
                );

                if (pageNum > pagination.totalPages) return null;

                return (
                  <Button
                    key={pageNum}
                    variant={
                      pageNum === pagination.page ? "default" : "outline"
                    }
                    size="sm"
                    onClick={() => onPageChange(pageNum)}
                    className="w-8 h-8 p-0"
                  >
                    {pageNum}
                  </Button>
                );
              })}
            </div>

            <Button
              variant="outline"
              size="sm"
              onClick={() => onPageChange(pagination.page + 1)}
              disabled={!pagination.hasNext}
            >
              Next
              <Icon icon="heroicons:chevron-right" className="w-4 h-4" />
            </Button>
          </div>
        </div>
      )}
    </div>
  );
};
-----------------------------------------------------------------------
Lib Folder:
-----------------------------------------------------------------------
--++--> lib/api/clients/parcels/delivery-slips.client.ts =======>
-----------------------------------------------------------------------
import { BaseApiClient, ApiResponse } from "../../base.client";
import type {
  DeliverySlip,
  CreateDeliverySlipRequest,
  UpdateDeliverySlipRequest,
  DeliverySlipFilters,
  AddParcelsToSlipRequest,
  RemoveParcelsFromSlipRequest,
  ReceiveSlipRequest,
  DeliverySlipStats,
  BulkSlipActionRequest,
  AvailableParcel,
  PaginatedDeliverySlips,
} from "@/lib/types/parcels/delivery-slips.types";
export class DeliverySlipsApiClient extends BaseApiClient {
  constructor() {
    super("parcels");
  }

  // ========================================
  // DELIVERY SLIP MANAGEMENT ENDPOINTS
  // ========================================

  /**
   * Create new delivery slip
   */
  async createDeliverySlip(
    request: CreateDeliverySlipRequest
  ): Promise<ApiResponse<DeliverySlip>> {
    return this.post<DeliverySlip>("/api/delivery-slips", request);
  }

  /**
   * Get delivery slips with filters and pagination
   */
  async getDeliverySlips(filters?: DeliverySlipFilters) {
    return this.getPaginated<DeliverySlip>("/api/delivery-slips", filters);
  }

  /**
   * Get delivery slip by ID
   */
  async getDeliverySlipById(id: string): Promise<ApiResponse<DeliverySlip>> {
    return this.get<DeliverySlip>(`/api/delivery-slips/${id}`);
  }

  /**
   * Update delivery slip
   */
  async updateDeliverySlip(
    id: string,
    request: UpdateDeliverySlipRequest
  ): Promise<ApiResponse<DeliverySlip>> {
    return this.patch<DeliverySlip>(`/api/delivery-slips/${id}`, request);
  }

  /**
   * Delete delivery slip
   */
  async deleteDeliverySlip(id: string): Promise<ApiResponse<void>> {
    return this.delete<void>(`/api/delivery-slips/${id}`);
  }

  // ========================================
  // PARCEL MANAGEMENT WITHIN SLIPS
  // ========================================

  /**
   * Add parcels to delivery slip
   */
  async addParcelsToSlip(
    slipId: string,
    request: AddParcelsToSlipRequest
  ): Promise<ApiResponse<DeliverySlip>> {
    return this.post<DeliverySlip>(
      `/api/delivery-slips/${slipId}/add-parcels`,
      request
    );
  }

  /**
   * Remove parcels from delivery slip
   */
  async removeParcelsFromSlip(
    slipId: string,
    request: RemoveParcelsFromSlipRequest
  ): Promise<ApiResponse<DeliverySlip>> {
    return this.post<DeliverySlip>(
      `/api/delivery-slips/${slipId}/remove-parcels`,
      request
    );
  }

  /**
   * Get available parcels for delivery slips
   */
  async getAvailableParcels(
    cityId?: string
  ): Promise<ApiResponse<AvailableParcel[]>> {
    const params = cityId ? { cityId } : {};
    return this.get<AvailableParcel[]>(
      "/api/delivery-slips/available-parcels",
      { params }
    );
  }

  // ========================================
  // DELIVERY SLIP OPERATIONS
  // ========================================

  /**
   * Mark delivery slip as received
   */
  async receiveSlip(
    slipId: string,
    request: ReceiveSlipRequest
  ): Promise<ApiResponse<DeliverySlip>> {
    return this.post<DeliverySlip>(
      `/api/delivery-slips/${slipId}/receive`,
      request
    );
  }

  /**
   * Scan parcel into delivery slip
   */
  async scanParcelIntoSlip(
    slipId: string,
    parcelCode: string
  ): Promise<ApiResponse<any>> {
    return this.post<any>(`/api/delivery-slips/${slipId}/scan/${parcelCode}`);
  }

  // ========================================
  // BULK OPERATIONS
  // ========================================

  /**
   * Perform bulk actions on delivery slips
   */
  async bulkAction(
    request: BulkSlipActionRequest
  ): Promise<
    ApiResponse<{ success: number; failed: number; errors: string[] }>
  > {
    return this.post<{ success: number; failed: number; errors: string[] }>(
      "/api/delivery-slips/bulk-action",
      request
    );
  }

  // ========================================
  // STATISTICS AND ANALYTICS
  // ========================================

  /**
   * Get delivery slip statistics
   */
  async getDeliverySlipStats(): Promise<ApiResponse<DeliverySlipStats>> {
    return this.get<DeliverySlipStats>("/api/delivery-slips/statistics");
  }

  // ========================================
  // EXPORT AND DOWNLOAD OPERATIONS
  // ========================================

  /**
   * Export delivery slips
   */
  async exportDeliverySlips(filters?: DeliverySlipFilters): Promise<Blob> {
    try {
      const response = await this.client.post(
        "/api/delivery-slips/export",
        filters || {},
        {
          responseType: "blob",
        }
      );
      return response.data; // Return the blob directly
    } catch (error) {
      throw error;
    }
  }

  /**
   * Download delivery slip PDF
   */
  async downloadSlipPdf(id: string): Promise<ApiResponse<Blob>> {
    return this.get<Blob>(`/api/delivery-slips/${id}/pdf`, {
      responseType: "blob",
    });
  }

  /**
   * Download delivery slip labels
   */
  async downloadSlipLabels(id: string): Promise<ApiResponse<Blob>> {
    return this.get<Blob>(`/api/delivery-slips/${id}/labels`, {
      responseType: "blob",
    });
  }

  // ========================================
  // UTILITY OPERATIONS
  // ========================================

  /**
   * Get delivery slip barcode
   */
  async getSlipBarcode(id: string): Promise<ApiResponse<any>> {
    return this.get<any>(`/api/delivery-slips/${id}/barcode`);
  }
}
// Export singleton instance
export const deliverySlipsApiClient = new DeliverySlipsApiClient();
-----------------------------------------------------------------------
--++--> lib/api/base.client.ts =======>
-----------------------------------------------------------------------
import axios, {
  AxiosInstance,
  AxiosRequestConfig,
  AxiosResponse,
  AxiosError,
  InternalAxiosRequestConfig,
} from "axios";
import { API_CONFIG, ServiceName, ErrorCode } from "@/lib/config/api.config";
import { getTenantFromUrl } from "@/lib/utils/tenant.utils";
// Extend Axios request config to include metadata
interface ExtendedAxiosRequestConfig extends InternalAxiosRequestConfig {
  metadata?: {
    startTime: number;
  };
}
export interface ApiError {
  code: ErrorCode;
  message: string;
  details?: any;
  statusCode?: number;
  timestamp: string;
  requestId?: string;
}
export interface ApiResponse<T = any> {
  success: boolean;
  data?: T;
  error?: ApiError;
  message?: string;
  timestamp: string;
}
export interface PaginatedResponse<T = any> {
  data: T[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
}
export class BaseApiClient {
  protected client: AxiosInstance;
  protected serviceName: ServiceName;
  protected tenantId: string | null = null;

  constructor(serviceName: ServiceName, customConfig?: AxiosRequestConfig) {
    this.serviceName = serviceName;
    const serviceConfig = API_CONFIG.services[serviceName];

    // Get tenant ID from URL
    this.tenantId = getTenantFromUrl();

    // Create axios instance
    this.client = axios.create({
      baseURL: serviceConfig.baseURL,
      timeout: serviceConfig.timeout,
      headers: {
        ...API_CONFIG.headers.common,
        ...(this.tenantId && { [API_CONFIG.headers.tenant]: this.tenantId }),
      },
      ...customConfig,
    });

    this.setupInterceptors();
  }

  private setupInterceptors(): void {
    // Request interceptor
    this.client.interceptors.request.use(
      (config: ExtendedAxiosRequestConfig) => {
        // Add auth token
        const token = this.getAuthToken();
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }

        // Add tenant ID if available
        if (this.tenantId) {
          config.headers[API_CONFIG.headers.tenant] = this.tenantId;
        }

        // Add request timestamp for debugging
        config.metadata = { startTime: Date.now() };

        return config;
      },
      (error) => Promise.reject(this.transformError(error))
    );

    // Response interceptor
    this.client.interceptors.response.use(
      (response: AxiosResponse) => {
        // Log response time for monitoring
        const endTime = Date.now();
        const config = response.config as ExtendedAxiosRequestConfig;
        const startTime = config.metadata?.startTime || endTime;
        const duration = endTime - startTime;

        if (duration > 3000) {
          console.warn(
            `Slow API request detected: ${response.config.url} took ${duration}ms`
          );
        }

        return response;
      },
      async (error: AxiosError) => {
        // Handle token refresh
        if (error.response?.status === 401 && this.serviceName === "auth") {
          const refreshed = await this.attemptTokenRefresh();
          if (refreshed && error.config) {
            // Retry original request with new token
            const token = this.getAuthToken();
            if (token) {
              error.config.headers.Authorization = `Bearer ${token}`;
            }
            return this.client.request(error.config);
          }
        }

        return Promise.reject(this.transformError(error));
      }
    );
  }

  private getAuthToken(): string | null {
    if (typeof window === "undefined") return null;
    return localStorage.getItem("auth_token");
  }

  private async attemptTokenRefresh(): Promise<boolean> {
    try {
      const refreshToken = localStorage.getItem("refresh_token");
      if (!refreshToken) return false;

      // Only attempt refresh from auth service
      if (this.serviceName !== "auth") return false;

      const response = await axios.post(
        `${API_CONFIG.services.auth.baseURL}/api/auth/refresh`,
        { refreshToken },
        {
          headers: {
            "Content-Type": "application/json",
            ...(this.tenantId && {
              [API_CONFIG.headers.tenant]: this.tenantId,
            }),
          },
        }
      );

      if (response.data.success && response.data.data) {
        const { accessToken, refreshToken: newRefreshToken } =
          response.data.data;
        localStorage.setItem("auth_token", accessToken);
        if (newRefreshToken) {
          localStorage.setItem("refresh_token", newRefreshToken);
        }
        return true;
      }
    } catch (error) {
      console.error("Token refresh failed:", error);
      this.clearAuthTokens();
    }
    return false;
  }

  private clearAuthTokens(): void {
    if (typeof window !== "undefined") {
      localStorage.removeItem("auth_token");
      localStorage.removeItem("refresh_token");
    }
  }

  private transformError(error: any): ApiError {
    const timestamp = new Date().toISOString();

    // Network or timeout errors
    if (!error.response) {
      return {
        code: error.code === "ECONNABORTED" ? "TIMEOUT_ERROR" : "NETWORK_ERROR",
        message: error.message || "Network error occurred",
        timestamp,
      };
    }

    // HTTP errors with response
    const { status, data } = error.response;
    const statusCode = status;

    // Map status codes to error codes
    let code: ErrorCode = "SERVER_ERROR";
    switch (statusCode) {
      case 400:
        code = "VALIDATION_ERROR";
        break;
      case 401:
        code = "AUTH_ERROR";
        break;
      case 403:
        code = "PERMISSION_ERROR";
        break;
      case 404:
        code = "NOT_FOUND";
        break;
      case 409:
        code = "CONFLICT";
        break;
      case 429:
        code = "RATE_LIMIT_ERROR";
        break;
      case 500:
      case 502:
      case 503:
      case 504:
        code = "SERVER_ERROR";
        break;
    }

    return {
      code,
      message:
        data?.message || data?.error || error.message || "An error occurred",
      details: data?.details,
      statusCode,
      timestamp,
      requestId: data?.requestId,
    };
  }

  // Generic HTTP methods
  protected async get<T>(
    endpoint: string,
    config?: AxiosRequestConfig
  ): Promise<ApiResponse<T>> {
    try {
      const response = await this.client.get(endpoint, config);
      return this.transformResponse<T>(response);
    } catch (error) {
      throw error; // Error is already transformed by interceptor
    }
  }

  protected async post<T>(
    endpoint: string,
    data?: any,
    config?: AxiosRequestConfig
  ): Promise<ApiResponse<T>> {
    try {
      const response = await this.client.post(endpoint, data, config);
      return this.transformResponse<T>(response);
    } catch (error) {
      throw error;
    }
  }

  protected async put<T>(
    endpoint: string,
    data?: any,
    config?: AxiosRequestConfig
  ): Promise<ApiResponse<T>> {
    try {
      const response = await this.client.put(endpoint, data, config);
      return this.transformResponse<T>(response);
    } catch (error) {
      throw error;
    }
  }

  protected async patch<T>(
    endpoint: string,
    data?: any,
    config?: AxiosRequestConfig
  ): Promise<ApiResponse<T>> {
    try {
      const response = await this.client.patch(endpoint, data, config);
      return this.transformResponse<T>(response);
    } catch (error) {
      throw error;
    }
  }

  protected async delete<T>(
    endpoint: string,
    config?: AxiosRequestConfig
  ): Promise<ApiResponse<T>> {
    try {
      const response = await this.client.delete(endpoint, config);
      return this.transformResponse<T>(response);
    } catch (error) {
      throw error;
    }
  }

  // Paginated requests
  protected async getPaginated<T>(
    endpoint: string,
    params?: Record<string, any>,
    config?: AxiosRequestConfig
  ): Promise<PaginatedResponse<T>> {
    try {
      const response = await this.client.get(endpoint, {
        ...config,
        params: { ...params, ...config?.params },
      });

      // Handle different response formats
      if (response.data.data && response.data.pagination) {
        // Standard paginated format: { data: T[], pagination: {...} }
        return response.data;
      } else if (Array.isArray(response.data.data)) {
        // Array wrapped in data property: { data: T[] }
        return {
          data: response.data.data,
          pagination: {
            page: 1,
            limit: response.data.data.length,
            total: response.data.data.length,
            totalPages: 1,
            hasNext: false,
            hasPrev: false,
          },
        };
      } else if (Array.isArray(response.data)) {
        // Direct array response: T[]
        return {
          data: response.data,
          pagination: {
            page: 1,
            limit: response.data.length,
            total: response.data.length,
            totalPages: 1,
            hasNext: false,
            hasPrev: false,
          },
        };
      } else if (response.data.success && response.data.data) {
        // Wrapped in success envelope: { success: true, data: T[] }
        const data = Array.isArray(response.data.data)
          ? response.data.data
          : [response.data.data];
        return {
          data,
          pagination: {
            page: 1,
            limit: data.length,
            total: data.length,
            totalPages: 1,
            hasNext: false,
            hasPrev: false,
          },
        };
      }

      // Log the actual response structure for debugging
      console.error("Unexpected response structure:", {
        data: response.data,
        dataType: typeof response.data,
        isArray: Array.isArray(response.data),
        hasData: "data" in response.data,
        hasSuccess: "success" in response.data,
        hasPagination: "pagination" in response.data,
      });

      throw new Error(
        `Invalid paginated response format. Expected array or paginated object, got: ${typeof response.data}`
      );
    } catch (error) {
      throw error;
    }
  }

  private transformResponse<T>(response: AxiosResponse): ApiResponse<T> {
    return {
      success: true,
      data: response.data.data || response.data,
      message: response.data.message,
      timestamp: new Date().toISOString(),
    };
  }

  // Utility methods
  public setTenant(tenantId: string): void {
    this.tenantId = tenantId;
    this.client.defaults.headers[API_CONFIG.headers.tenant] = tenantId;
  }

  public clearTenant(): void {
    this.tenantId = null;
    delete this.client.defaults.headers[API_CONFIG.headers.tenant];
  }

  public getServiceName(): ServiceName {
    return this.serviceName;
  }

  public getBaseURL(): string {
    return this.client.defaults.baseURL || "";
  }
}
-----------------------------------------------------------------------
--++--> lib/stores/parcels/parcels.store.ts =======>
-----------------------------------------------------------------------
import { create } from "zustand";
import { persist } from "zustand/middleware";
import { parcelsApiClient } from "@/lib/api/clients/parcels/parcels.client";
import type {
  Parcel,
  CreateParcelRequest,
  UpdateParcelRequest,
  ParcelFilters,
  ParcelStatistics,
  ChangeParcelStatusRequest,
  BulkParcelActionRequest,
  BulkActionResult,
  PaginatedParcelsResponse,
} from "@/lib/types/parcels/parcels.types";
import { toast } from "sonner";
interface ParcelsState {
  // Core state
  parcels: Parcel[];
  myParcels: Parcel[];
  currentParcel: Parcel | null;
  statistics: ParcelStatistics | null;

  // UI state
  isLoading: boolean;
  isCreating: boolean;
  isUpdating: boolean;
  isDeleting: boolean;
  error: string | null;

  // Pagination state
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };

  // Filters state
  filters: ParcelFilters;

  // Selection state for bulk operations
  selectedIds: string[];

  parcelHistory: Array<{
    id: string;
    statusCode: string;
    statusName: string;
    comment?: string;
    changedAt: string;
    changedBy?: string;
  }>;
  isLoadingHistory: boolean;

  // Actions
  setFilters: (filters: Partial<ParcelFilters>) => void;
  clearFilters: () => void;
  setSelectedIds: (ids: string[]) => void;
  clearSelectedIds: () => void;

  // API Actions
  fetchParcels: () => Promise<void>;
  fetchMyParcels: () => Promise<void>;
  fetchParcelById: (id: string) => Promise<Parcel | null>;
  createParcel: (data: CreateParcelRequest) => Promise<Parcel | null>;
  updateParcel: (
    id: string,
    data: UpdateParcelRequest
  ) => Promise<Parcel | null>;
  deleteParcel: (id: string) => Promise<boolean>;
  changeParcelStatus: (
    id: string,
    data: ChangeParcelStatusRequest
  ) => Promise<boolean>;
  updatePaymentStatus: (
    id: string,
    paymentStatus: string,
    comment?: string
  ) => Promise<boolean>;

  // Specialized fetches
  fetchPickupReadyParcels: () => Promise<void>;
  fetchParcelsByStatus: (statusCode: string) => Promise<void>;
  searchParcelsByPhone: (phone: string) => Promise<void>;

  // Bulk operations
  bulkAction: (
    data: BulkParcelActionRequest
  ) => Promise<BulkActionResult | null>;
  bulkChangeStatus: (
    parcelIds: string[],
    statusCode: string,
    comment?: string
  ) => Promise<boolean>;
  bulkDeleteParcels: (parcelIds: string[]) => Promise<boolean>;

  // Statistics
  fetchStatistics: () => Promise<void>;
  fetchParcelHistory: (id: string) => Promise<void>;

  // Utility methods
  getParcelById: (id: string) => Parcel | undefined;
  getParcelsByStatus: (statusCode: string) => Parcel[];
  resetState: () => void;
  clearError: () => void;
}
const DEFAULT_FILTERS: ParcelFilters = {
  page: 1,
  limit: 10,
  search: "",
  sortBy: "createdAt",
  sortParcel: "desc",
};
const DEFAULT_PAGINATION = {
  page: 1,
  limit: 10,
  total: 0,
  totalPages: 0,
  hasNext: false,
  hasPrev: false,
};
export const useParcelsStore = create<ParcelsState>()(
  persist(
    (set, get) => ({
      // Initial state
      parcels: [],
      myParcels: [],
      currentParcel: null,
      statistics: null,
      isLoading: false,
      isCreating: false,
      isUpdating: false,
      isDeleting: false,
      error: null,
      pagination: DEFAULT_PAGINATION,
      filters: DEFAULT_FILTERS,
      selectedIds: [],
      parcelHistory: [],
      isLoadingHistory: false,

      // Filter actions
      setFilters: (newFilters) => {
        const updatedFilters = { ...get().filters, ...newFilters };
        set({ filters: updatedFilters });

        // Reset to page 1 if search or other filters changed
        if ("search" in newFilters || "statusCode" in newFilters) {
          set({ filters: { ...updatedFilters, page: 1 } });
        }

        // Auto-fetch with new filters
        get().fetchParcels();
      },

      clearFilters: () => {
        set({ filters: DEFAULT_FILTERS });
        get().fetchParcels();
      },

      setSelectedIds: (ids) => set({ selectedIds: ids }),
      clearSelectedIds: () => set({ selectedIds: [] }),

      // Fetch parcels with filters and pagination
      fetchParcels: async () => {
        const { filters } = get();
        set({ isLoading: true, error: null });

        try {
          const response = await parcelsApiClient.getParcels(filters);

          if (response.data && response.data.length) {
            set({
              parcels: response.data[0].data,
              pagination: response.data[0].meta,
              isLoading: false,
            });
          } else {
            throw new Error(
              response.error?.message || "Failed to fetch parcels"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error fetching parcels:", error);
          set({ error: errorMessage, isLoading: false });
          toast.error("Failed to fetch parcels");
        }
      },

      // Fetch current user's parcels
      fetchMyParcels: async () => {
        const { filters } = get();
        set({ isLoading: true, error: null });

        try {
          const response = await parcelsApiClient.getMyParcels(filters);

          if (response.success && response.data) {
            set({
              myParcels: response.data.data,
              pagination: response.data.meta,
              isLoading: false,
            });
          } else {
            throw new Error(
              response.error?.message || "Failed to fetch my parcels"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error fetching my parcels:", error);
          set({ error: errorMessage, isLoading: false });
          toast.error("Failed to fetch your parcels");
        }
      },

      // Fetch parcel by ID
      fetchParcelById: async (id: string) => {
        set({ isLoading: true, error: null });

        try {
          const response = await parcelsApiClient.getParcelById(id);

          if (response.success && response.data) {
            set({ currentParcel: response.data, isLoading: false });
            return response.data;
          } else {
            throw new Error(response.error?.message || "Parcel not found");
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error fetching parcel:", error);
          set({
            error: errorMessage,
            isLoading: false,
            currentParcel: null,
          });
          toast.error("Failed to fetch parcel details");
          return null;
        }
      },

      // Create parcel
      createParcel: async (data: CreateParcelRequest) => {
        set({ isCreating: true, error: null });

        try {
          const response = await parcelsApiClient.createParcel(data);

          if (response.success && response.data) {
            const newParcel = response.data;

            // Add to list if it matches current filters
            const { parcels } = get();
            set({
              parcels: [newParcel, ...parcels],
              isCreating: false,
            });

            toast.success("Parcel created successfully");

            // Refresh the list to get accurate pagination
            get().fetchParcels();

            return newParcel;
          } else {
            throw new Error(
              response.error?.message || "Failed to create parcel"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error creating parcel:", error);
          set({ error: errorMessage, isCreating: false });
          toast.error(`Failed to create parcel: ${errorMessage}`);
          return null;
        }
      },

      // Update parcel
      updateParcel: async (id: string, data: UpdateParcelRequest) => {
        set({ isUpdating: true, error: null });

        try {
          const response = await parcelsApiClient.updateParcel(id, data);

          if (response.success && response.data) {
            const updatedParcel = response.data;

            // Update in list
            const { parcels } = get();
            const updatedList = parcels.map((parcel) =>
              parcel.id === id ? updatedParcel : parcel
            );

            set({
              parcels: updatedList,
              currentParcel: updatedParcel,
              isUpdating: false,
            });

            toast.success("Parcel updated successfully");
            return updatedParcel;
          } else {
            throw new Error(
              response.error?.message || "Failed to update parcel"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error updating parcel:", error);
          set({ error: errorMessage, isUpdating: false });
          toast.error(`Failed to update parcel: ${errorMessage}`);
          return null;
        }
      },

      // Delete parcel
      deleteParcel: async (id: string) => {
        set({ isDeleting: true, error: null });

        try {
          const response = await parcelsApiClient.deleteParcel(id);

          if (response.success) {
            // Remove from list
            const { parcels } = get();
            const updatedList = parcels.filter((parcel) => parcel.id !== id);

            set({
              parcels: updatedList,
              currentParcel: null,
              isDeleting: false,
            });

            toast.success("Parcel deleted successfully");

            // Refresh to get accurate pagination
            get().fetchParcels();

            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to delete parcel"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error deleting parcel:", error);
          set({ error: errorMessage, isDeleting: false });
          toast.error(`Failed to delete parcel: ${errorMessage}`);
          return false;
        }
      },

      // Change parcel status
      changeParcelStatus: async (
        id: string,
        data: ChangeParcelStatusRequest
      ) => {
        try {
          const response = await parcelsApiClient.changeParcelStatus(id, data);

          if (response.success && response.data) {
            const updatedParcel = response.data;

            // Update in list
            const { parcels } = get();
            const updatedList = parcels.map((parcel) =>
              parcel.id === id ? updatedParcel : parcel
            );

            set({
              parcels: updatedList,
              currentParcel: updatedParcel,
            });

            toast.success(`Parcel status changed to ${data.statusCode}`);
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to change parcel status"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error changing parcel status:", error);
          toast.error(`Failed to change status: ${errorMessage}`);
          return false;
        }
      },

      // Update payment status
      updatePaymentStatus: async (
        id: string,
        paymentStatus: string,
        comment?: string
      ) => {
        try {
          const response = await parcelsApiClient.updatePaymentStatus(
            id,
            paymentStatus,
            comment
          );

          if (response.success && response.data) {
            const updatedParcel = response.data;

            // Update in list
            const { parcels } = get();
            const updatedList = parcels.map((parcel) =>
              parcel.id === id ? updatedParcel : parcel
            );

            set({
              parcels: updatedList,
              currentParcel: updatedParcel,
            });

            toast.success(`Payment status updated to ${paymentStatus}`);
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to update payment status"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error updating payment status:", error);
          toast.error(`Failed to update payment status: ${errorMessage}`);
          return false;
        }
      },

      // Fetch pickup ready parcels
      fetchPickupReadyParcels: async () => {
        const { filters } = get();
        set({ isLoading: true, error: null });

        try {
          const response = await parcelsApiClient.getPickupReadyParcels(
            filters
          );

          if (response.success && response.data) {
            set({
              parcels: response.data.data,
              pagination: response.data.meta,
              isLoading: false,
            });
          }
        } catch (error) {
          console.error("Error fetching pickup ready parcels:", error);
          toast.error("Failed to fetch pickup ready parcels");
          set({ isLoading: false });
        }
      },

      // Fetch parcels by status
      fetchParcelsByStatus: async (statusCode: string) => {
        const { filters } = get();
        set({ isLoading: true, error: null });

        try {
          const response = await parcelsApiClient.getParcelsByStatus(
            statusCode,
            filters
          );

          if (response.success && response.data) {
            set({
              parcels: response.data.data,
              pagination: response.data.meta,
              isLoading: false,
            });
          }
        } catch (error) {
          console.error("Error fetching parcels by status:", error);
          toast.error("Failed to fetch parcels by status");
          set({ isLoading: false });
        }
      },

      // Search parcels by phone
      searchParcelsByPhone: async (phone: string) => {
        const { filters } = get();
        set({ isLoading: true, error: null });

        try {
          const response = await parcelsApiClient.searchParcelsByPhone(
            phone,
            filters
          );

          if (response.success && response.data) {
            set({
              parcels: response.data.data,
              pagination: response.data.meta,
              isLoading: false,
            });
          }
        } catch (error) {
          console.error("Error searching parcels by phone:", error);
          toast.error("Failed to search parcels by phone");
          set({ isLoading: false });
        }
      },

      // Bulk action
      bulkAction: async (data: BulkParcelActionRequest) => {
        set({ isLoading: true, error: null });

        try {
          const response = await parcelsApiClient.bulkAction(data);

          if (response.success && response.data) {
            toast.success(
              `Bulk action completed: ${response.data.success} successful, ${response.data.failed} failed`
            );

            if (response.data.failed > 0) {
              toast.warning(
                `${response.data.failed} parcels could not be processed`
              );
            }

            // Clear selection and refresh
            set({ selectedIds: [], isLoading: false });
            get().fetchParcels();

            return response.data;
          } else {
            throw new Error(
              response.error?.message || "Failed to perform bulk action"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error performing bulk action:", error);
          set({ error: errorMessage, isLoading: false });
          toast.error(`Failed to perform bulk action: ${errorMessage}`);
          return null;
        }
      },

      // Bulk change status
      bulkChangeStatus: async (
        parcelIds: string[],
        statusCode: string,
        comment?: string
      ) => {
        try {
          const response = await parcelsApiClient.bulkChangeStatus(
            parcelIds,
            statusCode,
            comment
          );

          if (response.success && response.data) {
            toast.success(
              `${response.data.success} parcels status changed successfully`
            );

            if (response.data.failed > 0) {
              toast.warning(
                `${response.data.failed} parcels could not be updated`
              );
            }

            // Clear selection and refresh
            set({ selectedIds: [] });
            get().fetchParcels();

            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to change parcels status"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error changing parcels status:", error);
          toast.error(`Failed to change status: ${errorMessage}`);
          return false;
        }
      },

      // Bulk delete parcels
      bulkDeleteParcels: async (parcelIds: string[]) => {
        set({ isDeleting: true, error: null });

        try {
          const response = await parcelsApiClient.bulkDeleteParcels(parcelIds);

          if (response.success && response.data) {
            toast.success(
              `${response.data.success} parcels deleted successfully`
            );

            if (response.data.failed > 0) {
              toast.warning(
                `${response.data.failed} parcels could not be deleted`
              );
            }

            // Clear selection and refresh
            set({ selectedIds: [], isDeleting: false });
            get().fetchParcels();

            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to delete parcels"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error bulk deleting parcels:", error);
          set({ error: errorMessage, isDeleting: false });
          toast.error(`Failed to delete parcels: ${errorMessage}`);
          return false;
        }
      },

      // Fetch statistics
      fetchStatistics: async () => {
        try {
          const response = await parcelsApiClient.getParcelStatistics();

          if (response.success && response.data) {
            set({ statistics: response.data });
          } else {
            throw new Error(
              response.error?.message || "Failed to fetch statistics"
            );
          }
        } catch (error) {
          console.error("Error fetching parcel statistics:", error);
        }
      },

      fetchParcelHistory: async (id: string) => {
        set({ isLoadingHistory: true, error: null });

        try {
          const response = await parcelsApiClient.getParcelHistory(id);

          if (response.success && response.data) {
            set({
              parcelHistory: response.data,
              isLoadingHistory: false,
            });
          } else {
            throw new Error(
              response.error?.message || "Failed to fetch parcel history"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error fetching parcel history:", error);
          set({
            error: errorMessage,
            isLoadingHistory: false,
            parcelHistory: [],
          });
          toast.error("Failed to fetch parcel history");
        }
      },

      // Utility methods
      getParcelById: (id: string) => {
        const { parcels } = get();
        return parcels.find((parcel) => parcel.id === id);
      },

      getParcelsByStatus: (statusCode: string) => {
        const { parcels } = get();
        return parcels.filter(
          (parcel) => parcel.parcelStatusCode === statusCode
        );
      },

      resetState: () => {
        set({
          parcels: [],
          myParcels: [],
          currentParcel: null,
          statistics: null,
          error: null,
          pagination: DEFAULT_PAGINATION,
          filters: DEFAULT_FILTERS,
          selectedIds: [],
          isLoading: false,
          isCreating: false,
          isUpdating: false,
          isDeleting: false,
        });
      },

      clearError: () => set({ error: null }),
    }),
    {
      name: "parcels-store",
      partialize: (state) => ({
        filters: state.filters,
        pagination: state.pagination,
        // Don't persist loading states or selections
      }),
      version: 1,
    }
  )
);
-----------------------------------------------------------------------
--++--> lib/stores/parcels/delivery-slips.store.ts =======>
-----------------------------------------------------------------------
import { create } from "zustand";
import { persist } from "zustand/middleware";
import { deliverySlipsApiClient } from "@/lib/api/clients/parcels/delivery-slips.client";
import type {
  DeliverySlip,
  CreateDeliverySlipRequest,
  UpdateDeliverySlipRequest,
  DeliverySlipFilters,
  AddParcelsToSlipRequest,
  RemoveParcelsFromSlipRequest,
  ReceiveSlipRequest,
  DeliverySlipStats,
  BulkSlipActionRequest,
  AvailableParcel,
  PaginatedDeliverySlips,
  DeliverySlipStatus,
} from "@/lib/types/parcels/delivery-slips.types";
import { toast } from "sonner";
interface DeliverySlipsState {
  // Core state
  deliverySlips: DeliverySlip[];
  currentDeliverySlip: DeliverySlip | null;
  availableParcels: AvailableParcel[];
  statistics: DeliverySlipStats | null;

  // UI state
  isLoading: boolean;
  isCreating: boolean;
  isUpdating: boolean;
  isDeleting: boolean;
  error: string | null;

  // Pagination state
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };

  // Filters state
  filters: DeliverySlipFilters;

  // Selection state for bulk operations
  selectedSlipIds: string[];

  // Actions
  setFilters: (filters: Partial<DeliverySlipFilters>) => void;
  clearFilters: () => void;
  setSelectedSlipIds: (ids: string[]) => void;
  clearSelectedSlipIds: () => void;

  // API Actions
  fetchDeliverySlips: () => Promise<void>;
  fetchDeliverySlipById: (id: string) => Promise<DeliverySlip | null>;
  createDeliverySlip: (
    data: CreateDeliverySlipRequest
  ) => Promise<DeliverySlip | null>;
  updateDeliverySlip: (
    id: string,
    data: UpdateDeliverySlipRequest
  ) => Promise<DeliverySlip | null>;
  deleteDeliverySlip: (id: string) => Promise<boolean>;

  // Slip operations
  addParcelsToSlip: (
    slipId: string,
    data: AddParcelsToSlipRequest
  ) => Promise<boolean>;
  removeParcelsFromSlip: (
    slipId: string,
    data: RemoveParcelsFromSlipRequest
  ) => Promise<boolean>;
  receiveSlip: (slipId: string, data: ReceiveSlipRequest) => Promise<boolean>;
  scanParcelIntoSlip: (slipId: string, parcelCode: string) => Promise<boolean>;

  // Bulk operations
  bulkAction: (data: BulkSlipActionRequest) => Promise<boolean>;

  // Available parcels
  fetchAvailableParcels: (cityId?: string) => Promise<void>;

  // Statistics
  fetchStatistics: () => Promise<void>;

  // Document operations
  downloadSlipPdf: (id: string) => Promise<boolean>;
  downloadSlipLabels: (id: string) => Promise<boolean>;
  getSlipBarcode: (id: string) => Promise<any | null>;

  // Export
  exportDeliverySlips: (
    filters?: DeliverySlipFilters
  ) => Promise<string | null>;

  // Utility methods
  getSlipById: (id: string) => DeliverySlip | undefined;
  getSlipsByStatus: (status: DeliverySlipStatus) => DeliverySlip[];
  resetState: () => void;
  clearError: () => void;
}
const DEFAULT_FILTERS: DeliverySlipFilters = {
  page: 1,
  limit: 10,
  search: "",
  sortBy: "createdAt",
  sortParcel: "desc",
};
const DEFAULT_PAGINATION = {
  page: 1,
  limit: 10,
  total: 0,
  totalPages: 0,
  hasNext: false,
  hasPrev: false,
};
export const useDeliverySlipsStore = create<DeliverySlipsState>()(
  persist(
    (set, get) => ({
      // Initial state
      deliverySlips: [],
      currentDeliverySlip: null,
      availableParcels: [],
      statistics: null,
      isLoading: false,
      isCreating: false,
      isUpdating: false,
      isDeleting: false,
      error: null,
      pagination: DEFAULT_PAGINATION,
      filters: DEFAULT_FILTERS,
      selectedSlipIds: [],

      // Filter actions
      setFilters: (newFilters) => {
        const updatedFilters = { ...get().filters, ...newFilters };
        set({ filters: updatedFilters });

        // Reset to page 1 if search or other filters changed
        if ("search" in newFilters || "status" in newFilters) {
          set({ filters: { ...updatedFilters, page: 1 } });
        }

        // Auto-fetch with new filters
        get().fetchDeliverySlips();
      },

      clearFilters: () => {
        set({ filters: DEFAULT_FILTERS });
        get().fetchDeliverySlips();
      },

      setSelectedSlipIds: (ids) => set({ selectedSlipIds: ids }),
      clearSelectedSlipIds: () => set({ selectedSlipIds: [] }),

      // Fetch delivery slips with filters and pagination
      fetchDeliverySlips: async () => {
        const { filters } = get();
        set({ isLoading: true, error: null });

        try {
          const response = await deliverySlipsApiClient.getDeliverySlips(
            filters
          );

          if (response.data && response.data.length > 0) {
            set({
              deliverySlips: response.data[0].data,
              pagination: response.data[0].meta,
              isLoading: false,
            });
          } else {
            throw new Error(
              response.error?.message || "Failed to fetch delivery slips"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error fetching delivery slips:", error);
          set({ error: errorMessage, isLoading: false });
          toast.error("Failed to fetch delivery slips");
        }
      },

      // Fetch delivery slip by ID
      fetchDeliverySlipById: async (id: string) => {
        set({ isLoading: true, error: null });

        try {
          const response = await deliverySlipsApiClient.getDeliverySlipById(id);

          if (response.success && response.data) {
            set({
              currentDeliverySlip: response.data,
              isLoading: false,
            });
            return response.data;
          } else {
            throw new Error(
              response.error?.message || "Delivery slip not found"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error fetching delivery slip:", error);
          set({
            error: errorMessage,
            isLoading: false,
            currentDeliverySlip: null,
          });
          toast.error("Failed to fetch delivery slip");
          return null;
        }
      },

      // Create delivery slip
      createDeliverySlip: async (data: CreateDeliverySlipRequest) => {
        set({ isCreating: true, error: null });

        try {
          const response = await deliverySlipsApiClient.createDeliverySlip(
            data
          );

          if (response.success && response.data) {
            const newSlip = response.data;

            // Add to list if it matches current filters
            const { deliverySlips } = get();
            set({
              deliverySlips: [newSlip, ...deliverySlips],
              isCreating: false,
            });

            toast.success("Delivery slip created successfully");

            // Refresh the list to get accurate pagination
            get().fetchDeliverySlips();

            return newSlip;
          } else {
            throw new Error(
              response.error?.message || "Failed to create delivery slip"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error creating delivery slip:", error);
          set({ error: errorMessage, isCreating: false });
          toast.error(`Failed to create delivery slip: ${errorMessage}`);
          return null;
        }
      },

      // Update delivery slip
      updateDeliverySlip: async (
        id: string,
        data: UpdateDeliverySlipRequest
      ) => {
        set({ isUpdating: true, error: null });

        try {
          const response = await deliverySlipsApiClient.updateDeliverySlip(
            id,
            data
          );

          if (response.success && response.data) {
            const updatedSlip = response.data;

            // Update in list
            const { deliverySlips } = get();
            const updatedList = deliverySlips.map((slip) =>
              slip.id === id ? updatedSlip : slip
            );

            set({
              deliverySlips: updatedList,
              currentDeliverySlip: updatedSlip,
              isUpdating: false,
            });

            toast.success("Delivery slip updated successfully");
            return updatedSlip;
          } else {
            throw new Error(
              response.error?.message || "Failed to update delivery slip"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error updating delivery slip:", error);
          set({ error: errorMessage, isUpdating: false });
          toast.error(`Failed to update delivery slip: ${errorMessage}`);
          return null;
        }
      },

      // Delete delivery slip
      deleteDeliverySlip: async (id: string) => {
        set({ isDeleting: true, error: null });

        try {
          const response = await deliverySlipsApiClient.deleteDeliverySlip(id);

          if (response.success) {
            // Remove from list
            const { deliverySlips } = get();
            const updatedList = deliverySlips.filter((slip) => slip.id !== id);

            set({
              deliverySlips: updatedList,
              currentDeliverySlip: null,
              isDeleting: false,
            });

            toast.success("Delivery slip deleted successfully");

            // Refresh to get accurate pagination
            get().fetchDeliverySlips();

            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to delete delivery slip"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error deleting delivery slip:", error);
          set({ error: errorMessage, isDeleting: false });
          toast.error(`Failed to delete delivery slip: ${errorMessage}`);
          return false;
        }
      },

      // Add parcels to slip
      addParcelsToSlip: async (
        slipId: string,
        data: AddParcelsToSlipRequest
      ) => {
        try {
          const response = await deliverySlipsApiClient.addParcelsToSlip(
            slipId,
            data
          );

          if (response.success && response.data) {
            const updatedSlip = response.data;

            // Update current slip if it matches
            const { currentDeliverySlip } = get();
            if (currentDeliverySlip?.id === slipId) {
              set({ currentDeliverySlip: updatedSlip });
            }

            // Update in list
            const { deliverySlips } = get();
            const updatedList = deliverySlips.map((slip) =>
              slip.id === slipId ? updatedSlip : slip
            );
            set({ deliverySlips: updatedList });

            toast.success("Parcels added to delivery slip successfully");
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to add parcels to slip"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error adding parcels to slip:", error);
          toast.error(`Failed to add parcels: ${errorMessage}`);
          return false;
        }
      },

      // Remove parcels from slip
      removeParcelsFromSlip: async (
        slipId: string,
        data: RemoveParcelsFromSlipRequest
      ) => {
        try {
          const response = await deliverySlipsApiClient.removeParcelsFromSlip(
            slipId,
            data
          );

          if (response.success && response.data) {
            const updatedSlip = response.data;

            // Update current slip if it matches
            const { currentDeliverySlip } = get();
            if (currentDeliverySlip?.id === slipId) {
              set({ currentDeliverySlip: updatedSlip });
            }

            // Update in list
            const { deliverySlips } = get();
            const updatedList = deliverySlips.map((slip) =>
              slip.id === slipId ? updatedSlip : slip
            );
            set({ deliverySlips: updatedList });

            toast.success("Parcels removed from delivery slip successfully");
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to remove parcels from slip"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error removing parcels from slip:", error);
          toast.error(`Failed to remove parcels: ${errorMessage}`);
          return false;
        }
      },

      // Receive slip
      receiveSlip: async (slipId: string, data: ReceiveSlipRequest) => {
        try {
          const response = await deliverySlipsApiClient.receiveSlip(
            slipId,
            data
          );

          if (response.success && response.data) {
            const updatedSlip = response.data;

            // Update current slip if it matches
            const { currentDeliverySlip } = get();
            if (currentDeliverySlip?.id === slipId) {
              set({ currentDeliverySlip: updatedSlip });
            }

            // Update in list
            const { deliverySlips } = get();
            const updatedList = deliverySlips.map((slip) =>
              slip.id === slipId ? updatedSlip : slip
            );
            set({ deliverySlips: updatedList });

            toast.success("Delivery slip marked as received successfully");
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to receive slip"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error receiving slip:", error);
          toast.error(`Failed to receive slip: ${errorMessage}`);
          return false;
        }
      },

      // Scan parcel into slip
      scanParcelIntoSlip: async (slipId: string, parcelCode: string) => {
        try {
          const response = await deliverySlipsApiClient.scanParcelIntoSlip(
            slipId,
            parcelCode
          );

          if (response.success) {
            toast.success("Parcel scanned successfully");

            // Refresh current slip to get updated data
            if (get().currentDeliverySlip?.id === slipId) {
              get().fetchDeliverySlipById(slipId);
            }

            return true;
          } else {
            throw new Error(response.error?.message || "Failed to scan parcel");
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error scanning parcel:", error);
          toast.error(`Failed to scan parcel: ${errorMessage}`);
          return false;
        }
      },

      // Bulk action
      bulkAction: async (data: BulkSlipActionRequest) => {
        try {
          const response = await deliverySlipsApiClient.bulkAction(data);

          if (response.success && response.data) {
            toast.success(
              `Bulk action completed: ${response.data.success} successful, ${response.data.failed} failed`
            );

            if (response.data.failed > 0) {
              toast.warning(`${response.data.failed} slips failed to process`);
            }

            // Clear selection and refresh
            set({ selectedSlipIds: [] });
            get().fetchDeliverySlips();

            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to execute bulk action"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error executing bulk action:", error);
          toast.error(`Failed to execute bulk action: ${errorMessage}`);
          return false;
        }
      },

      // Fetch available parcels
      fetchAvailableParcels: async (cityId?: string) => {
        try {
          const response = await deliverySlipsApiClient.getAvailableParcels(
            cityId
          );

          if (response.success && response.data) {
            set({ availableParcels: response.data });
          } else {
            throw new Error(
              response.error?.message || "Failed to fetch available parcels"
            );
          }
        } catch (error) {
          console.error("Error fetching available parcels:", error);
          toast.error("Failed to fetch available parcels");
        }
      },

      // Fetch statistics
      fetchStatistics: async () => {
        try {
          const response = await deliverySlipsApiClient.getDeliverySlipStats();

          if (response.success && response.data) {
            set({ statistics: response.data });
          } else {
            throw new Error(
              response.error?.message || "Failed to fetch statistics"
            );
          }
        } catch (error) {
          console.error("Error fetching delivery slip statistics:", error);
        }
      },

      // Download slip PDF
      downloadSlipPdf: async (id: string) => {
        try {
          const response = await deliverySlipsApiClient.downloadSlipPdf(id);

          if (response.success && response.data) {
            // Create download link
            const url = window.URL.createObjectURL(response.data);
            const a = document.createElement("a");
            a.href = url;
            a.download = `delivery-slip-${id}.pdf`;
            a.click();
            window.URL.revokeObjectURL(url);

            toast.success("PDF downloaded successfully");
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to download PDF"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error downloading PDF:", error);
          toast.error(`Failed to download PDF: ${errorMessage}`);
          return false;
        }
      },

      // Download slip labels
      downloadSlipLabels: async (id: string) => {
        try {
          const response = await deliverySlipsApiClient.downloadSlipLabels(id);

          if (response.success && response.data) {
            // Create download link
            const url = window.URL.createObjectURL(response.data);
            const a = document.createElement("a");
            a.href = url;
            a.download = `delivery-slip-labels-${id}.pdf`;
            a.click();
            window.URL.revokeObjectURL(url);

            toast.success("Labels downloaded successfully");
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to download labels"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error downloading labels:", error);
          toast.error(`Failed to download labels: ${errorMessage}`);
          return false;
        }
      },

      // Get slip barcode
      getSlipBarcode: async (id: string) => {
        try {
          const response = await deliverySlipsApiClient.getSlipBarcode(id);

          if (response.success && response.data) {
            return response.data;
          } else {
            throw new Error(response.error?.message || "Failed to get barcode");
          }
        } catch (error) {
          console.error("Error getting barcode:", error);
          toast.error("Failed to get barcode");
          return null;
        }
      },

      // Export delivery slips
      exportDeliverySlips: async (filters?: DeliverySlipFilters) => {
        set({ isLoading: true, error: null });

        try {
          const filtersToUse = filters || get().filters;
          const blob = await deliverySlipsApiClient.exportDeliverySlips(
            filtersToUse
          );

          // Create download link
          const url = window.URL.createObjectURL(blob);
          const link = document.createElement("a");
          link.href = url;
          link.download = `delivery-slips-${
            new Date().toISOString().split("T")[0]
          }.csv`;
          document.body.appendChild(link); // Required for Firefox
          link.click();
          document.body.removeChild(link);
          window.URL.revokeObjectURL(url);

          set({ isLoading: false });
          toast.success("Export completed successfully");
          return url;
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error exporting delivery slips:", error);
          set({ error: errorMessage, isLoading: false });
          toast.error(`Failed to export delivery slips: ${errorMessage}`);
          return null;
        }
      },

      // Utility methods
      getSlipById: (id: string) => {
        return get().deliverySlips.find((slip) => slip.id === id);
      },

      getSlipsByStatus: (status: DeliverySlipStatus) => {
        return get().deliverySlips.filter((slip) => slip.status === status);
      },

      resetState: () => {
        set({
          deliverySlips: [],
          currentDeliverySlip: null,
          availableParcels: [],
          statistics: null,
          error: null,
          pagination: DEFAULT_PAGINATION,
          filters: DEFAULT_FILTERS,
          selectedSlipIds: [],
          isLoading: false,
          isCreating: false,
          isUpdating: false,
          isDeleting: false,
        });
      },

      clearError: () => set({ error: null }),
    }),
    {
      name: "delivery-slips-store",
      partialize: (state) => ({
        filters: state.filters,
        selectedSlipIds: state.selectedSlipIds,
        // Don't persist loading states or large data
      }),
      version: 1,
    }
  )
);
-----------------------------------------------------------------------
--++--> lib/stores/parcels/cities.store.ts =======>
-----------------------------------------------------------------------
import { create } from "zustand";
import { persist } from "zustand/middleware";
import { citiesApiClient } from "@/lib/api/clients/parcels/cities.client";
import type {
  City,
  CreateCityRequest,
  UpdateCityRequest,
  CitiesFilters,
  ZoneStats,
} from "@/lib/types/parcels/cities.types";
import { toast } from "sonner";
interface CitiesState {
  // Core state
  cities: City[];
  currentCity: City | null;
  isLoading: boolean;
  error: string | null;

  // Pagination
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };

  // Filters
  filters: CitiesFilters;

  // Additional data
  pickupCities: City[];
  zoneStats: ZoneStats[];
  availableZones: string[];

  // Selection for bulk operations
  selectedCityIds: string[];

  // Actions
  setCities: (cities: City[]) => void;
  setCurrentCity: (city: City | null) => void;
  setPagination: (pagination: Partial<CitiesState["pagination"]>) => void;
  setFilters: (filters: Partial<CitiesFilters>) => void;
  clearError: () => void;
  setSelectedCityIds: (ids: string[]) => void;

  // API Actions
  fetchCities: () => Promise<void>;
  fetchCityById: (id: string) => Promise<City | null>;
  createCity: (data: CreateCityRequest) => Promise<boolean>;
  updateCity: (id: string, data: UpdateCityRequest) => Promise<boolean>;
  deleteCity: (id: string) => Promise<boolean>;
  toggleCityStatus: (id: string) => Promise<boolean>;
  fetchPickupCities: () => Promise<void>;
  fetchZoneStats: () => Promise<void>;
  fetchAvailableZones: () => Promise<void>;

  // Bulk operations
  bulkDeleteCities: (ids: string[]) => Promise<boolean>;
  bulkUpdateStatus: (ids: string[], status: boolean) => Promise<boolean>;

  // Search and validation
  searchCities: (query: string) => Promise<City[]>;
  validateCityRef: (ref: string, excludeId?: string) => Promise<boolean>;

  // Reset state
  resetState: () => void;
}
const initialState = {
  cities: [],
  currentCity: null,
  isLoading: false,
  error: null,
  pagination: {
    page: 1,
    limit: 10,
    total: 0,
    totalPages: 0,
    hasNext: false,
    hasPrev: false,
  },
  filters: {
    page: 1,
    limit: 10,
  },
  pickupCities: [],
  zoneStats: [],
  availableZones: [],
  selectedCityIds: [],
};
export const useCitiesStore = create<CitiesState>()(
  persist(
    (set, get) => ({
      ...initialState,

      // Setters
      setCities: (cities) => set({ cities }),

      setCurrentCity: (city) => set({ currentCity: city }),

      setPagination: (pagination) =>
        set((state) => ({
          pagination: { ...state.pagination, ...pagination },
        })),

      setFilters: (filters) => {
        set((state) => {
          const newFilters = { ...state.filters, ...filters };
          // Reset to page 1 when filters change (except page change)
          if (filters.page === undefined) {
            newFilters.page = 1;
          }
          return { filters: newFilters };
        });
        // Auto-fetch when filters change
        get().fetchCities();
      },

      clearError: () => set({ error: null }),

      setSelectedCityIds: (ids) => set({ selectedCityIds: ids }),

      // Fetch cities with current filters
      fetchCities: async () => {
        set({ isLoading: true, error: null });

        try {
          const { filters } = get();
          const response = await citiesApiClient.getCities(filters);

          if (response.success && response.data) {
            set({
              cities: response.data.data,
              pagination: response.data.meta,
              isLoading: false,
            });
          } else {
            throw new Error(
              response.error?.message || "Failed to fetch cities"
            );
          }
        } catch (error: any) {
          set({
            isLoading: false,
            error: error.message || "An error occurred while fetching cities",
          });
          toast.error("Failed to fetch cities");
        }
      },

      // Fetch single city by ID
      fetchCityById: async (id: string) => {
        set({ isLoading: true, error: null });

        try {
          const response = await citiesApiClient.getCityById(id);

          if (response.success && response.data) {
            set({ currentCity: response.data, isLoading: false });
            return response.data;
          } else {
            throw new Error(response.error?.message || "City not found");
          }
        } catch (error: any) {
          set({
            isLoading: false,
            error: error.message || "Failed to fetch city",
          });
          toast.error("Failed to fetch city details");
          return null;
        }
      },

      // Create new city
      createCity: async (data: CreateCityRequest) => {
        set({ isLoading: true, error: null });

        try {
          const response = await citiesApiClient.createCity(data);

          if (response.success && response.data) {
            // Add to local state
            set((state) => ({
              cities: [response.data!, ...state.cities],
              isLoading: false,
            }));

            toast.success("City created successfully");
            return true;
          } else {
            throw new Error(response.error?.message || "Failed to create city");
          }
        } catch (error: any) {
          set({
            isLoading: false,
            error: error.message || "Failed to create city",
          });
          toast.error(error.message || "Failed to create city");
          return false;
        }
      },

      // Update city
      updateCity: async (id: string, data: UpdateCityRequest) => {
        set({ isLoading: true, error: null });

        try {
          const response = await citiesApiClient.updateCity(id, data);

          if (response.success && response.data) {
            // Update in local state
            set((state) => ({
              cities: state.cities.map((city) =>
                city.id === id ? response.data! : city
              ),
              currentCity:
                state.currentCity?.id === id
                  ? response.data!
                  : state.currentCity,
              isLoading: false,
            }));

            toast.success("City updated successfully");
            return true;
          } else {
            throw new Error(response.error?.message || "Failed to update city");
          }
        } catch (error: any) {
          set({
            isLoading: false,
            error: error.message || "Failed to update city",
          });
          toast.error(error.message || "Failed to update city");
          return false;
        }
      },

      // Delete city
      deleteCity: async (id: string) => {
        set({ isLoading: true, error: null });

        try {
          const response = await citiesApiClient.deleteCity(id);

          if (response.success) {
            // Remove from local state
            set((state) => ({
              cities: state.cities.filter((city) => city.id !== id),
              currentCity:
                state.currentCity?.id === id ? null : state.currentCity,
              isLoading: false,
            }));

            toast.success("City deleted successfully");
            return true;
          } else {
            throw new Error(response.error?.message || "Failed to delete city");
          }
        } catch (error: any) {
          set({
            isLoading: false,
            error: error.message || "Failed to delete city",
          });
          toast.error(error.message || "Failed to delete city");
          return false;
        }
      },

      // Toggle city status
      toggleCityStatus: async (id: string) => {
        try {
          const response = await citiesApiClient.toggleCityStatus(id);

          if (response.success && response.data) {
            // Update in local state
            set((state) => ({
              cities: state.cities.map((city) =>
                city.id === id ? response.data! : city
              ),
              currentCity:
                state.currentCity?.id === id
                  ? response.data!
                  : state.currentCity,
            }));

            const status = response.data.status ? "activated" : "deactivated";
            toast.success(`City ${status} successfully`);
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to toggle city status"
            );
          }
        } catch (error: any) {
          toast.error(error.message || "Failed to toggle city status");
          return false;
        }
      },

      // Fetch pickup cities
      fetchPickupCities: async () => {
        try {
          const response = await citiesApiClient.getPickupCities();

          if (response.success && response.data) {
            set({ pickupCities: response.data });
          }
        } catch (error: any) {
          console.error("Failed to fetch pickup cities:", error);
        }
      },

      // Fetch zone statistics
      fetchZoneStats: async () => {
        try {
          const response = await citiesApiClient.getZoneStats();

          if (response.success && response.data) {
            set({ zoneStats: response.data });
          }
        } catch (error: any) {
          console.error("Failed to fetch zone stats:", error);
        }
      },

      // Fetch available zones
      fetchAvailableZones: async () => {
        try {
          const response = await citiesApiClient.getAvailableZones();

          if (response.success && response.data) {
            set({ availableZones: response.data });
          }
        } catch (error: any) {
          console.error("Failed to fetch available zones:", error);
        }
      },

      // Bulk delete cities
      bulkDeleteCities: async (ids: string[]) => {
        set({ isLoading: true, error: null });

        try {
          const response = await citiesApiClient.bulkDeleteCities(ids);

          if (response.success) {
            // Remove from local state
            set((state) => ({
              cities: state.cities.filter((city) => !ids.includes(city.id)),
              selectedCityIds: [],
              isLoading: false,
            }));

            toast.success(
              `${
                response.data?.deleted || ids.length
              } cities deleted successfully`
            );
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to delete cities"
            );
          }
        } catch (error: any) {
          set({
            isLoading: false,
            error: error.message || "Failed to delete cities",
          });
          toast.error(error.message || "Failed to delete cities");
          return false;
        }
      },

      // Bulk update status
      bulkUpdateStatus: async (ids: string[], status: boolean) => {
        set({ isLoading: true, error: null });

        try {
          const response = await citiesApiClient.bulkUpdateCitiesStatus(
            ids,
            status
          );

          if (response.success) {
            // Update in local state
            set((state) => ({
              cities: state.cities.map((city) =>
                ids.includes(city.id) ? { ...city, status } : city
              ),
              selectedCityIds: [],
              isLoading: false,
            }));

            const action = status ? "activated" : "deactivated";
            toast.success(
              `${
                response.data?.updated || ids.length
              } cities ${action} successfully`
            );
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to update cities"
            );
          }
        } catch (error: any) {
          set({
            isLoading: false,
            error: error.message || "Failed to update cities",
          });
          toast.error(error.message || "Failed to update cities");
          return false;
        }
      },

      // Search cities
      searchCities: async (query: string) => {
        try {
          const response = await citiesApiClient.searchCities(query);

          if (response.success && response.data) {
            return response.data;
          }
          return [];
        } catch (error) {
          console.error("Failed to search cities:", error);
          return [];
        }
      },

      // Validate city reference
      validateCityRef: async (ref: string, excludeId?: string) => {
        try {
          const response = await citiesApiClient.validateCityRef(
            ref,
            excludeId
          );

          if (response.success && response.data) {
            return response.data.isUnique;
          }
          return false;
        } catch (error) {
          console.error("Failed to validate city reference:", error);
          return false;
        }
      },

      // Reset state
      resetState: () => set(initialState),
    }),
    {
      name: "cities-store",
      partialize: (state) => ({
        filters: state.filters,
        pagination: state.pagination,
      }),
      version: 1,
    }
  )
);
-----------------------------------------------------------------------
--++--> lib/stores/parcels/pickup-cities.store.ts =======>
-----------------------------------------------------------------------
import { create } from "zustand";
import { persist } from "zustand/middleware";
import { pickupCitiesApiClient } from "@/lib/api/clients/parcels/pickup-cities.client";
import type {
  PickupCity,
  CreatePickupCityRequest,
  UpdatePickupCityRequest,
  PickupCityFilters,
  PaginatedResponse,
  PickupCityStatistics,
} from "@/lib/types/parcels/pickup-cities.types";
import { toast } from "sonner";
interface PickupCitiesState {
  // Core state
  pickupCities: PickupCity[];
  activePickupCities: PickupCity[];
  selectedPickupCity: PickupCity | null;
  statistics: PickupCityStatistics | null;

  // UI state
  isLoading: boolean;
  isCreating: boolean;
  isUpdating: boolean;
  isDeleting: boolean;
  error: string | null;

  // Pagination state
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };

  // Filters state
  filters: PickupCityFilters;

  // Selection state for bulk operations
  selectedIds: string[];

  // Actions
  setFilters: (filters: Partial<PickupCityFilters>) => void;
  clearFilters: () => void;
  setSelectedIds: (ids: string[]) => void;
  clearSelectedIds: () => void;

  // API Actions
  fetchPickupCities: () => Promise<void>;
  fetchActivePickupCities: () => Promise<void>;
  fetchPickupCityById: (id: string) => Promise<PickupCity | null>;
  createPickupCity: (
    data: CreatePickupCityRequest
  ) => Promise<PickupCity | null>;
  updatePickupCity: (
    id: string,
    data: UpdatePickupCityRequest
  ) => Promise<PickupCity | null>;
  deletePickupCity: (id: string) => Promise<boolean>;
  togglePickupCityStatus: (id: string) => Promise<boolean>;

  // Bulk operations
  bulkDeletePickupCities: (ids: string[]) => Promise<boolean>;
  bulkToggleStatus: (ids: string[], status: boolean) => Promise<boolean>;

  // Statistics
  fetchStatistics: () => Promise<void>;

  // Utility methods
  getPickupCityById: (id: string) => PickupCity | undefined;
  resetState: () => void;
  clearError: () => void;
}
const DEFAULT_FILTERS: PickupCityFilters = {
  page: 1,
  limit: 10,
  search: "",
  sortBy: "name",
  sortParcel: "asc",
};
const DEFAULT_PAGINATION = {
  page: 1,
  limit: 10,
  total: 0,
  totalPages: 0,
  hasNext: false,
  hasPrev: false,
};
export const usePickupCitiesStore = create<PickupCitiesState>()(
  persist(
    (set, get) => ({
      // Initial state
      pickupCities: [],
      activePickupCities: [],
      selectedPickupCity: null,
      statistics: null,
      isLoading: false,
      isCreating: false,
      isUpdating: false,
      isDeleting: false,
      error: null,
      pagination: DEFAULT_PAGINATION,
      filters: DEFAULT_FILTERS,
      selectedIds: [],

      // Filter actions
      setFilters: (newFilters) => {
        const updatedFilters = { ...get().filters, ...newFilters };
        set({ filters: updatedFilters });

        // Reset to page 1 if search or other filters changed
        if ("search" in newFilters || "status" in newFilters) {
          set({ filters: { ...updatedFilters, page: 1 } });
        }

        // Auto-fetch with new filters
        get().fetchPickupCities();
      },

      clearFilters: () => {
        set({ filters: DEFAULT_FILTERS });
        get().fetchPickupCities();
      },

      setSelectedIds: (ids) => set({ selectedIds: ids }),
      clearSelectedIds: () => set({ selectedIds: [] }),

      // Fetch pickup cities with filters and pagination
      fetchPickupCities: async () => {
        const { filters } = get();
        set({ isLoading: true, error: null });

        try {
          const response = await pickupCitiesApiClient.getPickupCities(filters);

          if (response.success && response.data) {
            set({
              pickupCities: response.data.data,
              pagination: response.data.meta,
              isLoading: false,
            });
          } else {
            throw new Error(
              response.error?.message || "Failed to fetch pickup cities"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error fetching pickup cities:", error);
          set({ error: errorMessage, isLoading: false });
          toast.error("Failed to fetch pickup cities");
        }
      },

      // Fetch active pickup cities only
      fetchActivePickupCities: async () => {
        try {
          const response = await pickupCitiesApiClient.getActivePickupCities();

          if (response.success && response.data) {
            set({ activePickupCities: response.data });
          } else {
            throw new Error(
              response.error?.message || "Failed to fetch active pickup cities"
            );
          }
        } catch (error) {
          console.error("Error fetching active pickup cities:", error);
          toast.error("Failed to fetch active pickup cities");
        }
      },

      // Fetch pickup city by ID
      fetchPickupCityById: async (id: string) => {
        set({ isLoading: true, error: null });

        try {
          const response = await pickupCitiesApiClient.getPickupCityById(id);

          if (response.success && response.data) {
            set({ selectedPickupCity: response.data, isLoading: false });
            return response.data;
          } else {
            throw new Error(response.error?.message || "Pickup city not found");
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error fetching pickup city:", error);
          set({
            error: errorMessage,
            isLoading: false,
            selectedPickupCity: null,
          });
          toast.error("Failed to fetch pickup city");
          return null;
        }
      },

      // Create pickup city
      createPickupCity: async (data: CreatePickupCityRequest) => {
        set({ isCreating: true, error: null });

        try {
          const response = await pickupCitiesApiClient.createPickupCity(data);

          if (response.success && response.data) {
            const newPickupCity = response.data;

            // Add to list if it matches current filters
            const { pickupCities } = get();
            set({
              pickupCities: [newPickupCity, ...pickupCities],
              isCreating: false,
            });

            toast.success("Pickup city created successfully");

            // Refresh the list to get accurate pagination
            get().fetchPickupCities();

            return newPickupCity;
          } else {
            throw new Error(
              response.error?.message || "Failed to create pickup city"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error creating pickup city:", error);
          set({ error: errorMessage, isCreating: false });
          toast.error(`Failed to create pickup city: ${errorMessage}`);
          return null;
        }
      },

      // Update pickup city
      updatePickupCity: async (id: string, data: UpdatePickupCityRequest) => {
        set({ isUpdating: true, error: null });

        try {
          const response = await pickupCitiesApiClient.updatePickupCity(
            id,
            data
          );

          if (response.success && response.data) {
            const updatedPickupCity = response.data;

            // Update in list
            const { pickupCities } = get();
            const updatedList = pickupCities.map((city) =>
              city.id === id ? updatedPickupCity : city
            );

            set({
              pickupCities: updatedList,
              selectedPickupCity: updatedPickupCity,
              isUpdating: false,
            });

            toast.success("Pickup city updated successfully");
            return updatedPickupCity;
          } else {
            throw new Error(
              response.error?.message || "Failed to update pickup city"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error updating pickup city:", error);
          set({ error: errorMessage, isUpdating: false });
          toast.error(`Failed to update pickup city: ${errorMessage}`);
          return null;
        }
      },

      // Delete pickup city
      deletePickupCity: async (id: string) => {
        set({ isDeleting: true, error: null });

        try {
          const response = await pickupCitiesApiClient.deletePickupCity(id);

          if (response.success) {
            // Remove from list
            const { pickupCities } = get();
            const updatedList = pickupCities.filter((city) => city.id !== id);

            set({
              pickupCities: updatedList,
              selectedPickupCity: null,
              isDeleting: false,
            });

            toast.success("Pickup city deleted successfully");

            // Refresh to get accurate pagination
            get().fetchPickupCities();

            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to delete pickup city"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error deleting pickup city:", error);
          set({ error: errorMessage, isDeleting: false });
          toast.error(`Failed to delete pickup city: ${errorMessage}`);
          return false;
        }
      },

      // Toggle pickup city status
      togglePickupCityStatus: async (id: string) => {
        try {
          const response = await pickupCitiesApiClient.togglePickupCityStatus(
            id
          );

          if (response.success && response.data) {
            const updatedPickupCity = response.data;

            // Update in list
            const { pickupCities } = get();
            const updatedList = pickupCities.map((city) =>
              city.id === id ? updatedPickupCity : city
            );

            set({
              pickupCities: updatedList,
              selectedPickupCity: updatedPickupCity,
            });

            const status = updatedPickupCity.status
              ? "activated"
              : "deactivated";
            toast.success(`Pickup city ${status} successfully`);

            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to toggle pickup city status"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error toggling pickup city status:", error);
          toast.error(`Failed to toggle status: ${errorMessage}`);
          return false;
        }
      },

      // Bulk delete pickup cities
      bulkDeletePickupCities: async (ids: string[]) => {
        set({ isDeleting: true, error: null });

        try {
          const response = await pickupCitiesApiClient.bulkDeletePickupCities(
            ids
          );

          if (response.success && response.data) {
            toast.success(
              `${response.data.successful} pickup cities deleted successfully`
            );

            if (response.data.failed.length > 0) {
              toast.warning(
                `${response.data.failed.length} pickup cities could not be deleted`
              );
            }

            // Clear selection and refresh
            set({ selectedIds: [], isDeleting: false });
            get().fetchPickupCities();

            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to delete pickup cities"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error bulk deleting pickup cities:", error);
          set({ error: errorMessage, isDeleting: false });
          toast.error(`Failed to delete pickup cities: ${errorMessage}`);
          return false;
        }
      },

      // Bulk toggle status
      bulkToggleStatus: async (ids: string[], status: boolean) => {
        try {
          const response = await pickupCitiesApiClient.bulkToggleStatus(
            ids,
            status
          );

          if (response.success && response.data) {
            const action = status ? "activated" : "deactivated";
            toast.success(
              `${response.data.successful} pickup cities ${action} successfully`
            );

            if (response.data.failed.length > 0) {
              toast.warning(
                `${response.data.failed.length} pickup cities could not be ${action}`
              );
            }

            // Clear selection and refresh
            set({ selectedIds: [] });
            get().fetchPickupCities();

            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to update pickup city status"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error bulk toggling pickup city status:", error);
          toast.error(`Failed to update status: ${errorMessage}`);
          return false;
        }
      },

      // Fetch statistics
      fetchStatistics: async () => {
        try {
          const response =
            await pickupCitiesApiClient.getPickupCityStatistics();

          if (response.success && response.data) {
            set({ statistics: response.data });
          } else {
            throw new Error(
              response.error?.message || "Failed to fetch statistics"
            );
          }
        } catch (error) {
          console.error("Error fetching pickup city statistics:", error);
        }
      },

      // Utility methods
      getPickupCityById: (id: string) => {
        const { pickupCities } = get();
        return pickupCities.find((city) => city.id === id);
      },

      resetState: () => {
        set({
          pickupCities: [],
          activePickupCities: [],
          selectedPickupCity: null,
          statistics: null,
          error: null,
          pagination: DEFAULT_PAGINATION,
          filters: DEFAULT_FILTERS,
          selectedIds: [],
          isLoading: false,
          isCreating: false,
          isUpdating: false,
          isDeleting: false,
        });
      },

      clearError: () => set({ error: null }),
    }),
    {
      name: "pickup-cities-store",
      partialize: (state) => ({
        activePickupCities: state.activePickupCities,
        statistics: state.statistics,
        // Don't persist loading states or selections
      }),
      version: 1,
    }
  )
);
-----------------------------------------------------------------------
--++--> lib/stores/parcels/tariffs.store.ts =======>
-----------------------------------------------------------------------
import { create } from "zustand";
import { tariffsApiClient } from "@/lib/api/clients/parcels/tariffs.client";
import type {
  Tariff,
  CreateTariffRequest,
  UpdateTariffRequest,
  TariffFilters,
  TariffCalculationRequest,
  TariffCalculationResult,
  BulkTariffImportRequest,
  BulkImportResult,
} from "@/lib/types/parcels/tariffs.types";
import { toast } from "sonner";
interface TariffState {
  // State
  tariffs: Tariff[];
  currentTariff: Tariff | null;
  isLoading: boolean;
  error: string | null;

  // Pagination
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };

  // Filters
  filters: TariffFilters;

  // Stats
  stats: {
    totalTariffs: number;
    averageDeliveryPrice: number;
    averageReturnPrice: number;
    averageRefusalPrice: number;
    averageDeliveryDelay: number;
    priceRanges: { range: string; count: number }[];
    delayDistribution: { delay: number; count: number }[];
    cityPairCoverage: {
      totalPossiblePairs: number;
      configuredPairs: number;
      coveragePercentage: number;
    };
  } | null;

  // Missing tariffs
  missingTariffs: Array<{
    pickupCityId: string;
    destinationCityId: string;
    pickupCity: {
      id: string;
      name: string;
      ref: string;
    };
    destinationCity: {
      id: string;
      name: string;
      ref: string;
    };
    route: string;
  }>;

  // Calculation result
  calculationResult: TariffCalculationResult | null;

  // Actions
  fetchTariffs: () => Promise<void>;
  fetchTariffById: (id: string) => Promise<void>;
  createTariff: (data: CreateTariffRequest) => Promise<boolean>;
  updateTariff: (id: string, data: UpdateTariffRequest) => Promise<boolean>;
  deleteTariff: (id: string) => Promise<boolean>;
  bulkImportTariffs: (
    data: BulkTariffImportRequest
  ) => Promise<BulkImportResult | null>;
  calculateTariff: (data: TariffCalculationRequest) => Promise<boolean>;
  fetchStats: () => Promise<void>;
  fetchMissingTariffs: () => Promise<void>;
  validateRoute: (
    pickupCityId: string,
    destinationCityId: string,
    excludeId?: string
  ) => Promise<boolean>;
  duplicateTariff: (
    id: string,
    pickupCityId: string,
    destinationCityId: string
  ) => Promise<boolean>;

  // Filter actions
  setFilters: (filters: Partial<TariffFilters>) => void;
  resetFilters: () => void;

  // Utility actions
  setCurrentTariff: (tariff: Tariff | null) => void;
  clearError: () => void;
  clearCalculationResult: () => void;
}
const initialFilters: TariffFilters = {
  page: 1,
  limit: 10,
  search: "",
};
export const useTariffsStore = create<TariffState>((set, get) => ({
  // Initial state
  tariffs: [],
  currentTariff: null,
  isLoading: false,
  error: null,
  pagination: {
    page: 1,
    limit: 10,
    total: 0,
    totalPages: 0,
    hasNext: false,
    hasPrev: false,
  },
  filters: initialFilters,
  stats: null,
  missingTariffs: [],
  calculationResult: null,

  // Fetch tariffs with filters
  fetchTariffs: async () => {
    const { filters } = get();
    set({ isLoading: true, error: null });

    try {
      const result = await tariffsApiClient.getTariffs(filters);

      if (result.data) {
        set({
          tariffs: result.data[0].data,
          pagination: result.data[0].meta,
          isLoading: false,
        });
      } else {
        throw new Error("Failed to fetch tariffs");
      }
    } catch (error: any) {
      console.error("Error fetching tariffs:", error);
      set({
        error: error?.message || "Failed to fetch tariffs",
        isLoading: false,
      });
      toast.error("Failed to fetch tariffs");
    }
  },

  // Fetch single tariff
  fetchTariffById: async (id: string) => {
    set({ isLoading: true, error: null });

    try {
      const result = await tariffsApiClient.getTariffById(id);

      if (result.success && result.data) {
        set({
          currentTariff: result.data,
          isLoading: false,
        });
      } else {
        throw new Error(result.error?.message || "Failed to fetch tariff");
      }
    } catch (error: any) {
      console.error("Error fetching tariff:", error);
      set({
        error: error?.message || "Failed to fetch tariff",
        isLoading: false,
      });
      toast.error("Failed to fetch tariff details");
    }
  },

  // Create tariff
  createTariff: async (data: CreateTariffRequest) => {
    set({ isLoading: true, error: null });

    try {
      const result = await tariffsApiClient.createTariff(data);

      if (result.success && result.data) {
        // Refresh the list
        await get().fetchTariffs();
        set({ isLoading: false });
        toast.success("Tariff created successfully");
        return true;
      } else {
        throw new Error(result.error?.message || "Failed to create tariff");
      }
    } catch (error: any) {
      console.error("Error creating tariff:", error);
      const errorMessage = error?.message || "Failed to create tariff";
      set({
        error: errorMessage,
        isLoading: false,
      });
      toast.error(errorMessage);
      return false;
    }
  },

  // Update tariff
  updateTariff: async (id: string, data: UpdateTariffRequest) => {
    set({ isLoading: true, error: null });

    try {
      const result = await tariffsApiClient.updateTariff(id, data);

      if (result.success && result.data) {
        const { tariffs, currentTariff } = get();

        // Update in list
        const updatedTariffs = tariffs.map((tariff) =>
          tariff.id === id ? result.data! : tariff
        );

        set({
          tariffs: updatedTariffs,
          currentTariff:
            currentTariff?.id === id ? result.data! : currentTariff,
          isLoading: false,
        });

        toast.success("Tariff updated successfully");
        return true;
      } else {
        throw new Error(result.error?.message || "Failed to update tariff");
      }
    } catch (error: any) {
      console.error("Error updating tariff:", error);
      const errorMessage = error?.message || "Failed to update tariff";
      set({
        error: errorMessage,
        isLoading: false,
      });
      toast.error(errorMessage);
      return false;
    }
  },

  // Delete tariff
  deleteTariff: async (id: string) => {
    set({ isLoading: true, error: null });

    try {
      const result = await tariffsApiClient.deleteTariff(id);

      if (result.success) {
        const { tariffs, currentTariff } = get();

        // Remove from list
        const updatedTariffs = tariffs.filter((tariff) => tariff.id !== id);

        set({
          tariffs: updatedTariffs,
          currentTariff: currentTariff?.id === id ? null : currentTariff,
          isLoading: false,
        });

        toast.success("Tariff deleted successfully");
        return true;
      } else {
        throw new Error(result.error?.message || "Failed to delete tariff");
      }
    } catch (error: any) {
      console.error("Error deleting tariff:", error);
      const errorMessage = error?.message || "Failed to delete tariff";
      set({
        error: errorMessage,
        isLoading: false,
      });
      toast.error(errorMessage);
      return false;
    }
  },

  // Bulk import tariffs
  bulkImportTariffs: async (data: BulkTariffImportRequest) => {
    set({ isLoading: true, error: null });

    try {
      const result = await tariffsApiClient.bulkImportTariffs(data);

      if (result.success && result.data) {
        // Refresh the list
        await get().fetchTariffs();
        set({ isLoading: false });

        const importResult = result.data;
        if (importResult.failed > 0) {
          toast.warning(
            `Import completed: ${importResult.success} successful, ${importResult.failed} failed`
          );
        } else {
          toast.success(
            `Successfully imported ${importResult.success} tariffs`
          );
        }

        return importResult;
      } else {
        throw new Error(result.error?.message || "Failed to import tariffs");
      }
    } catch (error: any) {
      console.error("Error importing tariffs:", error);
      const errorMessage = error?.message || "Failed to import tariffs";
      set({
        error: errorMessage,
        isLoading: false,
      });
      toast.error(errorMessage);
      return null;
    }
  },

  // Calculate tariff
  calculateTariff: async (data: TariffCalculationRequest) => {
    set({ isLoading: true, error: null });

    try {
      const result = await tariffsApiClient.calculateTariff(data);

      if (result.success && result.data) {
        set({
          calculationResult: result.data,
          isLoading: false,
        });
        return true;
      } else {
        throw new Error(
          result.error?.message || "No tariff found for this route"
        );
      }
    } catch (error: any) {
      console.error("Error calculating tariff:", error);
      const errorMessage = error?.message || "Failed to calculate tariff";
      set({
        error: errorMessage,
        isLoading: false,
        calculationResult: null,
      });
      toast.error(errorMessage);
      return false;
    }
  },

  // Fetch stats
  fetchStats: async () => {
    try {
      const result = await tariffsApiClient.getTariffStats();

      if (result.success && result.data) {
        set({ stats: result.data });
      }
    } catch (error) {
      console.error("Error fetching tariff stats:", error);
    }
  },

  // Fetch missing tariffs
  fetchMissingTariffs: async () => {
    try {
      const result = await tariffsApiClient.getMissingTariffs();

      if (result.success && result.data) {
        set({ missingTariffs: result.data });
      }
    } catch (error) {
      console.error("Error fetching missing tariffs:", error);
    }
  },

  // Validate route
  validateRoute: async (
    pickupCityId: string,
    destinationCityId: string,
    excludeId?: string
  ) => {
    try {
      const result = await tariffsApiClient.validateTariffRoute(
        pickupCityId,
        destinationCityId,
        excludeId
      );

      if (result.success && result.data) {
        if (result.data.exists) {
          toast.error("A tariff already exists for this route");
          return false;
        }
        return true;
      }
      return true;
    } catch (error) {
      console.error("Error validating route:", error);
      return true; // Allow on validation error
    }
  },

  // Duplicate tariff
  duplicateTariff: async (
    id: string,
    pickupCityId: string,
    destinationCityId: string
  ) => {
    set({ isLoading: true, error: null });

    try {
      const result = await tariffsApiClient.duplicateTariff(
        id,
        pickupCityId,
        destinationCityId
      );

      if (result.success && result.data) {
        await get().fetchTariffs();
        set({ isLoading: false });
        toast.success("Tariff duplicated successfully");
        return true;
      } else {
        throw new Error(result.error?.message || "Failed to duplicate tariff");
      }
    } catch (error: any) {
      console.error("Error duplicating tariff:", error);
      const errorMessage = error?.message || "Failed to duplicate tariff";
      set({
        error: errorMessage,
        isLoading: false,
      });
      toast.error(errorMessage);
      return false;
    }
  },

  // Filter actions
  setFilters: (newFilters: Partial<TariffFilters>) => {
    const { filters } = get();
    const updatedFilters = { ...filters, ...newFilters };

    // Reset to page 1 when filters change (except for page changes)
    if (!newFilters.page) {
      updatedFilters.page = 1;
    }

    set({ filters: updatedFilters });

    // Auto-fetch when filters change
    get().fetchTariffs();
  },

  resetFilters: () => {
    set({ filters: initialFilters });
    get().fetchTariffs();
  },

  // Utility actions
  setCurrentTariff: (tariff: Tariff | null) => {
    set({ currentTariff: tariff });
  },

  clearError: () => {
    set({ error: null });
  },

  clearCalculationResult: () => {
    set({ calculationResult: null });
  },
}));
-----------------------------------------------------------------------
--++--> lib/stores/parcels/zones.store.ts =======>
-----------------------------------------------------------------------
import { create } from "zustand";
import { persist } from "zustand/middleware";
import { zonesApiClient } from "@/lib/api/clients/parcels/zones.client";
import { citiesApiClient } from "@/lib/api/clients/parcels/cities.client";
import type {
  Zone,
  CreateZoneRequest,
  UpdateZoneRequest,
  ZoneFilters,
  ZoneStatistics,
  AvailableCity,
} from "@/lib/types/parcels/zones.types";
import { toast } from "sonner";
interface ZonesState {
  // Data state
  zones: Zone[];
  activeZones: Zone[];
  currentZone: Zone | null;
  availableCities: AvailableCity[];
  statistics: ZoneStatistics | null;

  // UI state
  loading: boolean;
  error: string | null;
  filters: ZoneFilters;
  selectedZones: string[];

  // Pagination
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };

  // Actions
  setFilters: (filters: Partial<ZoneFilters>) => void;
  clearFilters: () => void;
  setSelectedZones: (zoneIds: string[]) => void;
  clearSelection: () => void;
  setError: (error: string | null) => void;
  clearError: () => void;

  // API actions
  fetchZones: (filters?: ZoneFilters) => Promise<void>;
  fetchActiveZones: () => Promise<void>;
  fetchZoneById: (id: string) => Promise<Zone | null>;
  fetchAvailableCities: () => Promise<void>;
  fetchStatistics: () => Promise<void>;

  // CRUD operations
  createZone: (data: CreateZoneRequest) => Promise<Zone | null>;
  updateZone: (id: string, data: UpdateZoneRequest) => Promise<Zone | null>;
  deleteZone: (id: string) => Promise<boolean>;
  toggleZoneStatus: (id: string) => Promise<boolean>;

  // Zone cities management
  addCitiesToZone: (zoneId: string, cityIds: string[]) => Promise<boolean>;
  removeCitiesFromZone: (zoneId: string, cityIds: string[]) => Promise<boolean>;

  // Bulk operations
  bulkDeleteZones: (zoneIds: string[]) => Promise<boolean>;
  bulkToggleStatus: (zoneIds: string[]) => Promise<boolean>;

  // Export
  exportZones: (filters?: ZoneFilters) => Promise<string | null>;

  // Utility methods
  getZoneById: (id: string) => Zone | undefined;
  getZonesByStatus: (status: boolean) => Zone[];
  getZonesCount: () => { total: number; active: number; inactive: number };
  refreshData: () => Promise<void>;
}
const DEFAULT_FILTERS: ZoneFilters = {
  page: 1,
  limit: 10,
  search: "",
  status: undefined,
};
const DEFAULT_PAGINATION = {
  page: 1,
  limit: 10,
  total: 0,
  totalPages: 0,
  hasNext: false,
  hasPrev: false,
};
export const useZonesStore = create<ZonesState>()(
  persist(
    (set, get) => ({
      // Initial state
      zones: [],
      activeZones: [],
      currentZone: null,
      availableCities: [],
      statistics: null,
      loading: false,
      error: null,
      filters: DEFAULT_FILTERS,
      selectedZones: [],
      pagination: DEFAULT_PAGINATION,

      // Filter and selection actions
      setFilters: (newFilters) => {
        const currentFilters = get().filters;
        const updatedFilters = { ...currentFilters, ...newFilters };

        // Reset page when filters change (except page itself)
        if (Object.keys(newFilters).some((key) => key !== "page")) {
          updatedFilters.page = 1;
        }

        set({ filters: updatedFilters });
        get().fetchZones(updatedFilters);
      },

      clearFilters: () => {
        set({ filters: DEFAULT_FILTERS });
        get().fetchZones(DEFAULT_FILTERS);
      },

      setSelectedZones: (zoneIds) => set({ selectedZones: zoneIds }),

      clearSelection: () => set({ selectedZones: [] }),

      setError: (error) => set({ error }),

      clearError: () => set({ error: null }),

      // Fetch zones with filters
      fetchZones: async (filters) => {
        set({ loading: true, error: null });

        try {
          const filtersToUse = filters || get().filters;
          const response = await zonesApiClient.getZones(filtersToUse);

          if (response.data) {
            set({
              zones: response.data[0].data,
              pagination: response.data[0].meta,
              loading: false,
            });
          } else {
            throw new Error(response.error?.message || "Failed to fetch zones");
          }
        } catch (error: any) {
          console.error("Error fetching zones:", error);
          set({
            error: error.message || "Failed to fetch zones",
            loading: false,
          });
          toast.error("Failed to fetch zones");
        }
      },

      // Fetch active zones only
      fetchActiveZones: async () => {
        try {
          const response = await zonesApiClient.getActiveZones();

          if (response.success && response.data) {
            set({ activeZones: response.data });
          }
        } catch (error: any) {
          console.error("Error fetching active zones:", error);
          toast.error("Failed to fetch active zones");
        }
      },

      // Fetch single zone
      fetchZoneById: async (id) => {
        set({ loading: true, error: null });

        try {
          const response = await zonesApiClient.getZoneById(id);

          if (response.success && response.data) {
            set({
              currentZone: response.data,
              loading: false,
            });
            return response.data;
          } else {
            throw new Error(response.error?.message || "Zone not found");
          }
        } catch (error: any) {
          console.error("Error fetching zone:", error);
          set({
            error: error.message || "Failed to fetch zone",
            loading: false,
            currentZone: null,
          });
          toast.error("Failed to fetch zone details");
          return null;
        }
      },

      // Fetch available cities for zone assignment
      fetchAvailableCities: async () => {
        try {
          const response = await citiesApiClient.getCities({
            page: 1,
            limit: 100,
            status: true,
          });

          if (response.success && response.data) {
            set({ availableCities: response.data.data });
          }
        } catch (error: any) {
          console.error("Error fetching available cities:", error);
          toast.error("Failed to fetch cities");
        }
      },

      // Fetch statistics
      fetchStatistics: async () => {
        try {
          const response = await zonesApiClient.getZoneStatistics();

          if (response.success && response.data) {
            set({ statistics: response.data });
          }
        } catch (error: any) {
          console.error("Error fetching zone statistics:", error);
        }
      },

      // Create zone
      createZone: async (data) => {
        set({ loading: true, error: null });

        try {
          const response = await zonesApiClient.createZone(data);

          if (response.success && response.data) {
            // Add to zones list
            const currentZones = get().zones;
            set({
              zones: [response.data, ...currentZones],
              loading: false,
            });

            // Update active zones if the new zone is active
            if (response.data.status) {
              get().fetchActiveZones();
            }

            // Update statistics
            get().fetchStatistics();

            toast.success("Zone created successfully");
            return response.data;
          } else {
            throw new Error(response.error?.message || "Failed to create zone");
          }
        } catch (error: any) {
          console.error("Error creating zone:", error);
          set({
            error: error.message || "Failed to create zone",
            loading: false,
          });
          toast.error(error.message || "Failed to create zone");
          return null;
        }
      },

      // Update zone
      updateZone: async (id, data) => {
        set({ loading: true, error: null });

        try {
          const response = await zonesApiClient.updateZone(id, data);

          if (response.success && response.data) {
            // Update in zones list
            const currentZones = get().zones;
            const updatedZones = currentZones.map((zone) =>
              zone.id === id ? response.data : zone
            );

            set({
              zones: updatedZones,
              currentZone: response.data,
              loading: false,
            });

            // Refresh active zones
            get().fetchActiveZones();

            // Update statistics
            get().fetchStatistics();

            toast.success("Zone updated successfully");
            return response.data;
          } else {
            throw new Error(response.error?.message || "Failed to update zone");
          }
        } catch (error: any) {
          console.error("Error updating zone:", error);
          set({
            error: error.message || "Failed to update zone",
            loading: false,
          });
          toast.error(error.message || "Failed to update zone");
          return null;
        }
      },

      // Delete zone
      deleteZone: async (id) => {
        try {
          const response = await zonesApiClient.deleteZone(id);

          if (response.success) {
            // Remove from zones list
            const currentZones = get().zones;
            const updatedZones = currentZones.filter((zone) => zone.id !== id);

            set({
              zones: updatedZones,
              currentZone: null,
            });

            // Update selected zones if needed
            const selectedZones = get().selectedZones;
            if (selectedZones.includes(id)) {
              set({
                selectedZones: selectedZones.filter((zoneId) => zoneId !== id),
              });
            }

            // Refresh active zones and statistics
            get().fetchActiveZones();
            get().fetchStatistics();

            toast.success("Zone deleted successfully");
            return true;
          } else {
            throw new Error(response.error?.message || "Failed to delete zone");
          }
        } catch (error: any) {
          console.error("Error deleting zone:", error);
          toast.error(error.message || "Failed to delete zone");
          return false;
        }
      },

      // Toggle zone status
      toggleZoneStatus: async (id) => {
        try {
          const response = await zonesApiClient.toggleZoneStatus(id);

          if (response.success && response.data) {
            // Update in zones list
            const currentZones = get().zones;
            const updatedZones = currentZones.map((zone) =>
              zone.id === id ? response.data : zone
            );

            set({ zones: updatedZones });

            // Refresh active zones
            get().fetchActiveZones();

            toast.success(
              `Zone ${
                response.data.status ? "activated" : "deactivated"
              } successfully`
            );
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to toggle zone status"
            );
          }
        } catch (error: any) {
          console.error("Error toggling zone status:", error);
          toast.error(error.message || "Failed to toggle zone status");
          return false;
        }
      },

      // Add cities to zone
      addCitiesToZone: async (zoneId, cityIds) => {
        try {
          const response = await zonesApiClient.addCitiesToZone(
            zoneId,
            cityIds
          );

          if (response.success && response.data) {
            // Update current zone if it matches
            const currentZone = get().currentZone;
            if (currentZone?.id === zoneId) {
              set({ currentZone: response.data });
            }

            toast.success("Cities added to zone successfully");
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to add cities to zone"
            );
          }
        } catch (error: any) {
          console.error("Error adding cities to zone:", error);
          toast.error(error.message || "Failed to add cities to zone");
          return false;
        }
      },

      // Remove cities from zone
      removeCitiesFromZone: async (zoneId, cityIds) => {
        try {
          const response = await zonesApiClient.removeCitiesFromZone(
            zoneId,
            cityIds
          );

          if (response.success && response.data) {
            // Update current zone if it matches
            const currentZone = get().currentZone;
            if (currentZone?.id === zoneId) {
              set({ currentZone: response.data });
            }

            toast.success("Cities removed from zone successfully");
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to remove cities from zone"
            );
          }
        } catch (error: any) {
          console.error("Error removing cities from zone:", error);
          toast.error(error.message || "Failed to remove cities from zone");
          return false;
        }
      },

      // Bulk delete zones
      bulkDeleteZones: async (zoneIds) => {
        try {
          const response = await zonesApiClient.bulkDeleteZones(zoneIds);

          if (response.success) {
            // Remove deleted zones from list
            const currentZones = get().zones;
            const remainingZones = currentZones.filter(
              (zone) => !zoneIds.includes(zone.id)
            );

            set({
              zones: remainingZones,
              selectedZones: [],
            });

            // Refresh data
            get().fetchActiveZones();
            get().fetchStatistics();

            toast.success(
              `Successfully deleted ${
                response.data?.successful || zoneIds.length
              } zone(s)`
            );

            if (response.data?.failed && response.data.failed.length > 0) {
              toast.warning(
                `Failed to delete ${response.data.failed.length} zone(s)`
              );
            }

            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to delete zones"
            );
          }
        } catch (error: any) {
          console.error("Error bulk deleting zones:", error);
          toast.error(error.message || "Failed to delete zones");
          return false;
        }
      },

      // Bulk toggle status
      bulkToggleStatus: async (zoneIds) => {
        try {
          const response = await zonesApiClient.bulkToggleStatus(zoneIds);

          if (response.success) {
            // Refresh zones to get updated statuses
            await get().fetchZones();

            set({ selectedZones: [] });

            toast.success(
              `Successfully updated ${
                response.data?.successful || zoneIds.length
              } zone(s)`
            );

            if (response.data?.failed && response.data.failed.length > 0) {
              toast.warning(
                `Failed to update ${response.data.failed.length} zone(s)`
              );
            }

            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to update zones"
            );
          }
        } catch (error: any) {
          console.error("Error bulk toggling zone status:", error);
          toast.error(error.message || "Failed to update zones");
          return false;
        }
      },

      // Export zones
      // Export zones - FIXED VERSION
      exportZones: async (filters) => {
        set({ loading: true, error: null });

        try {
          const filtersToUse = filters || get().filters;

          // Send the request with the correct structure
          const result = await zonesApiClient.exportZones({
            page: filtersToUse.page || 1,
            limit: filtersToUse.limit || 1000,
            search: filtersToUse.search || "",
            status: filtersToUse.status,
          });

          if (result.success && result.data) {
            set({ loading: false });
            toast.success(
              `Exported ${result.data.totalRecords} zones successfully`
            );
            return result.data.downloadUrl;
          } else {
            throw new Error(result.error?.message || "Failed to export zones");
          }
        } catch (error: any) {
          console.error("Error exporting zones:", error);
          const errorMessage = error?.message || "Failed to export zones";
          set({
            error: errorMessage,
            loading: false,
          });
          toast.error(errorMessage);
          return null;
        }
      },

      // Utility methods
      getZoneById: (id) => {
        return get().zones.find((zone) => zone.id === id);
      },

      getZonesByStatus: (status) => {
        return get().zones.filter((zone) => zone.status === status);
      },

      getZonesCount: () => {
        const zones = get().zones;
        return {
          total: zones.length,
          active: zones.filter((zone) => zone.status).length,
          inactive: zones.filter((zone) => !zone.status).length,
        };
      },

      // Refresh all data
      refreshData: async () => {
        const promises = [
          get().fetchZones(),
          get().fetchActiveZones(),
          get().fetchStatistics(),
          get().fetchAvailableCities(),
        ];

        await Promise.allSettled(promises);
      },
    }),
    {
      name: "zones-store",
      partialize: (state) => ({
        filters: state.filters,
        selectedZones: state.selectedZones,
      }),
      version: 1,
    }
  )
);
-----------------------------------------------------------------------
Types folders:
-----------------------------------------------------------------------
--++--> lib/types/parcels/delivery-slips.types.ts =======>
-----------------------------------------------------------------------
export enum DeliverySlipStatus {
  PENDING = "PENDING",
  RECEIVED = "RECEIVED",
  CANCELLED = "CANCELLED",
}

export interface DeliverySlip {
  id: string;
  tenantId: string;
  userId: string;
  reference: string;
  cityId?: string;
  status: DeliverySlipStatus;
  receivedAt?: Date;
  receivedBy?: string;
  notes?: string;
  createdAt: Date;
  updatedAt: Date;
  createdBy?: string;
  updatedBy?: string;

  // Relations
  city?: {
    id: string;
    name: string;
    ref: string;
  };
  creator?: {
    id: string;
    name: string;
    email: string;
  };
  items: DeliverySlipItem[];
  summary: {
    totalParcels: number;
    scannedParcels: number;
    unscannedParcels: number;
    totalValue: number;
  };
}

export interface DeliverySlipItem {
  deliverySlipId: string;
  parcelId: string;
  scanned: boolean;
  scannedAt?: Date;
  scannedBy?: string;
  parcel: {
    id: string;
    code: string;
    recipientName: string;
    recipientPhone: string;
    destinationCity: string;
    price: number;
    statusCode: string;
    statusName: string;
  };
}

export interface CreateDeliverySlipRequest {
  cityId?: string;
  parcelIds?: string[];
  notes?: string;
  autoReceive?: boolean;
}

export interface UpdateDeliverySlipRequest {
  cityId?: string;
  notes?: string;
  status?: DeliverySlipStatus;
}

export interface DeliverySlipFilters {
  page?: number;
  limit?: number;
  search?: string;
  status?: DeliverySlipStatus;
  cityId?: string;
  userId?: string;
  startDate?: string;
  endDate?: string;
  sortBy?: string;
  sortParcel?: "asc" | "desc";
}

export interface AddParcelsToSlipRequest {
  parcelIds: string[];
  comment?: string;
  markAsScanned?: boolean;
}

export interface RemoveParcelsFromSlipRequest {
  parcelIds: string[];
  reason?: string;
}

export interface ReceiveSlipRequest {
  notes?: string;
  parcelIds?: string[];
  forceReceive?: boolean;
}

export interface DeliverySlipStats {
  totalSlips: number;
  pendingSlips: number;
  receivedSlips: number;
  cancelledSlips: number;
  totalParcelsInSlips: number;
  totalValueInSlips: number;
  averageParcelsPerSlip: number;
  recentActivity: Array<{
    date: string;
    slipsCreated: number;
    slipsReceived: number;
  }>;
  topCities: Array<{
    cityName: string;
    slipCount: number;
    parcelCount: number;
  }>;
}

export interface BulkSlipActionRequest {
  slipIds: string[];
  action: string;
  comment?: string;
}

export interface AvailableParcel {
  id: string;
  code: string;
  recipientName: string;
  recipientPhone: string;
  price: number;
  createdAt: Date;
  pickupCity: {
    id: string;
    name: string;
    ref: string;
  };
  destinationCity: {
    id: string;
    name: string;
    ref: string;
  };
}

export interface PaginatedDeliverySlips {
  data: DeliverySlip[];
  meta: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
}

===============================================================================================================
# WORKFLOW DES COMMANDES
===============================================================================================================
## ÉTAPE 1 : CRÉATION DE COLIS

**Vue Client (Seller)**
Cette étape permet au client (seller) de créer un nouveau colis en renseignant toutes les informations nécessaires à la livraison.

### 1. Accès au formulaire de création
- Le client navigue vers : Gestion des colis > Nouveau Colis
- Le système affiche le formulaire de création de colis

### 2. Saisie des informations obligatoires
Le client renseigne les champs suivants :

**Informations destinataire :**
- Destinataire* (obligatoire) : Nom du destinataire
- Téléphone* (obligatoire) : Numéro de téléphone du destinataire
- Ville* (obligatoire) : Ville de livraison (sélection via liste déroulante)
- Adresse* (obligatoire) : Adresse complète de livraison

**Informations colis :**
- Code suivi (facultatif) : Code de suivi personnalisé
- Marchandise (facultatif) : produit (sélection via liste déroulante)
- Quantité (facultatif) : Nombre d'articles
- Prix* (obligatoire) : Montant de la commande
- Commentaire (facultatif) : Informations complémentaires (autre téléphone, date de livraison souhaitée, etc.)

**Options spéciales :**
- Interdit d'ouvrir le colis : Case à cocher
- Colis à remplacer : Case à cocher
- Colis de Stock : Case à cocher

**Actions disponibles**
- Enregistrer : Valide et crée le colis
- Reset : Remet à zéro tous les champs du formulaire

### 3. Vue client - Suivi des colis créés
**Accès :** Menu Gestion des colis > Colis pour ramassage

Après la création d'un colis, le client peut consulter ses colis en attente de ramassage dans une interface dédiée.

**Informations affichées dans le tableau :**
- Code d'envoi : Identifiant unique du colis (ex: BSK0925539432LE)
- Destinataire : Nom du destinataire
- Statut : Badge coloré indiquant l'état actuel
  - "Nouveau Colis" : colis créé, en attente de traitement
  - "Attente De Ramassage" : colis prêt pour collecte
- Date de création : Date et heure de création du colis
- Prix : Montant de la commande (en DH)
- Téléphone : Numéro du destinataire
- Ville : Ville de destination
- Bon de livraison : Référence du bon associé (ex: BL-280225-0192950-16-161)
- Actions : Boutons d'actions disponibles (icône information, icône update et icône delete)

**NB:** icône update et icône delete si le status de colis est "Nouveau colis"
**Icône information :** Accès aux détails via le bouton d'actions

### Vue administrateur - Supervision des colis
**Accès :** Menu Colis

**Informations affichées dans le tableau de bord :**
- Code d'envoi : Identifiant unique du colis
- Date d'expédition : Date de création du colis
- Téléphone : Numéro du destinataire
- Nom du magasin : Nom du client (seller)
- État : Statut actuel du colis (Non paye, paye, facture)
- Statut : Badge coloré indiquant l'état
- Ville : Ville de destination
- Prix : Montant de la commande
- Actions : Boutons d'actions disponibles pour chaque colis

**Actions disponibles par colis :**
L'administrateur dispose d'un menu d'actions contextuel pour chaque colis avec les options suivantes :
- 📄 Détails du suivi : Consultation de l'historique complet du colis
- ℹ️ Information du colis : Affichage des détails de la commande
- ✏️ Modifier le colis : Édition des informations du colis
- ✏️ Change Ville : Modification de la ville de destination
- 👤 Change Vendeur : Réassignation du vendeur/client
- ⚠️ Réinitialiser ce colis : Remise à zéro du statut du colis
- ⚠️ Relance ce colis : Relancement du processus de traitement

## ÉTAPE 2 : CRÉATION DES BONS DE LIVRAISON

Cette étape correspond à la réception physique des colis à l'agence et à la génération automatique des bons de livraison. Le système utilise la technologie de scan de codes-barres pour traiter les colis et mettre à jour automatiquement leur statut selon la zone géographique.

### 1. Accès à l'interface de scan
- L'agent navigue vers : Menu > Bons de livraison
- Clic sur le bouton "Code Bar Scanner" dans la barre d'outils

### 2. Interface de scan
L'interface propose deux méthodes de scan :
- **Scan manuel ou douchette :** Champ de saisie "CLIC ICI AVANT LE SCAN" pour saisie manuelle ou par douchette le code
- **Scan caméra :** Bouton "📷 Utiliser Camera" pour scan automatique via webcam/caméra mobile (scan qr code or barcode)

### 3. Traitement automatique du scan
Une fois le code-barres scanné ou saisi :
- Le système identifie automatiquement le colis
- Génère un bon de livraison avec référence unique
- Met à jour le statut selon la logique géographique

### 4. Logique de changement de statut

**Cas 1 : Destination dans la même zone que l'agence**
- Condition : Ville de destination = Zone de l'agence de ramassage
- Nouveau statut : "Reçu"
- Action : Le colis reste dans l'agence pour livraison locale

**Cas 2 : Destination dans une zone différente**
- Condition : Ville de destination ≠ Zone de l'agence de ramassage
- Nouveau statut : "Ramassé"
- Action : Le colis doit être transféré vers l'agence de destination

### 4. Interface de gestion des bons de livraison
Vue tableau des bons créés :
- Référence: Code unique du bon (BL-XXXXXX-XXX)
- Client
- Date de création: Date et heure de création du bon
- Date de réception
- Statut
- Colis: Nombre de colis dans le bon
- Total: Montant total en DH
- Actions:
  - 👁 Détails du bon : Consultation détaillée du bon de livraison
  - ✅ Bon bien reçu : Confirmation de réception du bon
  - 📄 Voir en PDF : Génération et téléchargement du bon au format PDF
  - 🏷 Voir les étiquettes : Affichage/impression des étiquettes de colis

## CRÉATION DE BONS DE LIVRAISON (INTERFACE CLIENT)

Cette fonctionnalité permet au client (seller) de créer ses propres bons de livraison (au cas où il ne va pas se déplacer à l'agence) en sélectionnant les colis qu'il souhaite regrouper.

### 1. Accès à l'interface de création
- Le client navigue vers : Menu > Bons de livraison
- La page affiche la liste des bons existants
- Clic sur le bouton "+ Ajouter Bon de livraison"
- Une deuxième page s'affiche:
  - Indicateur de nombre de colis éligibles pour création d'un bon
  - Bouton principal : "+ Créer bon de livraison"

### 2. Création de bons de livraison
- Clic sur ce bouton pour accéder à l'interface détaillée de sélection des colis
- Une fois le bouton "Créer bon de livraison" cliqué, le système affiche l'interface complète avec :

**Liste des nouveaux colis disponibles:** Tableau des colis éligibles pour ajout au bon :
- Code d'envoi: Identifiant unique du colis
- Destinataire: Nom du destinataire
- Date de création: Date de création du colis
- Prix: Montant en DH
- Ville: Ville de destination
- Actions: Bouton "+" pour ajouter le colis et Case à cocher pour sélection multiple et Bouton "Ajouter" (en bas) : Ajouter tous les colis sélectionnés

**Liste des colis ajoutés au bon:** Section qui affiche les colis sélectionnés pour le bon en cours de création.
- Vide initialement : "Aucun enregistrement disponible" / "Aucune entrées correspondants trouvés"
- Après ajout : Liste des colis inclus dans le bon

**Tickets et Bon de livraison - Obtenir en PDF** Trois options de génération disponibles :
- Génération du premier type de ticket (Première image)
- Génération de deuxième type de ticket (deuxième image)
- Génération de bon de livraison (troisieme image)

### 3. Vue tableau des bons de livraison
Après création, les bons apparaissent dans le tableau principal :
- Référence
- Date de création
- Statut
- Colis
- Actions

## CRÉATION DES BONS DE DISTRIBUTION

Cette étape permet à l'administrateur d'affecter les colis aux livreurs en créant des bons de distribution. Le processus implique la sélection d'une zone géographique, l'assignation d'un livreur spécifique, puis la sélection des colis à distribuer soit manuellement soit par scan.

### 1. Accès à l'interface de distribution
- L'administrateur navigue vers : Menu > Bons de distribution
- Clic sur le bouton "+ Ajouter Bon De Distribution"
- **Sélection de la zone:**
  - Liste déroulante des zones disponibles
  - Affichage du nombre de colis en attente par zone
- **Sélection du livreur:**
  - Liste déroulante des livreurs disponibles pour la zone sélectionnée

### 2. Création du bon et sélection des colis
Une fois le bouton "Créer" cliqué, le système affiche l'interface de sélection des colis :

**Liste des nouveaux colis disponibles:** Tableau des colis éligibles pour distribution dans la zone sélectionnée
- Code d'envoi
- Client
- Date de réception
- Ville
- Livreur
- Adresse
- Commentaire
- Prix
- Statut
- Actions: (Boutons d'ajout et sélection + Case à cocher)

**Liste des colis ajoutés au bon :** Affiche les colis sélectionnés pour le bon de distribution en cours

**Interface de scan pour retrait de colis:**
- Champ de scan : "CLIC ICI AVANT LE SCAN"
- Scan caméra : Bouton "📷 Utiliser Camera" (scan qr code or barcode)
- Fonctionnalité : Permet de retirer des colis du bon par scan

### 3. Vue tableau des bons de distribution créés
Une fois créés, les bons apparaissent dans le tableau principal des bons de distribution :
- Référence
- Date de création
- Date d'Enregistrement
- Zone
- Livreur
- Statut
- Colis
- Actions:
  - 📄 Détails du bon : Consultation détaillée
  - 🗑 Supprimer le bon : Suppression du bon
  - ✏️ Modifier le bon : Édition des paramètres
  - 📄 Voir en PDF : Génération du document
  - 📊 Export Excel : Export des données

### 3. Logique de changement de statut après distribution

**Cas 1 : Distribution dans la même zone (livraison locale)**
- Condition : Ville de destination = Zone de ramassage/agence
- Changement de statut : "Reçu" → "En distribution"
- Action : Le colis passe directement en phase de livraison finale
- Workflow : Colis → Bon de livraison→ Bon de distribution → Livraison directe

**Cas 2 : Distribution vers une zone différente (transfert inter-agences)**
- Condition : Ville de destination ≠ Zone de ramassage/agence
- Étape intermédiaire : Création d'un "Bon d'envoi" (à détailler)
- Action : Le colis doit être transféré vers l'agence de la zone de destination
- Workflow : Colis → Bon de livraison→ Bon d'envoi ( Transfert → a l l'agence destination )→ Bon de distribution → Livraison

## CRÉATION DES BONS D'ENVOI

Cette étape gère les colis qui doivent être transférés vers d'autres zones géographiques. Lorsqu'un colis à une destination différente de la zone de ramassage, il passe par un bon d'envoi avant d'être acheminé vers l'agence de destination appropriée.

### 1. Accès à l'interface de création
- L'administrateur navigue vers : Menu > Bons d'envoi
- Clic sur le bouton "+ Ajouter Bon D'envoi ( Zone )"
- **Sélection de la zone de destination**
  - Liste déroulante des zones de destination disponibles
  - Sélection de la zone vers laquelle transférer les colis

### 2. Création du bon et sélection des colis
**Liste des nouveaux colis disponibles :** Tableau des colis éligibles pour transfert vers la zone sélectionnée
- Code d'envoi
- Client
- Date de ramassage
- Prix
- Ville
- Actions: (Boutons d'ajout et Case à cocher)

**Liste des colis ajoutés au bon :** Section "LIST DES COLIS AJOUTÉS" Affiche les colis sélectionnés pour le bon d'envoi
- Toutes les elements de liste de colis disponible + la colonne scanned (indicateur de scan)

**Interface de scan :**
- Champ de scan : "CLIC ICI AVANT LE SCAN"
- Scan caméra : Bouton "📷 Utiliser Camera" (scan qr code or barcode)
- Fonctionnalité : Retrait de colis du bon par scan

### 3. Vue tableau des bons d'envoi créés
Une fois créés, les bons d'envoi apparaissent dans le tableau principal :
- Référence
- Date de création
- Date de réception
- Zone
- Statut
- Colis
- Actions:
  - 👁 Détails du bon : Consultation détaillée du bon d'envoi
  - ✅ Bon bien reçu :
  - ✏️ Modifier le bon : Édition des paramètres du bon d'envoi
  - 📄 Voir en PDF : Génération et téléchargement du bon au format PDF
  - 📊 Export Excel : Export des données du bon vers Excel

### 4. Changement de statut des colis
**Transition automatique :** Une fois les colis ajoutés au bon d'envoi et le bon finalisé :
- Statut précédent : "Ramassé"
- Nouveau statut : "Expédié"
- Action : Les colis sont prêts pour transfert physique vers l'agence de destination

### 5. Workflow de transfert inter-agences
- **Agence source :** Création du bon d'envoi (statut "Ramasse")
- **Expédition :** Colis passent au statut "Expédié"
- **Transport :** Acheminement physique vers agence de destination
- **Agence destination :** Réception et scan des colis
- **Suite du processus :** Création de bons de distribution locaux

## GESTION DES BONS DE PAIEMENT

Le module de bons de paiement gère la comptabilité et les règlements financiers dans le système. Il se divise en deux catégories principales : les paiements aux livreurs individuels et les paiements aux modérateurs de zone pour les transferts inter-agences.

- **Bons de paiement pour livreur :** Règlement des livreurs individuels
- **Bons de paiement pour zone :** Comptabilité avec les modérateurs de zone

## BONS DE PAIEMENT POUR LIVREUR

Cette fonctionnalité permet de créer et gérer les paiements destinés aux livreurs individuels pour les livraisons effectuées dans leur zone d'intervention.

### 1. Accès à l'interface
- Navigation : Menu > Bons de paiement > Pour livreur
- Clic sur "+ Ajouter Bon Pour Livreur"

### 2. Création de bon de paiement pour livreur
- **Sélectionner la zone:** Liste déroulante avec statistiques (Affichage du nombre de livraisons réussies et échecs)
- **Sélection du livreur:** Liste déroulante des livreurs avec statistiques individuelles (Affichage du nombre de livraisons réussies et échecs)
- **Création et configuration du bon:**

**Liste des nouveaux colis:** Tableau des colis livrés éligibles au paiement :
- Code d'envoi
- Client
- Téléphone
- Date de livraison
- Statut
- Ville
- Prix
- Frais
- Total
- Actions:
  - Détails du suivi : Historique complet
  - Information du colis : Détails de la commande
  - Modifier le colis : Édition des informations
  - Change Ville : Modification destination
  - Change Vendeur : Réassignation vendeur
  - Colis non livré : Marquage échec livraison
  - Changer le prix : Ajustement montant
  - Remboursement : Gestion des retours

**Section "AUTRES FRAIS"** Interface pour ajouter des frais supplémentaires :
- Désignation : Description du frais
- Quantité
- Prix unitaire
- Total

### 3. Vue tableau des bons de paiement
Interface principale des bons créés :
- Référence
- Date de création
- Date Changement de statuts
- Zone
- Livreur
- Portefeuille
- Screen
- Statut
- Colis (Nb)
- Total

### 4. Cycle de vie des bons de paiement
Changement de statut se fait en 3 étapes

**1. Attente de paiement**
- Bon créé avec les colis livrés
- En attente de traitement financier

**2. Encore de traitement**
- Paiement en cours de traitement
- Vérifications comptables en cours

**3. Payé**
- Paiement effectué au livreur
- Clôture comptable du bon

Lors du passage au statut "Payé", une popup s'affiche avec :
- Champ Virement : Montant du virement
- Champ Cash : Montant en espèces
- Bouton "Payé" : Confirmation finale du paiement

## BONS DE PAIEMENT POUR ZONE

Cette fonctionnalité gère la comptabilité avec les modérateurs de zone pour les transferts inter-agences. Elle permet de régler financièrement les zones qui ont reçu et traité des colis provenant d'autres agences.

### 1. Accès à l'interface
- Navigation : Menu > Bons de paiement > Pour zone
- Clic sur "+ Ajouter Bon Pour Zone"

### 2. Sélection de la zone

### 3. Création et configuration du bon
**Liste des nouveaux colis:** Tableau des colis livrés dans la zone éligibles au paiement
- Code d'envoi
- Client
- Téléphone
- Date de livraison
- Statut
- Ville
- Prix
- Frais
- Total

**Liste des colis ajoutés:**
- Code d'envoi
- Client
- Téléphone
- Date de livraison
- Statut
- Ville
- Prix
- Frais
- Total

### 4. Vue tableau des bons de paiement pour zone
Interface principale des bons créés :
- Référence
- Date de création
- Date Changement de statuts
- Zone
- Statut
- Colis
- Total

### 5. Gestion des statuts de paiement
Cycle de vie des bons de paiement pour zone :

**1. Attente de paiement**
- Bon créé pour la zone
- En attente de traitement comptable

**2. En cours de traitement**
- Paiement en cours de validation
- Vérifications inter-agences

**3. Payé**
- Règlement effectué à la zone
- Clôture comptable du transfert

## GESTION DES BONS DE RETOUR

### Bons de retour pour livreur

**Table contents :**
- Référence
- Date de création
- Livreur
- Type
- Statut
- Colis
- Actions

*Exemple :*
BRL-240925-0126910-76-133 | 2025-09-24 13:20 | Youness RBT | Demande | Incomplet | 0 | 22 | 2 | update/delete

**Créer Bons de retour for livreur:**
- Sélection le livreur
- Select LISTE DES COLIS DEMANDE DE RETOUR
- Create Bons de retour

### Bons de retour pour zone

**Table contents :**
- Référence
- Date de création
- Date de réception
- Ville
- Statut
- Colis
- Actions

*Exemple :*
BRV-170925-0126750-79-V | 2025-09-17 13:51 | 2025-09-17 16:03 | HUB CASABLANCA | Reçu | 3 | details/voir/delete
(youness bousaou ali housni)

**Créer Bons de retour for zone:**
- Sélection la zone
- List des colis ajoutés
- Create Bons de retour

### Bons de retour pour client (customer)

**Table contents :**
- Référence
- Date de création
- Date de réception
- Nom du magasin
- Statut
- Colis
- Actions

*Exemple :*
BRC-160925-0126540-77-138 | 2025-09-16 17:33 | 2025-09-17 09:36 | Metalivraison - (546) | Reçu | 1Nouveau | 6 | details/voir/export
(milad settaoui milad settaoui)

**Créer Bons de retour for customer:**
- Sélection le client
- Ajouter liste des colis returne
- create Bons de retour for customer
===============================================================================================================
Nest js backend Parcels-Service:
===============================================================================================================
--++--> prisma/schema.prisma =======>
-----------------------------------------------------------------------
generator client {
  provider = "prisma-client-js"
}
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}
// ========================================
// CORE REFERENCE DATA
// These models define the foundational data for the delivery system
// ========================================
/**
 * City Model
 * Represents cities where packages can be picked up or delivered
 * Supports multi-tenant architecture with soft deletes
 */
model City {
  id         String  @id @default(cuid()) // Unique identifier using CUID
  tenantId   String // Multi-tenant support - isolates data per organization
  ref        String // Business reference code (e.g., "CAS" for Casablanca)
  name       String // Display name of the city
  zone       String? // Optional zone grouping for logistics
  pickupCity Boolean @default(false) // Whether this city accepts package pickups
  status     Boolean @default(true) // Active/inactive flag for business operations

  // Soft delete pattern - allows data recovery and maintains referential integrity
  isDeleted Boolean   @default(false) // Soft delete flag
  deletedAt DateTime? // Timestamp when deleted
  deletedBy String? // User who performed the deletion

  // Audit trail - tracks data changes for compliance and debugging
  createdAt DateTime @default(now()) // Record creation timestamp
  updatedAt DateTime @updatedAt // Auto-updated on record changes
  createdBy String? // User who created the record
  updatedBy String? // User who last updated the record

  // Relations - Define how cities connect to other entities
  pickupTariffs        Tariff[]       @relation("PickupCity") // Tariffs where this city is pickup
  destinationTariffs   Tariff[]       @relation("DestinationCity") // Tariffs where this city is destination
  zones                ZoneCity[] // Many-to-many relationship with zones
  parcelsAsPickup      Parcel[]       @relation("PickupCity") // Parcels picked up from this city
  parcelsAsDestination Parcel[]       @relation("DestinationCity") // Parcels delivered to this city
  deliverySlips        DeliverySlip[] // Delivery slips for this city

  // Optimized indexes for common query patterns
  @@unique([tenantId, ref, isDeleted]) // Ensures unique business codes per tenant
  @@index([tenantId, isDeleted, status]) // Fast tenant + active city queries
  @@index([tenantId, isDeleted, pickupCity]) // Quick pickup city filtering
  @@index([tenantId, zone]) // Zone-based queries within tenant
  @@index([name]) // City name searches
  @@map("cities") // Custom table name
}
/**
 * PickupCity Model
 * Specialized reference for pickup locations/hubs
 * Separate from regular cities for operational flexibility
 */
model PickupCity {
  id       String  @id @default(cuid())
  tenantId String // Multi-tenant isolation
  ref      String // Business reference (e.g., "CAS_HUB")
  name     String // Display name (e.g., "HUB CASABLANCA")
  status   Boolean @default(true) // Active status

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations
  tariffs Tariff[] @relation("PickupCityRef") // Optional tariff reference

  // Indexes and constraints
  @@unique([tenantId, ref, isDeleted]) // Unique pickup city refs per tenant
  @@index([tenantId, isDeleted, status]) // Active pickup cities per tenant
  @@map("pickup_cities")
}
/**
 * Tariff Model
 * Defines pricing and delivery terms between city pairs
 * Core business logic for cost calculation
 */
model Tariff {
  id                String  @id @default(cuid())
  tenantId          String // Multi-tenant support
  pickupCityId      String // Source city for package
  destinationCityId String // Destination city for package
  deliveryPrice     Decimal @db.Decimal(10, 2) // Standard delivery fee (precise decimal for money)
  returnPrice       Decimal @default(0) @db.Decimal(10, 2) // Fee for returning undelivered packages
  refusalPrice      Decimal @default(0) @db.Decimal(10, 2) // Fee for refused packages
  deliveryDelay     Int     @db.SmallInt // Expected delivery time in days

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations
  pickupCity      City        @relation("PickupCity", fields: [pickupCityId], references: [id])
  destinationCity City        @relation("DestinationCity", fields: [destinationCityId], references: [id])
  pickupCityRef   PickupCity? @relation("PickupCityRef", fields: [pickupCityRefId], references: [id])
  pickupCityRefId String? // Optional reference to pickup city hub
  parcels         Parcel[] // Parcels using this tariff

  // Optimized indexes for route-based pricing queries
  @@unique([tenantId, pickupCityId, destinationCityId, isDeleted]) // Unique routes per tenant
  @@index([tenantId, isDeleted]) // Tenant-wide tariff queries
  @@index([pickupCityId, destinationCityId]) // Fast route-based lookups
  @@map("tariffs")
}
/**
 * Zone Model
 * Logical grouping of cities for operational management
 * Used for organizing delivery routes and staff assignments
 */
model Zone {
  id       String  @id @default(cuid())
  tenantId String // Multi-tenant support
  name     String // Zone name (e.g., "HUB CASABLANCA")
  status   Boolean @default(true) // Active status

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations - Zones coordinate multiple operational processes
  cities              ZoneCity[] // Cities within this zone
  distributionSlips   DistributionSlip[] // Distribution assignments for this zone
  shippingSlips       ShippingSlip[] // Inter-zone shipments to this zone
  returnSlipsForZone  ReturnSlip[]       @relation("ReturnSlipZone") // Returns processed by zone
  paymentSlipsForZone PaymentSlip[]      @relation("PaymentSlipZone") // Payments processed by zone

  // Indexes for zone-based operations
  @@unique([tenantId, name, isDeleted]) // Unique zone names per tenant
  @@index([tenantId, isDeleted, status]) // Active zones per tenant
  @@map("zones")
}
/**
 * ZoneCity Junction Table
 * Many-to-many relationship between zones and cities
 * Allows flexible city-to-zone assignments
 */
model ZoneCity {
  zoneId String // Reference to zone
  cityId String // Reference to city

  // Relations with cascade delete - if zone/city deleted, remove assignment
  zone Zone @relation(fields: [zoneId], references: [id], onDelete: Cascade)
  city City @relation(fields: [cityId], references: [id], onDelete: Cascade)

  @@id([zoneId, cityId]) // Composite primary key - more efficient than separate ID
  @@map("zone_cities")
}
/**
 * ParcelStatus Model
 * Defines the workflow states an parcel can be in
 * Core to tracking package lifecycle
 */
model ParcelStatus {
  id       String  @id @default(cuid())
  tenantId String // Multi-tenant support
  code     String  @db.VarChar(50) // Business code (e.g., "NEW_PACKAGE", "DELIVERED")
  name     String  @db.VarChar(100) // Display name (e.g., "Nouveau Colis", "Livré")
  color    String  @db.VarChar(7) // Hex color for UI display (#FF0000)
  isLocked Boolean @default(false) // Whether status can be manually changed
  status   Boolean @default(true) // Active status

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations
  parcels               Parcel[] // Parcels in this status
  parcelStatusHistories ParcelStatusHistory[] // Status change history

  // Constraints and indexes
  @@unique([tenantId, code, isDeleted]) // Unique status codes per tenant
  @@unique([tenantId, color, isDeleted]) // Unique colors per tenant (UI requirement)
  @@index([tenantId, isDeleted, status]) // Active statuses per tenant
  @@map("parcel_statuses")
}
// ========================================
// PARCELS CORE
// The heart of the delivery system - manages package parcels
// ========================================
/**
 * Parcel Model
 * Central entity representing a package delivery request
 * Contains all information needed for pickup, delivery, and payment
 */
model Parcel {
  id       String @id @default(cuid())
  tenantId String // Multi-tenant support
  userId   String // Seller/client who created the parcel
  code     String @unique @db.VarChar(50) // Unique business code (e.g., BSK0925539432LE)

  // Customer information - who receives the package
  recipientName    String  @db.VarChar(200) // Customer name
  recipientPhone   String  @db.VarChar(20) // Primary contact number
  recipientAddress String  @db.Text // Full delivery address
  alternativePhone String? @db.VarChar(20) // Backup contact number

  // Location - pickup and delivery cities
  pickupCityId      String // Where package is collected
  destinationCityId String // Where package is delivered

  // Package details - what's being delivered
  trackingCode String? @db.VarChar(100) // Custom tracking code from seller
  productName  String? @db.VarChar(200) // Product description
  quantity     Int?    @default(1) @db.SmallInt // Number of items
  price        Decimal @db.Decimal(12, 2) // COD amount (Cash on Delivery value)
  comment      String? @db.Text // Special delivery instructions

  // Package handling options - business rules
  cannotOpen Boolean @default(false) // Package cannot be opened for inspection
  canReplace Boolean @default(false) // Can substitute with different item
  isStock    Boolean @default(false) // Is this a stock/inventory item

  // Status and workflow tracking
  parcelStatusId   String // Current status reference
  parcelStatusCode String        @db.VarChar(50) // Current status code (for fast queries)
  paymentStatus    PaymentStatus @default(PENDING) // Payment processing state

  // Pricing - calculated from tariff, stored for historical accuracy
  deliveryPrice Decimal @db.Decimal(10, 2) // Standard delivery fee
  returnPrice   Decimal @default(0) @db.Decimal(10, 2) // Return fee if undelivered
  refusalPrice  Decimal @default(0) @db.Decimal(10, 2) // Refusal fee if rejected
  deliveryDelay Int     @db.SmallInt // Expected delivery days
  tariffId      String? // Reference to tariff used for pricing

  // Delivery tracking - operational data
  deliveryAttempts Int       @default(0) @db.SmallInt // How many delivery attempts made
  lastAttemptDate  DateTime? // When last delivery was attempted
  deliveredAt      DateTime? // When successfully delivered
  deliveredBy      String? // ID of delivery person who completed

  // Return/Refusal tracking - handling failed deliveries
  returnedAt    DateTime? // When package was returned to sender
  returnReason  String?   @db.Text // Why package was returned
  refusedAt     DateTime? // When package was refused by recipient
  refusalReason String?   @db.Text // Why package was refused

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations - how parcels connect to other system components
  pickupCity      City         @relation("PickupCity", fields: [pickupCityId], references: [id])
  destinationCity City         @relation("DestinationCity", fields: [destinationCityId], references: [id])
  parcelStatus    ParcelStatus @relation(fields: [parcelStatusId], references: [id])
  tariff          Tariff?      @relation(fields: [tariffId], references: [id])

  // Status change history for audit trail
  statusHistory ParcelStatusHistory[]

  // Slip associations - tracking through various operational documents
  deliverySlipItems     DeliverySlipItem[] // When parcel is collected from sender
  distributionSlipItems DistributionSlipItem[] // When parcel is assigned for delivery
  shippingSlipItems     ShippingSlipItem[] // When parcel is shipped between zones
  returnSlipItems       ReturnSlipItem[] // When parcel is returned to sender
  paymentSlipItems      PaymentSlipItem[] // When payment is processed

  // Optimized indexes for common query patterns
  @@index([tenantId, isDeleted]) // Basic tenant filtering
  @@index([tenantId, userId, isDeleted]) // Parcels by user
  @@index([tenantId, parcelStatusCode, isDeleted]) // Parcels by status
  @@index([tenantId, paymentStatus, isDeleted]) // Parcels by payment status
  @@index([tenantId, createdAt, isDeleted]) // Time-based queries within tenant
  @@index([recipientPhone, tenantId]) // Customer phone lookup
  @@index([pickupCityId, destinationCityId]) // Route-based queries
  @@index([deliveredAt]) // Delivered parcels analytics
  @@map("parcels")
}
/**
 * ParcelStatusHistory Model
 * Tracks all status changes for an parcel
 * Provides complete audit trail of parcel lifecycle
 */
model ParcelStatusHistory {
  id             String   @id @default(cuid())
  parcelId       String // Reference to the parcel
  parcelStatusId String // Reference to the status
  statusCode     String   @db.VarChar(50) // Status code for fast queries
  comment        String?  @db.Text // Optional comment about the change
  changedBy      String? // User who made the change
  changedAt      DateTime @default(now()) // When the change occurred

  // Relations with cascade delete - if parcel deleted, remove history
  parcel       Parcel       @relation(fields: [parcelId], references: [id], onDelete: Cascade)
  parcelStatus ParcelStatus @relation(fields: [parcelStatusId], references: [id])

  // Optimized indexes for history queries
  @@index([parcelId, changedAt]) // Parcel history timeline
  @@index([statusCode, changedAt]) // Status-based reporting and analytics
  @@map("parcel_status_history")
}
// ========================================
// DELIVERY SLIPS (Bons de livraison)
// Documents for tracking package collection from senders
// ========================================
/**
 * DeliverySlip Model
 * Represents a collection document for packages from senders
 * Groups multiple parcels for efficient pickup operations
 */
model DeliverySlip {
  id        String  @id @default(cuid())
  tenantId  String // Multi-tenant support
  userId    String // Client/seller who created the slip
  reference String  @unique @db.VarChar(50) // Business reference (BL-XXXXXX-XXX)
  cityId    String? // City where packages are collected

  status DeliverySlipStatus @default(PENDING) // Processing status

  // Reception tracking - when packages are actually collected
  receivedAt DateTime? // When collection was completed
  receivedBy String? // Staff member who performed collection

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations
  city  City?              @relation(fields: [cityId], references: [id])
  items DeliverySlipItem[] // Individual parcels on this slip

  // Optimized indexes for operational queries
  @@index([tenantId, userId, isDeleted]) // Slips by client
  @@index([tenantId, status, isDeleted]) // Slips by processing status
  @@index([tenantId, createdAt, isDeleted]) // Time-based slip queries
  @@map("delivery_slips")
}
/**
 * DeliverySlipItem Model
 * Junction table linking parcels to delivery slips
 * Tracks scanning/processing of individual packages
 */
model DeliverySlipItem {
  deliverySlipId String // Reference to delivery slip
  parcelId       String // Reference to parcel
  scanned        Boolean   @default(false) // Whether package was scanned/processed
  scannedAt      DateTime? // When scanning occurred
  scannedBy      String? // Who performed the scan

  // Relations with cascade delete
  deliverySlip DeliverySlip @relation(fields: [deliverySlipId], references: [id], onDelete: Cascade)
  parcel       Parcel       @relation(fields: [parcelId], references: [id])

  @@id([deliverySlipId, parcelId]) // Composite primary key - efficient and prevents duplicates
  @@index([parcelId]) // Reverse lookup - find slips for an parcel
  @@map("delivery_slip_items")
}
// ========================================
// SHIPPING SLIPS (Bons d'envoi)
// Documents for inter-zone package transfers
// ========================================
/**
 * ShippingSlip Model
 * Manages transfer of packages between different zones/hubs
 * Critical for multi-location delivery networks
 */
model ShippingSlip {
  id                String @id @default(cuid())
  tenantId          String // Multi-tenant support
  reference         String @unique @db.VarChar(50) // Business reference (BE-XXXXXX-XXX)
  destinationZoneId String // Zone receiving the packages

  status ShippingSlipStatus @default(PENDING) // Transfer status

  // Shipping process tracking
  shippedAt  DateTime? // When packages left origin
  shippedBy  String? // Who sent the packages
  receivedAt DateTime? // When packages arrived at destination
  receivedBy String? // Who received the packages

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations
  destinationZone Zone               @relation(fields: [destinationZoneId], references: [id])
  items           ShippingSlipItem[] // Individual parcels being shipped

  // Optimized indexes for logistics queries
  @@index([tenantId, status, isDeleted]) // Slips by status
  @@index([tenantId, createdAt, isDeleted]) // Time-based queries
  @@index([destinationZoneId, status]) // Zone-specific shipping status
  @@map("shipping_slips")
}
/**
 * ShippingSlipItem Model
 * Links individual parcels to shipping slips
 * Tracks package movement between zones
 */
model ShippingSlipItem {
  shippingSlipId String // Reference to shipping slip
  parcelId       String // Reference to parcel being shipped
  scanned        Boolean   @default(false) // Whether package was scanned for shipping
  scannedAt      DateTime? // When scan occurred
  scannedBy      String? // Who performed the scan

  // Relations with cascade delete
  shippingSlip ShippingSlip @relation(fields: [shippingSlipId], references: [id], onDelete: Cascade)
  parcel       Parcel       @relation(fields: [parcelId], references: [id])

  @@id([shippingSlipId, parcelId]) // Composite primary key
  @@index([parcelId]) // Reverse lookup capability
  @@map("shipping_slip_items")
}
// ========================================
// DISTRIBUTION SLIPS (Bons de distribution)
// Documents for assigning packages to delivery personnel
// ========================================
/**
 * DistributionSlip Model
 * Assigns packages to delivery personnel for final delivery
 * Core document for last-mile delivery operations
 */
model DistributionSlip {
  id               String  @id @default(cuid())
  tenantId         String // Multi-tenant support
  reference        String  @unique @db.VarChar(50) // Business reference (BD-XXXXXX-XXX)
  zoneId           String // Zone where delivery occurs
  deliveryPersonId String? // Assigned delivery person

  status DistributionSlipStatus @default(PENDING) // Assignment status

  // Assignment tracking
  assignedAt DateTime? // When assigned to delivery person
  assignedBy String? // Who made the assignment

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations
  zone  Zone                   @relation(fields: [zoneId], references: [id])
  items DistributionSlipItem[] // Parcels assigned for delivery

  // Optimized indexes for delivery management
  @@index([tenantId, status, isDeleted]) // Slips by status
  @@index([tenantId, createdAt, isDeleted]) // Time-based queries
  @@index([zoneId, status]) // Zone-specific distribution status
  @@index([deliveryPersonId, status]) // Person-specific assignments
  @@map("distribution_slips")
}
/**
 * DistributionSlipItem Model
 * Links parcels to distribution assignments
 * Tracks individual package assignments to delivery staff
 */
model DistributionSlipItem {
  distributionSlipId String // Reference to distribution slip
  parcelId           String // Reference to parcel for delivery
  scanned            Boolean   @default(false) // Whether assignment was scanned/confirmed
  scannedAt          DateTime? // When scan occurred
  scannedBy          String? // Who performed the scan

  // Relations with cascade delete
  distributionSlip DistributionSlip @relation(fields: [distributionSlipId], references: [id], onDelete: Cascade)
  parcel           Parcel           @relation(fields: [parcelId], references: [id])

  @@id([distributionSlipId, parcelId]) // Composite primary key
  @@index([parcelId]) // Reverse lookup capability
  @@map("distribution_slip_items")
}
// ========================================
// RETURN SLIPS (Bons de retour)
// Documents for handling undelivered packages
// ========================================
/**
 * ReturnSlip Model
 * Manages packages that couldn't be delivered and need to be returned
 * Supports different return types: from drivers, zones, or back to customers
 */
model ReturnSlip {
  id        String         @id @default(cuid())
  tenantId  String // Multi-tenant support
  reference String         @unique @db.VarChar(50) // Business reference (BRL/BRV/BRC-XXXXXX-XXX)
  type      ReturnSlipType // Type of return (DRIVER/ZONE/CUSTOMER)

  // Type-specific associations - polymorphic relationship pattern
  deliveryPersonId String? // For DRIVER type - returns from delivery staff
  zoneId           String? // For ZONE type - returns from operational zones
  customerId       String? // For CUSTOMER type - returns to specific customers
  customerName     String? @db.VarChar(200) // Display name for customer returns

  status ReturnSlipStatus @default(PENDING) // Processing status

  // Processing workflow tracking
  processedAt DateTime? // When return processing started
  processedBy String? // Who initiated processing
  receivedAt  DateTime? // When returned packages were received
  receivedBy  String? // Who received the returned packages

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations
  zone  Zone?            @relation("ReturnSlipZone", fields: [zoneId], references: [id])
  items ReturnSlipItem[] // Individual parcels being returned

  // Optimized indexes for return management
  @@index([tenantId, type, isDeleted]) // Returns by type
  @@index([tenantId, status, isDeleted]) // Returns by processing status
  @@index([tenantId, createdAt, isDeleted]) // Time-based return queries
  @@index([deliveryPersonId, status]) // Driver-specific returns
  @@index([zoneId, status]) // Zone-specific returns
  @@index([customerId]) // Customer-specific returns
  @@map("return_slips")
}
/**
 * ReturnSlipItem Model
 * Links individual parcels to return slips
 * Captures return reasons and processing details
 */
model ReturnSlipItem {
  returnSlipId String // Reference to return slip
  parcelId     String // Reference to parcel being returned
  returnReason String?   @db.Text // Detailed reason for return
  scanned      Boolean   @default(false) // Whether return was scanned/processed
  scannedAt    DateTime? // When scan occurred
  scannedBy    String? // Who performed the scan

  // Relations with cascade delete
  returnSlip ReturnSlip @relation(fields: [returnSlipId], references: [id], onDelete: Cascade)
  parcel     Parcel     @relation(fields: [parcelId], references: [id])

  @@id([returnSlipId, parcelId]) // Composite primary key
  @@index([parcelId]) // Reverse lookup capability
  @@map("return_slip_items")
}
// ========================================
// PAYMENT SLIPS (Bons de paiement)
// Documents for processing delivery payments and fees
// ========================================
/**
 * PaymentSlip Model
 * Manages payment collection and distribution for delivery services
 * Handles payments to delivery personnel and zone operations
 */
model PaymentSlip {
  id        String          @id @default(cuid())
  tenantId  String // Multi-tenant support
  reference String          @unique @db.VarChar(50) // Business reference (BPL/BPV-XXXXXX-XXX)
  type      PaymentSlipType // Payment type (DRIVER/ZONE)

  // Type-specific associations
  deliveryPersonId String? // For DRIVER type - payments to delivery staff
  zoneId           String? // For ZONE type - payments to zone operations

  // Payment amount breakdown - using Decimal for financial precision
  totalAmount    Decimal @default(0) @db.Decimal(12, 2) // Total payment amount
  cashAmount     Decimal @default(0) @db.Decimal(12, 2) // Cash component
  transferAmount Decimal @default(0) @db.Decimal(12, 2) // Bank transfer component
  additionalFees Decimal @default(0) @db.Decimal(12, 2) // Extra fees and charges

  status PaymentSlipStatus @default(PENDING) // Payment processing status

  // Payment workflow tracking
  processedAt DateTime? // When payment processing started
  processedBy String? // Who initiated processing
  paidAt      DateTime? // When payment was completed
  paidBy      String? // Who completed the payment

  // Additional information
  notes String? @db.Text // Payment notes and comments

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations
  zone            Zone?                      @relation("PaymentSlipZone", fields: [zoneId], references: [id])
  items           PaymentSlipItem[] // Individual parcel payments
  additionalItems PaymentSlipAdditionalFee[] // Extra fees and charges

  // Optimized indexes for financial queries
  @@index([tenantId, type, isDeleted]) // Payments by type
  @@index([tenantId, status, isDeleted]) // Payments by status
  @@index([tenantId, createdAt, isDeleted]) // Time-based payment queries
  @@index([deliveryPersonId, status]) // Driver-specific payments
  @@index([zoneId, status]) // Zone-specific payments
  @@map("payment_slips")
}
/**
 * PaymentSlipItem Model
 * Links individual parcel payments to payment slips
 * Tracks specific fees for each parcel (delivery, return, refusal)
 */
model PaymentSlipItem {
  paymentSlipId String // Reference to payment slip
  parcelId      String // Reference to parcel
  feeType       String  @db.VarChar(20) // Type of fee (DELIVERY, RETURN, REFUSAL)
  amount        Decimal @db.Decimal(10, 2) // Payment amount for this parcel/fee

  // Relations with cascade delete
  paymentSlip PaymentSlip @relation(fields: [paymentSlipId], references: [id], onDelete: Cascade)
  parcel      Parcel      @relation(fields: [parcelId], references: [id])

  @@id([paymentSlipId, parcelId, feeType]) // Composite primary key - prevents duplicate fee types per parcel
  @@index([parcelId]) // Reverse lookup capability
  @@map("payment_slip_items")
}
/**
 * PaymentSlipAdditionalFee Model
 * Handles extra fees and charges not tied to specific parcels
 * Examples: fuel costs, equipment rental, bonus payments
 */
model PaymentSlipAdditionalFee {
  id            String  @id @default(cuid())
  paymentSlipId String // Reference to payment slip
  description   String  @db.VarChar(200) // Fee description
  quantity      Int     @default(1) @db.SmallInt // Quantity for unit-based fees
  unitPrice     Decimal @db.Decimal(10, 2) // Price per unit
  totalPrice    Decimal @db.Decimal(10, 2) // Total fee amount (quantity × unit price)

  // Relations with cascade delete
  paymentSlip PaymentSlip @relation(fields: [paymentSlipId], references: [id], onDelete: Cascade)

  @@index([paymentSlipId]) // Payment slip lookup
  @@map("payment_slip_additional_fees")
}
// ========================================
// ENUMS
// Define the possible values for status and type fields
// ========================================
/**
 * PaymentStatus Enum
 * Tracks the payment lifecycle for parcels
 */
enum PaymentStatus {
  PENDING // Payment not yet received
  PAID // Payment has been received
  INVOICED // Invoice has been generated
}
/**
 * DeliverySlipStatus Enum
 * Tracks the collection process status
 */
enum DeliverySlipStatus {
  PENDING // Created but packages not yet collected
  RECEIVED // Packages have been collected and processed
  CANCELLED // Collection was cancelled
}
/**
 * ShippingSlipStatus Enum
 * Tracks inter-zone transfer status
 */
enum ShippingSlipStatus {
  PENDING // Created but not yet shipped
  SHIPPED // Packages have been sent to destination
  RECEIVED // Packages received at destination zone
  CANCELLED // Shipment was cancelled
}
/**
 * DistributionSlipStatus Enum
 * Tracks delivery assignment status
 */
enum DistributionSlipStatus {
  PENDING // Created but not yet assigned to delivery person
  ASSIGNED // Assigned to delivery person for delivery
  COMPLETED // All packages have been delivered
  CANCELLED // Distribution assignment was cancelled
}
/**
 * ReturnSlipType Enum
 * Defines different types of return processes
 */
enum ReturnSlipType {
  DRIVER // Return from delivery driver to hub (BRL - Bon de Retour Livreur)
  ZONE // Return from zone to central hub (BRV - Bon de Retour Ville)
  CUSTOMER // Return to customer/sender (BRC - Bon de Retour Client)
}
/**
 * ReturnSlipStatus Enum
 * Tracks return processing status
 */
enum ReturnSlipStatus {
  PENDING // Created but processing not started
  INCOMPLETE // Partially processed - some items handled
  RECEIVED // All items have been processed and received
  CANCELLED // Return process was cancelled
}
/**
 * PaymentSlipType Enum
 * Defines different payment slip types
 */
enum PaymentSlipType {
  DRIVER // Payment to delivery driver (BPL - Bon de Paiement Livreur)
  ZONE // Payment to zone operations (BPV - Bon de Paiement Ville)
}
/**
 * PaymentSlipStatus Enum
 * Tracks payment processing workflow
 */
enum PaymentSlipStatus {
  PENDING // Created but processing not started
  IN_PROCESSING // Payment is being processed
  AWAITING_PAYMENT // Waiting for actual payment to be made
  VERIFIED // Payment has been verified
  PAID // Payment completed successfully
  CANCELLED // Payment was cancelled
}
-----------------------------------------------------------------------
--++--> prisma/seed.ts =======>
-----------------------------------------------------------------------
import { PrismaClient } from '@prisma/client';
import { Decimal } from '@prisma/client/runtime/library';
const prisma = new PrismaClient();
/**
 * Reset Database Function
 * Clears all data in reverse dependency parcel to avoid foreign key constraints
 */
async function resetDatabase() {
  console.log('🗑️ Resetting parcels database...');

  // Delete in reverse parcel of dependencies to avoid foreign key constraint errors
  await prisma.paymentSlipAdditionalFee.deleteMany({});
  await prisma.paymentSlipItem.deleteMany({});
  await prisma.paymentSlip.deleteMany({});

  await prisma.returnSlipItem.deleteMany({});
  await prisma.returnSlip.deleteMany({});

  await prisma.distributionSlipItem.deleteMany({});
  await prisma.distributionSlip.deleteMany({});

  await prisma.shippingSlipItem.deleteMany({});
  await prisma.shippingSlip.deleteMany({});

  await prisma.deliverySlipItem.deleteMany({});
  await prisma.deliverySlip.deleteMany({});

  await prisma.parcelStatusHistory.deleteMany({});
  await prisma.parcel.deleteMany({});

  await prisma.tariff.deleteMany({});
  await prisma.parcelStatus.deleteMany({});
  await prisma.zoneCity.deleteMany({});
  await prisma.zone.deleteMany({});
  await prisma.pickupCity.deleteMany({});
  await prisma.city.deleteMany({});

  console.log('✅ Database reset completed');
}
async function main() {
  console.log('🌱 Starting Parcels service seed...');

  // Reset database - comment out if you want to preserve existing data
  await resetDatabase();

  // Multi-tenant configuration
  const tenantId = 'cmfo1utdj00005820owl4mluk';
  const adminUserId = 'cmfo1utlp000g5820u6jov7rw';

  console.log(`📋 Seeding data for tenant: ${tenantId}`);

  // ========================================
  // 1. CREATE CITIES
  // ========================================

  const cities = await Promise.all([
    // Major pickup cities - can accept packages for collection
    prisma.city.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'CAS',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'CAS',
        name: 'Casablanca',
        zone: 'Zone A',
        pickupCity: true, // Can accept pickups
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.city.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'RAB',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'RAB',
        name: 'Rabat',
        zone: 'Zone A',
        pickupCity: true,
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.city.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'MAR',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'MAR',
        name: 'Marrakech',
        zone: 'Zone B',
        pickupCity: true,
        status: true,
        createdBy: adminUserId,
      },
    }),

    // Delivery-only cities - cannot accept pickups
    prisma.city.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'FEZ',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'FEZ',
        name: 'Fez',
        zone: 'Zone B',
        pickupCity: false, // Delivery only
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.city.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'TAN',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'TAN',
        name: 'Tangier',
        zone: 'Zone C',
        pickupCity: false,
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.city.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'AGA',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'AGA',
        name: 'Agadir',
        zone: 'Zone C',
        pickupCity: false,
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.city.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'SALE',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'SALE',
        name: 'Salé',
        zone: 'Zone A',
        pickupCity: false,
        status: true,
        createdBy: adminUserId,
      },
    }),
  ]);

  console.log(`✅ Created ${cities.length} cities`);

  // ========================================
  // 2. CREATE PICKUP CITIES (HUBS)
  // ========================================

  const pickupCities = await Promise.all([
    prisma.pickupCity.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'CAS_HUB',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'CAS_HUB',
        name: 'HUB CASABLANCA',
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.pickupCity.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'RAB_HUB',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'RAB_HUB',
        name: 'HUB RABAT',
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.pickupCity.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'MAR_HUB',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'MAR_HUB',
        name: 'HUB MARRAKECH',
        status: true,
        createdBy: adminUserId,
      },
    }),
  ]);

  console.log(`✅ Created ${pickupCities.length} pickup cities`);

  // ========================================
  // 3. CREATE ZONES
  // ========================================

  const zones = await Promise.all([
    prisma.zone.upsert({
      where: {
        tenantId_name_isDeleted: {
          tenantId,
          name: 'HUB CASABLANCA',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        name: 'HUB CASABLANCA',
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.zone.upsert({
      where: {
        tenantId_name_isDeleted: {
          tenantId,
          name: 'HUB RABAT',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        name: 'HUB RABAT',
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.zone.upsert({
      where: {
        tenantId_name_isDeleted: {
          tenantId,
          name: 'HUB MARRAKECH',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        name: 'HUB MARRAKECH',
        status: true,
        createdBy: adminUserId,
      },
    }),
  ]);

  console.log(`✅ Created ${zones.length} zones`);

  // ========================================
  // 4. ASSIGN CITIES TO ZONES
  // ========================================

  // Get city and zone references for assignments
  const casablancaCity = cities.find((c) => c.ref === 'CAS');
  const rabatCity = cities.find((c) => c.ref === 'RAB');
  const saleCity = cities.find((c) => c.ref === 'SALE');
  const fezCity = cities.find((c) => c.ref === 'FEZ');
  const marrakechCity = cities.find((c) => c.ref === 'MAR');
  const tangierCity = cities.find((c) => c.ref === 'TAN');
  const agadirCity = cities.find((c) => c.ref === 'AGA');

  const casablancaZone = zones.find((z) => z.name === 'HUB CASABLANCA');
  const rabatZone = zones.find((z) => z.name === 'HUB RABAT');
  const marrakechZone = zones.find((z) => z.name === 'HUB MARRAKECH');

  // Create zone-city assignments
  const zoneAssignments = [];

  // Casablanca Zone
  if (casablancaCity && casablancaZone) {
    zoneAssignments.push(
      prisma.zoneCity.upsert({
        where: {
          zoneId_cityId: {
            zoneId: casablancaZone.id,
            cityId: casablancaCity.id,
          },
        },
        update: {},
        create: {
          zoneId: casablancaZone.id,
          cityId: casablancaCity.id,
        },
      }),
    );
  }

  // Rabat Zone (includes Rabat and Salé)
  if (rabatCity && saleCity && rabatZone) {
    zoneAssignments.push(
      prisma.zoneCity.upsert({
        where: {
          zoneId_cityId: {
            zoneId: rabatZone.id,
            cityId: rabatCity.id,
          },
        },
        update: {},
        create: {
          zoneId: rabatZone.id,
          cityId: rabatCity.id,
        },
      }),
      prisma.zoneCity.upsert({
        where: {
          zoneId_cityId: {
            zoneId: rabatZone.id,
            cityId: saleCity.id,
          },
        },
        update: {},
        create: {
          zoneId: rabatZone.id,
          cityId: saleCity.id,
        },
      }),
    );
  }

  // Marrakech Zone (includes Marrakech, Fez, Tangier, Agadir)
  if (marrakechCity && fezCity && tangierCity && agadirCity && marrakechZone) {
    zoneAssignments.push(
      prisma.zoneCity.upsert({
        where: {
          zoneId_cityId: {
            zoneId: marrakechZone.id,
            cityId: marrakechCity.id,
          },
        },
        update: {},
        create: {
          zoneId: marrakechZone.id,
          cityId: marrakechCity.id,
        },
      }),
      prisma.zoneCity.upsert({
        where: {
          zoneId_cityId: {
            zoneId: marrakechZone.id,
            cityId: fezCity.id,
          },
        },
        update: {},
        create: {
          zoneId: marrakechZone.id,
          cityId: fezCity.id,
        },
      }),
      prisma.zoneCity.upsert({
        where: {
          zoneId_cityId: {
            zoneId: marrakechZone.id,
            cityId: tangierCity.id,
          },
        },
        update: {},
        create: {
          zoneId: marrakechZone.id,
          cityId: tangierCity.id,
        },
      }),
      prisma.zoneCity.upsert({
        where: {
          zoneId_cityId: {
            zoneId: marrakechZone.id,
            cityId: agadirCity.id,
          },
        },
        update: {},
        create: {
          zoneId: marrakechZone.id,
          cityId: agadirCity.id,
        },
      }),
    );
  }

  await Promise.all(zoneAssignments);
  console.log(`✅ Created zone-city assignments`);

  // ========================================
  // 5. CREATE PARCEL STATUSES
  // ========================================

  const parcelStatuses = await Promise.all([
    // Initial parcel status
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'NEW_PACKAGE',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'NEW_PACKAGE',
        name: 'Nouveau Colis',
        color: '#3B82F6', // Blue
        isLocked: true, // System-managed status
        status: true,
        createdBy: adminUserId,
      },
    }),

    // Collection and processing statuses
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'RECEIVED',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'RECEIVED',
        name: 'Reçu',
        color: '#10B981', // Emerald
        isLocked: false,
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'COLLECTED',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'COLLECTED',
        name: 'Ramassé',
        color: '#8B5CF6', // Purple
        isLocked: false,
        status: true,
        createdBy: adminUserId,
      },
    }),

    // Shipping and transfer statuses
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'DISPATCHED',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'DISPATCHED',
        name: 'Expédié',
        color: '#F59E0B', // Amber
        isLocked: false,
        status: true,
        createdBy: adminUserId,
      },
    }),

    // Distribution and delivery statuses
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'PUT_IN_DISTRIBUTION',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'PUT_IN_DISTRIBUTION',
        name: 'Mis en distribution',
        color: '#06B6D4', // Cyan
        isLocked: false,
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'OUT_FOR_DELIVERY',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'OUT_FOR_DELIVERY',
        name: 'En cours de livraison',
        color: '#F97316', // Orange
        isLocked: false,
        status: true,
        createdBy: adminUserId,
      },
    }),

    // Final delivery statuses
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'DELIVERED',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'DELIVERED',
        name: 'Livré',
        color: '#22C55E', // Green
        isLocked: true, // System-managed status
        status: true,
        createdBy: adminUserId,
      },
    }),

    // Return and refusal statuses
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'RETURNED',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'RETURNED',
        name: 'Retourné',
        color: '#EF4444', // Red
        isLocked: true, // System-managed status
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'REFUSED',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'REFUSED',
        name: 'Refusé',
        color: '#DC2626', // Red-600
        isLocked: false,
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'CANCELLED',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'CANCELLED',
        name: 'Annulé',
        color: '#6B7280', // Gray
        isLocked: false,
        status: true,
        createdBy: adminUserId,
      },
    }),
  ]);

  console.log(`✅ Created ${parcelStatuses.length} parcel statuses`);

  // ========================================
  // 6. CREATE TARIFFS (PRICING ROUTES)
  // ========================================

  if (
    casablancaCity &&
    rabatCity &&
    fezCity &&
    marrakechCity &&
    tangierCity &&
    agadirCity
  ) {
    const tariffs = await Promise.all([
      // From Casablanca to other cities
      prisma.tariff.upsert({
        where: {
          tenantId_pickupCityId_destinationCityId_isDeleted: {
            tenantId,
            pickupCityId: casablancaCity.id,
            destinationCityId: rabatCity.id,
            isDeleted: false,
          },
        },
        update: {},
        create: {
          tenantId,
          pickupCityId: casablancaCity.id,
          destinationCityId: rabatCity.id,
          deliveryPrice: new Decimal('25.00'), // Using Decimal for precision
          returnPrice: new Decimal('20.00'),
          refusalPrice: new Decimal('15.00'),
          deliveryDelay: 1,
          createdBy: adminUserId,
        },
      }),
      prisma.tariff.upsert({
        where: {
          tenantId_pickupCityId_destinationCityId_isDeleted: {
            tenantId,
            pickupCityId: casablancaCity.id,
            destinationCityId: fezCity.id,
            isDeleted: false,
          },
        },
        update: {},
        create: {
          tenantId,
          pickupCityId: casablancaCity.id,
          destinationCityId: fezCity.id,
          deliveryPrice: new Decimal('40.00'),
          returnPrice: new Decimal('35.00'),
          refusalPrice: new Decimal('25.00'),
          deliveryDelay: 2,
          createdBy: adminUserId,
        },
      }),
      prisma.tariff.upsert({
        where: {
          tenantId_pickupCityId_destinationCityId_isDeleted: {
            tenantId,
            pickupCityId: casablancaCity.id,
            destinationCityId: marrakechCity.id,
            isDeleted: false,
          },
        },
        update: {},
        create: {
          tenantId,
          pickupCityId: casablancaCity.id,
          destinationCityId: marrakechCity.id,
          deliveryPrice: new Decimal('35.00'),
          returnPrice: new Decimal('30.00'),
          refusalPrice: new Decimal('20.00'),
          deliveryDelay: 2,
          createdBy: adminUserId,
        },
      }),
      prisma.tariff.upsert({
        where: {
          tenantId_pickupCityId_destinationCityId_isDeleted: {
            tenantId,
            pickupCityId: casablancaCity.id,
            destinationCityId: tangierCity.id,
            isDeleted: false,
          },
        },
        update: {},
        create: {
          tenantId,
          pickupCityId: casablancaCity.id,
          destinationCityId: tangierCity.id,
          deliveryPrice: new Decimal('45.00'),
          returnPrice: new Decimal('40.00'),
          refusalPrice: new Decimal('30.00'),
          deliveryDelay: 3,
          createdBy: adminUserId,
        },
      }),
      prisma.tariff.upsert({
        where: {
          tenantId_pickupCityId_destinationCityId_isDeleted: {
            tenantId,
            pickupCityId: casablancaCity.id,
            destinationCityId: agadirCity.id,
            isDeleted: false,
          },
        },
        update: {},
        create: {
          tenantId,
          pickupCityId: casablancaCity.id,
          destinationCityId: agadirCity.id,
          deliveryPrice: new Decimal('50.00'),
          returnPrice: new Decimal('45.00'),
          refusalPrice: new Decimal('35.00'),
          deliveryDelay: 3,
          createdBy: adminUserId,
        },
      }),

      // From Rabat to other cities
      prisma.tariff.upsert({
        where: {
          tenantId_pickupCityId_destinationCityId_isDeleted: {
            tenantId,
            pickupCityId: rabatCity.id,
            destinationCityId: casablancaCity.id,
            isDeleted: false,
          },
        },
        update: {},
        create: {
          tenantId,
          pickupCityId: rabatCity.id,
          destinationCityId: casablancaCity.id,
          deliveryPrice: new Decimal('25.00'),
          returnPrice: new Decimal('20.00'),
          refusalPrice: new Decimal('15.00'),
          deliveryDelay: 1,
          createdBy: adminUserId,
        },
      }),

      // From Marrakech to other cities
      prisma.tariff.upsert({
        where: {
          tenantId_pickupCityId_destinationCityId_isDeleted: {
            tenantId,
            pickupCityId: marrakechCity.id,
            destinationCityId: casablancaCity.id,
            isDeleted: false,
          },
        },
        update: {},
        create: {
          tenantId,
          pickupCityId: marrakechCity.id,
          destinationCityId: casablancaCity.id,
          deliveryPrice: new Decimal('35.00'),
          returnPrice: new Decimal('30.00'),
          refusalPrice: new Decimal('20.00'),
          deliveryDelay: 2,
          createdBy: adminUserId,
        },
      }),
    ]);

    console.log(`✅ Created ${tariffs.length} tariff routes`);
  }

  // ========================================
  // 7. CREATE SAMPLE PARCELS
  // ========================================

  const newPackageStatus = parcelStatuses.find((s) => s.code === 'NEW_PACKAGE');

  if (newPackageStatus && casablancaCity && rabatCity && marrakechCity) {
    // Get tariffs for sample parcels
    const casaToRabatTariff = await prisma.tariff.findFirst({
      where: {
        tenantId,
        pickupCityId: casablancaCity.id,
        destinationCityId: rabatCity.id,
        isDeleted: false,
      },
    });

    const casaToMarrakechTariff = await prisma.tariff.findFirst({
      where: {
        tenantId,
        pickupCityId: casablancaCity.id,
        destinationCityId: marrakechCity.id,
        isDeleted: false,
      },
    });

    const sampleParcels = [];

    if (casaToRabatTariff) {
      sampleParcels.push(
        prisma.parcel.create({
          data: {
            tenantId,
            userId: adminUserId,
            code: 'BSK0925539432LE',
            recipientName: 'Ahmed Benjelloun',
            recipientPhone: '+212661234567',
            recipientAddress: '123 Avenue Mohammed V, Agdal, Rabat',
            alternativePhone: '+212537123456',
            pickupCityId: casablancaCity.id,
            destinationCityId: rabatCity.id,
            productName: 'Smartphone Case Premium',
            quantity: 1,
            price: new Decimal('350.00'),
            comment: 'Appeler avant livraison - Livraison après 14h',
            parcelStatusId: newPackageStatus.id,
            parcelStatusCode: newPackageStatus.code,
            deliveryPrice: casaToRabatTariff.deliveryPrice,
            returnPrice: casaToRabatTariff.returnPrice,
            refusalPrice: casaToRabatTariff.refusalPrice,
            deliveryDelay: casaToRabatTariff.deliveryDelay,
            tariffId: casaToRabatTariff.id,
            createdBy: adminUserId,
          },
        }),
        prisma.parcel.create({
          data: {
            tenantId,
            userId: adminUserId,
            code: 'BSK0925539433LE',
            recipientName: 'Fatima El Mansouri',
            recipientPhone: '+212662345678',
            recipientAddress: '456 Rue Hassan II, Centre-ville, Rabat',
            pickupCityId: casablancaCity.id,
            destinationCityId: rabatCity.id,
            productName: 'Laptop Charger Dell',
            quantity: 1,
            price: new Decimal('450.00'),
            parcelStatusId: newPackageStatus.id,
            parcelStatusCode: newPackageStatus.code,
            deliveryPrice: casaToRabatTariff.deliveryPrice,
            returnPrice: casaToRabatTariff.returnPrice,
            refusalPrice: casaToRabatTariff.refusalPrice,
            deliveryDelay: casaToRabatTariff.deliveryDelay,
            tariffId: casaToRabatTariff.id,
            createdBy: adminUserId,
          },
        }),
      );
    }

    if (casaToMarrakechTariff) {
      sampleParcels.push(
        prisma.parcel.create({
          data: {
            tenantId,
            userId: adminUserId,
            code: 'BSK0925539434LE',
            recipientName: 'Youssef Benali',
            recipientPhone: '+212663456789',
            recipientAddress: '789 Avenue Mohammed VI, Gueliz, Marrakech',
            pickupCityId: casablancaCity.id,
            destinationCityId: marrakechCity.id,
            productName: 'Wireless Headphones',
            quantity: 2,
            price: new Decimal('680.00'),
            comment: 'Fragile - Manipuler avec précaution',
            cannotOpen: true, // Special handling
            parcelStatusId: newPackageStatus.id,
            parcelStatusCode: newPackageStatus.code,
            deliveryPrice: casaToMarrakechTariff.deliveryPrice,
            returnPrice: casaToMarrakechTariff.returnPrice,
            refusalPrice: casaToMarrakechTariff.refusalPrice,
            deliveryDelay: casaToMarrakechTariff.deliveryDelay,
            tariffId: casaToMarrakechTariff.id,
            createdBy: adminUserId,
          },
        }),
      );
    }

    const createdParcels = await Promise.all(sampleParcels);
    console.log(`✅ Created ${createdParcels.length} sample parcels`);

    // Create status history for each parcel
    const statusHistories = createdParcels.map((parcel) =>
      prisma.parcelStatusHistory.create({
        data: {
          parcelId: parcel.id,
          parcelStatusId: newPackageStatus.id,
          statusCode: newPackageStatus.code,
          comment: 'Parcel created successfully',
          changedBy: adminUserId,
        },
      }),
    );

    await Promise.all(statusHistories);
    console.log(
      `✅ Created status history for ${statusHistories.length} parcels`,
    );
  }

  // ========================================
  // COMPLETION SUMMARY
  // ========================================

  console.log('\n🎉 Parcels service seed completed successfully!');
  console.log('\n📋 Created Data Summary:');
  console.log(`Tenant ID: ${tenantId}`);
  console.log(`Cities: ${cities.length}`);
  console.log(`Pickup Cities: ${pickupCities.length}`);
  console.log(`Zones: ${zones.length}`);
  console.log(`Parcel Statuses: ${parcelStatuses.length}`);

  const totalTariffs = await prisma.tariff.count({
    where: { tenantId, isDeleted: false },
  });
  const totalParcels = await prisma.parcel.count({
    where: { tenantId, isDeleted: false },
  });

  console.log(`Tariff Routes: ${totalTariffs}`);
  console.log(`Sample Parcels: ${totalParcels}`);

  console.log('\n✅ Database seeding completed - Ready for testing!');
}
// Execute the seeding process
main()
  .catch((e) => {
    console.error('❌ Parcels seed failed:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
-----------------------------------------------------------------------
--++--> src/modules/shipping-slips/dto/shipping-slip.dto.ts =======>
-----------------------------------------------------------------------
import {
  IsString,
  IsArray,
  IsOptional,
  IsNotEmpty,
  IsEnum,
  IsDateString,
} from 'class-validator';
import { Transform, Type } from 'class-transformer';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { PaginationDto } from '../../../common/dto/pagination.dto';
// Enums for status management
export enum ShippingSlipStatus {
  PENDING = 'PENDING',
  SHIPPED = 'SHIPPED',
  RECEIVED = 'RECEIVED',
  CANCELLED = 'CANCELLED',
}
export class CreateShippingSlipDto {
  @ApiProperty({
    example: 'cuid123',
    description: 'Destination zone ID where packages will be shipped',
  })
  @IsString()
  @IsNotEmpty()
  destinationZoneId: string;

  @ApiPropertyOptional({
    example: ['parcel1', 'parcel2'],
    description: 'Array of parcel IDs to include in shipping slip',
  })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  parcelIds?: string[];
}
export class UpdateShippingSlipDto {
  @ApiPropertyOptional({
    example: 'cuid456',
    description: 'Update destination zone ID',
  })
  @IsOptional()
  @IsString()
  destinationZoneId?: string;

  @ApiPropertyOptional({
    enum: ShippingSlipStatus,
    example: ShippingSlipStatus.SHIPPED,
    description: 'Update shipping slip status',
  })
  @IsOptional()
  @IsEnum(ShippingSlipStatus)
  status?: ShippingSlipStatus;

  @ApiPropertyOptional({
    example: ['parcel1', 'parcel2', 'parcel3'],
    description: 'Update parcel IDs in shipping slip',
  })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  parcelIds?: string[];
}
export class ShippingSlipQueryDto extends PaginationDto {
  @ApiPropertyOptional({
    example: 'BE-123456',
    description: 'Search by reference or zone name',
  })
  @IsOptional()
  @IsString()
  search?: string;

  @ApiPropertyOptional({
    example: 'cuid123',
    description: 'Filter by destination zone ID',
  })
  @IsOptional()
  @IsString()
  destinationZoneId?: string;

  @ApiPropertyOptional({
    enum: ShippingSlipStatus,
    example: ShippingSlipStatus.PENDING,
    description: 'Filter by shipping slip status',
  })
  @IsOptional()
  @IsEnum(ShippingSlipStatus)
  status?: ShippingSlipStatus;

  @ApiPropertyOptional({
    example: '2024-01-01',
    description: 'Filter by creation date from (YYYY-MM-DD)',
  })
  @IsOptional()
  @IsDateString()
  dateFrom?: string;

  @ApiPropertyOptional({
    example: '2024-12-31',
    description: 'Filter by creation date to (YYYY-MM-DD)',
  })
  @IsOptional()
  @IsDateString()
  dateTo?: string;
}
export class ShippingSlipItemDto {
  @ApiProperty()
  parcelId: string;

  @ApiProperty()
  scanned: boolean;

  @ApiPropertyOptional()
  scannedAt?: Date;

  @ApiPropertyOptional()
  scannedBy?: string;

  @ApiPropertyOptional()
  parcel?: {
    id: string;
    code: string;
    recipientName: string;
    recipientPhone: string;
    destinationCity: {
      id: string;
      name: string;
      ref: string;
    };
    price: number;
    parcelStatusCode: string;
  };
}
export class ShippingSlipResponseDto {
  @ApiProperty()
  id: string;

  @ApiProperty()
  tenantId: string;

  @ApiProperty()
  reference: string;

  @ApiProperty()
  destinationZoneId: string;

  @ApiProperty({ enum: ShippingSlipStatus })
  status: ShippingSlipStatus;

  @ApiPropertyOptional()
  shippedAt?: Date;

  @ApiPropertyOptional()
  shippedBy?: string;

  @ApiPropertyOptional()
  receivedAt?: Date;

  @ApiPropertyOptional()
  receivedBy?: string;

  @ApiProperty()
  createdAt: Date;

  @ApiProperty()
  updatedAt: Date;

  @ApiPropertyOptional()
  createdBy?: string;

  @ApiPropertyOptional()
  updatedBy?: string;

  @ApiPropertyOptional()
  destinationZone?: {
    id: string;
    name: string;
  };

  @ApiPropertyOptional({ type: [ShippingSlipItemDto] })
  items?: ShippingSlipItemDto[];

  @ApiPropertyOptional()
  _count?: {
    items: number;
    scannedItems: number;
    totalValue: number;
  };
}
export class ShippingSlipStatsDto {
  @ApiProperty({ description: 'Total shipping slips' })
  total: number;

  @ApiProperty({ description: 'Pending shipping slips' })
  pending: number;

  @ApiProperty({ description: 'Shipped but not received' })
  inTransit: number;

  @ApiProperty({ description: 'Completed shipping slips' })
  completed: number;

  @ApiProperty({ description: 'Cancelled shipping slips' })
  cancelled: number;

  @ApiProperty({ description: 'Total packages shipped this month' })
  packagesShippedThisMonth: number;

  @ApiProperty({ description: 'Average packages per slip' })
  averagePackagesPerSlip: number;

  @ApiProperty({ description: 'Top destination zones' })
  topDestinationZones: Array<{
    zoneId: string;
    zoneName: string;
    count: number;
    percentage: number;
  }>;
}
export class AddParcelsToShippingSlipDto {
  @ApiProperty({
    example: ['parcel1', 'parcel2'],
    description: 'Array of parcel IDs to add to shipping slip',
  })
  @IsArray()
  @IsString({ each: true })
  @IsNotEmpty({ each: true })
  parcelIds: string[];
}
export class RemoveParcelsFromShippingSlipDto {
  @ApiProperty({
    example: ['parcel1', 'parcel2'],
    description: 'Array of parcel IDs to remove from shipping slip',
  })
  @IsArray()
  @IsString({ each: true })
  @IsNotEmpty({ each: true })
  parcelIds: string[];
}
export class ScanParcelDto {
  @ApiProperty({
    example: 'BSK0925539432LE',
    description: 'Parcel code to scan',
  })
  @IsString()
  @IsNotEmpty()
  parcelCode: string;
}
export class BulkScanDto {
  @ApiProperty({
    example: ['BSK0925539432LE', 'BSK0925539433LE'],
    description: 'Array of parcel codes to scan',
  })
  @IsArray()
  @IsString({ each: true })
  @IsNotEmpty({ each: true })
  parcelCodes: string[];
}
export class AvailableParcelsQueryDto extends PaginationDto {
  @ApiProperty({
    example: 'cuid123',
    description: 'Destination zone ID to filter available parcels',
  })
  @IsString()
  @IsNotEmpty()
  destinationZoneId: string;

  @ApiPropertyOptional({
    example: 'BSK092',
    description: 'Search parcels by code or recipient name',
  })
  @IsOptional()
  @IsString()
  search?: string;
}
export class AvailableParcelDto {
  @ApiProperty()
  id: string;

  @ApiProperty()
  code: string;

  @ApiProperty()
  recipientName: string;

  @ApiProperty()
  recipientPhone: string;

  @ApiProperty()
  price: number;

  @ApiProperty()
  parcelStatusCode: string;

  @ApiProperty()
  createdAt: Date;

  @ApiProperty()
  pickupCity: {
    id: string;
    name: string;
    ref: string;
  };

  @ApiProperty()
  destinationCity: {
    id: string;
    name: string;
    ref: string;
  };
}
-----------------------------------------------------------------------
--++--> src/modules/shipping-slips/shipping-slips.controller.ts =======>
-----------------------------------------------------------------------
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  HttpStatus,
  HttpCode,
  BadRequestException,
} from '@nestjs/common';
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiParam,
  ApiBadRequestResponse,
  ApiNotFoundResponse,
  ApiConflictResponse,
} from '@nestjs/swagger';
import { ShippingSlipsService } from './shipping-slips.service';
import {
  CreateShippingSlipDto,
  UpdateShippingSlipDto,
  ShippingSlipQueryDto,
  ShippingSlipResponseDto,
  ShippingSlipStatsDto,
  AddParcelsToShippingSlipDto,
  RemoveParcelsFromShippingSlipDto,
  ScanParcelDto,
  BulkScanDto,
  AvailableParcelsQueryDto,
  AvailableParcelDto,
} from './dto/shipping-slip.dto';
import { PaginatedResult } from '../../common/dto/pagination.dto';
import {
  GlobalAuth,
  CurrentTenant,
  CurrentUser,
  Public,
} from '@network-saas/auth-lib';
import { ParseCuidPipe } from '../../common/pipes/parse-cuid.pipe';
@ApiTags('shipping-slips')
@Controller('shipping-slips')
export class ShippingSlipsController {
  constructor(private readonly shippingSlipsService: ShippingSlipsService) {}

  @Post()
  @GlobalAuth('shipping_slips:create')
  @ApiOperation({
    summary: 'Create a new shipping slip',
    description:
      'Create a shipping slip for transferring packages between zones',
  })
  @ApiResponse({
    status: 201,
    description: 'Shipping slip created successfully',
    type: ShippingSlipResponseDto,
  })
  @ApiBadRequestResponse({ description: 'Invalid zone or parcels' })
  async create(
    @Body() createDto: CreateShippingSlipDto,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<ShippingSlipResponseDto> {
    return this.shippingSlipsService.create(createDto, tenantId, user.id);
  }

  @Get()
  @GlobalAuth('shipping_slips:read')
  @ApiOperation({
    summary: 'Get all shipping slips',
    description: 'Retrieve paginated list of shipping slips with filtering',
  })
  @ApiResponse({
    status: 200,
    description: 'Shipping slips retrieved successfully',
    type: PaginatedResult<ShippingSlipResponseDto>,
  })
  async findAll(
    @CurrentTenant() tenantId: string,
    @Query() query: ShippingSlipQueryDto,
  ): Promise<PaginatedResult<ShippingSlipResponseDto>> {
    return this.shippingSlipsService.findAll(tenantId, query);
  }

  @Get('stats')
  @GlobalAuth('shipping_slips:read')
  @ApiOperation({
    summary: 'Get shipping slip statistics',
    description: 'Get comprehensive statistics about shipping operations',
  })
  @ApiResponse({
    status: 200,
    description: 'Statistics retrieved successfully',
    type: ShippingSlipStatsDto,
  })
  async getStatistics(
    @CurrentTenant() tenantId: string,
  ): Promise<ShippingSlipStatsDto> {
    return this.shippingSlipsService.getStatistics(tenantId);
  }

  @Get('available-parcels')
  @GlobalAuth('shipping_slips:read')
  @ApiOperation({
    summary: 'Get available parcels for shipping',
    description:
      'Get parcels that can be added to a shipping slip for a specific zone',
  })
  @ApiResponse({
    status: 200,
    description: 'Available parcels retrieved successfully',
    type: PaginatedResult<AvailableParcelDto>,
  })
  async getAvailableParcels(
    @CurrentTenant() tenantId: string,
    @Query() query: AvailableParcelsQueryDto,
  ): Promise<PaginatedResult<AvailableParcelDto>> {
    return this.shippingSlipsService.getAvailableParcels(tenantId, query);
  }

  @Get(':id')
  @GlobalAuth('shipping_slips:read')
  @ApiOperation({
    summary: 'Get shipping slip by ID',
    description: 'Retrieve a specific shipping slip with all items',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Shipping slip ID' })
  @ApiResponse({
    status: 200,
    description: 'Shipping slip retrieved successfully',
    type: ShippingSlipResponseDto,
  })
  @ApiNotFoundResponse({ description: 'Shipping slip not found' })
  async findOne(
    @Param('id', ParseCuidPipe) id: string,
    @CurrentTenant() tenantId: string,
  ): Promise<ShippingSlipResponseDto> {
    return this.shippingSlipsService.findOne(id, tenantId);
  }

  @Patch(':id')
  @GlobalAuth('shipping_slips:update')
  @ApiOperation({
    summary: 'Update shipping slip',
    description: 'Update shipping slip details',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Shipping slip ID' })
  @ApiResponse({
    status: 200,
    description: 'Shipping slip updated successfully',
    type: ShippingSlipResponseDto,
  })
  @ApiNotFoundResponse({ description: 'Shipping slip not found' })
  @ApiBadRequestResponse({ description: 'Cannot modify shipped/received slip' })
  async update(
    @Param('id', ParseCuidPipe) id: string,
    @Body() updateDto: UpdateShippingSlipDto,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<ShippingSlipResponseDto> {
    return this.shippingSlipsService.update(id, updateDto, tenantId, user.id);
  }

  @Delete(':id')
  @GlobalAuth('shipping_slips:delete')
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({
    summary: 'Delete shipping slip',
    description: 'Soft delete a shipping slip (only if pending)',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Shipping slip ID' })
  @ApiResponse({
    status: 204,
    description: 'Shipping slip deleted successfully',
  })
  @ApiNotFoundResponse({ description: 'Shipping slip not found' })
  @ApiBadRequestResponse({ description: 'Cannot delete shipped/received slip' })
  async remove(
    @Param('id', ParseCuidPipe) id: string,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<void> {
    await this.shippingSlipsService.remove(id, tenantId, user.id);
  }

  @Post(':id/add-parcels')
  @GlobalAuth('shipping_slips:update')
  @ApiOperation({
    summary: 'Add parcels to shipping slip',
    description: 'Add multiple parcels to an existing shipping slip',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Shipping slip ID' })
  @ApiResponse({
    status: 200,
    description: 'Parcels added successfully',
    type: ShippingSlipResponseDto,
  })
  @ApiBadRequestResponse({
    description: 'Invalid parcels or slip not modifiable',
  })
  async addParcels(
    @Param('id', ParseCuidPipe) id: string,
    @Body() addParcelsDto: AddParcelsToShippingSlipDto,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<ShippingSlipResponseDto> {
    return this.shippingSlipsService.addParcels(
      id,
      addParcelsDto.parcelIds,
      tenantId,
      user.id,
    );
  }

  @Post(':id/remove-parcels')
  @GlobalAuth('shipping_slips:update')
  @ApiOperation({
    summary: 'Remove parcels from shipping slip',
    description: 'Remove multiple parcels from an existing shipping slip',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Shipping slip ID' })
  @ApiResponse({
    status: 200,
    description: 'Parcels removed successfully',
    type: ShippingSlipResponseDto,
  })
  @ApiBadRequestResponse({
    description: 'Parcels not in slip or slip not modifiable',
  })
  async removeParcels(
    @Param('id', ParseCuidPipe) id: string,
    @Body() removeParcelsDto: RemoveParcelsFromShippingSlipDto,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<ShippingSlipResponseDto> {
    return this.shippingSlipsService.removeParcels(
      id,
      removeParcelsDto.parcelIds,
      tenantId,
      user.id,
    );
  }

  @Post(':id/scan-parcel')
  @GlobalAuth('shipping_slips:scan')
  @ApiOperation({
    summary: 'Scan parcel for shipping',
    description: 'Scan an parcel code to mark it as processed for shipping',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Shipping slip ID' })
  @ApiResponse({
    status: 200,
    description: 'Parcel scanned successfully',
    schema: {
      type: 'object',
      properties: {
        success: { type: 'boolean' },
        message: { type: 'string' },
        parcel: { type: 'object' },
        scanInfo: { type: 'object' },
      },
    },
  })
  @ApiBadRequestResponse({
    description: 'Parcel not in slip or already scanned',
  })
  async scanParcel(
    @Param('id', ParseCuidPipe) id: string,
    @Body() scanDto: ScanParcelDto,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ) {
    return this.shippingSlipsService.scanParcel(
      id,
      scanDto.parcelCode,
      tenantId,
      user.id,
    );
  }

  @Post(':id/scan-bulk')
  @GlobalAuth('shipping_slips:scan')
  @ApiOperation({
    summary: 'Bulk scan parcels for shipping',
    description: 'Scan multiple parcel codes at once',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Shipping slip ID' })
  @ApiResponse({
    status: 200,
    description: 'Bulk scan completed',
    schema: {
      type: 'object',
      properties: {
        success: { type: 'boolean' },
        scannedCount: { type: 'number' },
        failedCount: { type: 'number' },
        results: { type: 'array', items: { type: 'object' } },
      },
    },
  })
  async bulkScanParcels(
    @Param('id', ParseCuidPipe) id: string,
    @Body() bulkScanDto: BulkScanDto,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ) {
    return this.shippingSlipsService.bulkScanParcels(
      id,
      bulkScanDto.parcelCodes,
      tenantId,
      user.id,
    );
  }

  @Post(':id/ship')
  @GlobalAuth('shipping_slips:ship')
  @ApiOperation({
    summary: 'Mark shipping slip as shipped',
    description: 'Mark the shipping slip as shipped and update parcel statuses',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Shipping slip ID' })
  @ApiResponse({
    status: 200,
    description: 'Shipping slip marked as shipped',
    type: ShippingSlipResponseDto,
  })
  @ApiBadRequestResponse({
    description: 'Cannot ship - invalid status or no parcels',
  })
  async markAsShipped(
    @Param('id', ParseCuidPipe) id: string,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<ShippingSlipResponseDto> {
    return this.shippingSlipsService.markAsShipped(id, tenantId, user.id);
  }

  @Post(':id/receive')
  @GlobalAuth('shipping_slips:receive')
  @ApiOperation({
    summary: 'Mark shipping slip as received',
    description: 'Mark the shipping slip as received at destination zone',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Shipping slip ID' })
  @ApiResponse({
    status: 200,
    description: 'Shipping slip marked as received',
    type: ShippingSlipResponseDto,
  })
  @ApiBadRequestResponse({
    description: 'Cannot receive - must be shipped first',
  })
  async markAsReceived(
    @Param('id', ParseCuidPipe) id: string,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<ShippingSlipResponseDto> {
    return this.shippingSlipsService.markAsReceived(id, tenantId, user.id);
  }

  @Post(':id/cancel')
  @GlobalAuth('shipping_slips:cancel')
  @ApiOperation({
    summary: 'Cancel shipping slip',
    description: 'Cancel a shipping slip and revert parcel statuses',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Shipping slip ID' })
  @ApiResponse({
    status: 200,
    description: 'Shipping slip cancelled successfully',
    type: ShippingSlipResponseDto,
  })
  @ApiBadRequestResponse({ description: 'Cannot cancel - already received' })
  async cancelShippingSlip(
    @Param('id', ParseCuidPipe) id: string,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<ShippingSlipResponseDto> {
    return this.shippingSlipsService.cancelShippingSlip(id, tenantId, user.id);
  }

  @Get(':id/pdf')
  @GlobalAuth('shipping_slips:read')
  @ApiOperation({
    summary: 'Generate shipping slip PDF',
    description: 'Generate and download PDF for the shipping slip',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Shipping slip ID' })
  @ApiResponse({
    status: 200,
    description: 'PDF generated successfully',
    headers: {
      'Content-Type': { description: 'application/pdf' },
      'Content-Disposition': { description: 'attachment; filename=...' },
    },
  })
  async generatePDF(
    @Param('id', ParseCuidPipe) id: string,
    @CurrentTenant() tenantId: string,
  ) {
    return this.shippingSlipsService.generatePDF(id, tenantId);
  }
}
-----------------------------------------------------------------------
--++--> src/modules/shipping-slips/shipping-slips.module.ts =======>
-----------------------------------------------------------------------
import { Module } from '@nestjs/common';
import { ShippingSlipsService } from './shipping-slips.service';
import { ShippingSlipsController } from './shipping-slips.controller';
import { PrismaModule } from '../../shared/services/prisma/prisma.module';
import { RedisModule } from '../../shared/services/redis/redis.module';
@Module({
  imports: [PrismaModule, RedisModule],
  controllers: [ShippingSlipsController],
  providers: [ShippingSlipsService],
  exports: [ShippingSlipsService],
})
export class ShippingSlipsModule {}
-----------------------------------------------------------------------
--++--> src/modules/shipping-slips/services/shipping-slips.service.ts =======>
-----------------------------------------------------------------------
import {
  Injectable,
  NotFoundException,
  BadRequestException,
  ConflictException,
  Logger,
} from '@nestjs/common';
import { PrismaService } from '../../shared/services/prisma/prisma.service';
import { RedisService } from '../../shared/services/redis/redis.service';
import {
  CreateShippingSlipDto,
  UpdateShippingSlipDto,
  ShippingSlipQueryDto,
  ShippingSlipResponseDto,
  ShippingSlipStatsDto,
  ShippingSlipStatus,
  AvailableParcelsQueryDto,
  AvailableParcelDto,
} from './dto/shipping-slip.dto';
import { PaginatedResult } from '../../common/dto/pagination.dto';
@Injectable()
export class ShippingSlipsService {
  private readonly logger = new Logger(ShippingSlipsService.name);

  constructor(
    private prisma: PrismaService,
    private redis: RedisService,
  ) {}

  async create(
    createDto: CreateShippingSlipDto,
    tenantId: string,
    userId: string,
  ): Promise<ShippingSlipResponseDto> {
    // Validate destination zone exists
    const destinationZone = await this.prisma.zone.findFirst({
      where: {
        id: createDto.destinationZoneId,
        tenantId,
        isDeleted: false,
        status: true,
      },
    });

    if (!destinationZone) {
      throw new BadRequestException('Invalid destination zone');
    }

    // Generate reference
    const reference = await this.generateReference(tenantId);

    // Validate parcels if provided
    let validatedParcels: string[] = [];
    if (createDto.parcelIds && createDto.parcelIds.length > 0) {
      validatedParcels = await this.validateParcelsForShipping(
        createDto.parcelIds,
        createDto.destinationZoneId,
        tenantId,
      );
    }

    // Create shipping slip in transaction
    const result = await this.prisma.$transaction(async (tx) => {
      // Create the shipping slip
      const shippingSlip = await tx.shippingSlip.create({
        data: {
          reference,
          destinationZoneId: createDto.destinationZoneId,
          status: ShippingSlipStatus.PENDING,
          tenantId,
          createdBy: userId,
        },
      });

      // Add parcels if provided
      if (validatedParcels.length > 0) {
        await tx.shippingSlipItem.createMany({
          data: validatedParcels.map((parcelId) => ({
            shippingSlipId: shippingSlip.id,
            parcelId,
          })),
        });

        // Update parcel status to DISPATCHED
        await tx.parcel.updateMany({
          where: {
            id: { in: validatedParcels },
            tenantId,
          },
          data: {
            parcelStatusCode: 'DISPATCHED',
            updatedBy: userId,
          },
        });

        // Add status history for parcels
        const dispatchedStatus = await tx.parcelStatus.findFirst({
          where: { tenantId, code: 'DISPATCHED', isDeleted: false },
        });

        if (dispatchedStatus) {
          await tx.parcelStatusHistory.createMany({
            data: validatedParcels.map((parcelId) => ({
              parcelId,
              parcelStatusId: dispatchedStatus.id,
              statusCode: 'DISPATCHED',
              comment: `Added to shipping slip ${reference}`,
              changedBy: userId,
            })),
          });
        }
      }

      return shippingSlip;
    });

    await this.clearCache(tenantId);

    this.logger.log(
      `Created shipping slip ${reference} for zone ${destinationZone.name} with ${validatedParcels.length} parcels`,
    );

    return this.findOne(result.id, tenantId);
  }

  async findAll(
    tenantId: string,
    query: ShippingSlipQueryDto,
  ): Promise<PaginatedResult<ShippingSlipResponseDto>> {
    const {
      page = 1,
      limit = 10,
      search,
      destinationZoneId,
      status,
      dateFrom,
      dateTo,
    } = query;
    const skip = (page - 1) * limit;

    // Build where clause
    const where: any = {
      tenantId,
      isDeleted: false,
    };

    if (search) {
      where.OR = [
        { reference: { contains: search, mode: 'insensitive' } },
        {
          destinationZone: {
            name: { contains: search, mode: 'insensitive' },
          },
        },
      ];
    }

    if (destinationZoneId) {
      where.destinationZoneId = destinationZoneId;
    }

    if (status) {
      where.status = status;
    }

    // Date filtering
    if (dateFrom || dateTo) {
      where.createdAt = {};
      if (dateFrom) {
        where.createdAt.gte = new Date(dateFrom);
      }
      if (dateTo) {
        const endDate = new Date(dateTo);
        endDate.setHours(23, 59, 59, 999);
        where.createdAt.lte = endDate;
      }
    }

    const [total, shippingSlips] = await Promise.all([
      this.prisma.shippingSlip.count({ where }),
      this.prisma.shippingSlip.findMany({
        where,
        skip,
        take: limit,
        orderBy: [{ createdAt: 'desc' }],
        include: {
          destinationZone: {
            select: { id: true, name: true },
          },
          _count: {
            select: { items: true },
          },
          items: {
            take: 5, // Limit for performance
            include: {
              parcel: {
                select: {
                  code: true,
                  recipientName: true,
                  price: true,
                },
              },
            },
          },
        },
      }),
    ]);

    const data = shippingSlips.map((slip) => this.mapToResponseDto(slip));
    return new PaginatedResult(data, page, limit, total);
  }

  async findOne(
    id: string,
    tenantId: string,
  ): Promise<ShippingSlipResponseDto> {
    const shippingSlip = await this.prisma.shippingSlip.findFirst({
      where: {
        id,
        tenantId,
        isDeleted: false,
      },
      include: {
        destinationZone: {
          select: { id: true, name: true },
        },
        _count: {
          select: { items: true },
        },
        items: {
          include: {
            parcel: {
              select: {
                id: true,
                code: true,
                recipientName: true,
                recipientPhone: true,
                price: true,
                parcelStatusCode: true,
                destinationCity: {
                  select: {
                    id: true,
                    name: true,
                    ref: true,
                  },
                },
              },
            },
          },
          orderBy: { parcel: { code: 'asc' } },
        },
      },
    });

    if (!shippingSlip) {
      throw new NotFoundException('Shipping slip not found');
    }

    return this.mapToResponseDto(shippingSlip);
  }

  async update(
    id: string,
    updateDto: UpdateShippingSlipDto,
    tenantId: string,
    userId: string,
  ): Promise<ShippingSlipResponseDto> {
    const existing = await this.prisma.shippingSlip.findFirst({
      where: { id, tenantId, isDeleted: false },
      include: { _count: { select: { items: true } } },
    });

    if (!existing) {
      throw new NotFoundException('Shipping slip not found');
    }

    // Check if modifiable
    if (existing.status !== ShippingSlipStatus.PENDING) {
      throw new BadRequestException(
        `Cannot modify shipping slip with status: ${existing.status}`,
      );
    }

    // Validate destination zone if updating
    if (updateDto.destinationZoneId) {
      const zone = await this.prisma.zone.findFirst({
        where: {
          id: updateDto.destinationZoneId,
          tenantId,
          isDeleted: false,
          status: true,
        },
      });

      if (!zone) {
        throw new BadRequestException('Invalid destination zone');
      }
    }

    // Handle parcel updates in transaction
    const result = await this.prisma.$transaction(async (tx) => {
      // Update shipping slip
      const updatedSlip = await tx.shippingSlip.update({
        where: { id },
        data: {
          destinationZoneId: updateDto.destinationZoneId,
          status: updateDto.status,
          updatedBy: userId,
        },
      });

      // Handle parcel replacements
      if (updateDto.parcelIds !== undefined) {
        // Get current parcels
        const currentItems = await tx.shippingSlipItem.findMany({
          where: { shippingSlipId: id },
        });
        const currentParcelIds = currentItems.map((item) => item.parcelId);

        // Remove all current parcels
        if (currentItems.length > 0) {
          await tx.shippingSlipItem.deleteMany({
            where: { shippingSlipId: id },
          });

          // Revert parcel statuses
          await tx.parcel.updateMany({
            where: { id: { in: currentParcelIds }, tenantId },
            data: { parcelStatusCode: 'COLLECTED', updatedBy: userId },
          });
        }

        // Add new parcels if provided
        if (updateDto.parcelIds.length > 0) {
          const validatedParcels = await this.validateParcelsForShipping(
            updateDto.parcelIds,
            updateDto.destinationZoneId || existing.destinationZoneId,
            tenantId,
          );

          await tx.shippingSlipItem.createMany({
            data: validatedParcels.map((parcelId) => ({
              shippingSlipId: id,
              parcelId,
            })),
          });

          // Update new parcel statuses
          await tx.parcel.updateMany({
            where: { id: { in: validatedParcels }, tenantId },
            data: { parcelStatusCode: 'DISPATCHED', updatedBy: userId },
          });
        }
      }

      return updatedSlip;
    });

    await this.clearCache(tenantId);

    this.logger.log(`Updated shipping slip ${id} for tenant ${tenantId}`);
    return this.findOne(id, tenantId);
  }

  async remove(id: string, tenantId: string, userId: string): Promise<void> {
    const existing = await this.prisma.shippingSlip.findFirst({
      where: { id, tenantId, isDeleted: false },
      include: {
        items: true,
      },
    });

    if (!existing) {
      throw new NotFoundException('Shipping slip not found');
    }

    if (existing.status !== ShippingSlipStatus.PENDING) {
      throw new BadRequestException(
        'Cannot delete shipping slip that has been shipped or received',
      );
    }

    await this.prisma.$transaction(async (tx) => {
      // Revert parcel statuses
      if (existing.items.length > 0) {
        const parcelIds = existing.items.map((item) => item.parcelId);

        await tx.parcel.updateMany({
          where: { id: { in: parcelIds }, tenantId },
          data: { parcelStatusCode: 'COLLECTED', updatedBy: userId },
        });

        // Remove shipping slip items
        await tx.shippingSlipItem.deleteMany({
          where: { shippingSlipId: id },
        });
      }

      // Soft delete shipping slip
      await tx.shippingSlip.update({
        where: { id },
        data: {
          isDeleted: true,
          deletedAt: new Date(),
          deletedBy: userId,
        },
      });
    });

    await this.clearCache(tenantId);
    this.logger.log(`Deleted shipping slip ${id} for tenant ${tenantId}`);
  }

  async getAvailableParcels(
    tenantId: string,
    query: AvailableParcelsQueryDto,
  ): Promise<PaginatedResult<AvailableParcelDto>> {
    const { page = 1, limit = 10, destinationZoneId, search } = query;
    const skip = (page - 1) * limit;

    // Validate destination zone
    const zone = await this.prisma.zone.findFirst({
      where: {
        id: destinationZoneId,
        tenantId,
        isDeleted: false,
      },
      include: {
        cities: {
          include: {
            city: { select: { id: true } },
          },
        },
      },
    });

    if (!zone) {
      throw new BadRequestException('Invalid destination zone');
    }

    const zoneCityIds = zone.cities.map((zc) => zc.city.id);

    // Build where clause for available parcels
    const where: any = {
      tenantId,
      isDeleted: false,
      parcelStatusCode: 'COLLECTED', // Only collected parcels can be shipped
      destinationCityId: { in: zoneCityIds }, // Parcels going to cities in this zone
      shippingSlipItems: { none: {} }, // Not already in a shipping slip
    };

    if (search) {
      where.OR = [
        { code: { contains: search, mode: 'insensitive' } },
        { recipientName: { contains: search, mode: 'insensitive' } },
      ];
    }

    const [total, parcels] = await Promise.all([
      this.prisma.parcel.count({ where }),
      this.prisma.parcel.findMany({
        where,
        skip,
        take: limit,
        orderBy: [{ createdAt: 'desc' }],
        select: {
          id: true,
          code: true,
          recipientName: true,
          recipientPhone: true,
          price: true,
          parcelStatusCode: true,
          createdAt: true,
          pickupCity: {
            select: { id: true, name: true, ref: true },
          },
          destinationCity: {
            select: { id: true, name: true, ref: true },
          },
        },
      }),
    ]);

    const data = parcels.map((parcel) => ({
      ...parcel,
      price: Number(parcel.price),
    }));

    return new PaginatedResult(data, page, limit, total);
  }

  async addParcels(
    id: string,
    parcelIds: string[],
    tenantId: string,
    userId: string,
  ): Promise<ShippingSlipResponseDto> {
    const shippingSlip = await this.prisma.shippingSlip.findFirst({
      where: { id, tenantId, isDeleted: false },
      include: { items: true },
    });

    if (!shippingSlip) {
      throw new NotFoundException('Shipping slip not found');
    }

    if (shippingSlip.status !== ShippingSlipStatus.PENDING) {
      throw new BadRequestException('Cannot modify shipped or received slip');
    }

    // Validate parcels
    const validatedParcels = await this.validateParcelsForShipping(
      parcelIds,
      shippingSlip.destinationZoneId,
      tenantId,
    );

    // Check if any parcels are already in this slip
    const existingParcelIds = shippingSlip.items.map((item) => item.parcelId);
    const newParcels = validatedParcels.filter(
      (parcelId) => !existingParcelIds.includes(parcelId),
    );

    if (newParcels.length === 0) {
      throw new BadRequestException(
        'All parcels are already in this shipping slip',
      );
    }

    await this.prisma.$transaction(async (tx) => {
      // Add new parcels
      await tx.shippingSlipItem.createMany({
        data: newParcels.map((parcelId) => ({
          shippingSlipId: id,
          parcelId,
        })),
      });

      // Update parcel statuses
      await tx.parcel.updateMany({
        where: { id: { in: newParcels }, tenantId },
        data: { parcelStatusCode: 'DISPATCHED', updatedBy: userId },
      });

      // Add status history
      const dispatchedStatus = await tx.parcelStatus.findFirst({
        where: { tenantId, code: 'DISPATCHED', isDeleted: false },
      });

      if (dispatchedStatus) {
        await tx.parcelStatusHistory.createMany({
          data: newParcels.map((parcelId) => ({
            parcelId,
            parcelStatusId: dispatchedStatus.id,
            statusCode: 'DISPATCHED',
            comment: `Added to shipping slip ${shippingSlip.reference}`,
            changedBy: userId,
          })),
        });
      }

      // Update shipping slip
      await tx.shippingSlip.update({
        where: { id },
        data: { updatedBy: userId },
      });
    });

    await this.clearCache(tenantId);

    this.logger.log(
      `Added ${newParcels.length} parcels to shipping slip ${shippingSlip.reference}`,
    );

    return this.findOne(id, tenantId);
  }

  async removeParcels(
    id: string,
    parcelIds: string[],
    tenantId: string,
    userId: string,
  ): Promise<ShippingSlipResponseDto> {
    const shippingSlip = await this.prisma.shippingSlip.findFirst({
      where: { id, tenantId, isDeleted: false },
      include: { items: true },
    });

    if (!shippingSlip) {
      throw new NotFoundException('Shipping slip not found');
    }

    if (shippingSlip.status !== ShippingSlipStatus.PENDING) {
      throw new BadRequestException('Cannot modify shipped or received slip');
    }

    // Check which parcels are actually in the slip
    const existingParcelIds = shippingSlip.items.map((item) => item.parcelId);
    const parcelsToRemove = parcelIds.filter((parcelId) =>
      existingParcelIds.includes(parcelId),
    );

    if (parcelsToRemove.length === 0) {
      throw new BadRequestException(
        'None of the specified parcels are in this shipping slip',
      );
    }

    await this.prisma.$transaction(async (tx) => {
      // Remove parcels from slip
      await tx.shippingSlipItem.deleteMany({
        where: {
          shippingSlipId: id,
          parcelId: { in: parcelsToRemove },
        },
      });

      // Revert parcel statuses
      await tx.parcel.updateMany({
        where: { id: { in: parcelsToRemove }, tenantId },
        data: { parcelStatusCode: 'COLLECTED', updatedBy: userId },
      });

      // Update shipping slip
      await tx.shippingSlip.update({
        where: { id },
        data: { updatedBy: userId },
      });
    });

    await this.clearCache(tenantId);

    this.logger.log(
      `Removed ${parcelsToRemove.length} parcels from shipping slip ${shippingSlip.reference}`,
    );

    return this.findOne(id, tenantId);
  }

  async scanParcel(
    id: string,
    parcelCode: string,
    tenantId: string,
    userId: string,
  ) {
    const shippingSlip = await this.prisma.shippingSlip.findFirst({
      where: { id, tenantId, isDeleted: false },
      include: {
        items: {
          include: {
            parcel: { select: { id: true, code: true, recipientName: true } },
          },
        },
      },
    });

    if (!shippingSlip) {
      throw new NotFoundException('Shipping slip not found');
    }

    // Find the parcel in the slip
    const slipItem = shippingSlip.items.find(
      (item) => item.parcel.code === parcelCode,
    );

    if (!slipItem) {
      throw new BadRequestException('Parcel not found in this shipping slip');
    }

    if (slipItem.scanned) {
      throw new BadRequestException('Parcel has already been scanned');
    }

    // Update scan status
    const updatedItem = await this.prisma.shippingSlipItem.update({
      where: {
        shippingSlipId_parcelId: {
          shippingSlipId: id,
          parcelId: slipItem.parcelId,
        },
      },
      data: {
        scanned: true,
        scannedAt: new Date(),
        scannedBy: userId,
      },
      include: {
        parcel: {
          select: {
            code: true,
            recipientName: true,
            recipientPhone: true,
            destinationCity: { select: { name: true } },
          },
        },
      },
    });

    this.logger.log(
      `Scanned parcel ${parcelCode} in shipping slip ${shippingSlip.reference}`,
    );

    return {
      success: true,
      message: `Parcel ${parcelCode} scanned successfully`,
      parcel: updatedItem.parcel,
      scanInfo: {
        scannedAt: updatedItem.scannedAt,
        scannedBy: userId,
      },
    };
  }

  async bulkScanParcels(
    id: string,
    parcelCodes: string[],
    tenantId: string,
    userId: string,
  ) {
    const results = [];
    let scannedCount = 0;
    let failedCount = 0;

    for (const parcelCode of parcelCodes) {
      try {
        const result = await this.scanParcel(id, parcelCode, tenantId, userId);
        results.push({ parcelCode, success: true, ...result });
        scannedCount++;
      } catch (error) {
        results.push({
          parcelCode,
          success: false,
          error: error.message,
        });
        failedCount++;
      }
    }

    this.logger.log(
      `Bulk scan completed: ${scannedCount} successful, ${failedCount} failed`,
    );

    return {
      success: true,
      scannedCount,
      failedCount,
      results,
    };
  }

  async markAsShipped(
    id: string,
    tenantId: string,
    userId: string,
  ): Promise<ShippingSlipResponseDto> {
    const shippingSlip = await this.prisma.shippingSlip.findFirst({
      where: { id, tenantId, isDeleted: false },
      include: { items: true, _count: { select: { items: true } } },
    });

    if (!shippingSlip) {
      throw new NotFoundException('Shipping slip not found');
    }

    if (shippingSlip.status !== ShippingSlipStatus.PENDING) {
      throw new BadRequestException('Only pending slips can be shipped');
    }

    if (shippingSlip._count.items === 0) {
      throw new BadRequestException('Cannot ship empty shipping slip');
    }

    const updatedSlip = await this.prisma.shippingSlip.update({
      where: { id },
      data: {
        status: ShippingSlipStatus.SHIPPED,
        shippedAt: new Date(),
        shippedBy: userId,
        updatedBy: userId,
      },
    });

    await this.clearCache(tenantId);

    this.logger.log(
      `Marked shipping slip ${shippingSlip.reference} as shipped`,
    );

    return this.findOne(id, tenantId);
  }

  async markAsReceived(
    id: string,
    tenantId: string,
    userId: string,
  ): Promise<ShippingSlipResponseDto> {
    const shippingSlip = await this.prisma.shippingSlip.findFirst({
      where: { id, tenantId, isDeleted: false },
      include: { items: true },
    });

    if (!shippingSlip) {
      throw new NotFoundException('Shipping slip not found');
    }

    if (shippingSlip.status !== ShippingSlipStatus.SHIPPED) {
      throw new BadRequestException('Only shipped slips can be received');
    }

    await this.prisma.$transaction(async (tx) => {
      // Update shipping slip status
      await tx.shippingSlip.update({
        where: { id },
        data: {
          status: ShippingSlipStatus.RECEIVED,
          receivedAt: new Date(),
          receivedBy: userId,
          updatedBy: userId,
        },
      });

      // Update parcel statuses to PUT_IN_DISTRIBUTION (ready for local delivery)
      const parcelIds = shippingSlip.items.map((item) => item.parcelId);
      if (parcelIds.length > 0) {
        await tx.parcel.updateMany({
          where: { id: { in: parcelIds }, tenantId },
          data: { parcelStatusCode: 'PUT_IN_DISTRIBUTION', updatedBy: userId },
        });

        // Add status history
        const distributionStatus = await tx.parcelStatus.findFirst({
          where: { tenantId, code: 'PUT_IN_DISTRIBUTION', isDeleted: false },
        });

        if (distributionStatus) {
          await tx.parcelStatusHistory.createMany({
            data: parcelIds.map((parcelId) => ({
              parcelId,
              parcelStatusId: distributionStatus.id,
              statusCode: 'PUT_IN_DISTRIBUTION',
              comment: `Received at destination zone via ${shippingSlip.reference}`,
              changedBy: userId,
            })),
          });
        }
      }
    });

    await this.clearCache(tenantId);

    this.logger.log(
      `Marked shipping slip ${shippingSlip.reference} as received`,
    );

    return this.findOne(id, tenantId);
  }

  async cancelShippingSlip(
    id: string,
    tenantId: string,
    userId: string,
  ): Promise<ShippingSlipResponseDto> {
    const shippingSlip = await this.prisma.shippingSlip.findFirst({
      where: { id, tenantId, isDeleted: false },
      include: { items: true },
    });

    if (!shippingSlip) {
      throw new NotFoundException('Shipping slip not found');
    }

    if (shippingSlip.status === ShippingSlipStatus.RECEIVED) {
      throw new BadRequestException(
        'Cannot cancel already received shipping slip',
      );
    }

    await this.prisma.$transaction(async (tx) => {
      // Cancel shipping slip
      await tx.shippingSlip.update({
        where: { id },
        data: {
          status: ShippingSlipStatus.CANCELLED,
          updatedBy: userId,
        },
      });

      // Revert parcel statuses back to COLLECTED
      const parcelIds = shippingSlip.items.map((item) => item.parcelId);
      if (parcelIds.length > 0) {
        await tx.parcel.updateMany({
          where: { id: { in: parcelIds }, tenantId },
          data: { parcelStatusCode: 'COLLECTED', updatedBy: userId },
        });
      }
    });

    await this.clearCache(tenantId);

    this.logger.log(`Cancelled shipping slip ${shippingSlip.reference}`);

    return this.findOne(id, tenantId);
  }

  async getStatistics(tenantId: string): Promise<ShippingSlipStatsDto> {
    // Try cache first
    const cached = await this.redis.getTenantCache(
      tenantId,
      'shipping-slip-stats',
    );
    if (cached) {
      return JSON.parse(cached);
    }

    const [statusCounts, thisMonthStats, allShippingSlips] = await Promise.all([
      // Status distribution
      this.prisma.shippingSlip.groupBy({
        by: ['status'],
        where: { tenantId, isDeleted: false },
        _count: true,
      }),

      // This month's packages
      this.prisma.shippingSlipItem.count({
        where: {
          shippingSlip: {
            tenantId,
            isDeleted: false,
            createdAt: {
              gte: new Date(new Date().getFullYear(), new Date().getMonth(), 1),
            },
          },
        },
      }),

      // Get all shipping slips to group manually
      this.prisma.shippingSlip.findMany({
        where: { tenantId, isDeleted: false },
        select: { destinationZoneId: true },
      }),
    ]);

    // Calculate stats
    const total = statusCounts.reduce((sum, stat) => sum + stat._count, 0);
    const pending =
      statusCounts.find((s) => s.status === 'PENDING')?._count || 0;
    const shipped =
      statusCounts.find((s) => s.status === 'SHIPPED')?._count || 0;
    const completed =
      statusCounts.find((s) => s.status === 'RECEIVED')?._count || 0;
    const cancelled =
      statusCounts.find((s) => s.status === 'CANCELLED')?._count || 0;

    // Get total packages across all slips
    const totalPackages = await this.prisma.shippingSlipItem.count({
      where: { shippingSlip: { tenantId, isDeleted: false } },
    });

    const averagePackagesPerSlip = total > 0 ? totalPackages / total : 0;

    // Group destinations manually to avoid circular reference
    const destinationCounts: Record<string, number> = {};
    allShippingSlips.forEach((slip) => {
      const zoneId = slip.destinationZoneId;
      destinationCounts[zoneId] = (destinationCounts[zoneId] || 0) + 1;
    });

    // Get top 5 destinations
    const topDestinationIds = Object.entries(destinationCounts)
      .sort(([, a], [, b]) => b - a)
      .slice(0, 5);

    // Get zone names for top destinations
    const zoneIds = topDestinationIds.map(([zoneId]) => zoneId);
    const zones = await this.prisma.zone.findMany({
      where: { id: { in: zoneIds }, tenantId },
      select: { id: true, name: true },
    });

    const topDestinationZones = topDestinationIds.map(([zoneId, count]) => {
      const zone = zones.find((z) => z.id === zoneId);
      return {
        zoneId,
        zoneName: zone?.name || 'Unknown Zone',
        count,
        percentage: total > 0 ? (count / total) * 100 : 0,
      };
    });

    const stats: ShippingSlipStatsDto = {
      total,
      pending,
      inTransit: shipped,
      completed,
      cancelled,
      packagesShippedThisMonth: thisMonthStats,
      averagePackagesPerSlip: Number(averagePackagesPerSlip.toFixed(1)),
      topDestinationZones,
    };

    // Cache for 30 minutes
    await this.redis.setTenantCache(
      tenantId,
      'shipping-slip-stats',
      JSON.stringify(stats),
      1800,
    );

    return stats;
  }

  async generatePDF(id: string, tenantId: string) {
    const shippingSlip = await this.findOne(id, tenantId);

    // This would integrate with your PDF generation service
    // For now, return a placeholder response
    return {
      success: true,
      message: 'PDF generation not implemented yet',
      shippingSlip,
    };
  }

  // Helper methods
  private async generateReference(tenantId: string): Promise<string> {
    const date = new Date();
    const dateStr = date.toISOString().slice(2, 10).replace(/-/g, '');

    // Get today's count for this tenant
    const todayStart = new Date(
      date.getFullYear(),
      date.getMonth(),
      date.getDate(),
    );
    const todayEnd = new Date(todayStart);
    todayEnd.setDate(todayEnd.getDate() + 1);

    const count = await this.prisma.shippingSlip.count({
      where: {
        tenantId,
        createdAt: {
          gte: todayStart,
          lt: todayEnd,
        },
      },
    });

    const sequence = String(count + 1).padStart(7, '0');
    const random = Math.floor(Math.random() * 100)
      .toString()
      .padStart(2, '0');

    return `BE-${dateStr}-${sequence}-${random}`;
  }

  private async validateParcelsForShipping(
    parcelIds: string[],
    destinationZoneId: string,
    tenantId: string,
  ): Promise<string[]> {
    // Get destination zone cities
    const zone = await this.prisma.zone.findFirst({
      where: { id: destinationZoneId, tenantId, isDeleted: false },
      include: {
        cities: { include: { city: { select: { id: true } } } },
      },
    });

    if (!zone) {
      throw new BadRequestException('Invalid destination zone');
    }

    const zoneCityIds = zone.cities.map((zc) => zc.city.id);

    // Validate parcels
    const parcels = await this.prisma.parcel.findMany({
      where: {
        id: { in: parcelIds },
        tenantId,
        isDeleted: false,
        parcelStatusCode: 'COLLECTED', // Must be collected
        destinationCityId: { in: zoneCityIds }, // Must be going to zone cities
        shippingSlipItems: { none: {} }, // Not already in another slip
      },
    });

    if (parcels.length !== parcelIds.length) {
      throw new BadRequestException(
        'Some parcels are invalid, not collected, or already in another shipping slip',
      );
    }

    return parcels.map((parcel) => parcel.id);
  }

  private async clearCache(tenantId: string): Promise<void> {
    await Promise.all([
      this.redis.delTenantCache(tenantId, 'shipping-slips'),
      this.redis.delTenantCache(tenantId, 'shipping-slip-stats'),
    ]);
  }

  private mapToResponseDto(shippingSlip: any): ShippingSlipResponseDto {
    const scannedItems =
      shippingSlip.items?.filter((item: any) => item.scanned).length || 0;
    const totalValue =
      shippingSlip.items?.reduce(
        (sum: number, item: any) => sum + Number(item.parcel?.price || 0),
        0,
      ) || 0;

    return {
      id: shippingSlip.id,
      tenantId: shippingSlip.tenantId,
      reference: shippingSlip.reference,
      destinationZoneId: shippingSlip.destinationZoneId,
      status: shippingSlip.status,
      shippedAt: shippingSlip.shippedAt,
      shippedBy: shippingSlip.shippedBy,
      receivedAt: shippingSlip.receivedAt,
      receivedBy: shippingSlip.receivedBy,
      createdAt: shippingSlip.createdAt,
      updatedAt: shippingSlip.updatedAt,
      createdBy: shippingSlip.createdBy,
      updatedBy: shippingSlip.updatedBy,
      destinationZone: shippingSlip.destinationZone,
      items: shippingSlip.items?.map((item: any) => ({
        parcelId: item.parcelId,
        scanned: item.scanned,
        scannedAt: item.scannedAt,
        scannedBy: item.scannedBy,
        parcel: item.parcel
          ? {
              id: item.parcel.id,
              code: item.parcel.code,
              recipientName: item.parcel.recipientName,
              recipientPhone: item.parcel.recipientPhone,
              destinationCity: item.parcel.destinationCity,
              price: Number(item.parcel.price),
              parcelStatusCode: item.parcel.parcelStatusCode,
            }
          : undefined,
      })),
      _count: {
        items: shippingSlip._count?.items || shippingSlip.items?.length || 0,
        scannedItems,
        totalValue: Number(totalValue.toFixed(2)),
      },
    };
  }
}
===============================================================================================================
===============================================================================================================
The Subject is :
- READ ALL THIS PROMPT I GIVE YOU.
- I Create A new parcels-service in my nest js project.
- You Alrady Give module delivery-slips and module parcels.
- So Now i want you help me and give me shipping-slips module in front with all pages and crud pages,
And all component and lib and store we will need to create this module in front.
_ Give me each file with page location.
===============================================================================================================
===============================================================================================================