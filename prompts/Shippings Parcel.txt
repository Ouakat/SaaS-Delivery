===============================================================================================================
My Next js front project structure:
===============================================================================================================
App Folder :
-----------------------------------------------------------------------
--++--> app/[locale]/(protected)/dashboard/page.tsx
--++--> app/[locale]/(protected)/profile/page.tsx
--++--> app/[locale]/(protected)/roles/page.tsx
-----------------------------------------------------------------------
--++--> app/[locale]/(protected)/delivery-slips/page.tsx =======>
-----------------------------------------------------------------------
"use client";
import React, { useEffect, useState, useCallback } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Icon } from "@/components/ui/icon";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Badge } from "@/components/ui/badge";
import { Input } from "@/components/ui/input";
import { Link } from "@/i18n/routing";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { DeliverySlipsTable } from "@/components/delivery-slips/delivery-slips-table";
import { DeliverySlipsStats } from "@/components/delivery-slips/delivery-slips-stats";
import { BulkActionsBar } from "@/components/delivery-slips/bulk-actions-bar";
import { useDeliverySlipsStore } from "@/lib/stores/parcels/delivery-slips.store";
import { useCitiesStore } from "@/lib/stores/parcels/cities.store";
import { useAuthStore } from "@/lib/stores/auth/auth.store";
import { ProtectedRoute } from "@/components/route/protected-route";
import { PARCELS_PERMISSIONS } from "@/lib/constants/parcels";
import { DeliverySlipStatus } from "@/lib/types/parcels/delivery-slips.types";
import { toast } from "sonner";
const DeliverySlipsPageContent = () => {
  const { hasPermission, user } = useAuthStore();
  const {
    deliverySlips,
    pagination,
    filters,
    statistics,
    selectedSlipIds,
    isLoading,
    error,
    setFilters,
    clearFilters,
    fetchDeliverySlips,
    fetchStatistics,
    clearSelectedSlipIds,
    exportDeliverySlips,
    resetState,
  } = useDeliverySlipsStore();

  const { cities, fetchCities } = useCitiesStore();

  const [showStats, setShowStats] = useState(false);
  const [searchTerm, setSearchTerm] = useState(filters.search || "");
  const [isExporting, setIsExporting] = useState(false);

  // Check permissions
  const canReadSlips = hasPermission(PARCELS_PERMISSIONS.DELIVERY_SLIPS_READ);
  const canCreateSlips = hasPermission(
    PARCELS_PERMISSIONS.DELIVERY_SLIPS_CREATE
  );
  const canUpdateSlips = hasPermission(
    PARCELS_PERMISSIONS.DELIVERY_SLIPS_UPDATE
  );
  const canDeleteSlips = hasPermission(
    PARCELS_PERMISSIONS.DELIVERY_SLIPS_DELETE
  );
  const canBulkActions = hasPermission(PARCELS_PERMISSIONS.DELIVERY_SLIPS_BULK);
  const canScanSlips = hasPermission(PARCELS_PERMISSIONS.DELIVERY_SLIPS_SCAN);

  // Initialize data
  useEffect(() => {
    if (canReadSlips) {
      fetchDeliverySlips();
      fetchCities();
      if (user?.userType !== "SELLER") {
        fetchStatistics();
      }
    }

    // Cleanup on unmount
    return () => {
      resetState();
    };
  }, [
    canReadSlips,
    fetchDeliverySlips,
    fetchCities,
    fetchStatistics,
    user?.userType,
    resetState,
  ]);

  // Handle search with debouncing
  const handleSearchChange = useCallback(
    (value: string) => {
      setSearchTerm(value);
      const timeoutId = setTimeout(() => {
        setFilters({ search: value, page: 1 });
      }, 500);
      return () => clearTimeout(timeoutId);
    },
    [setFilters]
  );

  // Handle status filter change
  const handleStatusFilter = (status: string) => {
    setFilters({
      status: status === "all" ? undefined : (status as DeliverySlipStatus),
      page: 1,
    });
  };

  // Handle city filter change
  const handleCityFilter = (cityId: string) => {
    setFilters({
      cityId: cityId === "all" ? undefined : cityId,
      page: 1,
    });
  };

  // Handle date range filters
  const handleDateRangeFilter = (range: string) => {
    const today = new Date();
    let startDate: string | undefined;
    let endDate: string | undefined;

    switch (range) {
      case "today":
        startDate = today.toISOString().split("T")[0];
        endDate = startDate;
        break;
      case "week":
        const weekAgo = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000);
        startDate = weekAgo.toISOString().split("T")[0];
        endDate = today.toISOString().split("T")[0];
        break;
      case "month":
        const monthAgo = new Date(today.getTime() - 30 * 24 * 60 * 60 * 1000);
        startDate = monthAgo.toISOString().split("T")[0];
        endDate = today.toISOString().split("T")[0];
        break;
      default:
        startDate = undefined;
        endDate = undefined;
    }

    setFilters({ startDate, endDate, page: 1 });
  };

  // Handle export
  const handleExport = async () => {
    setIsExporting(true);
    try {
      await exportDeliverySlips(filters);
      // Toast is already shown in the store
    } catch (error) {
      // Error toast is already shown in the store
    } finally {
      setIsExporting(false);
    }
  };

  // Handle pagination
  const handlePageChange = (page: number) => {
    setFilters({ page });
  };

  // Handle clear all filters
  const handleClearAllFilters = () => {
    setSearchTerm("");
    clearFilters();
  };

  if (!canReadSlips) {
    return (
      <div className="space-y-6">
        <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
          <div>
            <h1 className="text-2xl font-bold text-default-900">
              Delivery Slips
            </h1>
            <p className="text-default-600">
              Manage package collection documents
            </p>
          </div>
        </div>

        <Alert color="destructive">
          <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
          <AlertDescription>
            You don't have permission to access delivery slips. Please contact
            your administrator.
          </AlertDescription>
        </Alert>
      </div>
    );
  }

  const activeFiltersCount = Object.values({
    search: filters.search,
    status: filters.status,
    cityId: filters.cityId,
    startDate: filters.startDate,
    endDate: filters.endDate,
  }).filter(Boolean).length;

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
        <div>
          <h1 className="text-2xl font-bold text-default-900">
            Delivery Slips
          </h1>
          <p className="text-default-600">
            Manage package collection documents and track pickup operations
          </p>
          {pagination.total > 0 && (
            <div className="flex items-center gap-4 mt-2 text-sm text-default-500">
              <span>Total: {pagination.total} slips</span>
              {selectedSlipIds.length > 0 && (
                <span>Selected: {selectedSlipIds.length}</span>
              )}
            </div>
          )}
        </div>

        <div className="flex items-center gap-2">
          {statistics && user?.userType !== "SELLER" && (
            <Button
              variant="outline"
              size="md"
              onClick={() => setShowStats(!showStats)}
            >
              <Icon icon="heroicons:chart-bar" className="w-4 h-4 mr-2" />
              {showStats ? "Hide" : "Show"} Stats
            </Button>
          )}

          {canCreateSlips && (
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button>
                  <Icon icon="heroicons:plus" className="w-4 h-4 mr-2" />
                  Create
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end">
                <DropdownMenuItem asChild>
                  <Link href="/delivery-slips/create">
                    <Icon
                      icon="heroicons:document-plus"
                      className="mr-2 h-4 w-4"
                    />
                    New Delivery Slip
                  </Link>
                </DropdownMenuItem>
                {canScanSlips && (
                  <>
                    <DropdownMenuSeparator />
                    <DropdownMenuItem asChild>
                      <Link href="/delivery-slips/scan">
                        <Icon
                          icon="heroicons:qr-code"
                          className="mr-2 h-4 w-4"
                        />
                        Scanner Interface
                      </Link>
                    </DropdownMenuItem>
                  </>
                )}
                {canBulkActions && (
                  <DropdownMenuItem asChild>
                    <Link href="/delivery-slips/bulk-receive">
                      <Icon
                        icon="heroicons:check-circle"
                        className="mr-2 h-4 w-4"
                      />
                      Bulk Receive
                    </Link>
                  </DropdownMenuItem>
                )}
              </DropdownMenuContent>
            </DropdownMenu>
          )}
        </div>
      </div>

      {/* Statistics */}
      {showStats && statistics && (
        <DeliverySlipsStats statistics={statistics} />
      )}

      {/* Error Alert */}
      {error && (
        <Alert color="destructive">
          <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      {/* Filters and Actions */}
      <Card>
        <CardHeader>
          <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
            <CardTitle className="flex items-center gap-2">
              All Delivery Slips
              {activeFiltersCount > 0 && (
                <Badge color="secondary" className="ml-2">
                  {activeFiltersCount} filter
                  {activeFiltersCount !== 1 ? "s" : ""} active
                </Badge>
              )}
            </CardTitle>
            <div className="flex items-center gap-2">
              <Button
                variant="outline"
                size="md"
                onClick={handleExport}
                disabled={isExporting}
              >
                {isExporting ? (
                  <Icon
                    icon="heroicons:arrow-path"
                    className="w-4 h-4 mr-2 animate-spin"
                  />
                ) : (
                  <Icon
                    icon="heroicons:document-arrow-down"
                    className="w-4 h-4 mr-2"
                  />
                )}
                Export
              </Button>
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button variant="outline" size="md">
                    <Icon icon="heroicons:funnel" className="w-4 h-4 mr-2" />
                    Filters
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end">
                  <DropdownMenuItem
                    onClick={() => handleDateRangeFilter("today")}
                  >
                    <Icon icon="heroicons:calendar" className="mr-2 h-4 w-4" />
                    Today
                  </DropdownMenuItem>
                  <DropdownMenuItem
                    onClick={() => handleDateRangeFilter("week")}
                  >
                    <Icon icon="heroicons:calendar" className="mr-2 h-4 w-4" />
                    Last 7 days
                  </DropdownMenuItem>
                  <DropdownMenuItem
                    onClick={() => handleDateRangeFilter("month")}
                  >
                    <Icon icon="heroicons:calendar" className="mr-2 h-4 w-4" />
                    Last 30 days
                  </DropdownMenuItem>
                  <DropdownMenuSeparator />
                  <DropdownMenuItem onClick={handleClearAllFilters}>
                    <Icon icon="heroicons:x-mark" className="mr-2 h-4 w-4" />
                    Clear All Filters
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            </div>
          </div>
        </CardHeader>
        <CardContent className="space-y-4">
          {/* Search and Filter Controls */}
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
            {/* Search */}
            <div className="lg:col-span-2">
              <Input
                placeholder="Search by reference, customer name, or phone..."
                value={searchTerm}
                onChange={(e) => handleSearchChange(e.target.value)}
                className="w-full"
              />
            </div>

            {/* Status Filter */}
            <div>
              <Select
                value={filters.status || "all"}
                onValueChange={handleStatusFilter}
              >
                <SelectTrigger>
                  <SelectValue placeholder="All Status" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">All Status</SelectItem>
                  <SelectItem value={DeliverySlipStatus.PENDING}>
                    <div className="flex items-center gap-2">
                      <div className="w-2 h-2 rounded-full bg-yellow-500" />
                      Pending
                    </div>
                  </SelectItem>
                  <SelectItem value={DeliverySlipStatus.RECEIVED}>
                    <div className="flex items-center gap-2">
                      <div className="w-2 h-2 rounded-full bg-green-500" />
                      Received
                    </div>
                  </SelectItem>
                  <SelectItem value={DeliverySlipStatus.CANCELLED}>
                    <div className="flex items-center gap-2">
                      <div className="w-2 h-2 rounded-full bg-red-500" />
                      Cancelled
                    </div>
                  </SelectItem>
                </SelectContent>
              </Select>
            </div>

            {/* City Filter */}
            <div>
              <Select
                value={filters.cityId || "all"}
                onValueChange={handleCityFilter}
              >
                <SelectTrigger>
                  <SelectValue placeholder="All Cities" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">All Cities</SelectItem>
                  <SelectItem value="none">No City</SelectItem>
                  {cities
                    .filter((city) => city.pickupCity && city.status)
                    .map((city) => (
                      <SelectItem key={city.id} value={city.id}>
                        {city.name} ({city.ref})
                      </SelectItem>
                    ))}
                </SelectContent>
              </Select>
            </div>
          </div>

          {/* Active Filters */}
          {activeFiltersCount > 0 && (
            <div className="flex items-center gap-2 flex-wrap">
              <span className="text-sm text-muted-foreground">
                Active filters:
              </span>
              {filters.search && (
                <Badge color="secondary" className="gap-1">
                  Search: {filters.search}
                  <button
                    onClick={() => {
                      setSearchTerm("");
                      setFilters({ search: "", page: 1 });
                    }}
                    className="ml-1 hover:bg-gray-200 rounded-full p-0.5"
                  >
                    <Icon icon="heroicons:x-mark" className="w-3 h-3" />
                  </button>
                </Badge>
              )}
              {filters.status && (
                <Badge color="secondary" className="gap-1">
                  Status: {filters.status}
                  <button
                    onClick={() => setFilters({ status: undefined, page: 1 })}
                    className="ml-1 hover:bg-gray-200 rounded-full p-0.5"
                  >
                    <Icon icon="heroicons:x-mark" className="w-3 h-3" />
                  </button>
                </Badge>
              )}
              {filters.cityId && (
                <Badge color="secondary" className="gap-1">
                  City:{" "}
                  {cities.find((c) => c.id === filters.cityId)?.name ||
                    "Unknown"}
                  <button
                    onClick={() => setFilters({ cityId: undefined, page: 1 })}
                    className="ml-1 hover:bg-gray-200 rounded-full p-0.5"
                  >
                    <Icon icon="heroicons:x-mark" className="w-3 h-3" />
                  </button>
                </Badge>
              )}
              {(filters.startDate || filters.endDate) && (
                <Badge color="secondary" className="gap-1">
                  Date Range
                  <button
                    onClick={() =>
                      setFilters({
                        startDate: undefined,
                        endDate: undefined,
                        page: 1,
                      })
                    }
                    className="ml-1 hover:bg-gray-200 rounded-full p-0.5"
                  >
                    <Icon icon="heroicons:x-mark" className="w-3 h-3" />
                  </button>
                </Badge>
              )}
              <Button
                variant="ghost"
                size="sm"
                onClick={handleClearAllFilters}
                className="h-6 px-2 text-xs"
              >
                Clear all
              </Button>
            </div>
          )}

          {/* Bulk Actions */}
          {selectedSlipIds.length > 0 && canBulkActions && (
            <BulkActionsBar
              selectedCount={selectedSlipIds.length}
              onClearSelection={clearSelectedSlipIds}
            />
          )}
        </CardContent>
      </Card>

      {/* Delivery Slips Table */}
      <Card>
        <CardContent className="p-0">
          <DeliverySlipsTable
            deliverySlips={deliverySlips}
            pagination={pagination}
            isLoading={isLoading}
            onPageChange={handlePageChange}
            canUpdate={canUpdateSlips}
            canDelete={canDeleteSlips}
            canBulkActions={canBulkActions}
          />
        </CardContent>
      </Card>

      {/* Quick Actions Card */}
      {canCreateSlips && (
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Icon icon="heroicons:bolt" className="w-5 h-5" />
              Quick Actions
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
              <Link href="/delivery-slips/create">
                <Button variant="outline" className="w-full h-auto p-4">
                  <div className="flex flex-col items-center gap-2">
                    <Icon icon="heroicons:plus-circle" className="w-8 h-8" />
                    <span>Create New Slip</span>
                    <span className="text-xs text-muted-foreground">
                      Start new collection
                    </span>
                  </div>
                </Button>
              </Link>

              {canScanSlips && (
                <Link href="/delivery-slips/scan">
                  <Button variant="outline" className="w-full h-auto p-4">
                    <div className="flex flex-col items-center gap-2">
                      <Icon icon="heroicons:qr-code" className="w-8 h-8" />
                      <span>Scan Parcels</span>
                      <span className="text-xs text-muted-foreground">
                        Use barcode scanner
                      </span>
                    </div>
                  </Button>
                </Link>
              )}

              {canBulkActions && (
                <Link href="/delivery-slips/bulk-receive">
                  <Button variant="outline" className="w-full h-auto p-4">
                    <div className="flex flex-col items-center gap-2">
                      <Icon icon="heroicons:check-circle" className="w-8 h-8" />
                      <span>Bulk Receive</span>
                      <span className="text-xs text-muted-foreground">
                        Process multiple slips
                      </span>
                    </div>
                  </Button>
                </Link>
              )}

              <Button
                variant="outline"
                className="w-full h-auto p-4"
                onClick={handleExport}
                disabled={isExporting}
              >
                <div className="flex flex-col items-center gap-2">
                  <Icon
                    icon="heroicons:document-arrow-down"
                    className="w-8 h-8"
                  />
                  <span>Export Data</span>
                  <span className="text-xs text-muted-foreground">
                    Download as Excel
                  </span>
                </div>
              </Button>
            </div>
          </CardContent>
        </Card>
      )}

      {/* Empty State */}
      {!isLoading && deliverySlips.length === 0 && (
        <Card>
          <CardContent className="p-8 text-center">
            <div className="space-y-4">
              <Icon
                icon="heroicons:document-text"
                className="w-16 h-16 text-muted-foreground mx-auto"
              />
              <div>
                <h3 className="font-medium text-default-900">
                  No delivery slips found
                </h3>
                <p className="text-sm text-muted-foreground mt-1">
                  {activeFiltersCount > 0
                    ? "Try adjusting your filters or search terms"
                    : "Get started by creating your first delivery slip"}
                </p>
              </div>
              {canCreateSlips && activeFiltersCount === 0 && (
                <div className="flex flex-col sm:flex-row gap-2 justify-center">
                  <Link href="/delivery-slips/create">
                    <Button>
                      <Icon icon="heroicons:plus" className="w-4 h-4 mr-2" />
                      Create First Delivery Slip
                    </Button>
                  </Link>
                  {canScanSlips && (
                    <Link href="/delivery-slips/scan">
                      <Button variant="outline">
                        <Icon
                          icon="heroicons:qr-code"
                          className="w-4 h-4 mr-2"
                        />
                        Open Scanner
                      </Button>
                    </Link>
                  )}
                </div>
              )}
              {activeFiltersCount > 0 && (
                <Button variant="outline" onClick={handleClearAllFilters}>
                  <Icon icon="heroicons:x-mark" className="w-4 h-4 mr-2" />
                  Clear All Filters
                </Button>
              )}
            </div>
          </CardContent>
        </Card>
      )}
    </div>
  );
};
// Main component wrapped with ProtectedRoute
const DeliverySlipsPage = () => {
  return (
    <ProtectedRoute
      requiredPermissions={[PARCELS_PERMISSIONS.DELIVERY_SLIPS_READ]}
      requiredAccessLevel="LIMITED"
      allowedAccountStatuses={["ACTIVE"]}
    >
      <DeliverySlipsPageContent />
    </ProtectedRoute>
  );
};
export default DeliverySlipsPage;
-----------------------------------------------------------------------
--++--> app/[locale]/(protected)/delivery-slips/[id]/page.tsx =======>
-----------------------------------------------------------------------
"use client";
import React, { useState, useEffect } from "react";
import { useRouter, useParams } from "next/navigation";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Icon } from "@/components/ui/icon";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";
import { Alert, AlertDescription } from "@/components/ui/alert";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Link } from "@/i18n/routing";
import { ProtectedRoute } from "@/components/route/protected-route";
import { PARCELS_PERMISSIONS } from "@/lib/constants/parcels";
import { useDeliverySlipsStore } from "@/lib/stores/parcels/delivery-slips.store";
import { useAuthStore } from "@/lib/stores/auth/auth.store";
import { DeliverySlipStatus } from "@/lib/types/parcels/delivery-slips.types";
import { toast } from "sonner";
// Status configurations
const statusConfig = {
  [DeliverySlipStatus.PENDING]: {
    label: "Pending",
    color: "bg-yellow-100 text-yellow-800",
    icon: "heroicons:clock",
  },
  [DeliverySlipStatus.RECEIVED]: {
    label: "Received",
    color: "bg-green-100 text-green-800",
    icon: "heroicons:check-circle",
  },
  [DeliverySlipStatus.CANCELLED]: {
    label: "Cancelled",
    color: "bg-red-100 text-red-800",
    icon: "heroicons:x-circle",
  },
};
const formatDate = (dateString: string, format: "short" | "long" = "short") => {
  const date = new Date(dateString);
  if (format === "short") {
    return date.toLocaleDateString("en-US", {
      month: "short",
      day: "2-digit",
      year: "numeric",
    });
  }
  return date.toLocaleDateString("en-US", {
    year: "numeric",
    month: "short",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
  });
};
const DeliverySlipDetailsPage = () => {
  const router = useRouter();
  const params = useParams();
  const slipId = params?.id as string;
  const { hasPermission, user } = useAuthStore();

  const {
    currentDeliverySlip,
    fetchDeliverySlipById,
    updateDeliverySlip,
    deleteDeliverySlip,
    receiveSlip,
    downloadSlipPdf,
    downloadSlipLabels,
    getSlipBarcode,
    isLoading,
    isUpdating,
    isDeleting,
    error,
  } = useDeliverySlipsStore();

  const [deleteDialog, setDeleteDialog] = useState(false);
  const [receiveDialog, setReceiveDialog] = useState(false);
  const [barcodeData, setBarcodeData] = useState<any>(null);
  const [showBarcode, setShowBarcode] = useState(false);

  const canUpdate = hasPermission(PARCELS_PERMISSIONS.DELIVERY_SLIPS_UPDATE);
  const canDelete = hasPermission(PARCELS_PERMISSIONS.DELIVERY_SLIPS_DELETE);
  const canReceive = hasPermission(PARCELS_PERMISSIONS.DELIVERY_SLIPS_RECEIVE);

  // Fetch slip data
  useEffect(() => {
    if (slipId) {
      fetchDeliverySlipById(slipId);
    }
  }, [slipId, fetchDeliverySlipById]);

  // Handle slip actions
  const handleReceiveSlip = async () => {
    if (!currentDeliverySlip) return;

    const success = await receiveSlip(currentDeliverySlip.id, {
      notes: "Slip received via details page",
    });

    if (success) {
      setReceiveDialog(false);
      toast.success("Delivery slip marked as received");
    }
  };

  const handleDeleteSlip = async () => {
    if (!currentDeliverySlip) return;

    const success = await deleteDeliverySlip(currentDeliverySlip.id);

    if (success) {
      setDeleteDialog(false);
      toast.success("Delivery slip deleted successfully");
      router.push("/delivery-slips");
    }
  };

  const handleDownloadPdf = async () => {
    if (!currentDeliverySlip) return;
    await downloadSlipPdf(currentDeliverySlip.id);
  };

  const handleDownloadLabels = async () => {
    if (!currentDeliverySlip) return;
    await downloadSlipLabels(currentDeliverySlip.id);
  };

  const handleShowBarcode = async () => {
    if (!currentDeliverySlip) return;

    if (!barcodeData) {
      const data = await getSlipBarcode(currentDeliverySlip.id);
      setBarcodeData(data);
    }
    setShowBarcode(true);
  };

  if (isLoading) {
    return (
      <ProtectedRoute
        requiredPermissions={[PARCELS_PERMISSIONS.DELIVERY_SLIPS_READ]}
        requiredAccessLevel="LIMITED"
      >
        <div className="container mx-auto py-6">
          <Card>
            <CardContent className="p-8">
              <div className="flex items-center justify-center space-x-2">
                <Icon
                  icon="heroicons:arrow-path"
                  className="w-5 h-5 animate-spin"
                />
                <span>Loading delivery slip details...</span>
              </div>
            </CardContent>
          </Card>
        </div>
      </ProtectedRoute>
    );
  }

  if (!currentDeliverySlip || error) {
    return (
      <ProtectedRoute
        requiredPermissions={[PARCELS_PERMISSIONS.DELIVERY_SLIPS_READ]}
        requiredAccessLevel="LIMITED"
      >
        <div className="container mx-auto py-8">
          <Alert color="destructive">
            <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
            <AlertDescription>
              {error || "Delivery slip not found or has been deleted."}
            </AlertDescription>
          </Alert>
        </div>
      </ProtectedRoute>
    );
  }

  const statusInfo = statusConfig[currentDeliverySlip.status];
  const canModify = currentDeliverySlip.status === DeliverySlipStatus.PENDING;

  return (
    <ProtectedRoute
      requiredPermissions={[PARCELS_PERMISSIONS.DELIVERY_SLIPS_READ]}
      requiredAccessLevel="LIMITED"
    >
      <div className="container mx-auto py-6 space-y-6">
        {/* Header */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-4">
            <div>
              <div className="flex items-center gap-2">
                <h1 className="text-3xl font-bold text-default-900">
                  {currentDeliverySlip.reference}
                </h1>
                <Badge className={statusInfo.color}>
                  <Icon icon={statusInfo.icon} className="w-3 h-3 mr-1" />
                  {statusInfo.label}
                </Badge>
              </div>
              <p className="text-lg text-default-600">Delivery Slip Details</p>
              <div className="flex items-center gap-4 mt-2 text-sm text-default-500">
                <span>
                  Created: {formatDate(currentDeliverySlip.createdAt)}
                </span>
                {currentDeliverySlip.receivedAt && (
                  <span>
                    Received: {formatDate(currentDeliverySlip.receivedAt)}
                  </span>
                )}
              </div>
            </div>
          </div>

          <div className="flex items-center gap-2">
            {/* Actions Dropdown */}
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button disabled={isUpdating || isDeleting}>
                  <Icon
                    icon="heroicons:ellipsis-horizontal"
                    className="w-4 h-4 mr-2"
                  />
                  Actions
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end">
                {canUpdate && canModify && (
                  <DropdownMenuItem asChild>
                    <Link
                      href={`/delivery-slips/${currentDeliverySlip.id}/edit`}
                    >
                      <Icon
                        icon="heroicons:pencil-square"
                        className="mr-2 h-4 w-4"
                      />
                      Edit Slip
                    </Link>
                  </DropdownMenuItem>
                )}

                {canReceive && canModify && (
                  <>
                    <DropdownMenuSeparator />
                    <DropdownMenuItem onClick={() => setReceiveDialog(true)}>
                      <Icon
                        icon="heroicons:check"
                        className="mr-2 h-4 w-4 text-green-600"
                      />
                      Mark as Received
                    </DropdownMenuItem>
                  </>
                )}

                <DropdownMenuSeparator />
                <DropdownMenuItem onClick={handleDownloadPdf}>
                  <Icon
                    icon="heroicons:document-arrow-down"
                    className="mr-2 h-4 w-4"
                  />
                  Download PDF
                </DropdownMenuItem>

                <DropdownMenuItem onClick={handleDownloadLabels}>
                  <Icon icon="heroicons:tag" className="mr-2 h-4 w-4" />
                  Download Labels
                </DropdownMenuItem>

                <DropdownMenuItem onClick={handleShowBarcode}>
                  <Icon icon="heroicons:qr-code" className="mr-2 h-4 w-4" />
                  Show Barcode
                </DropdownMenuItem>

                {canDelete && canModify && (
                  <>
                    <DropdownMenuSeparator />
                    <DropdownMenuItem
                      className="text-red-600 focus:text-red-600"
                      onClick={() => setDeleteDialog(true)}
                    >
                      <Icon icon="heroicons:trash" className="mr-2 h-4 w-4" />
                      Delete Slip
                    </DropdownMenuItem>
                  </>
                )}
              </DropdownMenuContent>
            </DropdownMenu>

            <Link href="/delivery-slips">
              <Button variant="outline">
                <Icon icon="heroicons:arrow-left" className="w-4 h-4 mr-2" />
                Back to Delivery Slips
              </Button>
            </Link>
          </div>
        </div>

        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          {/* Main Content */}
          <div className="lg:col-span-2 space-y-6">
            {/* Slip Information */}
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:document-text" className="w-5 h-5" />
                  Slip Information
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <h4 className="font-medium text-default-900">Reference</h4>
                    <p className="text-default-600 font-mono">
                      {currentDeliverySlip.reference}
                    </p>
                  </div>
                  <div>
                    <h4 className="font-medium text-default-900">Status</h4>
                    <Badge className={statusInfo.color}>
                      <Icon icon={statusInfo.icon} className="w-3 h-3 mr-1" />
                      {statusInfo.label}
                    </Badge>
                  </div>
                  <div>
                    <h4 className="font-medium text-default-900">
                      Collection City
                    </h4>
                    <p className="text-default-600">
                      {currentDeliverySlip.city?.name || "Not specified"}
                    </p>
                  </div>
                  <div>
                    <h4 className="font-medium text-default-900">
                      Total Parcels
                    </h4>
                    <p className="text-default-600">
                      {currentDeliverySlip.summary.totalParcels}
                    </p>
                  </div>
                  <div>
                    <h4 className="font-medium text-default-900">
                      Scanned Parcels
                    </h4>
                    <p className="text-default-600">
                      {currentDeliverySlip.summary.scannedParcels} /{" "}
                      {currentDeliverySlip.summary.totalParcels}
                    </p>
                  </div>
                  <div>
                    <h4 className="font-medium text-default-900">
                      Total Value
                    </h4>
                    <p className="text-default-600">
                      {currentDeliverySlip.summary.totalValue.toFixed(2)} DH
                    </p>
                  </div>
                </div>

                {currentDeliverySlip.notes && (
                  <div>
                    <h4 className="font-medium text-default-900">Notes</h4>
                    <p className="text-default-600">
                      {currentDeliverySlip.notes}
                    </p>
                  </div>
                )}
              </CardContent>
            </Card>

            {/* Parcels List */}
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:cube" className="w-5 h-5" />
                  Parcels ({currentDeliverySlip.items.length})
                </CardTitle>
              </CardHeader>
              <CardContent className="p-0">
                <Table>
                  <TableHeader>
                    <TableRow>
                      <TableHead>Parcel Code</TableHead>
                      <TableHead>Recipient</TableHead>
                      <TableHead>Destination</TableHead>
                      <TableHead>Price</TableHead>
                      <TableHead>Status</TableHead>
                      <TableHead>Scanned</TableHead>
                    </TableRow>
                  </TableHeader>
                  <TableBody>
                    {currentDeliverySlip.items.map((item) => (
                      <TableRow key={item.parcelId}>
                        <TableCell>
                          <code className="text-sm font-medium">
                            {item.parcel.code}
                          </code>
                        </TableCell>
                        <TableCell>
                          <div>
                            <div className="font-medium">
                              {item.parcel.recipientName}
                            </div>
                            <div className="text-sm text-muted-foreground">
                              {item.parcel.recipientPhone}
                            </div>
                          </div>
                        </TableCell>
                        <TableCell>{item.parcel.destinationCity}</TableCell>
                        <TableCell>
                          <Badge color="primary">
                            {item.parcel.price.toFixed(2)} DH
                          </Badge>
                        </TableCell>
                        <TableCell>
                          <Badge color="secondary">
                            {item.parcel.statusName}
                          </Badge>
                        </TableCell>
                        <TableCell>
                          {item.scanned ? (
                            <div className="flex items-center gap-1 text-green-600">
                              <Icon
                                icon="heroicons:check-circle"
                                className="w-4 h-4"
                              />
                              <span className="text-sm">
                                {item.scannedAt
                                  ? formatDate(item.scannedAt.toString())
                                  : "Scanned"}
                              </span>
                            </div>
                          ) : (
                            <div className="flex items-center gap-1 text-yellow-600">
                              <Icon
                                icon="heroicons:clock"
                                className="w-4 h-4"
                              />
                              <span className="text-sm">Pending</span>
                            </div>
                          )}
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </CardContent>
            </Card>
          </div>

          {/* Sidebar */}
          <div className="space-y-6">
            {/* Summary */}
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon
                    icon="heroicons:clipboard-document-list"
                    className="w-5 h-5"
                  />
                  Summary
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="space-y-3">
                  <div className="flex justify-between">
                    <span className="text-sm text-muted-foreground">
                      Total Parcels:
                    </span>
                    <span className="font-medium">
                      {currentDeliverySlip.summary.totalParcels}
                    </span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-sm text-muted-foreground">
                      Scanned:
                    </span>
                    <span className="font-medium text-green-600">
                      {currentDeliverySlip.summary.scannedParcels}
                    </span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-sm text-muted-foreground">
                      Pending:
                    </span>
                    <span className="font-medium text-yellow-600">
                      {currentDeliverySlip.summary.unscannedParcels}
                    </span>
                  </div>
                  <div className="flex justify-between border-t pt-3">
                    <span className="text-sm text-muted-foreground">
                      Total Value:
                    </span>
                    <span className="font-medium">
                      {currentDeliverySlip.summary.totalValue.toFixed(2)} DH
                    </span>
                  </div>
                </div>

                {/* Progress Bar */}
                <div className="space-y-2">
                  <div className="flex justify-between text-sm">
                    <span>Scan Progress</span>
                    <span>
                      {Math.round(
                        (currentDeliverySlip.summary.scannedParcels /
                          currentDeliverySlip.summary.totalParcels) *
                          100
                      )}
                      %
                    </span>
                  </div>
                  <div className="w-full bg-gray-200 rounded-full h-2">
                    <div
                      className="bg-primary h-2 rounded-full"
                      style={{
                        width: `${
                          (currentDeliverySlip.summary.scannedParcels /
                            currentDeliverySlip.summary.totalParcels) *
                          100
                        }%`,
                      }}
                    />
                  </div>
                </div>
              </CardContent>
            </Card>

            {/* Timeline */}
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:clock" className="w-5 h-5" />
                  Timeline
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="space-y-4">
                  <div className="flex items-start gap-3">
                    <div className="w-2 h-2 bg-blue-500 rounded-full mt-2" />
                    <div>
                      <p className="text-sm font-medium">Created</p>
                      <p className="text-xs text-muted-foreground">
                        {formatDate(currentDeliverySlip.createdAt, "long")}
                      </p>
                      {currentDeliverySlip.createdBy && (
                        <p className="text-xs text-muted-foreground">
                          by {currentDeliverySlip.createdBy}
                        </p>
                      )}
                    </div>
                  </div>

                  {currentDeliverySlip.receivedAt && (
                    <div className="flex items-start gap-3">
                      <div className="w-2 h-2 bg-green-500 rounded-full mt-2" />
                      <div>
                        <p className="text-sm font-medium">Received</p>
                        <p className="text-xs text-muted-foreground">
                          {formatDate(currentDeliverySlip.receivedAt, "long")}
                        </p>
                        {currentDeliverySlip.receivedBy && (
                          <p className="text-xs text-muted-foreground">
                            by {currentDeliverySlip.receivedBy}
                          </p>
                        )}
                      </div>
                    </div>
                  )}
                </div>
              </CardContent>
            </Card>

            {/* Quick Actions */}
            {canModify && (
              <Card>
                <CardHeader>
                  <CardTitle className="flex items-center gap-2">
                    <Icon icon="heroicons:bolt" className="w-5 h-5" />
                    Quick Actions
                  </CardTitle>
                </CardHeader>
                <CardContent className="space-y-2">
                  {canReceive && (
                    <Button
                      className="w-full"
                      onClick={() => setReceiveDialog(true)}
                      disabled={isUpdating}
                    >
                      <Icon icon="heroicons:check" className="w-4 h-4 mr-2" />
                      Mark as Received
                    </Button>
                  )}

                  {canUpdate && (
                    <Link
                      href={`/delivery-slips/${currentDeliverySlip.id}/edit`}
                    >
                      <Button variant="outline" className="w-full">
                        <Icon
                          icon="heroicons:pencil"
                          className="w-4 h-4 mr-2"
                        />
                        Edit Slip
                      </Button>
                    </Link>
                  )}

                  <Link href={`/delivery-slips/${currentDeliverySlip.id}/scan`}>
                    <Button variant="outline" className="w-full">
                      <Icon icon="heroicons:qr-code" className="w-4 h-4 mr-2" />
                      Scan Parcels
                    </Button>
                  </Link>
                </CardContent>
              </Card>
            )}
          </div>
        </div>

        {/* Receive Confirmation Dialog */}
        <AlertDialog open={receiveDialog} onOpenChange={setReceiveDialog}>
          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>Mark as Received</AlertDialogTitle>
              <AlertDialogDescription>
                Are you sure you want to mark this delivery slip as received?
                This will update the status of all parcels in the slip.
                {currentDeliverySlip.summary.unscannedParcels > 0 && (
                  <div className="mt-2 p-2 bg-yellow-50 border border-yellow-200 rounded">
                    <p className="text-sm text-yellow-800">
                      Note: {currentDeliverySlip.summary.unscannedParcels}{" "}
                      parcels have not been scanned yet.
                    </p>
                  </div>
                )}
              </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
              <AlertDialogCancel>Cancel</AlertDialogCancel>
              <AlertDialogAction
                onClick={handleReceiveSlip}
                disabled={isUpdating}
              >
                {isUpdating && (
                  <Icon
                    icon="heroicons:arrow-path"
                    className="mr-2 h-4 w-4 animate-spin"
                  />
                )}
                Mark as Received
              </AlertDialogAction>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>

        {/* Delete Confirmation Dialog */}
        <AlertDialog open={deleteDialog} onOpenChange={setDeleteDialog}>
          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>Delete Delivery Slip</AlertDialogTitle>
              <AlertDialogDescription>
                Are you sure you want to delete this delivery slip? This action
                cannot be undone and will reset all parcels back to
                "NEW_PACKAGE" status.
              </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
              <AlertDialogCancel>Cancel</AlertDialogCancel>
              <AlertDialogAction
                onClick={handleDeleteSlip}
                disabled={isDeleting}
                className="bg-red-600 text-white hover:bg-red-700"
              >
                {isDeleting && (
                  <Icon
                    icon="heroicons:arrow-path"
                    className="mr-2 h-4 w-4 animate-spin"
                  />
                )}
                Delete Slip
              </AlertDialogAction>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>

        {/* Barcode Dialog */}
        <AlertDialog open={showBarcode} onOpenChange={setShowBarcode}>
          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>Delivery Slip Barcode</AlertDialogTitle>
              <AlertDialogDescription>
                Scan this barcode to quickly access this delivery slip
              </AlertDialogDescription>
            </AlertDialogHeader>
            <div className="flex flex-col items-center space-y-4 py-4">
              {barcodeData && (
                <>
                  <div className="text-center">
                    <p className="font-mono text-lg">{barcodeData.reference}</p>
                  </div>
                  <div className="bg-white p-4 rounded border">
                    {/* Here you would render the actual barcode/QR code */}
                    <div className="w-48 h-48 bg-gray-100 flex items-center justify-center">
                      <Icon
                        icon="heroicons:qr-code"
                        className="w-24 h-24 text-gray-400"
                      />
                    </div>
                  </div>
                </>
              )}
            </div>
            <AlertDialogFooter>
              <AlertDialogCancel>Close</AlertDialogCancel>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>
      </div>
    </ProtectedRoute>
  );
};
export default DeliverySlipDetailsPage;
-----------------------------------------------------------------------
--++--> app/[locale]/(protected)/delivery-slips/[id]/edit/page.tsx =======>
-----------------------------------------------------------------------
"use client";
import React, { useState, useEffect } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { useRouter, useParams } from "next/navigation";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Badge } from "@/components/ui/badge";
import { Icon } from "@/components/ui/icon";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Checkbox } from "@/components/ui/checkbox";
import { Link } from "@/i18n/routing";
import { useDeliverySlipsStore } from "@/lib/stores/parcels/delivery-slips.store";
import { useCitiesStore } from "@/lib/stores/parcels/cities.store";
import { useAuthStore } from "@/lib/stores/auth/auth.store";
import { ProtectedRoute } from "@/components/route/protected-route";
import { PARCELS_PERMISSIONS } from "@/lib/constants/parcels";
import { DeliverySlipStatus } from "@/lib/types/parcels/delivery-slips.types";
import { toast } from "sonner";
import { cn } from "@/lib/utils/ui.utils";
// Form schema for editing delivery slip
const editDeliverySlipSchema = z.object({
  cityId: z.string().optional(),
  notes: z.string().max(500).optional(),
  status: z.nativeEnum(DeliverySlipStatus).optional(),
});
type EditDeliverySlipFormData = z.infer<typeof editDeliverySlipSchema>;
const EditDeliverySlipPageContent = () => {
  const router = useRouter();
  const params = useParams();
  const slipId = params?.id as string;

  const { hasPermission, user } = useAuthStore();
  const {
    currentDeliverySlip,
    fetchDeliverySlipById,
    updateDeliverySlip,
    addParcelsToSlip,
    removeParcelsFromSlip,
    fetchAvailableParcels,
    availableParcels,
    isUpdating,
    isLoading,
    error,
  } = useDeliverySlipsStore();
  const { cities, fetchCities } = useCitiesStore();

  const [selectedNewParcels, setSelectedNewParcels] = useState<string[]>([]);
  const [parcelsToRemove, setParcelsToRemove] = useState<string[]>([]);
  const [searchTerm, setSearchTerm] = useState("");

  // Check permissions
  const canUpdateSlips = hasPermission(
    PARCELS_PERMISSIONS.DELIVERY_SLIPS_UPDATE
  );

  const {
    register,
    handleSubmit,
    watch,
    setValue,
    formState: { errors, isDirty },
    reset,
  } = useForm<EditDeliverySlipFormData>({
    resolver: zodResolver(editDeliverySlipSchema),
  });

  const watchedStatus = watch("status");

  // Initialize data
  useEffect(() => {
    if (canUpdateSlips && slipId) {
      fetchDeliverySlipById(slipId);
      fetchCities();
      fetchAvailableParcels();
    }
  }, [
    canUpdateSlips,
    slipId,
    fetchDeliverySlipById,
    fetchCities,
    fetchAvailableParcels,
  ]);

  // Populate form when delivery slip is loaded
  useEffect(() => {
    if (currentDeliverySlip) {
      reset({
        cityId: currentDeliverySlip.cityId || undefined,
        notes: currentDeliverySlip.notes || "",
        status: currentDeliverySlip.status,
      });
    }
  }, [currentDeliverySlip, reset]);

  const canModify = currentDeliverySlip?.status === DeliverySlipStatus.PENDING;

  const handleParcelSelection = (parcelId: string, checked: boolean) => {
    if (checked) {
      setSelectedNewParcels((prev) => [...prev, parcelId]);
    } else {
      setSelectedNewParcels((prev) => prev.filter((id) => id !== parcelId));
    }
  };

  const handleRemoveParcel = (parcelId: string, checked: boolean) => {
    if (checked) {
      setParcelsToRemove((prev) => [...prev, parcelId]);
    } else {
      setParcelsToRemove((prev) => prev.filter((id) => id !== parcelId));
    }
  };

  const handleAddParcels = async () => {
    if (!currentDeliverySlip || selectedNewParcels.length === 0) return;

    const success = await addParcelsToSlip(currentDeliverySlip.id, {
      parcelIds: selectedNewParcels,
      markAsScanned: true,
      comment: "Added via edit page",
    });

    if (success) {
      setSelectedNewParcels([]);
      fetchAvailableParcels();
      toast.success("Parcels added successfully");
    }
  };

  const handleRemoveParcels = async () => {
    if (!currentDeliverySlip || parcelsToRemove.length === 0) return;

    const success = await removeParcelsFromSlip(currentDeliverySlip.id, {
      parcelIds: parcelsToRemove,
      reason: "Removed via edit page",
    });

    if (success) {
      setParcelsToRemove([]);
      toast.success("Parcels removed successfully");
    }
  };

  // Filter available parcels
  const filteredAvailableParcels = availableParcels.filter(
    (parcel) =>
      parcel.code.toLowerCase().includes(searchTerm.toLowerCase()) ||
      parcel.recipientName.toLowerCase().includes(searchTerm.toLowerCase()) ||
      parcel.recipientPhone.includes(searchTerm)
  );

  const onSubmit = async (data: EditDeliverySlipFormData) => {
    if (!currentDeliverySlip) return;

    const updatedSlip = await updateDeliverySlip(currentDeliverySlip.id, data);

    if (updatedSlip) {
      toast.success("Delivery slip updated successfully");
      router.push(`/delivery-slips/${currentDeliverySlip.id}`);
    }
  };

  if (!canUpdateSlips) {
    return (
      <div className="container mx-auto py-8">
        <Alert color="destructive">
          <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
          <AlertDescription>
            You don't have permission to edit delivery slips. Please contact
            your administrator.
          </AlertDescription>
        </Alert>
      </div>
    );
  }

  if (isLoading) {
    return (
      <div className="container mx-auto py-6">
        <Card>
          <CardContent className="p-8">
            <div className="flex items-center justify-center space-x-2">
              <Icon
                icon="heroicons:arrow-path"
                className="w-5 h-5 animate-spin"
              />
              <span>Loading delivery slip...</span>
            </div>
          </CardContent>
        </Card>
      </div>
    );
  }

  if (!currentDeliverySlip || error) {
    return (
      <div className="container mx-auto py-8">
        <Alert color="destructive">
          <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
          <AlertDescription>
            {error || "Delivery slip not found or has been deleted."}
          </AlertDescription>
        </Alert>
      </div>
    );
  }

  return (
    <div className="container mx-auto py-6 space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-default-900">
            Edit Delivery Slip
          </h1>
          <p className="text-default-600">
            {currentDeliverySlip.reference}  {currentDeliverySlip.status}
          </p>
        </div>
        <div className="flex items-center gap-2">
          <Link href={`/delivery-slips/${currentDeliverySlip.id}`}>
            <Button variant="outline">
              <Icon icon="heroicons:eye" className="w-4 h-4 mr-2" />
              View Details
            </Button>
          </Link>
          <Link href="/delivery-slips">
            <Button variant="outline">
              <Icon icon="heroicons:arrow-left" className="w-4 h-4 mr-2" />
              Back to List
            </Button>
          </Link>
        </div>
      </div>

      {/* Status Warning */}
      {!canModify && (
        <Alert color="warning">
          <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
          <AlertDescription>
            This delivery slip has status "{currentDeliverySlip.status}" and
            cannot be modified. Only pending slips can be edited.
          </AlertDescription>
        </Alert>
      )}

      {/* Error Alert */}
      {error && (
        <Alert color="destructive">
          <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Main Form */}
        <div className="lg:col-span-2 space-y-6">
          {/* Basic Information */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon icon="heroicons:document-text" className="w-5 h-5" />
                Basic Information
              </CardTitle>
            </CardHeader>
            <CardContent>
              <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
                {/* City Selection */}
                <div className="space-y-2">
                  <Label htmlFor="cityId">Collection City</Label>
                  <Select
                    value={watch("cityId") || ""}
                    onValueChange={(value) =>
                      setValue("cityId", value || undefined)
                    }
                    disabled={!canModify}
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="Select collection city" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="none">No specific city</SelectItem>
                      {cities
                        .filter((city) => city.pickupCity && city.status)
                        .map((city) => (
                          <SelectItem key={city.id} value={city.id}>
                            {city.name} ({city.ref})
                          </SelectItem>
                        ))}
                    </SelectContent>
                  </Select>
                </div>

                {/* Status Selection (Admin only) */}
                {user?.userType !== "SELLER" && (
                  <div className="space-y-2">
                    <Label htmlFor="status">Status</Label>
                    <Select
                      value={watchedStatus}
                      onValueChange={(value) =>
                        setValue("status", value as DeliverySlipStatus)
                      }
                      disabled={!canModify}
                    >
                      <SelectTrigger>
                        <SelectValue placeholder="Select status" />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value={DeliverySlipStatus.PENDING}>
                          Pending
                        </SelectItem>
                        <SelectItem value={DeliverySlipStatus.RECEIVED}>
                          Received
                        </SelectItem>
                        <SelectItem value={DeliverySlipStatus.CANCELLED}>
                          Cancelled
                        </SelectItem>
                      </SelectContent>
                    </Select>
                  </div>
                )}

                {/* Notes */}
                <div className="space-y-2">
                  <Label htmlFor="notes">Notes</Label>
                  <Textarea
                    id="notes"
                    {...register("notes")}
                    placeholder="Add any special instructions or notes..."
                    rows={3}
                    disabled={!canModify}
                  />
                  {errors.notes && (
                    <p className="text-xs text-destructive">
                      {errors.notes.message}
                    </p>
                  )}
                </div>

                {/* Submit Button */}
                <div className="flex gap-2">
                  <Button
                    type="submit"
                    disabled={isUpdating || !isDirty || !canModify}
                  >
                    {isUpdating && (
                      <Icon
                        icon="heroicons:arrow-path"
                        className="mr-2 h-4 w-4 animate-spin"
                      />
                    )}
                    Update Slip
                  </Button>
                  <Button
                    type="button"
                    variant="outline"
                    onClick={() => reset()}
                    disabled={isUpdating || !isDirty}
                  >
                    Reset Changes
                  </Button>
                </div>
              </form>
            </CardContent>
          </Card>

          {/* Current Parcels */}
          <Card>
            <CardHeader>
              <div className="flex items-center justify-between">
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:cube" className="w-5 h-5" />
                  Current Parcels ({currentDeliverySlip.items.length})
                </CardTitle>
                {canModify && parcelsToRemove.length > 0 && (
                  <Button
                    size="sm"
                    color="destructive"
                    onClick={handleRemoveParcels}
                    disabled={isUpdating}
                  >
                    Remove Selected ({parcelsToRemove.length})
                  </Button>
                )}
              </div>
            </CardHeader>
            <CardContent className="space-y-2">
              {currentDeliverySlip.items.map((item) => (
                <div
                  key={item.parcelId}
                  className={cn(
                    "flex items-center space-x-3 p-3 border rounded-lg",
                    parcelsToRemove.includes(item.parcelId)
                      ? "bg-red-50 border-red-200"
                      : "hover:bg-muted/50"
                  )}
                >
                  {canModify && (
                    <Checkbox
                      checked={parcelsToRemove.includes(item.parcelId)}
                      onCheckedChange={(checked) =>
                        handleRemoveParcel(item.parcelId, checked as boolean)
                      }
                    />
                  )}
                  <div className="flex-1 min-w-0">
                    <div className="flex items-center gap-2">
                      <code className="text-sm font-medium">
                        {item.parcel.code}
                      </code>
                      <Badge color="primary" className="text-xs">
                        {item.parcel.price.toFixed(2)} DH
                      </Badge>
                      {item.scanned && (
                        <Badge color="secondary" className="text-xs">
                          Scanned
                        </Badge>
                      )}
                    </div>
                    <div className="text-sm text-muted-foreground">
                      {item.parcel.recipientName}  {item.parcel.recipientPhone}
                    </div>
                    <div className="text-xs text-muted-foreground">
                      To: {item.parcel.destinationCity}
                    </div>
                  </div>
                </div>
              ))}
            </CardContent>
          </Card>

          {/* Add New Parcels */}
          {canModify && (
            <Card>
              <CardHeader>
                <div className="flex items-center justify-between">
                  <CardTitle className="flex items-center gap-2">
                    <Icon icon="heroicons:plus-circle" className="w-5 h-5" />
                    Add Parcels
                  </CardTitle>
                  {selectedNewParcels.length > 0 && (
                    <Button
                      size="sm"
                      onClick={handleAddParcels}
                      disabled={isUpdating}
                    >
                      Add Selected ({selectedNewParcels.length})
                    </Button>
                  )}
                </div>
              </CardHeader>
              <CardContent className="space-y-4">
                {/* Search */}
                <Input
                  placeholder="Search available parcels..."
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                />

                {/* Available Parcels */}
                <div className="space-y-2 max-h-64 overflow-y-auto">
                  {filteredAvailableParcels.length === 0 ? (
                    <div className="text-center py-8">
                      <Icon
                        icon="heroicons:inbox"
                        className="w-12 h-12 text-muted-foreground mx-auto mb-4"
                      />
                      <p className="text-muted-foreground">
                        No available parcels found
                      </p>
                    </div>
                  ) : (
                    filteredAvailableParcels.map((parcel) => (
                      <div
                        key={parcel.id}
                        className={cn(
                          "flex items-center space-x-3 p-3 border rounded-lg",
                          selectedNewParcels.includes(parcel.id)
                            ? "bg-primary/5 border-primary"
                            : "hover:bg-muted/50"
                        )}
                      >
                        <Checkbox
                          checked={selectedNewParcels.includes(parcel.id)}
                          onCheckedChange={(checked) =>
                            handleParcelSelection(parcel.id, checked as boolean)
                          }
                        />
                        <div className="flex-1 min-w-0">
                          <div className="flex items-center gap-2">
                            <code className="text-sm font-medium">
                              {parcel.code}
                            </code>
                            <Badge color="primary" className="text-xs">
                              {Number(parcel.price).toFixed(2)} DH
                            </Badge>
                          </div>
                          <div className="text-sm text-muted-foreground">
                            {parcel.recipientName}  {parcel.recipientPhone}
                          </div>
                          <div className="text-xs text-muted-foreground">
                            {parcel.pickupCity.name} {" "}
                            {parcel.destinationCity.name}
                          </div>
                        </div>
                      </div>
                    ))
                  )}
                </div>
              </CardContent>
            </Card>
          )}
        </div>

        {/* Sidebar */}
        <div className="space-y-6">
          {/* Current Summary */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon
                  icon="heroicons:clipboard-document-list"
                  className="w-5 h-5"
                />
                Current Summary
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="space-y-2">
                <div className="flex justify-between text-sm">
                  <span>Total parcels:</span>
                  <span className="font-medium">
                    {currentDeliverySlip.summary.totalParcels}
                  </span>
                </div>
                <div className="flex justify-between text-sm">
                  <span>Scanned parcels:</span>
                  <span className="font-medium">
                    {currentDeliverySlip.summary.scannedParcels}
                  </span>
                </div>
                <div className="flex justify-between text-sm">
                  <span>Total value:</span>
                  <span className="font-medium">
                    {currentDeliverySlip.summary.totalValue.toFixed(2)} DH
                  </span>
                </div>
                <div className="flex justify-between text-sm">
                  <span>Status:</span>
                  <Badge color="primary">{currentDeliverySlip.status}</Badge>
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Quick Actions */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon icon="heroicons:bolt" className="w-5 h-5" />
                Quick Actions
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-2">
              <Link href={`/delivery-slips/${currentDeliverySlip.id}/scan`}>
                <Button variant="outline" className="w-full">
                  <Icon icon="heroicons:qr-code" className="w-4 h-4 mr-2" />
                  Scan Parcels
                </Button>
              </Link>

              <Link href={`/delivery-slips/${currentDeliverySlip.id}`}>
                <Button variant="outline" className="w-full">
                  <Icon icon="heroicons:eye" className="w-4 h-4 mr-2" />
                  View Details
                </Button>
              </Link>

              {canModify && (
                <Button
                  variant="outline"
                  className="w-full"
                  onClick={() => {
                    const confirmed = window.confirm(
                      "Are you sure you want to cancel this delivery slip?"
                    );
                    if (confirmed) {
                      setValue("status", DeliverySlipStatus.CANCELLED);
                      handleSubmit(onSubmit)();
                    }
                  }}
                >
                  <Icon icon="heroicons:x-circle" className="w-4 h-4 mr-2" />
                  Cancel Slip
                </Button>
              )}
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
};
// Main component wrapped with ProtectedRoute
const EditDeliverySlipPage = () => {
  return (
    <ProtectedRoute
      requiredPermissions={[PARCELS_PERMISSIONS.DELIVERY_SLIPS_UPDATE]}
      requiredAccessLevel="LIMITED"
      allowedAccountStatuses={["ACTIVE"]}
    >
      <EditDeliverySlipPageContent />
    </ProtectedRoute>
  );
};
export default EditDeliverySlipPage;
-----------------------------------------------------------------------
--++--> app/[locale]/(protected)/delivery-slips/[id]/scan/page.tsx =======>
-----------------------------------------------------------------------
"use client";
import React, { useState, useEffect, useRef } from "react";
import { useRouter, useParams } from "next/navigation";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Badge } from "@/components/ui/badge";
import { Icon } from "@/components/ui/icon";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Link } from "@/i18n/routing";
import { useDeliverySlipsStore } from "@/lib/stores/parcels/delivery-slips.store";
import { useAuthStore } from "@/lib/stores/auth/auth.store";
import { ProtectedRoute } from "@/components/route/protected-route";
import { PARCELS_PERMISSIONS } from "@/lib/constants/parcels";
import { DeliverySlipStatus } from "@/lib/types/parcels/delivery-slips.types";
import { toast } from "sonner";
import { cn } from "@/lib/utils/ui.utils";
interface ScanResult {
  success: boolean;
  code: string;
  timestamp: Date;
  message?: string;
  error?: string;
}
const ScanSpecificSlipPageContent = () => {
  const router = useRouter();
  const params = useParams();
  const slipId = params?.id as string;

  const { hasPermission } = useAuthStore();
  const {
    currentDeliverySlip,
    fetchDeliverySlipById,
    addParcelsToSlip,
    isLoading,
    error,
  } = useDeliverySlipsStore();

  const [scanInput, setScanInput] = useState("");
  const [scanResults, setScanResults] = useState<ScanResult[]>([]);
  const [isScanning, setIsScanning] = useState(false);
  const [sessionStats, setSessionStats] = useState({
    totalScans: 0,
    successfulScans: 0,
    failedScans: 0,
    startTime: new Date(),
  });

  const scanInputRef = useRef<HTMLInputElement>(null);

  const canScanSlips = hasPermission(PARCELS_PERMISSIONS.DELIVERY_SLIPS_SCAN);

  // Load delivery slip data
  useEffect(() => {
    if (canScanSlips && slipId) {
      fetchDeliverySlipById(slipId);
    }
  }, [canScanSlips, slipId, fetchDeliverySlipById]);

  // Auto-focus scan input
  useEffect(() => {
    const focusInput = () => {
      if (scanInputRef.current) {
        scanInputRef.current.focus();
      }
    };

    focusInput();
    const interval = setInterval(focusInput, 1000);
    return () => clearInterval(interval);
  }, []);

  const processScan = async (code: string) => {
    if (!code.trim() || !currentDeliverySlip) return;

    // Check if already scanned
    if (scanResults.some((result) => result.code === code)) {
      toast.warning("This parcel has already been scanned");
      return;
    }

    setIsScanning(true);

    try {
      const success = await addParcelsToSlip(currentDeliverySlip.id, {
        parcelIds: [code], // This might need adjustment based on your API
        markAsScanned: true,
        comment: "Scanned via dedicated slip scanner",
      });

      const result: ScanResult = {
        success,
        code,
        timestamp: new Date(),
        message: success ? "Parcel added successfully" : "Failed to add parcel",
        error: success ? undefined : "Parcel not found or invalid",
      };

      setScanResults((prev) => [result, ...prev]);
      setSessionStats((prev) => ({
        ...prev,
        totalScans: prev.totalScans + 1,
        successfulScans: success
          ? prev.successfulScans + 1
          : prev.successfulScans,
        failedScans: !success ? prev.failedScans + 1 : prev.failedScans,
      }));

      if (success) {
        toast.success(`Parcel ${code} scanned successfully`);
        // Refresh slip data
        fetchDeliverySlipById(currentDeliverySlip.id);
      } else {
        toast.error(`Failed to scan parcel ${code}`);
      }
    } catch (error) {
      const result: ScanResult = {
        success: false,
        code,
        timestamp: new Date(),
        error: error instanceof Error ? error.message : "Unknown error",
      };

      setScanResults((prev) => [result, ...prev]);
      setSessionStats((prev) => ({
        ...prev,
        totalScans: prev.totalScans + 1,
        failedScans: prev.failedScans + 1,
      }));

      toast.error(`Error scanning ${code}: ${result.error}`);
    } finally {
      setIsScanning(false);
      setScanInput("");
    }
  };

  const handleManualScan = (e: React.FormEvent) => {
    e.preventDefault();
    if (scanInput.trim()) {
      processScan(scanInput.trim());
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === "Enter") {
      e.preventDefault();
      if (scanInput.trim()) {
        processScan(scanInput.trim());
      }
    }
  };

  const clearSession = () => {
    setScanResults([]);
    setSessionStats({
      totalScans: 0,
      successfulScans: 0,
      failedScans: 0,
      startTime: new Date(),
    });
    setScanInput("");
  };

  if (!canScanSlips) {
    return (
      <div className="container mx-auto py-8">
        <Alert color="destructive">
          <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
          <AlertDescription>
            You don't have permission to scan delivery slips. Please contact
            your administrator.
          </AlertDescription>
        </Alert>
      </div>
    );
  }

  if (isLoading) {
    return (
      <div className="container mx-auto py-6">
        <Card>
          <CardContent className="p-8">
            <div className="flex items-center justify-center space-x-2">
              <Icon
                icon="heroicons:arrow-path"
                className="w-5 h-5 animate-spin"
              />
              <span>Loading delivery slip...</span>
            </div>
          </CardContent>
        </Card>
      </div>
    );
  }

  if (!currentDeliverySlip || error) {
    return (
      <div className="container mx-auto py-8">
        <Alert color="destructive">
          <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
          <AlertDescription>
            {error || "Delivery slip not found or has been deleted."}
          </AlertDescription>
        </Alert>
      </div>
    );
  }

  const canModify = currentDeliverySlip.status === DeliverySlipStatus.PENDING;

  return (
    <div className="container mx-auto py-6 space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-default-900">Scan Parcels</h1>
          <p className="text-default-600">
            {currentDeliverySlip.reference}  Scan parcels into this delivery
            slip
          </p>
        </div>
        <div className="flex items-center gap-2">
          <Link href={`/delivery-slips/${currentDeliverySlip.id}`}>
            <Button variant="outline">
              <Icon icon="heroicons:eye" className="w-4 h-4 mr-2" />
              View Details
            </Button>
          </Link>
          <Link href="/delivery-slips">
            <Button variant="outline">
              <Icon icon="heroicons:arrow-left" className="w-4 h-4 mr-2" />
              Back to List
            </Button>
          </Link>
        </div>
      </div>

      {/* Status Warning */}
      {!canModify && (
        <Alert color="warning">
          <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
          <AlertDescription>
            This delivery slip has status "{currentDeliverySlip.status}" and
            cannot be modified. Only pending slips can be scanned.
          </AlertDescription>
        </Alert>
      )}

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Main Scanner */}
        <div className="lg:col-span-2 space-y-6">
          {/* Slip Information */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon icon="heroicons:document-text" className="w-5 h-5" />
                Delivery Slip Information
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <Label className="text-sm font-medium">Reference</Label>
                  <p className="font-mono">{currentDeliverySlip.reference}</p>
                </div>
                <div>
                  <Label className="text-sm font-medium">Status</Label>
                  <Badge color="secondary">{currentDeliverySlip.status}</Badge>
                </div>
                <div>
                  <Label className="text-sm font-medium">Total Parcels</Label>
                  <p>{currentDeliverySlip.summary.totalParcels}</p>
                </div>
                <div>
                  <Label className="text-sm font-medium">Scanned Parcels</Label>
                  <p className="text-green-600">
                    {currentDeliverySlip.summary.scannedParcels} /{" "}
                    {currentDeliverySlip.summary.totalParcels}
                  </p>
                </div>
              </div>

              {/* Progress Bar */}
              <div className="space-y-2">
                <div className="flex justify-between text-sm">
                  <span>Scan Progress</span>
                  <span>
                    {Math.round(
                      (currentDeliverySlip.summary.scannedParcels /
                        currentDeliverySlip.summary.totalParcels) *
                        100
                    )}
                    %
                  </span>
                </div>
                <div className="w-full bg-gray-200 rounded-full h-2">
                  <div
                    className="bg-primary h-2 rounded-full"
                    style={{
                      width: `${
                        (currentDeliverySlip.summary.scannedParcels /
                          currentDeliverySlip.summary.totalParcels) *
                        100
                      }%`,
                    }}
                  />
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Scanner Interface */}
          {canModify && (
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:qr-code" className="w-5 h-5" />
                  Scanner Interface
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="space-y-2">
                  <Label>Scan or enter parcel code:</Label>
                  <form onSubmit={handleManualScan} className="flex gap-2">
                    <Input
                      ref={scanInputRef}
                      value={scanInput}
                      onChange={(e) => setScanInput(e.target.value)}
                      onKeyPress={handleKeyPress}
                      placeholder="Click here before scanning or type parcel code..."
                      className="flex-1 font-mono"
                      disabled={isScanning}
                      autoComplete="off"
                    />
                    <Button
                      type="submit"
                      disabled={!scanInput.trim() || isScanning}
                    >
                      {isScanning ? (
                        <Icon
                          icon="heroicons:arrow-path"
                          className="w-4 h-4 animate-spin"
                        />
                      ) : (
                        <Icon icon="heroicons:plus" className="w-4 h-4" />
                      )}
                    </Button>
                  </form>
                </div>

                {/* Instructions */}
                <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
                  <h4 className="font-medium text-blue-900 mb-2">
                    Scanning Instructions:
                  </h4>
                  <ul className="text-sm text-blue-800 space-y-1">
                    <li> Click in the input field above before scanning</li>
                    <li> Use a barcode scanner to scan parcel codes</li>
                    <li> Press Enter or click + to manually add codes</li>
                    <li> Each successful scan adds the parcel to this slip</li>
                  </ul>
                </div>
              </CardContent>
            </Card>
          )}

          {/* Scan Results */}
          {scanResults.length > 0 && (
            <Card>
              <CardHeader>
                <div className="flex items-center justify-between">
                  <CardTitle className="flex items-center gap-2">
                    <Icon icon="heroicons:list-bullet" className="w-5 h-5" />
                    Scan Results ({scanResults.length})
                  </CardTitle>
                  <Button size="sm" variant="outline" onClick={clearSession}>
                    <Icon icon="heroicons:trash" className="w-4 h-4 mr-2" />
                    Clear Session
                  </Button>
                </div>
              </CardHeader>
              <CardContent>
                <div className="space-y-2 max-h-64 overflow-y-auto">
                  {scanResults.map((result, index) => (
                    <div
                      key={index}
                      className={cn(
                        "flex items-center justify-between p-3 border rounded-lg",
                        result.success
                          ? "bg-green-50 border-green-200"
                          : "bg-red-50 border-red-200"
                      )}
                    >
                      <div className="flex items-center gap-3">
                        <Icon
                          icon={
                            result.success
                              ? "heroicons:check-circle"
                              : "heroicons:x-circle"
                          }
                          className={cn(
                            "w-5 h-5",
                            result.success ? "text-green-600" : "text-red-600"
                          )}
                        />
                        <div>
                          <code className="text-sm font-medium">
                            {result.code}
                          </code>
                          <div className="text-xs text-muted-foreground">
                            {result.timestamp.toLocaleTimeString()}
                          </div>
                        </div>
                      </div>
                      <div className="text-xs">
                        {result.success ? result.message : result.error}
                      </div>
                    </div>
                  ))}
                </div>
              </CardContent>
            </Card>
          )}

          {/* Current Parcels */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon icon="heroicons:cube" className="w-5 h-5" />
                Current Parcels ({currentDeliverySlip.items.length})
              </CardTitle>
            </CardHeader>
            <CardContent>
              <div className="space-y-2 max-h-64 overflow-y-auto">
                {currentDeliverySlip.items.length === 0 ? (
                  <div className="text-center py-8">
                    <Icon
                      icon="heroicons:inbox"
                      className="w-12 h-12 text-muted-foreground mx-auto mb-4"
                    />
                    <p className="text-muted-foreground">
                      No parcels in this delivery slip yet
                    </p>
                  </div>
                ) : (
                  currentDeliverySlip.items.map((item) => (
                    <div
                      key={item.parcelId}
                      className="flex items-center justify-between p-3 border rounded-lg"
                    >
                      <div className="flex items-center gap-3">
                        {item.scanned ? (
                          <Icon
                            icon="heroicons:check-circle"
                            className="w-5 h-5 text-green-600"
                          />
                        ) : (
                          <Icon
                            icon="heroicons:clock"
                            className="w-5 h-5 text-yellow-600"
                          />
                        )}
                        <div>
                          <code className="text-sm font-medium">
                            {item.parcel.code}
                          </code>
                          <div className="text-xs text-muted-foreground">
                            {item.parcel.recipientName} {" "}
                            {item.parcel.recipientPhone}
                          </div>
                        </div>
                      </div>
                      <div className="text-right">
                        <Badge color="primary" className="text-xs">
                          {item.parcel.price.toFixed(2)} DH
                        </Badge>
                        <div className="text-xs text-muted-foreground">
                          To: {item.parcel.destinationCity}
                        </div>
                      </div>
                    </div>
                  ))
                )}
              </div>
            </CardContent>
          </Card>
        </div>

        {/* Sidebar */}
        <div className="space-y-6">
          {/* Session Stats */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon icon="heroicons:chart-bar" className="w-5 h-5" />
                Session Statistics
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="space-y-3">
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Total scans:
                  </span>
                  <span className="font-medium">{sessionStats.totalScans}</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Successful:
                  </span>
                  <span className="font-medium text-green-600">
                    {sessionStats.successfulScans}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">Failed:</span>
                  <span className="font-medium text-red-600">
                    {sessionStats.failedScans}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Success rate:
                  </span>
                  <span className="font-medium">
                    {sessionStats.totalScans > 0
                      ? Math.round(
                          (sessionStats.successfulScans /
                            sessionStats.totalScans) *
                            100
                        )
                      : 0}
                    %
                  </span>
                </div>
                <div className="flex justify-between text-xs border-t pt-2">
                  <span className="text-muted-foreground">
                    Session started:
                  </span>
                  <span>{sessionStats.startTime.toLocaleTimeString()}</span>
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Slip Summary */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon
                  icon="heroicons:clipboard-document-list"
                  className="w-5 h-5"
                />
                Slip Summary
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="space-y-3">
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Reference:
                  </span>
                  <code className="text-sm font-medium">
                    {currentDeliverySlip.reference}
                  </code>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">Status:</span>
                  <Badge color="secondary">{currentDeliverySlip.status}</Badge>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">City:</span>
                  <span className="text-sm">
                    {currentDeliverySlip.city?.name || "Not specified"}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Total value:
                  </span>
                  <span className="font-medium">
                    {currentDeliverySlip.summary.totalValue.toFixed(2)} DH
                  </span>
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Quick Actions */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon icon="heroicons:bolt" className="w-5 h-5" />
                Quick Actions
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-2">
              <Link href={`/delivery-slips/${currentDeliverySlip.id}`}>
                <Button variant="outline" className="w-full">
                  <Icon icon="heroicons:eye" className="w-4 h-4 mr-2" />
                  View Slip Details
                </Button>
              </Link>

              {canModify && (
                <Link href={`/delivery-slips/${currentDeliverySlip.id}/edit`}>
                  <Button variant="outline" className="w-full">
                    <Icon icon="heroicons:pencil" className="w-4 h-4 mr-2" />
                    Edit Slip
                  </Button>
                </Link>
              )}

              <Link href="/delivery-slips/scan">
                <Button variant="outline" className="w-full">
                  <Icon icon="heroicons:qr-code" className="w-4 h-4 mr-2" />
                  General Scanner
                </Button>
              </Link>

              <Link href="/delivery-slips">
                <Button variant="outline" className="w-full">
                  <Icon icon="heroicons:list-bullet" className="w-4 h-4 mr-2" />
                  All Delivery Slips
                </Button>
              </Link>

              {canModify &&
                currentDeliverySlip.summary.unscannedParcels === 0 && (
                  <Button
                    className="w-full"
                    onClick={() => {
                      // Quick receive action
                      router.push(
                        `/delivery-slips/${currentDeliverySlip.id}?action=receive`
                      );
                    }}
                  >
                    <Icon icon="heroicons:check" className="w-4 h-4 mr-2" />
                    Mark as Received
                  </Button>
                )}
            </CardContent>
          </Card>

          {/* Help */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon
                  icon="heroicons:question-mark-circle"
                  className="w-5 h-5"
                />
                Scanning Tips
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-3">
              <div className="text-sm space-y-2">
                <p className="font-medium">For best results:</p>
                <ul className="text-muted-foreground space-y-1 text-xs">
                  <li> Keep the input field focused</li>
                  <li> Scan codes one at a time</li>
                  <li> Wait for confirmation before next scan</li>
                  <li> Check scan results for any errors</li>
                </ul>
              </div>
              <div className="text-sm space-y-2">
                <p className="font-medium">Troubleshooting:</p>
                <ul className="text-muted-foreground space-y-1 text-xs">
                  <li> Ensure parcels are not already in other slips</li>
                  <li> Verify parcel codes are correct</li>
                  <li> Contact support for persistent issues</li>
                </ul>
              </div>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
};
// Main component wrapped with ProtectedRoute
const ScanSpecificSlipPage = () => {
  return (
    <ProtectedRoute
      requiredPermissions={[PARCELS_PERMISSIONS.DELIVERY_SLIPS_SCAN]}
      requiredAccessLevel="LIMITED"
      allowedAccountStatuses={["ACTIVE"]}
    >
      <ScanSpecificSlipPageContent />
    </ProtectedRoute>
  );
};
export default ScanSpecificSlipPage;
-----------------------------------------------------------------------
--++--> app/[locale]/(protected)/delivery-slips/create/page.tsx =======>
-----------------------------------------------------------------------
"use client";
import React, { useState, useEffect } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { useRouter } from "next/navigation";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";
import { Badge } from "@/components/ui/badge";
import { Icon } from "@/components/ui/icon";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Checkbox } from "@/components/ui/checkbox";
import { Link } from "@/i18n/routing";
import { useDeliverySlipsStore } from "@/lib/stores/parcels/delivery-slips.store";
import { useCitiesStore } from "@/lib/stores/parcels/cities.store";
import { useAuthStore } from "@/lib/stores/auth/auth.store";
import { ProtectedRoute } from "@/components/route/protected-route";
import { PARCELS_PERMISSIONS } from "@/lib/constants/parcels";
import { toast } from "sonner";
import { cn } from "@/lib/utils/ui.utils";
// Form schema for creating delivery slip
const createDeliverySlipSchema = z.object({
  cityId: z.string().optional(),
  parcelIds: z.array(z.string()).optional(),
  notes: z.string().max(500).optional(),
  autoReceive: z.boolean().default(false),
});
type CreateDeliverySlipFormData = z.infer<typeof createDeliverySlipSchema>;
const CreateDeliverySlipPageContent = () => {
  const router = useRouter();
  const { hasPermission, user } = useAuthStore();
  const {
    createDeliverySlip,
    fetchAvailableParcels,
    availableParcels,
    isCreating,
    error,
  } = useDeliverySlipsStore();
  const { cities, fetchCities } = useCitiesStore();

  const [selectedParcels, setSelectedParcels] = useState<string[]>([]);
  const [selectedCity, setSelectedCity] = useState<string>("");
  const [searchTerm, setSearchTerm] = useState("");

  // Check permissions
  const canCreateSlips = hasPermission(
    PARCELS_PERMISSIONS.DELIVERY_SLIPS_CREATE
  );

  const {
    register,
    handleSubmit,
    watch,
    setValue,
    formState: { errors, isDirty },
    reset,
  } = useForm<CreateDeliverySlipFormData>({
    resolver: zodResolver(createDeliverySlipSchema),
    defaultValues: {
      autoReceive: false,
      parcelIds: [],
    },
  });

  const watchedCityId = watch("cityId");
  const watchedAutoReceive = watch("autoReceive");

  // Initialize data
  useEffect(() => {
    if (canCreateSlips) {
      fetchCities();
      fetchAvailableParcels();
    }
  }, [canCreateSlips, fetchCities, fetchAvailableParcels]);

  // Update available parcels when city filter changes
  useEffect(() => {
    if (selectedCity) {
      fetchAvailableParcels(selectedCity);
    } else {
      fetchAvailableParcels();
    }
  }, [selectedCity, fetchAvailableParcels]);

  // Update form when parcels selection changes
  useEffect(() => {
    setValue("parcelIds", selectedParcels, { shouldDirty: true });
  }, [selectedParcels, setValue]);

  const handleParcelSelection = (parcelId: string, checked: boolean) => {
    if (checked) {
      setSelectedParcels((prev) => [...prev, parcelId]);
    } else {
      setSelectedParcels((prev) => prev.filter((id) => id !== parcelId));
    }
  };

  const handleSelectAll = (checked: boolean) => {
    if (checked) {
      const allParcelIds = filteredParcels.map((parcel) => parcel.id);
      setSelectedParcels(allParcelIds);
    } else {
      setSelectedParcels([]);
    }
  };

  const handleCityFilter = (cityId: string) => {
    setSelectedCity(cityId === "all" ? "" : cityId);
  };

  // Filter parcels based on search term
  const filteredParcels = availableParcels.filter(
    (parcel) =>
      parcel.code.toLowerCase().includes(searchTerm.toLowerCase()) ||
      parcel.recipientName.toLowerCase().includes(searchTerm.toLowerCase()) ||
      parcel.recipientPhone.includes(searchTerm)
  );

  const onSubmit = async (data: CreateDeliverySlipFormData) => {
    if (!canCreateSlips) {
      toast.error("You don't have permission to create delivery slips");
      return;
    }

    const deliverySlip = await createDeliverySlip({
      cityId: data.cityId,
      parcelIds: selectedParcels,
      notes: data.notes,
      autoReceive: data.autoReceive,
    });

    if (deliverySlip) {
      toast.success("Delivery slip created successfully");
      router.push(`/delivery-slips/${deliverySlip.id}`);
    }
  };

  if (!canCreateSlips) {
    return (
      <div className="container mx-auto py-8">
        <Alert color="destructive">
          <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
          <AlertDescription>
            You don't have permission to create delivery slips. Please contact
            your administrator.
          </AlertDescription>
        </Alert>
      </div>
    );
  }

  const totalValue = filteredParcels
    .filter((parcel) => selectedParcels.includes(parcel.id))
    .reduce((sum, parcel) => sum + Number(parcel.price), 0);

  return (
    <div className="container mx-auto py-6 space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-default-900">
            Create Delivery Slip
          </h1>
          <p className="text-default-600">
            Create a new delivery slip to group parcels for collection
          </p>
        </div>
        <Link href="/delivery-slips">
          <Button variant="outline">
            <Icon icon="heroicons:arrow-left" className="w-4 h-4 mr-2" />
            Back to Delivery Slips
          </Button>
        </Link>
      </div>

      {/* Error Alert */}
      {error && (
        <Alert color="destructive">
          <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Main Form */}
        <div className="lg:col-span-2 space-y-6">
          {/* Basic Information */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon icon="heroicons:document-text" className="w-5 h-5" />
                Basic Information
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              {/* City Selection */}
              <div className="space-y-2">
                <Label htmlFor="cityId">Collection City (Optional)</Label>
                <Select
                  value={watchedCityId || ""}
                  onValueChange={(value) =>
                    setValue("cityId", value || undefined)
                  }
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Select collection city" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="none">No specific city</SelectItem>
                    {cities
                      .filter((city) => city.pickupCity && city.status)
                      .map((city) => (
                        <SelectItem key={city.id} value={city.id}>
                          {city.name} ({city.ref})
                        </SelectItem>
                      ))}
                  </SelectContent>
                </Select>
              </div>

              {/* Notes */}
              <div className="space-y-2">
                <Label htmlFor="notes">Notes (Optional)</Label>
                <Textarea
                  id="notes"
                  {...register("notes")}
                  placeholder="Add any special instructions or notes..."
                  rows={3}
                />
                {errors.notes && (
                  <p className="text-xs text-destructive">
                    {errors.notes.message}
                  </p>
                )}
              </div>

              {/* Auto-receive option */}
              <div className="flex items-center justify-between p-4 border rounded-lg">
                <div className="space-y-0.5">
                  <Label>Auto-receive slip</Label>
                  <p className="text-xs text-muted-foreground">
                    Automatically mark this slip as received upon creation
                  </p>
                </div>
                <Switch
                  {...register("autoReceive")}
                  checked={watchedAutoReceive}
                  onCheckedChange={(checked) =>
                    setValue("autoReceive", checked)
                  }
                />
              </div>
            </CardContent>
          </Card>

          {/* Parcel Selection */}
          <Card>
            <CardHeader>
              <div className="flex items-center justify-between">
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:cube" className="w-5 h-5" />
                  Select Parcels
                </CardTitle>
                <Badge color="primary">{selectedParcels.length} selected</Badge>
              </div>
            </CardHeader>
            <CardContent className="space-y-4">
              {/* Filters */}
              <div className="flex flex-col sm:flex-row gap-4">
                <div className="flex-1">
                  <Input
                    placeholder="Search by code, recipient name, or phone..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                  />
                </div>
                <div>
                  <Select
                    value={selectedCity || "all"}
                    onValueChange={handleCityFilter}
                  >
                    <SelectTrigger className="w-[200px]">
                      <SelectValue placeholder="Filter by pickup city" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">All cities</SelectItem>
                      {cities
                        .filter((city) => city.pickupCity && city.status)
                        .map((city) => (
                          <SelectItem key={city.id} value={city.id}>
                            {city.name}
                          </SelectItem>
                        ))}
                    </SelectContent>
                  </Select>
                </div>
              </div>

              {/* Select All */}
              {filteredParcels.length > 0 && (
                <div className="flex items-center space-x-2 p-3 bg-muted rounded-lg">
                  <Checkbox
                    id="select-all"
                    checked={
                      filteredParcels.length > 0 &&
                      filteredParcels.every((parcel) =>
                        selectedParcels.includes(parcel.id)
                      )
                    }
                    onCheckedChange={handleSelectAll}
                  />
                  <Label htmlFor="select-all" className="text-sm font-medium">
                    Select all visible parcels ({filteredParcels.length})
                  </Label>
                </div>
              )}

              {/* Parcels List */}
              <div className="space-y-2 max-h-96 overflow-y-auto">
                {filteredParcels.length === 0 ? (
                  <div className="text-center py-8">
                    <Icon
                      icon="heroicons:inbox"
                      className="w-12 h-12 text-muted-foreground mx-auto mb-4"
                    />
                    <p className="text-muted-foreground">
                      {searchTerm || selectedCity
                        ? "No parcels match your filters"
                        : "No available parcels for delivery slips"}
                    </p>
                  </div>
                ) : (
                  filteredParcels.map((parcel) => (
                    <div
                      key={parcel.id}
                      className={cn(
                        "flex items-center space-x-3 p-3 border rounded-lg",
                        selectedParcels.includes(parcel.id)
                          ? "bg-primary/5 border-primary"
                          : "hover:bg-muted/50"
                      )}
                    >
                      <Checkbox
                        checked={selectedParcels.includes(parcel.id)}
                        onCheckedChange={(checked) =>
                          handleParcelSelection(parcel.id, checked as boolean)
                        }
                      />
                      <div className="flex-1 min-w-0">
                        <div className="flex items-center gap-2">
                          <code className="text-sm font-medium">
                            {parcel.code}
                          </code>
                          <Badge color="primary" className="text-xs">
                            {Number(parcel.price).toFixed(2)} DH
                          </Badge>
                        </div>
                        <div className="text-sm text-muted-foreground">
                          {parcel.recipientName}  {parcel.recipientPhone}
                        </div>
                        <div className="text-xs text-muted-foreground">
                          {parcel.pickupCity.name} {" "}
                          {parcel.destinationCity.name}
                        </div>
                      </div>
                    </div>
                  ))
                )}
              </div>
            </CardContent>
          </Card>
        </div>

        {/* Sidebar */}
        <div className="space-y-6">
          {/* Summary */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon
                  icon="heroicons:clipboard-document-list"
                  className="w-5 h-5"
                />
                Summary
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="space-y-2">
                <div className="flex justify-between text-sm">
                  <span>Selected parcels:</span>
                  <span className="font-medium">{selectedParcels.length}</span>
                </div>
                <div className="flex justify-between text-sm">
                  <span>Total value:</span>
                  <span className="font-medium">
                    {totalValue.toFixed(2)} DH
                  </span>
                </div>
                <div className="flex justify-between text-sm">
                  <span>Collection city:</span>
                  <span className="font-medium">
                    {watchedCityId
                      ? cities.find((c) => c.id === watchedCityId)?.name ||
                        "Unknown"
                      : "Not specified"}
                  </span>
                </div>
                <div className="flex justify-between text-sm">
                  <span>Auto-receive:</span>
                  <span className="font-medium">
                    {watchedAutoReceive ? "Yes" : "No"}
                  </span>
                </div>
              </div>

              {watchedAutoReceive && (
                <Alert color="info" variant="soft">
                  <Icon
                    icon="heroicons:information-circle"
                    className="h-4 w-4"
                  />
                  <AlertDescription>
                    The slip will be automatically marked as received and
                    parcels will have their status updated.
                  </AlertDescription>
                </Alert>
              )}
            </CardContent>
          </Card>

          {/* Actions */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon icon="heroicons:cog-6-tooth" className="w-5 h-5" />
                Actions
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <Button
                onClick={handleSubmit(onSubmit)}
                disabled={isCreating || selectedParcels.length === 0}
                className="w-full"
              >
                {isCreating && (
                  <Icon
                    icon="heroicons:arrow-path"
                    className="mr-2 h-4 w-4 animate-spin"
                  />
                )}
                Create Delivery Slip
              </Button>

              <Button
                type="button"
                variant="outline"
                onClick={() => {
                  reset();
                  setSelectedParcels([]);
                  setSelectedCity("");
                  setSearchTerm("");
                }}
                disabled={isCreating || !isDirty}
                className="w-full"
              >
                Reset Form
              </Button>
            </CardContent>
          </Card>

          {/* Help */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon
                  icon="heroicons:question-mark-circle"
                  className="w-5 h-5"
                />
                Help
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-3">
              <div className="text-sm space-y-2">
                <p className="font-medium">What is a delivery slip?</p>
                <p className="text-muted-foreground">
                  A delivery slip groups multiple parcels for efficient pickup
                  operations. It serves as a collection document.
                </p>
              </div>
              <div className="text-sm space-y-2">
                <p className="font-medium">Parcel status changes:</p>
                <ul className="text-muted-foreground space-y-1">
                  <li> Same city: NEW_PACKAGE  RECEIVED</li>
                  <li> Different city: NEW_PACKAGE  COLLECTED</li>
                </ul>
              </div>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
};
// Main component wrapped with ProtectedRoute
const CreateDeliverySlipPage = () => {
  return (
    <ProtectedRoute
      requiredPermissions={[PARCELS_PERMISSIONS.DELIVERY_SLIPS_CREATE]}
      requiredAccessLevel="LIMITED"
      allowedAccountStatuses={["ACTIVE"]}
    >
      <CreateDeliverySlipPageContent />
    </ProtectedRoute>
  );
};
export default CreateDeliverySlipPage;
-----------------------------------------------------------------------
--++--> app/[locale]/(protected)/delivery-slips/bulk-receive/page.tsx =======>
-----------------------------------------------------------------------
"use client";
import React, { useState, useEffect } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Badge } from "@/components/ui/badge";
import { Icon } from "@/components/ui/icon";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Checkbox } from "@/components/ui/checkbox";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Link } from "@/i18n/routing";
import { useDeliverySlipsStore } from "@/lib/stores/parcels/delivery-slips.store";
import { useCitiesStore } from "@/lib/stores/parcels/cities.store";
import { useAuthStore } from "@/lib/stores/auth/auth.store";
import { ProtectedRoute } from "@/components/route/protected-route";
import { PARCELS_PERMISSIONS } from "@/lib/constants/parcels";
import { DeliverySlipStatus } from "@/lib/types/parcels/delivery-slips.types";
import { toast } from "sonner";
import { cn } from "@/lib/utils/ui.utils";
interface BulkReceiveData {
  slipIds: string[];
  notes: string;
  forceReceive: boolean;
}
const formatDate = (dateString: string) => {
  return new Date(dateString).toLocaleDateString("en-US", {
    month: "short",
    day: "2-digit",
    year: "numeric",
    hour: "2-digit",
    minute: "2-digit",
  });
};
const BulkReceiveDeliverySlipsPageContent = () => {
  const { hasPermission } = useAuthStore();
  const { deliverySlips, fetchDeliverySlips, bulkAction, isLoading, error } =
    useDeliverySlipsStore();
  const { cities, fetchCities } = useCitiesStore();

  const [selectedSlips, setSelectedSlips] = useState<string[]>([]);
  const [notes, setNotes] = useState("");
  const [forceReceive, setForceReceive] = useState(false);
  const [filterCity, setFilterCity] = useState<string>("all");
  const [searchTerm, setSearchTerm] = useState("");
  const [showConfirmDialog, setShowConfirmDialog] = useState(false);
  const [isProcessing, setIsProcessing] = useState(false);

  const canReceiveSlips = hasPermission(
    PARCELS_PERMISSIONS.DELIVERY_SLIPS_RECEIVE
  );
  const canBulkActions = hasPermission(PARCELS_PERMISSIONS.DELIVERY_SLIPS_BULK);

  // Load data on mount
  useEffect(() => {
    if (canReceiveSlips) {
      fetchDeliverySlips();
      fetchCities();
    }
  }, [canReceiveSlips, fetchDeliverySlips, fetchCities]);

  // Filter pending slips
  const pendingSlips = deliverySlips.filter(
    (slip) => slip.status === DeliverySlipStatus.PENDING
  );

  // Apply filters
  const filteredSlips = pendingSlips.filter((slip) => {
    const matchesSearch =
      slip.reference.toLowerCase().includes(searchTerm.toLowerCase()) ||
      slip.items.some(
        (item) =>
          item.parcel.recipientName
            .toLowerCase()
            .includes(searchTerm.toLowerCase()) ||
          item.parcel.recipientPhone.includes(searchTerm)
      );

    const matchesCity =
      filterCity === "all" ||
      slip.cityId === filterCity ||
      (!slip.cityId && filterCity === "none");

    return matchesSearch && matchesCity;
  });

  const handleSlipSelection = (slipId: string, checked: boolean) => {
    if (checked) {
      setSelectedSlips((prev) => [...prev, slipId]);
    } else {
      setSelectedSlips((prev) => prev.filter((id) => id !== slipId));
    }
  };

  const handleSelectAll = (checked: boolean) => {
    if (checked) {
      setSelectedSlips(filteredSlips.map((slip) => slip.id));
    } else {
      setSelectedSlips([]);
    }
  };

  const getSlipStats = () => {
    const selectedSlipData = filteredSlips.filter((slip) =>
      selectedSlips.includes(slip.id)
    );

    return {
      totalSlips: selectedSlipData.length,
      totalParcels: selectedSlipData.reduce(
        (sum, slip) => sum + slip.summary.totalParcels,
        0
      ),
      totalValue: selectedSlipData.reduce(
        (sum, slip) => sum + slip.summary.totalValue,
        0
      ),
      unscannedParcels: selectedSlipData.reduce(
        (sum, slip) => sum + slip.summary.unscannedParcels,
        0
      ),
    };
  };

  const handleBulkReceive = async () => {
    if (selectedSlips.length === 0) {
      toast.error("Please select at least one delivery slip");
      return;
    }

    setIsProcessing(true);

    try {
      const success = await bulkAction({
        slipIds: selectedSlips,
        action: "RECEIVE",
        comment: notes || "Bulk received via bulk receive page",
      });

      if (success) {
        toast.success(
          `Successfully processed ${selectedSlips.length} delivery slips`
        );
        setSelectedSlips([]);
        setNotes("");
        setShowConfirmDialog(false);
        // Refresh data
        fetchDeliverySlips();
      }
    } catch (error) {
      toast.error("Failed to process bulk receive operation");
    } finally {
      setIsProcessing(false);
    }
  };

  if (!canReceiveSlips || !canBulkActions) {
    return (
      <div className="container mx-auto py-8">
        <Alert color="destructive">
          <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
          <AlertDescription>
            You don't have permission to perform bulk receive operations. Please
            contact your administrator.
          </AlertDescription>
        </Alert>
      </div>
    );
  }

  const stats = getSlipStats();

  return (
    <div className="container mx-auto py-6 space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-default-900">
            Bulk Receive Delivery Slips
          </h1>
          <p className="text-default-600">
            Process multiple delivery slips for bulk receiving operations
          </p>
        </div>
        <Link href="/delivery-slips">
          <Button variant="outline">
            <Icon icon="heroicons:arrow-left" className="w-4 h-4 mr-2" />
            Back to Delivery Slips
          </Button>
        </Link>
      </div>

      {/* Error Alert */}
      {error && (
        <Alert color="destructive">
          <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Main Content */}
        <div className="lg:col-span-2 space-y-6">
          {/* Filters */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon icon="heroicons:funnel" className="w-5 h-5" />
                Filters & Search
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div className="space-y-2">
                  <Label>Search delivery slips:</Label>
                  <Input
                    placeholder="Search by reference, customer name, or phone..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                  />
                </div>
                <div className="space-y-2">
                  <Label>Filter by city:</Label>
                  <Select value={filterCity} onValueChange={setFilterCity}>
                    <SelectTrigger>
                      <SelectValue placeholder="All cities" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">All cities</SelectItem>
                      <SelectItem value="none">No city specified</SelectItem>
                      {cities
                        .filter((city) => city.pickupCity && city.status)
                        .map((city) => (
                          <SelectItem key={city.id} value={city.id}>
                            {city.name} ({city.ref})
                          </SelectItem>
                        ))}
                    </SelectContent>
                  </Select>
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Delivery Slips Selection */}
          <Card>
            <CardHeader>
              <div className="flex items-center justify-between">
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:document-text" className="w-5 h-5" />
                  Select Delivery Slips ({filteredSlips.length})
                </CardTitle>
                <div className="flex items-center gap-2">
                  {selectedSlips.length > 0 && (
                    <Badge color="secondary">
                      {selectedSlips.length} selected
                    </Badge>
                  )}
                  {filteredSlips.length > 0 && (
                    <Button
                      size="sm"
                      variant="outline"
                      onClick={() =>
                        handleSelectAll(
                          selectedSlips.length !== filteredSlips.length
                        )
                      }
                    >
                      {selectedSlips.length === filteredSlips.length
                        ? "Deselect All"
                        : "Select All"}
                    </Button>
                  )}
                </div>
              </div>
            </CardHeader>
            <CardContent>
              {filteredSlips.length === 0 ? (
                <div className="text-center py-8">
                  <Icon
                    icon="heroicons:document-text"
                    className="w-12 h-12 text-muted-foreground mx-auto mb-4"
                  />
                  <p className="text-muted-foreground">
                    {pendingSlips.length === 0
                      ? "No pending delivery slips found"
                      : "No delivery slips match your filters"}
                  </p>
                  {pendingSlips.length === 0 && (
                    <Link href="/delivery-slips/create">
                      <Button className="mt-4">
                        <Icon icon="heroicons:plus" className="w-4 h-4 mr-2" />
                        Create Delivery Slip
                      </Button>
                    </Link>
                  )}
                </div>
              ) : (
                <div className="overflow-x-auto">
                  <Table>
                    <TableHeader>
                      <TableRow>
                        <TableHead className="w-12">
                          <Checkbox
                            checked={
                              filteredSlips.length > 0 &&
                              selectedSlips.length === filteredSlips.length
                            }
                            onCheckedChange={handleSelectAll}
                          />
                        </TableHead>
                        <TableHead>Reference</TableHead>
                        <TableHead>Created</TableHead>
                        <TableHead>City</TableHead>
                        <TableHead>Parcels</TableHead>
                        <TableHead>Scanned</TableHead>
                        <TableHead>Value</TableHead>
                        <TableHead>Progress</TableHead>
                      </TableRow>
                    </TableHeader>
                    <TableBody>
                      {filteredSlips.map((slip) => (
                        <TableRow key={slip.id}>
                          <TableCell>
                            <Checkbox
                              checked={selectedSlips.includes(slip.id)}
                              onCheckedChange={(checked) =>
                                handleSlipSelection(slip.id, checked as boolean)
                              }
                            />
                          </TableCell>
                          <TableCell>
                            <div>
                              <code className="text-sm font-medium">
                                {slip.reference}
                              </code>
                              <Badge color="secondary" className="ml-2 text-xs">
                                {slip.status}
                              </Badge>
                            </div>
                          </TableCell>
                          <TableCell className="text-sm">
                            {formatDate(slip.createdAt)}
                          </TableCell>
                          <TableCell>
                            {slip.city ? (
                              <Badge color="primary" className="text-xs">
                                {slip.city.name}
                              </Badge>
                            ) : (
                              <span className="text-xs text-muted-foreground">
                                Not specified
                              </span>
                            )}
                          </TableCell>
                          <TableCell>
                            <div className="text-sm">
                              <span className="font-medium">
                                {slip.summary.totalParcels}
                              </span>
                              <span className="text-muted-foreground">
                                {" "}
                                total
                              </span>
                            </div>
                          </TableCell>
                          <TableCell>
                            <div className="text-sm">
                              <span className="font-medium text-green-600">
                                {slip.summary.scannedParcels}
                              </span>
                              {slip.summary.unscannedParcels > 0 && (
                                <span className="text-yellow-600">
                                  {" "}
                                  ({slip.summary.unscannedParcels} pending)
                                </span>
                              )}
                            </div>
                          </TableCell>
                          <TableCell>
                            <Badge color="primary" className="text-xs">
                              {slip.summary.totalValue.toFixed(2)} DH
                            </Badge>
                          </TableCell>
                          <TableCell>
                            <div className="flex items-center gap-2">
                              <div className="w-16 bg-gray-200 rounded-full h-2">
                                <div
                                  className="bg-primary h-2 rounded-full"
                                  style={{
                                    width: `${
                                      slip.summary.totalParcels > 0
                                        ? (slip.summary.scannedParcels /
                                            slip.summary.totalParcels) *
                                          100
                                        : 0
                                    }%`,
                                  }}
                                />
                              </div>
                              <span className="text-xs text-muted-foreground">
                                {slip.summary.totalParcels > 0
                                  ? Math.round(
                                      (slip.summary.scannedParcels /
                                        slip.summary.totalParcels) *
                                        100
                                    )
                                  : 0}
                                %
                              </span>
                            </div>
                          </TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </div>
              )}
            </CardContent>
          </Card>

          {/* Bulk Action Settings */}
          {selectedSlips.length > 0 && (
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:cog-6-tooth" className="w-5 h-5" />
                  Bulk Receive Settings
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="space-y-2">
                  <Label>Notes (Optional)</Label>
                  <Textarea
                    value={notes}
                    onChange={(e) => setNotes(e.target.value)}
                    placeholder="Add notes for this bulk receive operation..."
                    rows={3}
                  />
                </div>

                <div className="flex items-center justify-between p-4 border rounded-lg">
                  <div className="space-y-0.5">
                    <Label>Force receive</Label>
                    <p className="text-xs text-muted-foreground">
                      Force receive even if some parcels are not scanned
                    </p>
                  </div>
                  <Checkbox
                    checked={forceReceive}
                    onCheckedChange={setForceReceive}
                  />
                </div>

                {stats.unscannedParcels > 0 && !forceReceive && (
                  <Alert color="warning">
                    <Icon
                      icon="heroicons:exclamation-triangle"
                      className="h-4 w-4"
                    />
                    <AlertDescription>
                      {stats.unscannedParcels} parcels across selected slips
                      have not been scanned. Enable "Force receive" to proceed
                      anyway.
                    </AlertDescription>
                  </Alert>
                )}

                <div className="flex gap-2">
                  <Button
                    onClick={() => setShowConfirmDialog(true)}
                    disabled={
                      isProcessing ||
                      (stats.unscannedParcels > 0 && !forceReceive)
                    }
                    className="flex-1"
                  >
                    {isProcessing ? (
                      <Icon
                        icon="heroicons:arrow-path"
                        className="mr-2 h-4 w-4 animate-spin"
                      />
                    ) : (
                      <Icon icon="heroicons:check" className="mr-2 h-4 w-4" />
                    )}
                    Receive {selectedSlips.length} Slip
                    {selectedSlips.length !== 1 ? "s" : ""}
                  </Button>
                  <Button
                    variant="outline"
                    onClick={() => setSelectedSlips([])}
                    disabled={isProcessing}
                  >
                    Clear Selection
                  </Button>
                </div>
              </CardContent>
            </Card>
          )}
        </div>

        {/* Sidebar */}
        <div className="space-y-6">
          {/* Summary */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon
                  icon="heroicons:clipboard-document-list"
                  className="w-5 h-5"
                />
                Summary
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="space-y-3">
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Available slips:
                  </span>
                  <span className="font-medium">{pendingSlips.length}</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Filtered slips:
                  </span>
                  <span className="font-medium">{filteredSlips.length}</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Selected slips:
                  </span>
                  <span className="font-medium text-primary">
                    {selectedSlips.length}
                  </span>
                </div>

                {selectedSlips.length > 0 && (
                  <>
                    <div className="border-t pt-3 space-y-2">
                      <div className="flex justify-between">
                        <span className="text-sm text-muted-foreground">
                          Total parcels:
                        </span>
                        <span className="font-medium">
                          {stats.totalParcels}
                        </span>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-sm text-muted-foreground">
                          Scanned parcels:
                        </span>
                        <span className="font-medium text-green-600">
                          {stats.totalParcels - stats.unscannedParcels}
                        </span>
                      </div>
                      {stats.unscannedParcels > 0 && (
                        <div className="flex justify-between">
                          <span className="text-sm text-muted-foreground">
                            Unscanned parcels:
                          </span>
                          <span className="font-medium text-yellow-600">
                            {stats.unscannedParcels}
                          </span>
                        </div>
                      )}
                      <div className="flex justify-between border-t pt-2">
                        <span className="text-sm text-muted-foreground">
                          Total value:
                        </span>
                        <span className="font-medium">
                          {stats.totalValue.toFixed(2)} DH
                        </span>
                      </div>
                    </div>
                  </>
                )}
              </div>
            </CardContent>
          </Card>

          {/* Quick Stats */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon icon="heroicons:chart-bar" className="w-5 h-5" />
                Quick Stats
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="grid grid-cols-2 gap-4">
                <div className="text-center p-3 bg-blue-50 rounded-lg">
                  <div className="text-2xl font-bold text-blue-600">
                    {pendingSlips.length}
                  </div>
                  <div className="text-xs text-blue-600">Pending</div>
                </div>
                <div className="text-center p-3 bg-green-50 rounded-lg">
                  <div className="text-2xl font-bold text-green-600">
                    {pendingSlips.reduce(
                      (sum, slip) => sum + slip.summary.totalParcels,
                      0
                    )}
                  </div>
                  <div className="text-xs text-green-600">Total Parcels</div>
                </div>
              </div>

              <div className="space-y-2">
                <div className="flex justify-between text-sm">
                  <span>Ready to receive:</span>
                  <span className="font-medium">
                    {
                      pendingSlips.filter(
                        (slip) => slip.summary.unscannedParcels === 0
                      ).length
                    }
                  </span>
                </div>
                <div className="flex justify-between text-sm">
                  <span>Need scanning:</span>
                  <span className="font-medium">
                    {
                      pendingSlips.filter(
                        (slip) => slip.summary.unscannedParcels > 0
                      ).length
                    }
                  </span>
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Quick Actions */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon icon="heroicons:bolt" className="w-5 h-5" />
                Quick Actions
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-2">
              <Link href="/delivery-slips/scan">
                <Button variant="outline" className="w-full">
                  <Icon icon="heroicons:qr-code" className="w-4 h-4 mr-2" />
                  Scanner Interface
                </Button>
              </Link>

              <Link href="/delivery-slips/create">
                <Button variant="outline" className="w-full">
                  <Icon icon="heroicons:plus" className="w-4 h-4 mr-2" />
                  Create New Slip
                </Button>
              </Link>

              <Link href="/delivery-slips">
                <Button variant="outline" className="w-full">
                  <Icon icon="heroicons:list-bullet" className="w-4 h-4 mr-2" />
                  All Delivery Slips
                </Button>
              </Link>

              <Button
                variant="outline"
                className="w-full"
                onClick={() => {
                  setSelectedSlips([]);
                  setSearchTerm("");
                  setFilterCity("all");
                  setNotes("");
                  setForceReceive(false);
                }}
              >
                <Icon icon="heroicons:arrow-path" className="w-4 h-4 mr-2" />
                Reset All Filters
              </Button>
            </CardContent>
          </Card>

          {/* Help */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon
                  icon="heroicons:question-mark-circle"
                  className="w-5 h-5"
                />
                Help
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-3">
              <div className="text-sm space-y-2">
                <p className="font-medium">Bulk Receive Process:</p>
                <ul className="text-muted-foreground space-y-1 text-xs">
                  <li>1. Filter and select delivery slips</li>
                  <li>2. Review unscanned parcels</li>
                  <li>3. Enable force receive if needed</li>
                  <li>4. Add notes and confirm operation</li>
                </ul>
              </div>
              <div className="text-sm space-y-2">
                <p className="font-medium">Best Practices:</p>
                <ul className="text-muted-foreground space-y-1 text-xs">
                  <li> Scan all parcels before receiving</li>
                  <li> Use force receive only when necessary</li>
                  <li> Add meaningful notes for tracking</li>
                </ul>
              </div>
            </CardContent>
          </Card>
        </div>
      </div>

      {/* Confirmation Dialog */}
      <AlertDialog open={showConfirmDialog} onOpenChange={setShowConfirmDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Confirm Bulk Receive</AlertDialogTitle>
            <AlertDialogDescription>
              You are about to mark {selectedSlips.length} delivery slip
              {selectedSlips.length !== 1 ? "s" : ""} as received. This will
              affect {stats.totalParcels} parcel
              {stats.totalParcels !== 1 ? "s" : ""} with a total value of{" "}
              {stats.totalValue.toFixed(2)} DH.
              {stats.unscannedParcels > 0 && (
                <div className="mt-3 p-3 bg-yellow-50 border border-yellow-200 rounded">
                  <p className="text-sm text-yellow-800">
                    <strong>Warning:</strong> {stats.unscannedParcels} parcels
                    have not been scanned yet. They will be automatically marked
                    as scanned.
                  </p>
                </div>
              )}
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={isProcessing}>
              Cancel
            </AlertDialogCancel>
            <AlertDialogAction
              onClick={handleBulkReceive}
              disabled={isProcessing}
            >
              {isProcessing && (
                <Icon
                  icon="heroicons:arrow-path"
                  className="mr-2 h-4 w-4 animate-spin"
                />
              )}
              Confirm Receive
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
};
// Main component wrapped with ProtectedRoute
const BulkReceiveDeliverySlipsPage = () => {
  return (
    <ProtectedRoute
      requiredPermissions={[
        PARCELS_PERMISSIONS.DELIVERY_SLIPS_RECEIVE,
        PARCELS_PERMISSIONS.DELIVERY_SLIPS_BULK,
      ]}
      requiredAccessLevel="LIMITED"
      allowedAccountStatuses={["ACTIVE"]}
    >
      <BulkReceiveDeliverySlipsPageContent />
    </ProtectedRoute>
  );
};
export default BulkReceiveDeliverySlipsPage;
-----------------------------------------------------------------------
--++--> app/[locale]/(protected)/delivery-slips/scan/page.tsx =======>
-----------------------------------------------------------------------
"use client";
import React, { useState, useEffect, useRef } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Badge } from "@/components/ui/badge";
import { Icon } from "@/components/ui/icon";
import { Alert, AlertDescription } from "@/components/ui/alert";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
} from "@/components/ui/dialog";
import { Link } from "@/i18n/routing";
import { useDeliverySlipsStore } from "@/lib/stores/parcels/delivery-slips.store";
import { useAuthStore } from "@/lib/stores/auth/auth.store";
import { ProtectedRoute } from "@/components/route/protected-route";
import { PARCELS_PERMISSIONS } from "@/lib/constants/parcels";
import { DeliverySlipStatus } from "@/lib/types/parcels/delivery-slips.types";
import { toast } from "sonner";
import { cn } from "@/lib/utils/ui.utils";
interface ScanResult {
  success: boolean;
  code: string;
  parcelDetails?: any;
  message?: string;
  error?: string;
}
interface ScanSession {
  slipId: string | null;
  scannedCodes: string[];
  results: ScanResult[];
  startTime: Date;
}
const ScannerDeliverySlipsPageContent = () => {
  const { hasPermission } = useAuthStore();
  const {
    deliverySlips,
    currentDeliverySlip,
    fetchDeliverySlips,
    fetchDeliverySlipById,
    scanParcelIntoSlip,
    addParcelsToSlip,
  } = useDeliverySlipsStore();

  const [scanInput, setScanInput] = useState("");
  const [selectedSlipId, setSelectedSlipId] = useState<string>("");
  const [scanSession, setScanSession] = useState<ScanSession>({
    slipId: null,
    scannedCodes: [],
    results: [],
    startTime: new Date(),
  });
  const [isScanning, setIsScanning] = useState(false);
  const [showCamera, setShowCamera] = useState(false);
  const [cameraError, setCameraError] = useState<string>("");
  const [lastScanResult, setLastScanResult] = useState<ScanResult | null>(null);

  const scanInputRef = useRef<HTMLInputElement>(null);
  const videoRef = useRef<HTMLVideoElement>(null);
  const streamRef = useRef<MediaStream | null>(null);

  const canScanSlips = hasPermission(PARCELS_PERMISSIONS.DELIVERY_SLIPS_SCAN);

  // Load delivery slips on mount
  useEffect(() => {
    if (canScanSlips) {
      fetchDeliverySlips();
    }
  }, [canScanSlips, fetchDeliverySlips]);

  // Auto-focus scan input
  useEffect(() => {
    const focusInput = () => {
      if (scanInputRef.current && !showCamera) {
        scanInputRef.current.focus();
      }
    };

    focusInput();
    const interval = setInterval(focusInput, 1000);
    return () => clearInterval(interval);
  }, [showCamera, selectedSlipId]);

  // Load selected slip details
  useEffect(() => {
    if (selectedSlipId) {
      fetchDeliverySlipById(selectedSlipId);
      setScanSession((prev) => ({
        ...prev,
        slipId: selectedSlipId,
        startTime: new Date(),
      }));
    }
  }, [selectedSlipId, fetchDeliverySlipById]);

  const handleSlipSelection = (slipId: string) => {
    setSelectedSlipId(slipId);
    // Clear previous session data
    setScanSession({
      slipId,
      scannedCodes: [],
      results: [],
      startTime: new Date(),
    });
    setLastScanResult(null);
  };

  const processScan = async (code: string) => {
    if (!code.trim() || !selectedSlipId) return;

    // Check if already scanned
    if (scanSession.scannedCodes.includes(code)) {
      toast.warning("This parcel has already been scanned");
      return;
    }

    setIsScanning(true);

    try {
      // First, try to add the parcel to the slip
      const success = await addParcelsToSlip(selectedSlipId, {
        parcelIds: [code], // Assuming code can be used as ID or needs validation
        markAsScanned: true,
        comment: "Scanned via scanner interface",
      });

      const result: ScanResult = {
        success,
        code,
        message: success ? "Parcel added successfully" : "Failed to add parcel",
        error: success ? undefined : "Parcel not found or invalid",
      };

      // Update session
      setScanSession((prev) => ({
        ...prev,
        scannedCodes: [...prev.scannedCodes, code],
        results: [result, ...prev.results],
      }));

      setLastScanResult(result);

      if (success) {
        toast.success(`Parcel ${code} scanned successfully`);
        // Refresh slip data
        fetchDeliverySlipById(selectedSlipId);
      } else {
        toast.error(`Failed to scan parcel ${code}`);
      }
    } catch (error) {
      const result: ScanResult = {
        success: false,
        code,
        error: error instanceof Error ? error.message : "Unknown error",
      };

      setScanSession((prev) => ({
        ...prev,
        scannedCodes: [...prev.scannedCodes, code],
        results: [result, ...prev.results],
      }));

      setLastScanResult(result);
      toast.error(`Error scanning ${code}: ${result.error}`);
    } finally {
      setIsScanning(false);
      setScanInput("");
    }
  };

  const handleManualScan = (e: React.FormEvent) => {
    e.preventDefault();
    if (scanInput.trim()) {
      processScan(scanInput.trim());
    }
  };

  const handleKeyPress = (e: React.KeyboardEvent) => {
    if (e.key === "Enter") {
      e.preventDefault();
      if (scanInput.trim()) {
        processScan(scanInput.trim());
      }
    }
  };

  const startCamera = async () => {
    try {
      setCameraError("");
      const stream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: "environment", // Use back camera on mobile
          width: { ideal: 1280 },
          height: { ideal: 720 },
        },
      });

      if (videoRef.current) {
        videoRef.current.srcObject = stream;
        streamRef.current = stream;
      }
      setShowCamera(true);
    } catch (error) {
      console.error("Camera access error:", error);
      setCameraError("Unable to access camera. Please check permissions.");
      setShowCamera(false);
    }
  };

  const stopCamera = () => {
    if (streamRef.current) {
      streamRef.current.getTracks().forEach((track) => track.stop());
      streamRef.current = null;
    }
    setShowCamera(false);
  };

  const resetSession = () => {
    setScanSession({
      slipId: selectedSlipId,
      scannedCodes: [],
      results: [],
      startTime: new Date(),
    });
    setLastScanResult(null);
    setScanInput("");
  };

  if (!canScanSlips) {
    return (
      <div className="container mx-auto py-8">
        <Alert color="destructive">
          <Icon icon="heroicons:exclamation-triangle" className="h-4 w-4" />
          <AlertDescription>
            You don't have permission to scan delivery slips. Please contact
            your administrator.
          </AlertDescription>
        </Alert>
      </div>
    );
  }

  const pendingSlips = deliverySlips.filter(
    (slip) => slip.status === DeliverySlipStatus.PENDING
  );

  return (
    <div className="container mx-auto py-6 space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-default-900">
            Delivery Slip Scanner
          </h1>
          <p className="text-default-600">
            Scan parcels into delivery slips using barcode or QR codes
          </p>
        </div>
        <Link href="/delivery-slips">
          <Button variant="outline">
            <Icon icon="heroicons:arrow-left" className="w-4 h-4 mr-2" />
            Back to Delivery Slips
          </Button>
        </Link>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Main Scanner */}
        <div className="lg:col-span-2 space-y-6">
          {/* Slip Selection */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon icon="heroicons:document-text" className="w-5 h-5" />
                Select Delivery Slip
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="space-y-2">
                <Label>Choose delivery slip to scan into:</Label>
                <Select
                  value={selectedSlipId}
                  onValueChange={handleSlipSelection}
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Select a delivery slip" />
                  </SelectTrigger>
                  <SelectContent>
                    {pendingSlips.map((slip) => (
                      <SelectItem key={slip.id} value={slip.id}>
                        <div className="flex items-center gap-2">
                          <span>{slip.reference}</span>
                          <Badge color="primary" className="text-xs">
                            {slip.summary.totalParcels} parcels
                          </Badge>
                          {slip.city && (
                            <Badge color="secondary" className="text-xs">
                              {slip.city.name}
                            </Badge>
                          )}
                        </div>
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>

              {pendingSlips.length === 0 && (
                <Alert color="warning">
                  <Icon
                    icon="heroicons:exclamation-triangle"
                    className="h-4 w-4"
                  />
                  <AlertDescription>
                    No pending delivery slips found. Create a delivery slip
                    first.
                  </AlertDescription>
                </Alert>
              )}
            </CardContent>
          </Card>

          {/* Scanner Interface */}
          {selectedSlipId && (
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center justify-between">
                  <div className="flex items-center gap-2">
                    <Icon icon="heroicons:qr-code" className="w-5 h-5" />
                    Scanner Interface
                  </div>
                  <div className="flex gap-2">
                    {!showCamera && (
                      <Button size="sm" variant="outline" onClick={startCamera}>
                        <Icon
                          icon="heroicons:camera"
                          className="w-4 h-4 mr-2"
                        />
                        Use Camera
                      </Button>
                    )}
                    {scanSession.results.length > 0 && (
                      <Button
                        size="sm"
                        variant="outline"
                        onClick={resetSession}
                      >
                        <Icon
                          icon="heroicons:arrow-path"
                          className="w-4 h-4 mr-2"
                        />
                        Reset Session
                      </Button>
                    )}
                  </div>
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                {/* Manual Input */}
                <div className="space-y-2">
                  <Label>Manual scan or barcode input:</Label>
                  <form onSubmit={handleManualScan} className="flex gap-2">
                    <Input
                      ref={scanInputRef}
                      value={scanInput}
                      onChange={(e) => setScanInput(e.target.value)}
                      onKeyPress={handleKeyPress}
                      placeholder="Click here before scanning or type parcel code..."
                      className="flex-1 font-mono"
                      disabled={isScanning}
                      autoComplete="off"
                    />
                    <Button
                      type="submit"
                      disabled={!scanInput.trim() || isScanning}
                    >
                      {isScanning ? (
                        <Icon
                          icon="heroicons:arrow-path"
                          className="w-4 h-4 animate-spin"
                        />
                      ) : (
                        <Icon icon="heroicons:plus" className="w-4 h-4" />
                      )}
                    </Button>
                  </form>
                </div>

                {/* Last Scan Result */}
                {lastScanResult && (
                  <Alert
                    color={lastScanResult.success ? "success" : "destructive"}
                  >
                    <Icon
                      icon={
                        lastScanResult.success
                          ? "heroicons:check-circle"
                          : "heroicons:x-circle"
                      }
                      className="h-4 w-4"
                    />
                    <AlertDescription>
                      <strong>{lastScanResult.code}:</strong>{" "}
                      {lastScanResult.message || lastScanResult.error}
                    </AlertDescription>
                  </Alert>
                )}

                {/* Instructions */}
                <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
                  <h4 className="font-medium text-blue-900 mb-2">
                    Scanning Instructions:
                  </h4>
                  <ul className="text-sm text-blue-800 space-y-1">
                    <li> Click in the input field above before scanning</li>
                    <li> Use a barcode scanner/gun to scan parcel codes</li>
                    <li> Or click &quot;Use Camera&quot; for mobile/webcam scanning</li>
                    <li> Press Enter or click + to manually add codes</li>
                    <li>
                       Scanned parcels will be automatically added to the slip
                    </li>
                  </ul>
                </div>
              </CardContent>
            </Card>
          )}

          {/* Scan Results */}
          {scanSession.results.length > 0 && (
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:list-bullet" className="w-5 h-5" />
                  Scan Results ({scanSession.results.length})
                </CardTitle>
              </CardHeader>
              <CardContent>
                <div className="space-y-2 max-h-64 overflow-y-auto">
                  {scanSession.results.map((result, index) => (
                    <div
                      key={index}
                      className={cn(
                        "flex items-center justify-between p-3 border rounded-lg",
                        result.success
                          ? "bg-green-50 border-green-200"
                          : "bg-red-50 border-red-200"
                      )}
                    >
                      <div className="flex items-center gap-3">
                        <Icon
                          icon={
                            result.success
                              ? "heroicons:check-circle"
                              : "heroicons:x-circle"
                          }
                          className={cn(
                            "w-5 h-5",
                            result.success ? "text-green-600" : "text-red-600"
                          )}
                        />
                        <div>
                          <code className="text-sm font-medium">
                            {result.code}
                          </code>
                          {result.parcelDetails && (
                            <div className="text-xs text-muted-foreground">
                              {result.parcelDetails.recipientName}
                            </div>
                          )}
                        </div>
                      </div>
                      <div className="text-xs text-muted-foreground">
                        {result.success ? result.message : result.error}
                      </div>
                    </div>
                  ))}
                </div>
              </CardContent>
            </Card>
          )}
        </div>

        {/* Sidebar */}
        <div className="space-y-6">
          {/* Current Slip Info */}
          {currentDeliverySlip && selectedSlipId === currentDeliverySlip.id && (
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:document-text" className="w-5 h-5" />
                  Current Slip
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="space-y-2">
                  <div className="flex justify-between text-sm">
                    <span>Reference:</span>
                    <code className="font-medium">
                      {currentDeliverySlip.reference}
                    </code>
                  </div>
                  <div className="flex justify-between text-sm">
                    <span>Total parcels:</span>
                    <span className="font-medium">
                      {currentDeliverySlip.summary.totalParcels}
                    </span>
                  </div>
                  <div className="flex justify-between text-sm">
                    <span>Scanned:</span>
                    <span className="font-medium text-green-600">
                      {currentDeliverySlip.summary.scannedParcels}
                    </span>
                  </div>
                  <div className="flex justify-between text-sm">
                    <span>Pending:</span>
                    <span className="font-medium text-yellow-600">
                      {currentDeliverySlip.summary.unscannedParcels}
                    </span>
                  </div>
                  <div className="flex justify-between text-sm border-t pt-2">
                    <span>Total value:</span>
                    <span className="font-medium">
                      {currentDeliverySlip.summary.totalValue.toFixed(2)} DH
                    </span>
                  </div>
                </div>

                {/* Progress */}
                <div className="space-y-2">
                  <div className="flex justify-between text-sm">
                    <span>Progress</span>
                    <span>
                      {Math.round(
                        (currentDeliverySlip.summary.scannedParcels /
                          currentDeliverySlip.summary.totalParcels) *
                          100
                      )}
                      %
                    </span>
                  </div>
                  <div className="w-full bg-gray-200 rounded-full h-2">
                    <div
                      className="bg-primary h-2 rounded-full"
                      style={{
                        width: `${
                          (currentDeliverySlip.summary.scannedParcels /
                            currentDeliverySlip.summary.totalParcels) *
                          100
                        }%`,
                      }}
                    />
                  </div>
                </div>
              </CardContent>
            </Card>
          )}

          {/* Session Stats */}
          {scanSession.results.length > 0 && (
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center gap-2">
                  <Icon icon="heroicons:chart-bar" className="w-5 h-5" />
                  Session Stats
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="space-y-2">
                  <div className="flex justify-between text-sm">
                    <span>Scans attempted:</span>
                    <span className="font-medium">
                      {scanSession.results.length}
                    </span>
                  </div>
                  <div className="flex justify-between text-sm">
                    <span>Successful:</span>
                    <span className="font-medium text-green-600">
                      {scanSession.results.filter((r) => r.success).length}
                    </span>
                  </div>
                  <div className="flex justify-between text-sm">
                    <span>Failed:</span>
                    <span className="font-medium text-red-600">
                      {scanSession.results.filter((r) => !r.success).length}
                    </span>
                  </div>
                  <div className="flex justify-between text-sm">
                    <span>Success rate:</span>
                    <span className="font-medium">
                      {scanSession.results.length > 0
                        ? Math.round(
                            (scanSession.results.filter((r) => r.success)
                              .length /
                              scanSession.results.length) *
                              100
                          )
                        : 0}
                      %
                    </span>
                  </div>
                </div>
              </CardContent>
            </Card>
          )}

          {/* Quick Actions */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <Icon icon="heroicons:bolt" className="w-5 h-5" />
                Quick Actions
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-2">
              <Link href="/delivery-slips/create">
                <Button variant="outline" className="w-full">
                  <Icon icon="heroicons:plus" className="w-4 h-4 mr-2" />
                  Create New Slip
                </Button>
              </Link>

              {selectedSlipId && (
                <Link href={`/delivery-slips/${selectedSlipId}`}>
                  <Button variant="outline" className="w-full">
                    <Icon icon="heroicons:eye" className="w-4 h-4 mr-2" />
                    View Slip Details
                  </Button>
                </Link>
              )}

              <Link href="/delivery-slips">
                <Button variant="outline" className="w-full">
                  <Icon icon="heroicons:list-bullet" className="w-4 h-4 mr-2" />
                  All Delivery Slips
                </Button>
              </Link>
            </CardContent>
          </Card>
        </div>
      </div>

      {/* Camera Modal */}
      <Dialog open={showCamera} onOpenChange={stopCamera}>
        <DialogContent className="max-w-2xl">
          <DialogHeader>
            <DialogTitle>Camera Scanner</DialogTitle>
            <DialogDescription>
              Position the barcode or QR code within the camera frame
            </DialogDescription>
          </DialogHeader>
          <div className="space-y-4">
            {cameraError ? (
              <Alert color="destructive">
                <Icon
                  icon="heroicons:exclamation-triangle"
                  className="h-4 w-4"
                />
                <AlertDescription>{cameraError}</AlertDescription>
              </Alert>
            ) : (
              <div className="relative">
                <video
                  ref={videoRef}
                  autoPlay
                  playsInline
                  className="w-full h-64 bg-black rounded-lg"
                />
                {/* Overlay for scan area */}
                <div className="absolute inset-0 border-2 border-primary border-dashed rounded-lg opacity-50 pointer-events-none" />
              </div>
            )}
            <div className="flex justify-end gap-2">
              <Button variant="outline" onClick={stopCamera}>
                Close Camera
              </Button>
            </div>
          </div>
        </DialogContent>
      </Dialog>
    </div>
  );
};
// Main component wrapped with ProtectedRoute
const ScannerDeliverySlipsPage = () => {
  return (
    <ProtectedRoute
      requiredPermissions={[PARCELS_PERMISSIONS.DELIVERY_SLIPS_SCAN]}
      requiredAccessLevel="LIMITED"
      allowedAccountStatuses={["ACTIVE"]}
    >
      <ScannerDeliverySlipsPageContent />
    </ProtectedRoute>
  );
};
export default ScannerDeliverySlipsPage;
-----------------------------------------------------------------------
--++--> app/[locale]/[...not-found]/page.tsx
--++--> app/[locale]/auth/forgot-password/page.tsx
--++--> app/[locale]/auth/login/page.tsx
--++--> app/[locale]/auth/register/page.tsx
--++--> app/[locale]/auth/reset-password/page.tsx
-----------------------------------------------------------------------
Components Folder:
-----------------------------------------------------------------------
--++--> components/route/protected-route.tsx =======>
-----------------------------------------------------------------------
"use client";
import { useEffect, useState, useRef, useMemo, useCallback } from "react";
import { useRouter, usePathname } from "next/navigation";
import { useAuthStore } from "@/lib/stores/auth/auth.store";
import { useTenantStore } from "@/lib/stores/auth/tenant.store";
import { toast } from "sonner";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Button } from "@/components/ui/button";
import {
  AlertCircle,
  Info,
  CheckCircle,
  Clock,
  Shield,
  UserX,
} from "lucide-react";
interface ProtectedRouteProps {
  children: React.ReactNode;
  requiredRoles?: string[];
  requiredPermissions?: string[];
  requiredUserTypes?: string[]; // Added this line
  requiredAccessLevel?: "NO_ACCESS" | "PROFILE_ONLY" | "LIMITED" | "FULL";
  allowedAccountStatuses?: string[];
  requireValidation?: boolean;
}
interface AccessResult {
  allowed: boolean;
  reason?: string;
  redirectTo?: string;
  showMessage?: boolean;
  messageType?: "info" | "warning" | "error";
}
// Constants
const ACCESS_LEVELS = ["NO_ACCESS", "PROFILE_ONLY", "LIMITED", "FULL"] as const;
const STATUS_CONFIGS = {
  PENDING: {
    icon: Clock,
    color: "text-blue-600",
    message:
      "Your account is pending admin approval. You'll receive an email notification once approved.",
    action: null,
  },
  INACTIVE: {
    icon: Info,
    color: "text-orange-600",
    message:
      "Please complete your profile information to activate your account.",
    action: { label: "Complete Profile", path: "/profile/complete" },
  },
  PENDING_VALIDATION: {
    icon: Shield,
    color: "text-yellow-600",
    message:
      "Your profile is under review. You have limited access until validation is complete.",
    action: null,
  },
  ACTIVE: {
    icon: CheckCircle,
    color: "text-green-600",
    message: "Your account is fully active and validated.",
    action: null,
  },
  REJECTED: {
    icon: UserX,
    color: "text-red-600",
    message:
      "Your account has been rejected. Please contact support for assistance.",
    action: { label: "Contact Support", path: "/contact" },
  },
  SUSPENDED: {
    icon: UserX,
    color: "text-red-600",
    message: "Your account has been suspended. Please contact support.",
    action: { label: "Contact Support", path: "/contact" },
  },
} as const;
const BLOCKED_REASONS = {
  PENDING: "Your account is pending admin approval",
  REJECTED: "Your account has been rejected. Please contact support",
  SUSPENDED: "Your account has been suspended. Please contact support",
} as const;
export function ProtectedRoute({
  children,
  requiredRoles = [],
  requiredPermissions = [],
  requiredUserTypes = [], // Added this line
  requiredAccessLevel,
  allowedAccountStatuses = [],
  requireValidation = false,
}: ProtectedRouteProps) {
  const router = useRouter();
  const pathname = usePathname();
  const [isInitialized, setIsInitialized] = useState(false);
  const [accessResult, setAccessResult] = useState<AccessResult>({
    allowed: false,
  });
  const initRef = useRef(false);
  const lastCheckRef = useRef<string>("");

  // Stable selectors to prevent unnecessary re-renders
  const isAuthenticated = useAuthStore((state) => state.isAuthenticated);
  const isLoading = useAuthStore((state) => state.isLoading);
  const user = useAuthStore((state) => state.user);
  const error = useAuthStore((state) => state.error);
  const isCheckingAuth = useAuthStore((state) => state.isCheckingAuth);
  const accountStatus = useAuthStore((state) => state.accountStatus);
  const validationStatus = useAuthStore((state) => state.validationStatus);
  const accessLevel = useAuthStore((state) => state.accessLevel);
  const requirements = useAuthStore((state) => state.requirements);
  const hasBlueCheckmark = useAuthStore((state) => state.hasBlueCheckmark);

  // Stable method references
  const checkAuth = useAuthStore((state) => state.checkAuth);
  const isAccountBlocked = useAuthStore((state) => state.isAccountBlocked);
  const needsProfileCompletion = useAuthStore(
    (state) => state.needsProfileCompletion
  );
  const needsValidation = useAuthStore((state) => state.needsValidation);
  const hasRole = useAuthStore((state) => state.hasRole);
  const hasAnyPermission = useAuthStore((state) => state.hasAnyPermission);
  const hasUserType = useAuthStore((state) => state.hasUserType); // Added this line

  const { fetchCurrentTenant, currentTenant } = useTenantStore();

  // Stable access check function with useCallback
  const checkAccess = useCallback((): AccessResult => {
    // Not authenticated
    if (!isAuthenticated || !user) {
      return {
        allowed: false,
        redirectTo: "/auth/login",
        reason: "Authentication required",
      };
    }

    // Account blocked scenarios
    if (isAccountBlocked()) {
      const status = accountStatus;
      const reason = status
        ? BLOCKED_REASONS[status as keyof typeof BLOCKED_REASONS]
        : "Access denied";
      const messageType = status === "PENDING" ? "info" : "error";

      return {
        allowed: false,
        redirectTo: "/auth/login",
        reason,
        showMessage: true,
        messageType,
      };
    }

    // Profile completion check
    if (needsProfileCompletion()) {
      if (
        pathname.includes("/profile/complete") ||
        pathname.includes("/auth")
      ) {
        return { allowed: true };
      }

      return {
        allowed: false,
        redirectTo: "/profile/complete",
        reason: "Please complete your profile to continue",
        showMessage: true,
        messageType: "info",
      };
    }

    // Access level check
    if (requiredAccessLevel) {
      const requiredIndex = ACCESS_LEVELS.indexOf(requiredAccessLevel);
      const currentIndex = ACCESS_LEVELS.indexOf(accessLevel || "NO_ACCESS");

      if (currentIndex < requiredIndex) {
        const isValidationRequired =
          requiredAccessLevel === "FULL" && needsValidation();
        const reason = isValidationRequired
          ? "This feature requires profile validation"
          : "Insufficient access level";

        return {
          allowed: false,
          redirectTo: "/dashboard",
          reason,
          showMessage: true,
          messageType: "warning",
        };
      }
    }

    // Account status check
    if (allowedAccountStatuses.length > 0 && accountStatus) {
      if (!allowedAccountStatuses.includes(accountStatus)) {
        return {
          allowed: false,
          redirectTo: "/dashboard",
          reason: "Your account status does not allow access to this feature",
          showMessage: true,
          messageType: "warning",
        };
      }
    }

    // Validation requirement check
    if (requireValidation && validationStatus !== "VALIDATED") {
      return {
        allowed: false,
        redirectTo: "/dashboard",
        reason: "This feature requires a validated account",
        showMessage: true,
        messageType: "warning",
      };
    }

    // User type check (Added this section)
    if (requiredUserTypes.length > 0) {
      const hasRequiredUserType = requiredUserTypes.some(
        (userType) => user.userType === userType
      );
      if (!hasRequiredUserType) {
        return {
          allowed: false,
          redirectTo: "/unauthorized",
          reason: "Access restricted to specific user types",
          showMessage: true,
          messageType: "error",
        };
      }
    }

    // Role check
    if (requiredRoles.length > 0) {
      const hasRequiredRole = requiredRoles.some((role) => hasRole(role));
      if (!hasRequiredRole) {
        return {
          allowed: false,
          redirectTo: "/unauthorized",
          reason: "Insufficient role permissions",
          showMessage: true,
          messageType: "error",
        };
      }
    }

    // Permission check
    if (requiredPermissions.length > 0) {
      const hasRequiredPermissions = hasAnyPermission(requiredPermissions);
      if (!hasRequiredPermissions) {
        return {
          allowed: false,
          redirectTo: "/unauthorized",
          reason: "Insufficient permissions",
          showMessage: true,
          messageType: "error",
        };
      }
    }

    return { allowed: true };
  }, [
    isAuthenticated,
    user,
    isAccountBlocked,
    accountStatus,
    needsProfileCompletion,
    pathname,
    accessLevel,
    requiredAccessLevel,
    needsValidation,
    allowedAccountStatuses,
    requireValidation,
    validationStatus,
    requiredUserTypes, // Added this line
    requiredRoles,
    hasRole,
    requiredPermissions,
    hasAnyPermission,
  ]);

  // Create a unique key for the current state to prevent unnecessary re-checks
  const stateKey = useMemo(() => {
    return [
      isAuthenticated,
      user?.id,
      user?.userType, // Added this line
      accountStatus,
      validationStatus,
      accessLevel,
      pathname,
      requiredAccessLevel,
      JSON.stringify(allowedAccountStatuses),
      requireValidation,
      JSON.stringify(requiredUserTypes), // Added this line
      JSON.stringify(requiredRoles),
      JSON.stringify(requiredPermissions),
    ].join("|");
  }, [
    isAuthenticated,
    user?.id,
    user?.userType, // Added this line
    accountStatus,
    validationStatus,
    accessLevel,
    pathname,
    requiredAccessLevel,
    allowedAccountStatuses,
    requireValidation,
    requiredUserTypes, // Added this line
    requiredRoles,
    requiredPermissions,
  ]);

  // Initialize authentication - only once
  useEffect(() => {
    if (initRef.current) return;
    initRef.current = true;

    const initialize = async () => {
      try {
        if (!isCheckingAuth) {
          await checkAuth();
        }

        // Fetch tenant data if authenticated and not loaded
        if (isAuthenticated && user && !currentTenant) {
          await fetchCurrentTenant().catch(console.error);
        }
      } catch (error) {
        console.error("Auth initialization failed:", error);
      } finally {
        setIsInitialized(true);
      }
    };

    initialize();
  }, []); // Empty dependency array - only run once

  // Check access when state changes
  useEffect(() => {
    if (!isInitialized || isLoading || isCheckingAuth) return;

    // Prevent unnecessary re-checks
    if (lastCheckRef.current === stateKey) return;
    lastCheckRef.current = stateKey;

    const result = checkAccess();
    setAccessResult(result);
  }, [isInitialized, isLoading, isCheckingAuth, stateKey, checkAccess]);

  // Handle redirects and messages - separate effect to prevent loops
  useEffect(() => {
    if (!isInitialized || isLoading || isCheckingAuth || accessResult.allowed) {
      return;
    }

    // Only show message and redirect if we have a valid access result
    if (accessResult.reason) {
      if (accessResult.showMessage) {
        const toastFn = {
          error: toast.error,
          warning: toast.warning,
          info: toast.info,
        }[accessResult.messageType || "info"];

        toastFn(accessResult.reason);
      }

      if (accessResult.redirectTo) {
        router.replace(accessResult.redirectTo);
      }
    }
  }, [
    accessResult.allowed,
    accessResult.reason,
    accessResult.redirectTo,
    accessResult.showMessage,
    accessResult.messageType,
    isInitialized,
    isLoading,
    isCheckingAuth,
    router,
  ]);

  // Loading state
  if (!isInitialized || isLoading || isCheckingAuth) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center space-y-4">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto" />
          <p className="text-muted-foreground">Initializing...</p>
        </div>
      </div>
    );
  }

  // Error state
  if (error) {
    return (
      <div className="flex items-center justify-center min-h-screen p-4">
        <div className="max-w-md w-full space-y-6 text-center">
          <Alert variant="outline">
            <AlertCircle className="h-4 w-4" />
            <AlertDescription>
              <div className="font-medium">Authentication Error</div>
              <div className="text-sm mt-1">{error}</div>
            </AlertDescription>
          </Alert>
          <Button
            onClick={() => {
              initRef.current = false;
              window.location.reload();
            }}
            className="w-full"
          >
            Retry
          </Button>
        </div>
      </div>
    );
  }

  // Access denied state
  if (!accessResult.allowed) {
    const statusConfig = accountStatus
      ? STATUS_CONFIGS[accountStatus as keyof typeof STATUS_CONFIGS]
      : null;

    const IconComponent = statusConfig?.icon || AlertCircle;

    return (
      <div className="flex items-center justify-center min-h-screen p-4">
        <div className="max-w-md w-full space-y-6 text-center">
          <div className="flex justify-center">
            <div className="rounded-full bg-default-100 p-3">
              <IconComponent
                className={`h-12 w-12 ${
                  statusConfig?.color || "text-gray-600"
                }`}
              />
            </div>
          </div>

          <div className="space-y-3">
            <h3 className="text-xl font-semibold text-default-900">
              Access Status
            </h3>
            <p className="text-sm text-default-600 leading-relaxed">
              {statusConfig?.message || accessResult.reason || "Access denied"}
            </p>

            {hasBlueCheckmark && (
              <div className="flex items-center justify-center gap-2 text-sm text-green-600">
                <CheckCircle className="h-4 w-4" />
                Verified Account
              </div>
            )}

            {requirements.length > 0 && (
              <div className="text-left">
                <div className="text-sm font-medium text-default-700 mb-2">
                  Requirements:
                </div>
                <ul className="text-xs text-default-600 space-y-1">
                  {requirements.map((req, index) => (
                    <li key={index} className="flex items-center gap-2">
                      <div className="w-1.5 h-1.5 rounded-full bg-default-400" />
                      {req}
                    </li>
                  ))}
                </ul>
              </div>
            )}
          </div>

          <div className="space-y-3">
            {statusConfig?.action && (
              <Button
                onClick={() => router.push(statusConfig.action!.path)}
                className="w-full"
              >
                {statusConfig.action.label}
              </Button>
            )}

            <Button
              variant="outline"
              onClick={() => router.push("/auth/login")}
              className="w-full"
            >
              Back to Login
            </Button>
          </div>

          {process.env.NODE_ENV === "development" && (
            <div className="mt-4 p-3 bg-muted rounded-lg text-xs text-left text-muted-foreground">
              <strong>Dev Info:</strong>
              <br />
              <strong>Account Status:</strong> {accountStatus}
              <br />
              <strong>Validation Status:</strong> {validationStatus}
              <br />
              <strong>Access Level:</strong> {accessLevel}
              <br />
              <strong>Required Access:</strong> {requiredAccessLevel || "Any"}
              <br />
              <strong>Required User Types:</strong>{" "}
              {requiredUserTypes.length > 0
                ? requiredUserTypes.join(", ")
                : "Any"}
              <br />
              <strong>Current User Type:</strong> {user?.userType || "None"}
              <br />
              <strong>Reason:</strong> {accessResult.reason}
            </div>
          )}
        </div>
      </div>
    );
  }

  return <>{children}</>;
}
-----------------------------------------------------------------------
--++--> components/users/bulk-actions-bar.tsx =======>
-----------------------------------------------------------------------
"use client";
import React, { useState } from "react";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Icon } from "@/components/ui/icon";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { useDeliverySlipsStore } from "@/lib/stores/parcels/delivery-slips.store";
import { toast } from "sonner";
interface BulkActionsBarProps {
  selectedCount: number;
  onClearSelection: () => void;
}
export const BulkActionsBar: React.FC<BulkActionsBarProps> = ({
  selectedCount,
  onClearSelection,
}) => {
  const { selectedSlipIds, bulkAction } = useDeliverySlipsStore();
  const [showReceiveDialog, setShowReceiveDialog] = useState(false);
  const [showCancelDialog, setShowCancelDialog] = useState(false);
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [isProcessing, setIsProcessing] = useState(false);

  const handleBulkReceive = async () => {
    setIsProcessing(true);
    try {
      const success = await bulkAction({
        slipIds: selectedSlipIds,
        action: "RECEIVE",
        comment: "Bulk received from table actions",
      });

      if (success) {
        setShowReceiveDialog(false);
        onClearSelection();
        toast.success(
          `Successfully received ${selectedSlipIds.length} delivery slips`
        );
      }
    } catch (error) {
      toast.error("Failed to receive delivery slips");
    } finally {
      setIsProcessing(false);
    }
  };

  const handleBulkCancel = async () => {
    setIsProcessing(true);
    try {
      const success = await bulkAction({
        slipIds: selectedSlipIds,
        action: "CANCEL",
        comment: "Bulk cancelled from table actions",
      });

      if (success) {
        setShowCancelDialog(false);
        onClearSelection();
        toast.success(
          `Successfully cancelled ${selectedSlipIds.length} delivery slips`
        );
      }
    } catch (error) {
      toast.error("Failed to cancel delivery slips");
    } finally {
      setIsProcessing(false);
    }
  };

  const handleBulkDelete = async () => {
    setIsProcessing(true);
    try {
      const success = await bulkAction({
        slipIds: selectedSlipIds,
        action: "DELETE",
        comment: "Bulk deleted from table actions",
      });

      if (success) {
        setShowDeleteDialog(false);
        onClearSelection();
        toast.success(
          `Successfully deleted ${selectedSlipIds.length} delivery slips`
        );
      }
    } catch (error) {
      toast.error("Failed to delete delivery slips");
    } finally {
      setIsProcessing(false);
    }
  };

  return (
    <>
      <div className="flex items-center justify-between p-3 bg-primary/5 border border-primary/20 rounded-lg">
        <div className="flex items-center gap-3">
          <Badge color="secondary" className="flex items-center gap-1">
            <Icon icon="heroicons:check-circle" className="w-3 h-3" />
            {selectedCount} selected
          </Badge>
          <span className="text-sm text-muted-foreground">
            Bulk actions available for selected delivery slips
          </span>
        </div>

        <div className="flex items-center gap-2">
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button size="sm" disabled={isProcessing}>
                <Icon
                  icon="heroicons:ellipsis-horizontal"
                  className="w-4 h-4 mr-2"
                />
                Bulk Actions
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              <DropdownMenuItem onClick={() => setShowReceiveDialog(true)}>
                <Icon
                  icon="heroicons:check"
                  className="mr-2 h-4 w-4 text-green-600"
                />
                Mark as Received
              </DropdownMenuItem>

              <DropdownMenuSeparator />

              <DropdownMenuItem onClick={() => setShowCancelDialog(true)}>
                <Icon
                  icon="heroicons:x-circle"
                  className="mr-2 h-4 w-4 text-yellow-600"
                />
                Cancel Slips
              </DropdownMenuItem>

              <DropdownMenuItem onClick={() => setShowDeleteDialog(true)}>
                <Icon
                  icon="heroicons:trash"
                  className="mr-2 h-4 w-4 text-red-600"
                />
                Delete Slips
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>

          <Button
            variant="outline"
            size="sm"
            onClick={onClearSelection}
            disabled={isProcessing}
          >
            Clear Selection
          </Button>
        </div>
      </div>

      {/* Bulk Receive Dialog */}
      <AlertDialog open={showReceiveDialog} onOpenChange={setShowReceiveDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Bulk Mark as Received</AlertDialogTitle>
            <AlertDialogDescription>
              Are you sure you want to mark {selectedCount} delivery slip
              {selectedCount !== 1 ? "s" : ""} as received? This will update the
              status of all parcels in these slips.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={isProcessing}>
              Cancel
            </AlertDialogCancel>
            <AlertDialogAction
              onClick={handleBulkReceive}
              disabled={isProcessing}
            >
              {isProcessing && (
                <Icon
                  icon="heroicons:arrow-path"
                  className="mr-2 h-4 w-4 animate-spin"
                />
              )}
              Mark as Received
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* Bulk Cancel Dialog */}
      <AlertDialog open={showCancelDialog} onOpenChange={setShowCancelDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Bulk Cancel Slips</AlertDialogTitle>
            <AlertDialogDescription>
              Are you sure you want to cancel {selectedCount} delivery slip
              {selectedCount !== 1 ? "s" : ""}? This action will change their
              status to cancelled.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={isProcessing}>
              Cancel
            </AlertDialogCancel>
            <AlertDialogAction
              onClick={handleBulkCancel}
              disabled={isProcessing}
              className="bg-yellow-600 text-white hover:bg-yellow-700"
            >
              {isProcessing && (
                <Icon
                  icon="heroicons:arrow-path"
                  className="mr-2 h-4 w-4 animate-spin"
                />
              )}
              Cancel Slips
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* Bulk Delete Dialog */}
      <AlertDialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Bulk Delete Slips</AlertDialogTitle>
            <AlertDialogDescription>
              Are you sure you want to delete {selectedCount} delivery slip
              {selectedCount !== 1 ? "s" : ""}? This action cannot be undone and
              will reset all parcels back to "NEW_PACKAGE" status.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel disabled={isProcessing}>
              Cancel
            </AlertDialogCancel>
            <AlertDialogAction
              onClick={handleBulkDelete}
              disabled={isProcessing}
              className="bg-red-600 text-white hover:bg-red-700"
            >
              {isProcessing && (
                <Icon
                  icon="heroicons:arrow-path"
                  className="mr-2 h-4 w-4 animate-spin"
                />
              )}
              Delete Slips
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  );
};
-----------------------------------------------------------------------
--++--> components/users/delivery-slips-stats.tsx =======>
-----------------------------------------------------------------------
"use client";
import React from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Icon } from "@/components/ui/icon";
import { DeliverySlipStats } from "@/lib/types/parcels/delivery-slips.types";
interface DeliverySlipsStatsProps {
  statistics: DeliverySlipStats;
}
export const DeliverySlipsStats: React.FC<DeliverySlipsStatsProps> = ({
  statistics,
}) => {
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
      {/* Total Slips */}
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Total Slips</CardTitle>
          <Icon
            icon="heroicons:document-text"
            className="h-4 w-4 text-muted-foreground"
          />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">{statistics.totalSlips}</div>
          <div className="text-xs text-muted-foreground mt-1">
            <span className="text-green-600">
              {statistics.receivedSlips} received
            </span>
            {"  "}
            <span className="text-yellow-600">
              {statistics.pendingSlips} pending
            </span>
            {statistics.cancelledSlips > 0 && (
              <>
                {"  "}
                <span className="text-red-600">
                  {statistics.cancelledSlips} cancelled
                </span>
              </>
            )}
          </div>
        </CardContent>
      </Card>

      {/* Total Parcels */}
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Total Parcels</CardTitle>
          <Icon
            icon="heroicons:cube"
            className="h-4 w-4 text-muted-foreground"
          />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">
            {statistics.totalParcelsInSlips}
          </div>
          <div className="text-xs text-muted-foreground mt-1">
            Avg {statistics.averageParcelsPerSlip.toFixed(1)} per slip
          </div>
        </CardContent>
      </Card>

      {/* Total Value */}
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Total Value</CardTitle>
          <Icon
            icon="heroicons:banknotes"
            className="h-4 w-4 text-muted-foreground"
          />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">
            {statistics.totalValueInSlips.toLocaleString()} DH
          </div>
          <div className="text-xs text-muted-foreground mt-1">
            All delivery slips
          </div>
        </CardContent>
      </Card>

      {/* Processing Rate */}
      <Card>
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="text-sm font-medium">Processing Rate</CardTitle>
          <Icon
            icon="heroicons:chart-bar"
            className="h-4 w-4 text-muted-foreground"
          />
        </CardHeader>
        <CardContent>
          <div className="text-2xl font-bold">
            {statistics.totalSlips > 0
              ? Math.round(
                  (statistics.receivedSlips / statistics.totalSlips) * 100
                )
              : 0}
            %
          </div>
          <div className="text-xs text-muted-foreground mt-1">
            Slips received
          </div>
        </CardContent>
      </Card>

      {/* Recent Activity Chart */}
      {statistics.recentActivity.length > 0 && (
        <Card className="md:col-span-2">
          <CardHeader>
            <CardTitle className="text-sm font-medium flex items-center gap-2">
              <Icon icon="heroicons:chart-line" className="h-4 w-4" />
              Recent Activity (Last 7 Days)
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="space-y-2">
              {statistics.recentActivity.slice(0, 5).map((activity, index) => (
                <div
                  key={index}
                  className="flex items-center justify-between py-1"
                >
                  <div className="text-sm">
                    {new Date(activity.date).toLocaleDateString("en-US", {
                      month: "short",
                      day: "numeric",
                    })}
                  </div>
                  <div className="flex items-center gap-4 text-xs">
                    <div className="flex items-center gap-1">
                      <div className="w-2 h-2 bg-blue-500 rounded-full" />
                      <span>{activity.slipsCreated} created</span>
                    </div>
                    <div className="flex items-center gap-1">
                      <div className="w-2 h-2 bg-green-500 rounded-full" />
                      <span>{activity.slipsReceived} received</span>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </CardContent>
        </Card>
      )}

      {/* Top Cities */}
      {statistics.topCities.length > 0 && (
        <Card className="md:col-span-2">
          <CardHeader>
            <CardTitle className="text-sm font-medium flex items-center gap-2">
              <Icon icon="heroicons:map-pin" className="h-4 w-4" />
              Top Cities
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="space-y-2">
              {statistics.topCities.slice(0, 5).map((city, index) => (
                <div
                  key={index}
                  className="flex items-center justify-between py-1"
                >
                  <div className="flex items-center gap-2">
                    <Badge color="primary" className="text-xs">
                      #{index + 1}
                    </Badge>
                    <span className="text-sm">{city.cityName}</span>
                  </div>
                  <div className="text-xs text-muted-foreground">
                    {city.slipCount} slips  {city.parcelCount} parcels
                  </div>
                </div>
              ))}
            </div>
          </CardContent>
        </Card>
      )}
    </div>
  );
};
-----------------------------------------------------------------------
--++--> components/users/delivery-slips-table.tsx =======>
-----------------------------------------------------------------------
"use client";
import React from "react";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Checkbox } from "@/components/ui/checkbox";
import { Icon } from "@/components/ui/icon";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Link } from "@/i18n/routing";
import { useDeliverySlipsStore } from "@/lib/stores/parcels/delivery-slips.store";
import {
  DeliverySlip,
  DeliverySlipStatus,
} from "@/lib/types/parcels/delivery-slips.types";
import { cn } from "@/lib/utils/ui.utils";
interface DeliverySlipsTableProps {
  deliverySlips: DeliverySlip[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
  isLoading: boolean;
  onPageChange: (page: number) => void;
  canUpdate: boolean;
  canDelete: boolean;
  canBulkActions: boolean;
}
const statusConfig = {
  [DeliverySlipStatus.PENDING]: {
    label: "Pending",
    color: "bg-yellow-100 text-yellow-800",
    icon: "heroicons:clock",
  },
  [DeliverySlipStatus.RECEIVED]: {
    label: "Received",
    color: "bg-green-100 text-green-800",
    icon: "heroicons:check-circle",
  },
  [DeliverySlipStatus.CANCELLED]: {
    label: "Cancelled",
    color: "bg-red-100 text-red-800",
    icon: "heroicons:x-circle",
  },
};
const formatDate = (dateString: string) => {
  return new Date(dateString).toLocaleDateString("en-US", {
    month: "short",
    day: "2-digit",
    year: "numeric",
    hour: "2-digit",
    minute: "2-digit",
  });
};
export const DeliverySlipsTable: React.FC<DeliverySlipsTableProps> = ({
  deliverySlips,
  pagination,
  isLoading,
  onPageChange,
  canUpdate,
  canDelete,
  canBulkActions,
}) => {
  const {
    selectedSlipIds,
    setSelectedSlipIds,
    receiveSlip,
    deleteDeliverySlip,
  } = useDeliverySlipsStore();

  const handleSelectAll = (checked: boolean) => {
    if (checked) {
      setSelectedSlipIds(deliverySlips.map((slip) => slip.id));
    } else {
      setSelectedSlipIds([]);
    }
  };

  const handleSelectSlip = (slipId: string, checked: boolean) => {
    if (checked) {
      setSelectedSlipIds([...selectedSlipIds, slipId]);
    } else {
      setSelectedSlipIds(selectedSlipIds.filter((id) => id !== slipId));
    }
  };

  const handleReceiveSlip = async (slipId: string) => {
    await receiveSlip(slipId, {
      notes: "Marked as received from table action",
    });
  };

  const handleDeleteSlip = async (slipId: string) => {
    if (window.confirm("Are you sure you want to delete this delivery slip?")) {
      await deleteDeliverySlip(slipId);
    }
  };

  if (isLoading) {
    return (
      <div className="p-8">
        <div className="space-y-4">
          {[...Array(5)].map((_, i) => (
            <div key={i} className="h-12 bg-gray-100 rounded animate-pulse" />
          ))}
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-4">
      <div className="overflow-x-auto">
        <Table>
          <TableHeader>
            <TableRow>
              {canBulkActions && (
                <TableHead className="w-12">
                  <Checkbox
                    checked={
                      deliverySlips.length > 0 &&
                      selectedSlipIds.length === deliverySlips.length
                    }
                    onCheckedChange={handleSelectAll}
                  />
                </TableHead>
              )}
              <TableHead>Reference</TableHead>
              <TableHead>Status</TableHead>
              <TableHead>Created</TableHead>
              <TableHead>City</TableHead>
              <TableHead>Parcels</TableHead>
              <TableHead>Progress</TableHead>
              <TableHead>Value</TableHead>
              <TableHead className="text-right">Actions</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {deliverySlips.length === 0 ? (
              <TableRow>
                <TableCell
                  colSpan={canBulkActions ? 9 : 8}
                  className="text-center py-8"
                >
                  <div className="space-y-2">
                    <Icon
                      icon="heroicons:document-text"
                      className="w-12 h-12 text-muted-foreground mx-auto"
                    />
                    <p className="text-muted-foreground">
                      No delivery slips found
                    </p>
                  </div>
                </TableCell>
              </TableRow>
            ) : (
              deliverySlips.map((slip) => {
                const statusInfo = statusConfig[slip.status];
                const canModify = slip.status === DeliverySlipStatus.PENDING;
                const progressPercent =
                  slip.summary.totalParcels > 0
                    ? Math.round(
                        (slip.summary.scannedParcels /
                          slip.summary.totalParcels) *
                          100
                      )
                    : 0;

                return (
                  <TableRow key={slip.id}>
                    {canBulkActions && (
                      <TableCell>
                        <Checkbox
                          checked={selectedSlipIds.includes(slip.id)}
                          onCheckedChange={(checked) =>
                            handleSelectSlip(slip.id, checked as boolean)
                          }
                        />
                      </TableCell>
                    )}
                    <TableCell>
                      <Link
                        href={`/delivery-slips/${slip.id}`}
                        className="hover:underline"
                      >
                        <code className="text-sm font-medium text-primary">
                          {slip.reference}
                        </code>
                      </Link>
                    </TableCell>
                    <TableCell>
                      <Badge className={cn("text-xs", statusInfo.color)}>
                        <Icon icon={statusInfo.icon} className="w-3 h-3 mr-1" />
                        {statusInfo.label}
                      </Badge>
                    </TableCell>
                    <TableCell className="text-sm">
                      {formatDate(slip.createdAt)}
                    </TableCell>
                    <TableCell>
                      {slip.city ? (
                        <Badge color="primary" className="text-xs">
                          {slip.city.name}
                        </Badge>
                      ) : (
                        <span className="text-xs text-muted-foreground">
                          Not specified
                        </span>
                      )}
                    </TableCell>
                    <TableCell>
                      <div className="text-sm">
                        <span className="font-medium">
                          {slip.summary.totalParcels}
                        </span>
                        <span className="text-muted-foreground"> total</span>
                      </div>
                      {slip.summary.scannedParcels > 0 && (
                        <div className="text-xs text-green-600">
                          {slip.summary.scannedParcels} scanned
                        </div>
                      )}
                    </TableCell>
                    <TableCell>
                      <div className="flex items-center gap-2">
                        <div className="w-16 bg-gray-200 rounded-full h-1.5">
                          <div
                            className="bg-primary h-1.5 rounded-full"
                            style={{ width: `${progressPercent}%` }}
                          />
                        </div>
                        <span className="text-xs text-muted-foreground min-w-[35px]">
                          {progressPercent}%
                        </span>
                      </div>
                    </TableCell>
                    <TableCell>
                      <Badge color="primary" className="text-xs">
                        {slip.summary.totalValue.toFixed(2)} DH
                      </Badge>
                    </TableCell>
                    <TableCell className="text-right">
                      <DropdownMenu>
                        <DropdownMenuTrigger asChild>
                          <Button variant="ghost" size="sm">
                            <Icon
                              icon="heroicons:ellipsis-horizontal"
                              className="w-4 h-4"
                            />
                          </Button>
                        </DropdownMenuTrigger>
                        <DropdownMenuContent align="end">
                          <DropdownMenuItem asChild>
                            <Link href={`/delivery-slips/${slip.id}`}>
                              <Icon
                                icon="heroicons:eye"
                                className="mr-2 h-4 w-4"
                              />
                              View Details
                            </Link>
                          </DropdownMenuItem>

                          {canUpdate && canModify && (
                            <DropdownMenuItem asChild>
                              <Link href={`/delivery-slips/${slip.id}/edit`}>
                                <Icon
                                  icon="heroicons:pencil-square"
                                  className="mr-2 h-4 w-4"
                                />
                                Edit Slip
                              </Link>
                            </DropdownMenuItem>
                          )}

                          <DropdownMenuItem asChild>
                            <Link href={`/delivery-slips/${slip.id}/scan`}>
                              <Icon
                                icon="heroicons:qr-code"
                                className="mr-2 h-4 w-4"
                              />
                              Scan Parcels
                            </Link>
                          </DropdownMenuItem>

                          <DropdownMenuSeparator />

                          {canModify && (
                            <DropdownMenuItem
                              onClick={() => handleReceiveSlip(slip.id)}
                            >
                              <Icon
                                icon="heroicons:check"
                                className="mr-2 h-4 w-4 text-green-600"
                              />
                              Mark as Received
                            </DropdownMenuItem>
                          )}

                          <DropdownMenuItem>
                            <Icon
                              icon="heroicons:document-arrow-down"
                              className="mr-2 h-4 w-4"
                            />
                            Download PDF
                          </DropdownMenuItem>

                          <DropdownMenuItem>
                            <Icon
                              icon="heroicons:tag"
                              className="mr-2 h-4 w-4"
                            />
                            Download Labels
                          </DropdownMenuItem>

                          {canDelete && canModify && (
                            <>
                              <DropdownMenuSeparator />
                              <DropdownMenuItem
                                className="text-red-600 focus:text-red-600"
                                onClick={() => handleDeleteSlip(slip.id)}
                              >
                                <Icon
                                  icon="heroicons:trash"
                                  className="mr-2 h-4 w-4"
                                />
                                Delete Slip
                              </DropdownMenuItem>
                            </>
                          )}
                        </DropdownMenuContent>
                      </DropdownMenu>
                    </TableCell>
                  </TableRow>
                );
              })
            )}
          </TableBody>
        </Table>
      </div>

      {/* Pagination */}
      {pagination.totalPages > 1 && (
        <div className="flex items-center justify-between px-4 py-3 border-t">
          <div className="text-sm text-muted-foreground">
            Showing {(pagination.page - 1) * pagination.limit + 1} to{" "}
            {Math.min(pagination.page * pagination.limit, pagination.total)} of{" "}
            {pagination.total} results
          </div>
          <div className="flex items-center gap-2">
            <Button
              variant="outline"
              size="sm"
              onClick={() => onPageChange(pagination.page - 1)}
              disabled={!pagination.hasPrev}
            >
              <Icon icon="heroicons:chevron-left" className="w-4 h-4" />
              Previous
            </Button>

            <div className="flex items-center gap-1">
              {[...Array(Math.min(5, pagination.totalPages))].map((_, i) => {
                const pageNum = Math.max(
                  1,
                  Math.min(
                    pagination.page - 2 + i,
                    pagination.totalPages - 4 + i
                  )
                );

                if (pageNum > pagination.totalPages) return null;

                return (
                  <Button
                    key={pageNum}
                    variant={
                      pageNum === pagination.page ? "default" : "outline"
                    }
                    size="sm"
                    onClick={() => onPageChange(pageNum)}
                    className="w-8 h-8 p-0"
                  >
                    {pageNum}
                  </Button>
                );
              })}
            </div>

            <Button
              variant="outline"
              size="sm"
              onClick={() => onPageChange(pagination.page + 1)}
              disabled={!pagination.hasNext}
            >
              Next
              <Icon icon="heroicons:chevron-right" className="w-4 h-4" />
            </Button>
          </div>
        </div>
      )}
    </div>
  );
};
-----------------------------------------------------------------------
Lib Folder:
-----------------------------------------------------------------------
--++--> lib/api/clients/parcels/delivery-slips.client.ts =======>
-----------------------------------------------------------------------
import { BaseApiClient, ApiResponse } from "../../base.client";
import type {
  DeliverySlip,
  CreateDeliverySlipRequest,
  UpdateDeliverySlipRequest,
  DeliverySlipFilters,
  AddParcelsToSlipRequest,
  RemoveParcelsFromSlipRequest,
  ReceiveSlipRequest,
  DeliverySlipStats,
  BulkSlipActionRequest,
  AvailableParcel,
  PaginatedDeliverySlips,
} from "@/lib/types/parcels/delivery-slips.types";
export class DeliverySlipsApiClient extends BaseApiClient {
  constructor() {
    super("parcels");
  }

  // ========================================
  // DELIVERY SLIP MANAGEMENT ENDPOINTS
  // ========================================

  /**
   * Create new delivery slip
   */
  async createDeliverySlip(
    request: CreateDeliverySlipRequest
  ): Promise<ApiResponse<DeliverySlip>> {
    return this.post<DeliverySlip>("/api/delivery-slips", request);
  }

  /**
   * Get delivery slips with filters and pagination
   */
  async getDeliverySlips(filters?: DeliverySlipFilters) {
    return this.getPaginated<DeliverySlip>("/api/delivery-slips", filters);
  }

  /**
   * Get delivery slip by ID
   */
  async getDeliverySlipById(id: string): Promise<ApiResponse<DeliverySlip>> {
    return this.get<DeliverySlip>(`/api/delivery-slips/${id}`);
  }

  /**
   * Update delivery slip
   */
  async updateDeliverySlip(
    id: string,
    request: UpdateDeliverySlipRequest
  ): Promise<ApiResponse<DeliverySlip>> {
    return this.patch<DeliverySlip>(`/api/delivery-slips/${id}`, request);
  }

  /**
   * Delete delivery slip
   */
  async deleteDeliverySlip(id: string): Promise<ApiResponse<void>> {
    return this.delete<void>(`/api/delivery-slips/${id}`);
  }

  // ========================================
  // PARCEL MANAGEMENT WITHIN SLIPS
  // ========================================

  /**
   * Add parcels to delivery slip
   */
  async addParcelsToSlip(
    slipId: string,
    request: AddParcelsToSlipRequest
  ): Promise<ApiResponse<DeliverySlip>> {
    return this.post<DeliverySlip>(
      `/api/delivery-slips/${slipId}/add-parcels`,
      request
    );
  }

  /**
   * Remove parcels from delivery slip
   */
  async removeParcelsFromSlip(
    slipId: string,
    request: RemoveParcelsFromSlipRequest
  ): Promise<ApiResponse<DeliverySlip>> {
    return this.post<DeliverySlip>(
      `/api/delivery-slips/${slipId}/remove-parcels`,
      request
    );
  }

  /**
   * Get available parcels for delivery slips
   */
  async getAvailableParcels(
    cityId?: string
  ): Promise<ApiResponse<AvailableParcel[]>> {
    const params = cityId ? { cityId } : {};
    return this.get<AvailableParcel[]>(
      "/api/delivery-slips/available-parcels",
      { params }
    );
  }

  // ========================================
  // DELIVERY SLIP OPERATIONS
  // ========================================

  /**
   * Mark delivery slip as received
   */
  async receiveSlip(
    slipId: string,
    request: ReceiveSlipRequest
  ): Promise<ApiResponse<DeliverySlip>> {
    return this.post<DeliverySlip>(
      `/api/delivery-slips/${slipId}/receive`,
      request
    );
  }

  /**
   * Scan parcel into delivery slip
   */
  async scanParcelIntoSlip(
    slipId: string,
    parcelCode: string
  ): Promise<ApiResponse<any>> {
    return this.post<any>(`/api/delivery-slips/${slipId}/scan/${parcelCode}`);
  }

  // ========================================
  // BULK OPERATIONS
  // ========================================

  /**
   * Perform bulk actions on delivery slips
   */
  async bulkAction(
    request: BulkSlipActionRequest
  ): Promise<
    ApiResponse<{ success: number; failed: number; errors: string[] }>
  > {
    return this.post<{ success: number; failed: number; errors: string[] }>(
      "/api/delivery-slips/bulk-action",
      request
    );
  }

  // ========================================
  // STATISTICS AND ANALYTICS
  // ========================================

  /**
   * Get delivery slip statistics
   */
  async getDeliverySlipStats(): Promise<ApiResponse<DeliverySlipStats>> {
    return this.get<DeliverySlipStats>("/api/delivery-slips/statistics");
  }

  // ========================================
  // EXPORT AND DOWNLOAD OPERATIONS
  // ========================================

  /**
   * Export delivery slips
   */
  async exportDeliverySlips(filters?: DeliverySlipFilters): Promise<Blob> {
    try {
      const response = await this.client.post(
        "/api/delivery-slips/export",
        filters || {},
        {
          responseType: "blob",
        }
      );
      return response.data; // Return the blob directly
    } catch (error) {
      throw error;
    }
  }

  /**
   * Download delivery slip PDF
   */
  async downloadSlipPdf(id: string): Promise<ApiResponse<Blob>> {
    return this.get<Blob>(`/api/delivery-slips/${id}/pdf`, {
      responseType: "blob",
    });
  }

  /**
   * Download delivery slip labels
   */
  async downloadSlipLabels(id: string): Promise<ApiResponse<Blob>> {
    return this.get<Blob>(`/api/delivery-slips/${id}/labels`, {
      responseType: "blob",
    });
  }

  // ========================================
  // UTILITY OPERATIONS
  // ========================================

  /**
   * Get delivery slip barcode
   */
  async getSlipBarcode(id: string): Promise<ApiResponse<any>> {
    return this.get<any>(`/api/delivery-slips/${id}/barcode`);
  }
}
// Export singleton instance
export const deliverySlipsApiClient = new DeliverySlipsApiClient();
-----------------------------------------------------------------------
--++--> lib/api/base.client.ts =======>
-----------------------------------------------------------------------
import axios, {
  AxiosInstance,
  AxiosRequestConfig,
  AxiosResponse,
  AxiosError,
  InternalAxiosRequestConfig,
} from "axios";
import { API_CONFIG, ServiceName, ErrorCode } from "@/lib/config/api.config";
import { getTenantFromUrl } from "@/lib/utils/tenant.utils";
// Extend Axios request config to include metadata
interface ExtendedAxiosRequestConfig extends InternalAxiosRequestConfig {
  metadata?: {
    startTime: number;
  };
}
export interface ApiError {
  code: ErrorCode;
  message: string;
  details?: any;
  statusCode?: number;
  timestamp: string;
  requestId?: string;
}
export interface ApiResponse<T = any> {
  success: boolean;
  data?: T;
  error?: ApiError;
  message?: string;
  timestamp: string;
}
export interface PaginatedResponse<T = any> {
  data: T[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
}
export class BaseApiClient {
  protected client: AxiosInstance;
  protected serviceName: ServiceName;
  protected tenantId: string | null = null;

  constructor(serviceName: ServiceName, customConfig?: AxiosRequestConfig) {
    this.serviceName = serviceName;
    const serviceConfig = API_CONFIG.services[serviceName];

    // Get tenant ID from URL
    this.tenantId = getTenantFromUrl();

    // Create axios instance
    this.client = axios.create({
      baseURL: serviceConfig.baseURL,
      timeout: serviceConfig.timeout,
      headers: {
        ...API_CONFIG.headers.common,
        ...(this.tenantId && { [API_CONFIG.headers.tenant]: this.tenantId }),
      },
      ...customConfig,
    });

    this.setupInterceptors();
  }

  private setupInterceptors(): void {
    // Request interceptor
    this.client.interceptors.request.use(
      (config: ExtendedAxiosRequestConfig) => {
        // Add auth token
        const token = this.getAuthToken();
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }

        // Add tenant ID if available
        if (this.tenantId) {
          config.headers[API_CONFIG.headers.tenant] = this.tenantId;
        }

        // Add request timestamp for debugging
        config.metadata = { startTime: Date.now() };

        return config;
      },
      (error) => Promise.reject(this.transformError(error))
    );

    // Response interceptor
    this.client.interceptors.response.use(
      (response: AxiosResponse) => {
        // Log response time for monitoring
        const endTime = Date.now();
        const config = response.config as ExtendedAxiosRequestConfig;
        const startTime = config.metadata?.startTime || endTime;
        const duration = endTime - startTime;

        if (duration > 3000) {
          console.warn(
            `Slow API request detected: ${response.config.url} took ${duration}ms`
          );
        }

        return response;
      },
      async (error: AxiosError) => {
        // Handle token refresh
        if (error.response?.status === 401 && this.serviceName === "auth") {
          const refreshed = await this.attemptTokenRefresh();
          if (refreshed && error.config) {
            // Retry original request with new token
            const token = this.getAuthToken();
            if (token) {
              error.config.headers.Authorization = `Bearer ${token}`;
            }
            return this.client.request(error.config);
          }
        }

        return Promise.reject(this.transformError(error));
      }
    );
  }

  private getAuthToken(): string | null {
    if (typeof window === "undefined") return null;
    return localStorage.getItem("auth_token");
  }

  private async attemptTokenRefresh(): Promise<boolean> {
    try {
      const refreshToken = localStorage.getItem("refresh_token");
      if (!refreshToken) return false;

      // Only attempt refresh from auth service
      if (this.serviceName !== "auth") return false;

      const response = await axios.post(
        `${API_CONFIG.services.auth.baseURL}/api/auth/refresh`,
        { refreshToken },
        {
          headers: {
            "Content-Type": "application/json",
            ...(this.tenantId && {
              [API_CONFIG.headers.tenant]: this.tenantId,
            }),
          },
        }
      );

      if (response.data.success && response.data.data) {
        const { accessToken, refreshToken: newRefreshToken } =
          response.data.data;
        localStorage.setItem("auth_token", accessToken);
        if (newRefreshToken) {
          localStorage.setItem("refresh_token", newRefreshToken);
        }
        return true;
      }
    } catch (error) {
      console.error("Token refresh failed:", error);
      this.clearAuthTokens();
    }
    return false;
  }

  private clearAuthTokens(): void {
    if (typeof window !== "undefined") {
      localStorage.removeItem("auth_token");
      localStorage.removeItem("refresh_token");
    }
  }

  private transformError(error: any): ApiError {
    const timestamp = new Date().toISOString();

    // Network or timeout errors
    if (!error.response) {
      return {
        code: error.code === "ECONNABORTED" ? "TIMEOUT_ERROR" : "NETWORK_ERROR",
        message: error.message || "Network error occurred",
        timestamp,
      };
    }

    // HTTP errors with response
    const { status, data } = error.response;
    const statusCode = status;

    // Map status codes to error codes
    let code: ErrorCode = "SERVER_ERROR";
    switch (statusCode) {
      case 400:
        code = "VALIDATION_ERROR";
        break;
      case 401:
        code = "AUTH_ERROR";
        break;
      case 403:
        code = "PERMISSION_ERROR";
        break;
      case 404:
        code = "NOT_FOUND";
        break;
      case 409:
        code = "CONFLICT";
        break;
      case 429:
        code = "RATE_LIMIT_ERROR";
        break;
      case 500:
      case 502:
      case 503:
      case 504:
        code = "SERVER_ERROR";
        break;
    }

    return {
      code,
      message:
        data?.message || data?.error || error.message || "An error occurred",
      details: data?.details,
      statusCode,
      timestamp,
      requestId: data?.requestId,
    };
  }

  // Generic HTTP methods
  protected async get<T>(
    endpoint: string,
    config?: AxiosRequestConfig
  ): Promise<ApiResponse<T>> {
    try {
      const response = await this.client.get(endpoint, config);
      return this.transformResponse<T>(response);
    } catch (error) {
      throw error; // Error is already transformed by interceptor
    }
  }

  protected async post<T>(
    endpoint: string,
    data?: any,
    config?: AxiosRequestConfig
  ): Promise<ApiResponse<T>> {
    try {
      const response = await this.client.post(endpoint, data, config);
      return this.transformResponse<T>(response);
    } catch (error) {
      throw error;
    }
  }

  protected async put<T>(
    endpoint: string,
    data?: any,
    config?: AxiosRequestConfig
  ): Promise<ApiResponse<T>> {
    try {
      const response = await this.client.put(endpoint, data, config);
      return this.transformResponse<T>(response);
    } catch (error) {
      throw error;
    }
  }

  protected async patch<T>(
    endpoint: string,
    data?: any,
    config?: AxiosRequestConfig
  ): Promise<ApiResponse<T>> {
    try {
      const response = await this.client.patch(endpoint, data, config);
      return this.transformResponse<T>(response);
    } catch (error) {
      throw error;
    }
  }

  protected async delete<T>(
    endpoint: string,
    config?: AxiosRequestConfig
  ): Promise<ApiResponse<T>> {
    try {
      const response = await this.client.delete(endpoint, config);
      return this.transformResponse<T>(response);
    } catch (error) {
      throw error;
    }
  }

  // Paginated requests
  protected async getPaginated<T>(
    endpoint: string,
    params?: Record<string, any>,
    config?: AxiosRequestConfig
  ): Promise<PaginatedResponse<T>> {
    try {
      const response = await this.client.get(endpoint, {
        ...config,
        params: { ...params, ...config?.params },
      });

      // Handle different response formats
      if (response.data.data && response.data.pagination) {
        // Standard paginated format: { data: T[], pagination: {...} }
        return response.data;
      } else if (Array.isArray(response.data.data)) {
        // Array wrapped in data property: { data: T[] }
        return {
          data: response.data.data,
          pagination: {
            page: 1,
            limit: response.data.data.length,
            total: response.data.data.length,
            totalPages: 1,
            hasNext: false,
            hasPrev: false,
          },
        };
      } else if (Array.isArray(response.data)) {
        // Direct array response: T[]
        return {
          data: response.data,
          pagination: {
            page: 1,
            limit: response.data.length,
            total: response.data.length,
            totalPages: 1,
            hasNext: false,
            hasPrev: false,
          },
        };
      } else if (response.data.success && response.data.data) {
        // Wrapped in success envelope: { success: true, data: T[] }
        const data = Array.isArray(response.data.data)
          ? response.data.data
          : [response.data.data];
        return {
          data,
          pagination: {
            page: 1,
            limit: data.length,
            total: data.length,
            totalPages: 1,
            hasNext: false,
            hasPrev: false,
          },
        };
      }

      // Log the actual response structure for debugging
      console.error("Unexpected response structure:", {
        data: response.data,
        dataType: typeof response.data,
        isArray: Array.isArray(response.data),
        hasData: "data" in response.data,
        hasSuccess: "success" in response.data,
        hasPagination: "pagination" in response.data,
      });

      throw new Error(
        `Invalid paginated response format. Expected array or paginated object, got: ${typeof response.data}`
      );
    } catch (error) {
      throw error;
    }
  }

  private transformResponse<T>(response: AxiosResponse): ApiResponse<T> {
    return {
      success: true,
      data: response.data.data || response.data,
      message: response.data.message,
      timestamp: new Date().toISOString(),
    };
  }

  // Utility methods
  public setTenant(tenantId: string): void {
    this.tenantId = tenantId;
    this.client.defaults.headers[API_CONFIG.headers.tenant] = tenantId;
  }

  public clearTenant(): void {
    this.tenantId = null;
    delete this.client.defaults.headers[API_CONFIG.headers.tenant];
  }

  public getServiceName(): ServiceName {
    return this.serviceName;
  }

  public getBaseURL(): string {
    return this.client.defaults.baseURL || "";
  }
}
-----------------------------------------------------------------------
--++--> lib/stores/parcels/parcels.store.ts =======>
-----------------------------------------------------------------------
import { create } from "zustand";
import { persist } from "zustand/middleware";
import { parcelsApiClient } from "@/lib/api/clients/parcels/parcels.client";
import type {
  Parcel,
  CreateParcelRequest,
  UpdateParcelRequest,
  ParcelFilters,
  ParcelStatistics,
  ChangeParcelStatusRequest,
  BulkParcelActionRequest,
  BulkActionResult,
  PaginatedParcelsResponse,
} from "@/lib/types/parcels/parcels.types";
import { toast } from "sonner";
interface ParcelsState {
  // Core state
  parcels: Parcel[];
  myParcels: Parcel[];
  currentParcel: Parcel | null;
  statistics: ParcelStatistics | null;

  // UI state
  isLoading: boolean;
  isCreating: boolean;
  isUpdating: boolean;
  isDeleting: boolean;
  error: string | null;

  // Pagination state
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };

  // Filters state
  filters: ParcelFilters;

  // Selection state for bulk operations
  selectedIds: string[];

  parcelHistory: Array<{
    id: string;
    statusCode: string;
    statusName: string;
    comment?: string;
    changedAt: string;
    changedBy?: string;
  }>;
  isLoadingHistory: boolean;

  // Actions
  setFilters: (filters: Partial<ParcelFilters>) => void;
  clearFilters: () => void;
  setSelectedIds: (ids: string[]) => void;
  clearSelectedIds: () => void;

  // API Actions
  fetchParcels: () => Promise<void>;
  fetchMyParcels: () => Promise<void>;
  fetchParcelById: (id: string) => Promise<Parcel | null>;
  createParcel: (data: CreateParcelRequest) => Promise<Parcel | null>;
  updateParcel: (
    id: string,
    data: UpdateParcelRequest
  ) => Promise<Parcel | null>;
  deleteParcel: (id: string) => Promise<boolean>;
  changeParcelStatus: (
    id: string,
    data: ChangeParcelStatusRequest
  ) => Promise<boolean>;
  updatePaymentStatus: (
    id: string,
    paymentStatus: string,
    comment?: string
  ) => Promise<boolean>;

  // Specialized fetches
  fetchPickupReadyParcels: () => Promise<void>;
  fetchParcelsByStatus: (statusCode: string) => Promise<void>;
  searchParcelsByPhone: (phone: string) => Promise<void>;

  // Bulk operations
  bulkAction: (
    data: BulkParcelActionRequest
  ) => Promise<BulkActionResult | null>;
  bulkChangeStatus: (
    parcelIds: string[],
    statusCode: string,
    comment?: string
  ) => Promise<boolean>;
  bulkDeleteParcels: (parcelIds: string[]) => Promise<boolean>;

  // Statistics
  fetchStatistics: () => Promise<void>;
  fetchParcelHistory: (id: string) => Promise<void>;

  // Utility methods
  getParcelById: (id: string) => Parcel | undefined;
  getParcelsByStatus: (statusCode: string) => Parcel[];
  resetState: () => void;
  clearError: () => void;
}
const DEFAULT_FILTERS: ParcelFilters = {
  page: 1,
  limit: 10,
  search: "",
  sortBy: "createdAt",
  sortParcel: "desc",
};
const DEFAULT_PAGINATION = {
  page: 1,
  limit: 10,
  total: 0,
  totalPages: 0,
  hasNext: false,
  hasPrev: false,
};
export const useParcelsStore = create<ParcelsState>()(
  persist(
    (set, get) => ({
      // Initial state
      parcels: [],
      myParcels: [],
      currentParcel: null,
      statistics: null,
      isLoading: false,
      isCreating: false,
      isUpdating: false,
      isDeleting: false,
      error: null,
      pagination: DEFAULT_PAGINATION,
      filters: DEFAULT_FILTERS,
      selectedIds: [],
      parcelHistory: [],
      isLoadingHistory: false,

      // Filter actions
      setFilters: (newFilters) => {
        const updatedFilters = { ...get().filters, ...newFilters };
        set({ filters: updatedFilters });

        // Reset to page 1 if search or other filters changed
        if ("search" in newFilters || "statusCode" in newFilters) {
          set({ filters: { ...updatedFilters, page: 1 } });
        }

        // Auto-fetch with new filters
        get().fetchParcels();
      },

      clearFilters: () => {
        set({ filters: DEFAULT_FILTERS });
        get().fetchParcels();
      },

      setSelectedIds: (ids) => set({ selectedIds: ids }),
      clearSelectedIds: () => set({ selectedIds: [] }),

      // Fetch parcels with filters and pagination
      fetchParcels: async () => {
        const { filters } = get();
        set({ isLoading: true, error: null });

        try {
          const response = await parcelsApiClient.getParcels(filters);

          if (response.data && response.data.length) {
            set({
              parcels: response.data[0].data,
              pagination: response.data[0].meta,
              isLoading: false,
            });
          } else {
            throw new Error(
              response.error?.message || "Failed to fetch parcels"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error fetching parcels:", error);
          set({ error: errorMessage, isLoading: false });
          toast.error("Failed to fetch parcels");
        }
      },

      // Fetch current user's parcels
      fetchMyParcels: async () => {
        const { filters } = get();
        set({ isLoading: true, error: null });

        try {
          const response = await parcelsApiClient.getMyParcels(filters);

          if (response.success && response.data) {
            set({
              myParcels: response.data.data,
              pagination: response.data.meta,
              isLoading: false,
            });
          } else {
            throw new Error(
              response.error?.message || "Failed to fetch my parcels"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error fetching my parcels:", error);
          set({ error: errorMessage, isLoading: false });
          toast.error("Failed to fetch your parcels");
        }
      },

      // Fetch parcel by ID
      fetchParcelById: async (id: string) => {
        set({ isLoading: true, error: null });

        try {
          const response = await parcelsApiClient.getParcelById(id);

          if (response.success && response.data) {
            set({ currentParcel: response.data, isLoading: false });
            return response.data;
          } else {
            throw new Error(response.error?.message || "Parcel not found");
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error fetching parcel:", error);
          set({
            error: errorMessage,
            isLoading: false,
            currentParcel: null,
          });
          toast.error("Failed to fetch parcel details");
          return null;
        }
      },

      // Create parcel
      createParcel: async (data: CreateParcelRequest) => {
        set({ isCreating: true, error: null });

        try {
          const response = await parcelsApiClient.createParcel(data);

          if (response.success && response.data) {
            const newParcel = response.data;

            // Add to list if it matches current filters
            const { parcels } = get();
            set({
              parcels: [newParcel, ...parcels],
              isCreating: false,
            });

            toast.success("Parcel created successfully");

            // Refresh the list to get accurate pagination
            get().fetchParcels();

            return newParcel;
          } else {
            throw new Error(
              response.error?.message || "Failed to create parcel"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error creating parcel:", error);
          set({ error: errorMessage, isCreating: false });
          toast.error(`Failed to create parcel: ${errorMessage}`);
          return null;
        }
      },

      // Update parcel
      updateParcel: async (id: string, data: UpdateParcelRequest) => {
        set({ isUpdating: true, error: null });

        try {
          const response = await parcelsApiClient.updateParcel(id, data);

          if (response.success && response.data) {
            const updatedParcel = response.data;

            // Update in list
            const { parcels } = get();
            const updatedList = parcels.map((parcel) =>
              parcel.id === id ? updatedParcel : parcel
            );

            set({
              parcels: updatedList,
              currentParcel: updatedParcel,
              isUpdating: false,
            });

            toast.success("Parcel updated successfully");
            return updatedParcel;
          } else {
            throw new Error(
              response.error?.message || "Failed to update parcel"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error updating parcel:", error);
          set({ error: errorMessage, isUpdating: false });
          toast.error(`Failed to update parcel: ${errorMessage}`);
          return null;
        }
      },

      // Delete parcel
      deleteParcel: async (id: string) => {
        set({ isDeleting: true, error: null });

        try {
          const response = await parcelsApiClient.deleteParcel(id);

          if (response.success) {
            // Remove from list
            const { parcels } = get();
            const updatedList = parcels.filter((parcel) => parcel.id !== id);

            set({
              parcels: updatedList,
              currentParcel: null,
              isDeleting: false,
            });

            toast.success("Parcel deleted successfully");

            // Refresh to get accurate pagination
            get().fetchParcels();

            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to delete parcel"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error deleting parcel:", error);
          set({ error: errorMessage, isDeleting: false });
          toast.error(`Failed to delete parcel: ${errorMessage}`);
          return false;
        }
      },

      // Change parcel status
      changeParcelStatus: async (
        id: string,
        data: ChangeParcelStatusRequest
      ) => {
        try {
          const response = await parcelsApiClient.changeParcelStatus(id, data);

          if (response.success && response.data) {
            const updatedParcel = response.data;

            // Update in list
            const { parcels } = get();
            const updatedList = parcels.map((parcel) =>
              parcel.id === id ? updatedParcel : parcel
            );

            set({
              parcels: updatedList,
              currentParcel: updatedParcel,
            });

            toast.success(`Parcel status changed to ${data.statusCode}`);
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to change parcel status"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error changing parcel status:", error);
          toast.error(`Failed to change status: ${errorMessage}`);
          return false;
        }
      },

      // Update payment status
      updatePaymentStatus: async (
        id: string,
        paymentStatus: string,
        comment?: string
      ) => {
        try {
          const response = await parcelsApiClient.updatePaymentStatus(
            id,
            paymentStatus,
            comment
          );

          if (response.success && response.data) {
            const updatedParcel = response.data;

            // Update in list
            const { parcels } = get();
            const updatedList = parcels.map((parcel) =>
              parcel.id === id ? updatedParcel : parcel
            );

            set({
              parcels: updatedList,
              currentParcel: updatedParcel,
            });

            toast.success(`Payment status updated to ${paymentStatus}`);
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to update payment status"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error updating payment status:", error);
          toast.error(`Failed to update payment status: ${errorMessage}`);
          return false;
        }
      },

      // Fetch pickup ready parcels
      fetchPickupReadyParcels: async () => {
        const { filters } = get();
        set({ isLoading: true, error: null });

        try {
          const response = await parcelsApiClient.getPickupReadyParcels(
            filters
          );

          if (response.success && response.data) {
            set({
              parcels: response.data.data,
              pagination: response.data.meta,
              isLoading: false,
            });
          }
        } catch (error) {
          console.error("Error fetching pickup ready parcels:", error);
          toast.error("Failed to fetch pickup ready parcels");
          set({ isLoading: false });
        }
      },

      // Fetch parcels by status
      fetchParcelsByStatus: async (statusCode: string) => {
        const { filters } = get();
        set({ isLoading: true, error: null });

        try {
          const response = await parcelsApiClient.getParcelsByStatus(
            statusCode,
            filters
          );

          if (response.success && response.data) {
            set({
              parcels: response.data.data,
              pagination: response.data.meta,
              isLoading: false,
            });
          }
        } catch (error) {
          console.error("Error fetching parcels by status:", error);
          toast.error("Failed to fetch parcels by status");
          set({ isLoading: false });
        }
      },

      // Search parcels by phone
      searchParcelsByPhone: async (phone: string) => {
        const { filters } = get();
        set({ isLoading: true, error: null });

        try {
          const response = await parcelsApiClient.searchParcelsByPhone(
            phone,
            filters
          );

          if (response.success && response.data) {
            set({
              parcels: response.data.data,
              pagination: response.data.meta,
              isLoading: false,
            });
          }
        } catch (error) {
          console.error("Error searching parcels by phone:", error);
          toast.error("Failed to search parcels by phone");
          set({ isLoading: false });
        }
      },

      // Bulk action
      bulkAction: async (data: BulkParcelActionRequest) => {
        set({ isLoading: true, error: null });

        try {
          const response = await parcelsApiClient.bulkAction(data);

          if (response.success && response.data) {
            toast.success(
              `Bulk action completed: ${response.data.success} successful, ${response.data.failed} failed`
            );

            if (response.data.failed > 0) {
              toast.warning(
                `${response.data.failed} parcels could not be processed`
              );
            }

            // Clear selection and refresh
            set({ selectedIds: [], isLoading: false });
            get().fetchParcels();

            return response.data;
          } else {
            throw new Error(
              response.error?.message || "Failed to perform bulk action"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error performing bulk action:", error);
          set({ error: errorMessage, isLoading: false });
          toast.error(`Failed to perform bulk action: ${errorMessage}`);
          return null;
        }
      },

      // Bulk change status
      bulkChangeStatus: async (
        parcelIds: string[],
        statusCode: string,
        comment?: string
      ) => {
        try {
          const response = await parcelsApiClient.bulkChangeStatus(
            parcelIds,
            statusCode,
            comment
          );

          if (response.success && response.data) {
            toast.success(
              `${response.data.success} parcels status changed successfully`
            );

            if (response.data.failed > 0) {
              toast.warning(
                `${response.data.failed} parcels could not be updated`
              );
            }

            // Clear selection and refresh
            set({ selectedIds: [] });
            get().fetchParcels();

            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to change parcels status"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error changing parcels status:", error);
          toast.error(`Failed to change status: ${errorMessage}`);
          return false;
        }
      },

      // Bulk delete parcels
      bulkDeleteParcels: async (parcelIds: string[]) => {
        set({ isDeleting: true, error: null });

        try {
          const response = await parcelsApiClient.bulkDeleteParcels(parcelIds);

          if (response.success && response.data) {
            toast.success(
              `${response.data.success} parcels deleted successfully`
            );

            if (response.data.failed > 0) {
              toast.warning(
                `${response.data.failed} parcels could not be deleted`
              );
            }

            // Clear selection and refresh
            set({ selectedIds: [], isDeleting: false });
            get().fetchParcels();

            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to delete parcels"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error bulk deleting parcels:", error);
          set({ error: errorMessage, isDeleting: false });
          toast.error(`Failed to delete parcels: ${errorMessage}`);
          return false;
        }
      },

      // Fetch statistics
      fetchStatistics: async () => {
        try {
          const response = await parcelsApiClient.getParcelStatistics();

          if (response.success && response.data) {
            set({ statistics: response.data });
          } else {
            throw new Error(
              response.error?.message || "Failed to fetch statistics"
            );
          }
        } catch (error) {
          console.error("Error fetching parcel statistics:", error);
        }
      },

      fetchParcelHistory: async (id: string) => {
        set({ isLoadingHistory: true, error: null });

        try {
          const response = await parcelsApiClient.getParcelHistory(id);

          if (response.success && response.data) {
            set({
              parcelHistory: response.data,
              isLoadingHistory: false,
            });
          } else {
            throw new Error(
              response.error?.message || "Failed to fetch parcel history"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error fetching parcel history:", error);
          set({
            error: errorMessage,
            isLoadingHistory: false,
            parcelHistory: [],
          });
          toast.error("Failed to fetch parcel history");
        }
      },

      // Utility methods
      getParcelById: (id: string) => {
        const { parcels } = get();
        return parcels.find((parcel) => parcel.id === id);
      },

      getParcelsByStatus: (statusCode: string) => {
        const { parcels } = get();
        return parcels.filter(
          (parcel) => parcel.parcelStatusCode === statusCode
        );
      },

      resetState: () => {
        set({
          parcels: [],
          myParcels: [],
          currentParcel: null,
          statistics: null,
          error: null,
          pagination: DEFAULT_PAGINATION,
          filters: DEFAULT_FILTERS,
          selectedIds: [],
          isLoading: false,
          isCreating: false,
          isUpdating: false,
          isDeleting: false,
        });
      },

      clearError: () => set({ error: null }),
    }),
    {
      name: "parcels-store",
      partialize: (state) => ({
        filters: state.filters,
        pagination: state.pagination,
        // Don't persist loading states or selections
      }),
      version: 1,
    }
  )
);
-----------------------------------------------------------------------
--++--> lib/stores/parcels/delivery-slips.store.ts =======>
-----------------------------------------------------------------------
import { create } from "zustand";
import { persist } from "zustand/middleware";
import { deliverySlipsApiClient } from "@/lib/api/clients/parcels/delivery-slips.client";
import type {
  DeliverySlip,
  CreateDeliverySlipRequest,
  UpdateDeliverySlipRequest,
  DeliverySlipFilters,
  AddParcelsToSlipRequest,
  RemoveParcelsFromSlipRequest,
  ReceiveSlipRequest,
  DeliverySlipStats,
  BulkSlipActionRequest,
  AvailableParcel,
  PaginatedDeliverySlips,
  DeliverySlipStatus,
} from "@/lib/types/parcels/delivery-slips.types";
import { toast } from "sonner";
interface DeliverySlipsState {
  // Core state
  deliverySlips: DeliverySlip[];
  currentDeliverySlip: DeliverySlip | null;
  availableParcels: AvailableParcel[];
  statistics: DeliverySlipStats | null;

  // UI state
  isLoading: boolean;
  isCreating: boolean;
  isUpdating: boolean;
  isDeleting: boolean;
  error: string | null;

  // Pagination state
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };

  // Filters state
  filters: DeliverySlipFilters;

  // Selection state for bulk operations
  selectedSlipIds: string[];

  // Actions
  setFilters: (filters: Partial<DeliverySlipFilters>) => void;
  clearFilters: () => void;
  setSelectedSlipIds: (ids: string[]) => void;
  clearSelectedSlipIds: () => void;

  // API Actions
  fetchDeliverySlips: () => Promise<void>;
  fetchDeliverySlipById: (id: string) => Promise<DeliverySlip | null>;
  createDeliverySlip: (
    data: CreateDeliverySlipRequest
  ) => Promise<DeliverySlip | null>;
  updateDeliverySlip: (
    id: string,
    data: UpdateDeliverySlipRequest
  ) => Promise<DeliverySlip | null>;
  deleteDeliverySlip: (id: string) => Promise<boolean>;

  // Slip operations
  addParcelsToSlip: (
    slipId: string,
    data: AddParcelsToSlipRequest
  ) => Promise<boolean>;
  removeParcelsFromSlip: (
    slipId: string,
    data: RemoveParcelsFromSlipRequest
  ) => Promise<boolean>;
  receiveSlip: (slipId: string, data: ReceiveSlipRequest) => Promise<boolean>;
  scanParcelIntoSlip: (slipId: string, parcelCode: string) => Promise<boolean>;

  // Bulk operations
  bulkAction: (data: BulkSlipActionRequest) => Promise<boolean>;

  // Available parcels
  fetchAvailableParcels: (cityId?: string) => Promise<void>;

  // Statistics
  fetchStatistics: () => Promise<void>;

  // Document operations
  downloadSlipPdf: (id: string) => Promise<boolean>;
  downloadSlipLabels: (id: string) => Promise<boolean>;
  getSlipBarcode: (id: string) => Promise<any | null>;

  // Export
  exportDeliverySlips: (
    filters?: DeliverySlipFilters
  ) => Promise<string | null>;

  // Utility methods
  getSlipById: (id: string) => DeliverySlip | undefined;
  getSlipsByStatus: (status: DeliverySlipStatus) => DeliverySlip[];
  resetState: () => void;
  clearError: () => void;
}
const DEFAULT_FILTERS: DeliverySlipFilters = {
  page: 1,
  limit: 10,
  search: "",
  sortBy: "createdAt",
  sortParcel: "desc",
};
const DEFAULT_PAGINATION = {
  page: 1,
  limit: 10,
  total: 0,
  totalPages: 0,
  hasNext: false,
  hasPrev: false,
};
export const useDeliverySlipsStore = create<DeliverySlipsState>()(
  persist(
    (set, get) => ({
      // Initial state
      deliverySlips: [],
      currentDeliverySlip: null,
      availableParcels: [],
      statistics: null,
      isLoading: false,
      isCreating: false,
      isUpdating: false,
      isDeleting: false,
      error: null,
      pagination: DEFAULT_PAGINATION,
      filters: DEFAULT_FILTERS,
      selectedSlipIds: [],

      // Filter actions
      setFilters: (newFilters) => {
        const updatedFilters = { ...get().filters, ...newFilters };
        set({ filters: updatedFilters });

        // Reset to page 1 if search or other filters changed
        if ("search" in newFilters || "status" in newFilters) {
          set({ filters: { ...updatedFilters, page: 1 } });
        }

        // Auto-fetch with new filters
        get().fetchDeliverySlips();
      },

      clearFilters: () => {
        set({ filters: DEFAULT_FILTERS });
        get().fetchDeliverySlips();
      },

      setSelectedSlipIds: (ids) => set({ selectedSlipIds: ids }),
      clearSelectedSlipIds: () => set({ selectedSlipIds: [] }),

      // Fetch delivery slips with filters and pagination
      fetchDeliverySlips: async () => {
        const { filters } = get();
        set({ isLoading: true, error: null });

        try {
          const response = await deliverySlipsApiClient.getDeliverySlips(
            filters
          );

          if (response.data && response.data.length > 0) {
            set({
              deliverySlips: response.data[0].data,
              pagination: response.data[0].meta,
              isLoading: false,
            });
          } else {
            throw new Error(
              response.error?.message || "Failed to fetch delivery slips"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error fetching delivery slips:", error);
          set({ error: errorMessage, isLoading: false });
          toast.error("Failed to fetch delivery slips");
        }
      },

      // Fetch delivery slip by ID
      fetchDeliverySlipById: async (id: string) => {
        set({ isLoading: true, error: null });

        try {
          const response = await deliverySlipsApiClient.getDeliverySlipById(id);

          if (response.success && response.data) {
            set({
              currentDeliverySlip: response.data,
              isLoading: false,
            });
            return response.data;
          } else {
            throw new Error(
              response.error?.message || "Delivery slip not found"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error fetching delivery slip:", error);
          set({
            error: errorMessage,
            isLoading: false,
            currentDeliverySlip: null,
          });
          toast.error("Failed to fetch delivery slip");
          return null;
        }
      },

      // Create delivery slip
      createDeliverySlip: async (data: CreateDeliverySlipRequest) => {
        set({ isCreating: true, error: null });

        try {
          const response = await deliverySlipsApiClient.createDeliverySlip(
            data
          );

          if (response.success && response.data) {
            const newSlip = response.data;

            // Add to list if it matches current filters
            const { deliverySlips } = get();
            set({
              deliverySlips: [newSlip, ...deliverySlips],
              isCreating: false,
            });

            toast.success("Delivery slip created successfully");

            // Refresh the list to get accurate pagination
            get().fetchDeliverySlips();

            return newSlip;
          } else {
            throw new Error(
              response.error?.message || "Failed to create delivery slip"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error creating delivery slip:", error);
          set({ error: errorMessage, isCreating: false });
          toast.error(`Failed to create delivery slip: ${errorMessage}`);
          return null;
        }
      },

      // Update delivery slip
      updateDeliverySlip: async (
        id: string,
        data: UpdateDeliverySlipRequest
      ) => {
        set({ isUpdating: true, error: null });

        try {
          const response = await deliverySlipsApiClient.updateDeliverySlip(
            id,
            data
          );

          if (response.success && response.data) {
            const updatedSlip = response.data;

            // Update in list
            const { deliverySlips } = get();
            const updatedList = deliverySlips.map((slip) =>
              slip.id === id ? updatedSlip : slip
            );

            set({
              deliverySlips: updatedList,
              currentDeliverySlip: updatedSlip,
              isUpdating: false,
            });

            toast.success("Delivery slip updated successfully");
            return updatedSlip;
          } else {
            throw new Error(
              response.error?.message || "Failed to update delivery slip"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error updating delivery slip:", error);
          set({ error: errorMessage, isUpdating: false });
          toast.error(`Failed to update delivery slip: ${errorMessage}`);
          return null;
        }
      },

      // Delete delivery slip
      deleteDeliverySlip: async (id: string) => {
        set({ isDeleting: true, error: null });

        try {
          const response = await deliverySlipsApiClient.deleteDeliverySlip(id);

          if (response.success) {
            // Remove from list
            const { deliverySlips } = get();
            const updatedList = deliverySlips.filter((slip) => slip.id !== id);

            set({
              deliverySlips: updatedList,
              currentDeliverySlip: null,
              isDeleting: false,
            });

            toast.success("Delivery slip deleted successfully");

            // Refresh to get accurate pagination
            get().fetchDeliverySlips();

            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to delete delivery slip"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error deleting delivery slip:", error);
          set({ error: errorMessage, isDeleting: false });
          toast.error(`Failed to delete delivery slip: ${errorMessage}`);
          return false;
        }
      },

      // Add parcels to slip
      addParcelsToSlip: async (
        slipId: string,
        data: AddParcelsToSlipRequest
      ) => {
        try {
          const response = await deliverySlipsApiClient.addParcelsToSlip(
            slipId,
            data
          );

          if (response.success && response.data) {
            const updatedSlip = response.data;

            // Update current slip if it matches
            const { currentDeliverySlip } = get();
            if (currentDeliverySlip?.id === slipId) {
              set({ currentDeliverySlip: updatedSlip });
            }

            // Update in list
            const { deliverySlips } = get();
            const updatedList = deliverySlips.map((slip) =>
              slip.id === slipId ? updatedSlip : slip
            );
            set({ deliverySlips: updatedList });

            toast.success("Parcels added to delivery slip successfully");
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to add parcels to slip"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error adding parcels to slip:", error);
          toast.error(`Failed to add parcels: ${errorMessage}`);
          return false;
        }
      },

      // Remove parcels from slip
      removeParcelsFromSlip: async (
        slipId: string,
        data: RemoveParcelsFromSlipRequest
      ) => {
        try {
          const response = await deliverySlipsApiClient.removeParcelsFromSlip(
            slipId,
            data
          );

          if (response.success && response.data) {
            const updatedSlip = response.data;

            // Update current slip if it matches
            const { currentDeliverySlip } = get();
            if (currentDeliverySlip?.id === slipId) {
              set({ currentDeliverySlip: updatedSlip });
            }

            // Update in list
            const { deliverySlips } = get();
            const updatedList = deliverySlips.map((slip) =>
              slip.id === slipId ? updatedSlip : slip
            );
            set({ deliverySlips: updatedList });

            toast.success("Parcels removed from delivery slip successfully");
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to remove parcels from slip"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error removing parcels from slip:", error);
          toast.error(`Failed to remove parcels: ${errorMessage}`);
          return false;
        }
      },

      // Receive slip
      receiveSlip: async (slipId: string, data: ReceiveSlipRequest) => {
        try {
          const response = await deliverySlipsApiClient.receiveSlip(
            slipId,
            data
          );

          if (response.success && response.data) {
            const updatedSlip = response.data;

            // Update current slip if it matches
            const { currentDeliverySlip } = get();
            if (currentDeliverySlip?.id === slipId) {
              set({ currentDeliverySlip: updatedSlip });
            }

            // Update in list
            const { deliverySlips } = get();
            const updatedList = deliverySlips.map((slip) =>
              slip.id === slipId ? updatedSlip : slip
            );
            set({ deliverySlips: updatedList });

            toast.success("Delivery slip marked as received successfully");
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to receive slip"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error receiving slip:", error);
          toast.error(`Failed to receive slip: ${errorMessage}`);
          return false;
        }
      },

      // Scan parcel into slip
      scanParcelIntoSlip: async (slipId: string, parcelCode: string) => {
        try {
          const response = await deliverySlipsApiClient.scanParcelIntoSlip(
            slipId,
            parcelCode
          );

          if (response.success) {
            toast.success("Parcel scanned successfully");

            // Refresh current slip to get updated data
            if (get().currentDeliverySlip?.id === slipId) {
              get().fetchDeliverySlipById(slipId);
            }

            return true;
          } else {
            throw new Error(response.error?.message || "Failed to scan parcel");
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error scanning parcel:", error);
          toast.error(`Failed to scan parcel: ${errorMessage}`);
          return false;
        }
      },

      // Bulk action
      bulkAction: async (data: BulkSlipActionRequest) => {
        try {
          const response = await deliverySlipsApiClient.bulkAction(data);

          if (response.success && response.data) {
            toast.success(
              `Bulk action completed: ${response.data.success} successful, ${response.data.failed} failed`
            );

            if (response.data.failed > 0) {
              toast.warning(`${response.data.failed} slips failed to process`);
            }

            // Clear selection and refresh
            set({ selectedSlipIds: [] });
            get().fetchDeliverySlips();

            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to execute bulk action"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error executing bulk action:", error);
          toast.error(`Failed to execute bulk action: ${errorMessage}`);
          return false;
        }
      },

      // Fetch available parcels
      fetchAvailableParcels: async (cityId?: string) => {
        try {
          const response = await deliverySlipsApiClient.getAvailableParcels(
            cityId
          );

          if (response.success && response.data) {
            set({ availableParcels: response.data });
          } else {
            throw new Error(
              response.error?.message || "Failed to fetch available parcels"
            );
          }
        } catch (error) {
          console.error("Error fetching available parcels:", error);
          toast.error("Failed to fetch available parcels");
        }
      },

      // Fetch statistics
      fetchStatistics: async () => {
        try {
          const response = await deliverySlipsApiClient.getDeliverySlipStats();

          if (response.success && response.data) {
            set({ statistics: response.data });
          } else {
            throw new Error(
              response.error?.message || "Failed to fetch statistics"
            );
          }
        } catch (error) {
          console.error("Error fetching delivery slip statistics:", error);
        }
      },

      // Download slip PDF
      downloadSlipPdf: async (id: string) => {
        try {
          const response = await deliverySlipsApiClient.downloadSlipPdf(id);

          if (response.success && response.data) {
            // Create download link
            const url = window.URL.createObjectURL(response.data);
            const a = document.createElement("a");
            a.href = url;
            a.download = `delivery-slip-${id}.pdf`;
            a.click();
            window.URL.revokeObjectURL(url);

            toast.success("PDF downloaded successfully");
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to download PDF"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error downloading PDF:", error);
          toast.error(`Failed to download PDF: ${errorMessage}`);
          return false;
        }
      },

      // Download slip labels
      downloadSlipLabels: async (id: string) => {
        try {
          const response = await deliverySlipsApiClient.downloadSlipLabels(id);

          if (response.success && response.data) {
            // Create download link
            const url = window.URL.createObjectURL(response.data);
            const a = document.createElement("a");
            a.href = url;
            a.download = `delivery-slip-labels-${id}.pdf`;
            a.click();
            window.URL.revokeObjectURL(url);

            toast.success("Labels downloaded successfully");
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to download labels"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error downloading labels:", error);
          toast.error(`Failed to download labels: ${errorMessage}`);
          return false;
        }
      },

      // Get slip barcode
      getSlipBarcode: async (id: string) => {
        try {
          const response = await deliverySlipsApiClient.getSlipBarcode(id);

          if (response.success && response.data) {
            return response.data;
          } else {
            throw new Error(response.error?.message || "Failed to get barcode");
          }
        } catch (error) {
          console.error("Error getting barcode:", error);
          toast.error("Failed to get barcode");
          return null;
        }
      },

      // Export delivery slips
      exportDeliverySlips: async (filters?: DeliverySlipFilters) => {
        set({ isLoading: true, error: null });

        try {
          const filtersToUse = filters || get().filters;
          const blob = await deliverySlipsApiClient.exportDeliverySlips(
            filtersToUse
          );

          // Create download link
          const url = window.URL.createObjectURL(blob);
          const link = document.createElement("a");
          link.href = url;
          link.download = `delivery-slips-${
            new Date().toISOString().split("T")[0]
          }.csv`;
          document.body.appendChild(link); // Required for Firefox
          link.click();
          document.body.removeChild(link);
          window.URL.revokeObjectURL(url);

          set({ isLoading: false });
          toast.success("Export completed successfully");
          return url;
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error exporting delivery slips:", error);
          set({ error: errorMessage, isLoading: false });
          toast.error(`Failed to export delivery slips: ${errorMessage}`);
          return null;
        }
      },

      // Utility methods
      getSlipById: (id: string) => {
        return get().deliverySlips.find((slip) => slip.id === id);
      },

      getSlipsByStatus: (status: DeliverySlipStatus) => {
        return get().deliverySlips.filter((slip) => slip.status === status);
      },

      resetState: () => {
        set({
          deliverySlips: [],
          currentDeliverySlip: null,
          availableParcels: [],
          statistics: null,
          error: null,
          pagination: DEFAULT_PAGINATION,
          filters: DEFAULT_FILTERS,
          selectedSlipIds: [],
          isLoading: false,
          isCreating: false,
          isUpdating: false,
          isDeleting: false,
        });
      },

      clearError: () => set({ error: null }),
    }),
    {
      name: "delivery-slips-store",
      partialize: (state) => ({
        filters: state.filters,
        selectedSlipIds: state.selectedSlipIds,
        // Don't persist loading states or large data
      }),
      version: 1,
    }
  )
);
-----------------------------------------------------------------------
--++--> lib/stores/parcels/cities.store.ts =======>
-----------------------------------------------------------------------
import { create } from "zustand";
import { persist } from "zustand/middleware";
import { citiesApiClient } from "@/lib/api/clients/parcels/cities.client";
import type {
  City,
  CreateCityRequest,
  UpdateCityRequest,
  CitiesFilters,
  ZoneStats,
} from "@/lib/types/parcels/cities.types";
import { toast } from "sonner";
interface CitiesState {
  // Core state
  cities: City[];
  currentCity: City | null;
  isLoading: boolean;
  error: string | null;

  // Pagination
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };

  // Filters
  filters: CitiesFilters;

  // Additional data
  pickupCities: City[];
  zoneStats: ZoneStats[];
  availableZones: string[];

  // Selection for bulk operations
  selectedCityIds: string[];

  // Actions
  setCities: (cities: City[]) => void;
  setCurrentCity: (city: City | null) => void;
  setPagination: (pagination: Partial<CitiesState["pagination"]>) => void;
  setFilters: (filters: Partial<CitiesFilters>) => void;
  clearError: () => void;
  setSelectedCityIds: (ids: string[]) => void;

  // API Actions
  fetchCities: () => Promise<void>;
  fetchCityById: (id: string) => Promise<City | null>;
  createCity: (data: CreateCityRequest) => Promise<boolean>;
  updateCity: (id: string, data: UpdateCityRequest) => Promise<boolean>;
  deleteCity: (id: string) => Promise<boolean>;
  toggleCityStatus: (id: string) => Promise<boolean>;
  fetchPickupCities: () => Promise<void>;
  fetchZoneStats: () => Promise<void>;
  fetchAvailableZones: () => Promise<void>;

  // Bulk operations
  bulkDeleteCities: (ids: string[]) => Promise<boolean>;
  bulkUpdateStatus: (ids: string[], status: boolean) => Promise<boolean>;

  // Search and validation
  searchCities: (query: string) => Promise<City[]>;
  validateCityRef: (ref: string, excludeId?: string) => Promise<boolean>;

  // Reset state
  resetState: () => void;
}
const initialState = {
  cities: [],
  currentCity: null,
  isLoading: false,
  error: null,
  pagination: {
    page: 1,
    limit: 10,
    total: 0,
    totalPages: 0,
    hasNext: false,
    hasPrev: false,
  },
  filters: {
    page: 1,
    limit: 10,
  },
  pickupCities: [],
  zoneStats: [],
  availableZones: [],
  selectedCityIds: [],
};
export const useCitiesStore = create<CitiesState>()(
  persist(
    (set, get) => ({
      ...initialState,

      // Setters
      setCities: (cities) => set({ cities }),

      setCurrentCity: (city) => set({ currentCity: city }),

      setPagination: (pagination) =>
        set((state) => ({
          pagination: { ...state.pagination, ...pagination },
        })),

      setFilters: (filters) => {
        set((state) => {
          const newFilters = { ...state.filters, ...filters };
          // Reset to page 1 when filters change (except page change)
          if (filters.page === undefined) {
            newFilters.page = 1;
          }
          return { filters: newFilters };
        });
        // Auto-fetch when filters change
        get().fetchCities();
      },

      clearError: () => set({ error: null }),

      setSelectedCityIds: (ids) => set({ selectedCityIds: ids }),

      // Fetch cities with current filters
      fetchCities: async () => {
        set({ isLoading: true, error: null });

        try {
          const { filters } = get();
          const response = await citiesApiClient.getCities(filters);

          if (response.success && response.data) {
            set({
              cities: response.data.data,
              pagination: response.data.meta,
              isLoading: false,
            });
          } else {
            throw new Error(
              response.error?.message || "Failed to fetch cities"
            );
          }
        } catch (error: any) {
          set({
            isLoading: false,
            error: error.message || "An error occurred while fetching cities",
          });
          toast.error("Failed to fetch cities");
        }
      },

      // Fetch single city by ID
      fetchCityById: async (id: string) => {
        set({ isLoading: true, error: null });

        try {
          const response = await citiesApiClient.getCityById(id);

          if (response.success && response.data) {
            set({ currentCity: response.data, isLoading: false });
            return response.data;
          } else {
            throw new Error(response.error?.message || "City not found");
          }
        } catch (error: any) {
          set({
            isLoading: false,
            error: error.message || "Failed to fetch city",
          });
          toast.error("Failed to fetch city details");
          return null;
        }
      },

      // Create new city
      createCity: async (data: CreateCityRequest) => {
        set({ isLoading: true, error: null });

        try {
          const response = await citiesApiClient.createCity(data);

          if (response.success && response.data) {
            // Add to local state
            set((state) => ({
              cities: [response.data!, ...state.cities],
              isLoading: false,
            }));

            toast.success("City created successfully");
            return true;
          } else {
            throw new Error(response.error?.message || "Failed to create city");
          }
        } catch (error: any) {
          set({
            isLoading: false,
            error: error.message || "Failed to create city",
          });
          toast.error(error.message || "Failed to create city");
          return false;
        }
      },

      // Update city
      updateCity: async (id: string, data: UpdateCityRequest) => {
        set({ isLoading: true, error: null });

        try {
          const response = await citiesApiClient.updateCity(id, data);

          if (response.success && response.data) {
            // Update in local state
            set((state) => ({
              cities: state.cities.map((city) =>
                city.id === id ? response.data! : city
              ),
              currentCity:
                state.currentCity?.id === id
                  ? response.data!
                  : state.currentCity,
              isLoading: false,
            }));

            toast.success("City updated successfully");
            return true;
          } else {
            throw new Error(response.error?.message || "Failed to update city");
          }
        } catch (error: any) {
          set({
            isLoading: false,
            error: error.message || "Failed to update city",
          });
          toast.error(error.message || "Failed to update city");
          return false;
        }
      },

      // Delete city
      deleteCity: async (id: string) => {
        set({ isLoading: true, error: null });

        try {
          const response = await citiesApiClient.deleteCity(id);

          if (response.success) {
            // Remove from local state
            set((state) => ({
              cities: state.cities.filter((city) => city.id !== id),
              currentCity:
                state.currentCity?.id === id ? null : state.currentCity,
              isLoading: false,
            }));

            toast.success("City deleted successfully");
            return true;
          } else {
            throw new Error(response.error?.message || "Failed to delete city");
          }
        } catch (error: any) {
          set({
            isLoading: false,
            error: error.message || "Failed to delete city",
          });
          toast.error(error.message || "Failed to delete city");
          return false;
        }
      },

      // Toggle city status
      toggleCityStatus: async (id: string) => {
        try {
          const response = await citiesApiClient.toggleCityStatus(id);

          if (response.success && response.data) {
            // Update in local state
            set((state) => ({
              cities: state.cities.map((city) =>
                city.id === id ? response.data! : city
              ),
              currentCity:
                state.currentCity?.id === id
                  ? response.data!
                  : state.currentCity,
            }));

            const status = response.data.status ? "activated" : "deactivated";
            toast.success(`City ${status} successfully`);
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to toggle city status"
            );
          }
        } catch (error: any) {
          toast.error(error.message || "Failed to toggle city status");
          return false;
        }
      },

      // Fetch pickup cities
      fetchPickupCities: async () => {
        try {
          const response = await citiesApiClient.getPickupCities();

          if (response.success && response.data) {
            set({ pickupCities: response.data });
          }
        } catch (error: any) {
          console.error("Failed to fetch pickup cities:", error);
        }
      },

      // Fetch zone statistics
      fetchZoneStats: async () => {
        try {
          const response = await citiesApiClient.getZoneStats();

          if (response.success && response.data) {
            set({ zoneStats: response.data });
          }
        } catch (error: any) {
          console.error("Failed to fetch zone stats:", error);
        }
      },

      // Fetch available zones
      fetchAvailableZones: async () => {
        try {
          const response = await citiesApiClient.getAvailableZones();

          if (response.success && response.data) {
            set({ availableZones: response.data });
          }
        } catch (error: any) {
          console.error("Failed to fetch available zones:", error);
        }
      },

      // Bulk delete cities
      bulkDeleteCities: async (ids: string[]) => {
        set({ isLoading: true, error: null });

        try {
          const response = await citiesApiClient.bulkDeleteCities(ids);

          if (response.success) {
            // Remove from local state
            set((state) => ({
              cities: state.cities.filter((city) => !ids.includes(city.id)),
              selectedCityIds: [],
              isLoading: false,
            }));

            toast.success(
              `${
                response.data?.deleted || ids.length
              } cities deleted successfully`
            );
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to delete cities"
            );
          }
        } catch (error: any) {
          set({
            isLoading: false,
            error: error.message || "Failed to delete cities",
          });
          toast.error(error.message || "Failed to delete cities");
          return false;
        }
      },

      // Bulk update status
      bulkUpdateStatus: async (ids: string[], status: boolean) => {
        set({ isLoading: true, error: null });

        try {
          const response = await citiesApiClient.bulkUpdateCitiesStatus(
            ids,
            status
          );

          if (response.success) {
            // Update in local state
            set((state) => ({
              cities: state.cities.map((city) =>
                ids.includes(city.id) ? { ...city, status } : city
              ),
              selectedCityIds: [],
              isLoading: false,
            }));

            const action = status ? "activated" : "deactivated";
            toast.success(
              `${
                response.data?.updated || ids.length
              } cities ${action} successfully`
            );
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to update cities"
            );
          }
        } catch (error: any) {
          set({
            isLoading: false,
            error: error.message || "Failed to update cities",
          });
          toast.error(error.message || "Failed to update cities");
          return false;
        }
      },

      // Search cities
      searchCities: async (query: string) => {
        try {
          const response = await citiesApiClient.searchCities(query);

          if (response.success && response.data) {
            return response.data;
          }
          return [];
        } catch (error) {
          console.error("Failed to search cities:", error);
          return [];
        }
      },

      // Validate city reference
      validateCityRef: async (ref: string, excludeId?: string) => {
        try {
          const response = await citiesApiClient.validateCityRef(
            ref,
            excludeId
          );

          if (response.success && response.data) {
            return response.data.isUnique;
          }
          return false;
        } catch (error) {
          console.error("Failed to validate city reference:", error);
          return false;
        }
      },

      // Reset state
      resetState: () => set(initialState),
    }),
    {
      name: "cities-store",
      partialize: (state) => ({
        filters: state.filters,
        pagination: state.pagination,
      }),
      version: 1,
    }
  )
);
-----------------------------------------------------------------------
--++--> lib/stores/parcels/pickup-cities.store.ts =======>
-----------------------------------------------------------------------
import { create } from "zustand";
import { persist } from "zustand/middleware";
import { pickupCitiesApiClient } from "@/lib/api/clients/parcels/pickup-cities.client";
import type {
  PickupCity,
  CreatePickupCityRequest,
  UpdatePickupCityRequest,
  PickupCityFilters,
  PaginatedResponse,
  PickupCityStatistics,
} from "@/lib/types/parcels/pickup-cities.types";
import { toast } from "sonner";
interface PickupCitiesState {
  // Core state
  pickupCities: PickupCity[];
  activePickupCities: PickupCity[];
  selectedPickupCity: PickupCity | null;
  statistics: PickupCityStatistics | null;

  // UI state
  isLoading: boolean;
  isCreating: boolean;
  isUpdating: boolean;
  isDeleting: boolean;
  error: string | null;

  // Pagination state
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };

  // Filters state
  filters: PickupCityFilters;

  // Selection state for bulk operations
  selectedIds: string[];

  // Actions
  setFilters: (filters: Partial<PickupCityFilters>) => void;
  clearFilters: () => void;
  setSelectedIds: (ids: string[]) => void;
  clearSelectedIds: () => void;

  // API Actions
  fetchPickupCities: () => Promise<void>;
  fetchActivePickupCities: () => Promise<void>;
  fetchPickupCityById: (id: string) => Promise<PickupCity | null>;
  createPickupCity: (
    data: CreatePickupCityRequest
  ) => Promise<PickupCity | null>;
  updatePickupCity: (
    id: string,
    data: UpdatePickupCityRequest
  ) => Promise<PickupCity | null>;
  deletePickupCity: (id: string) => Promise<boolean>;
  togglePickupCityStatus: (id: string) => Promise<boolean>;

  // Bulk operations
  bulkDeletePickupCities: (ids: string[]) => Promise<boolean>;
  bulkToggleStatus: (ids: string[], status: boolean) => Promise<boolean>;

  // Statistics
  fetchStatistics: () => Promise<void>;

  // Utility methods
  getPickupCityById: (id: string) => PickupCity | undefined;
  resetState: () => void;
  clearError: () => void;
}
const DEFAULT_FILTERS: PickupCityFilters = {
  page: 1,
  limit: 10,
  search: "",
  sortBy: "name",
  sortParcel: "asc",
};
const DEFAULT_PAGINATION = {
  page: 1,
  limit: 10,
  total: 0,
  totalPages: 0,
  hasNext: false,
  hasPrev: false,
};
export const usePickupCitiesStore = create<PickupCitiesState>()(
  persist(
    (set, get) => ({
      // Initial state
      pickupCities: [],
      activePickupCities: [],
      selectedPickupCity: null,
      statistics: null,
      isLoading: false,
      isCreating: false,
      isUpdating: false,
      isDeleting: false,
      error: null,
      pagination: DEFAULT_PAGINATION,
      filters: DEFAULT_FILTERS,
      selectedIds: [],

      // Filter actions
      setFilters: (newFilters) => {
        const updatedFilters = { ...get().filters, ...newFilters };
        set({ filters: updatedFilters });

        // Reset to page 1 if search or other filters changed
        if ("search" in newFilters || "status" in newFilters) {
          set({ filters: { ...updatedFilters, page: 1 } });
        }

        // Auto-fetch with new filters
        get().fetchPickupCities();
      },

      clearFilters: () => {
        set({ filters: DEFAULT_FILTERS });
        get().fetchPickupCities();
      },

      setSelectedIds: (ids) => set({ selectedIds: ids }),
      clearSelectedIds: () => set({ selectedIds: [] }),

      // Fetch pickup cities with filters and pagination
      fetchPickupCities: async () => {
        const { filters } = get();
        set({ isLoading: true, error: null });

        try {
          const response = await pickupCitiesApiClient.getPickupCities(filters);

          if (response.success && response.data) {
            set({
              pickupCities: response.data.data,
              pagination: response.data.meta,
              isLoading: false,
            });
          } else {
            throw new Error(
              response.error?.message || "Failed to fetch pickup cities"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error fetching pickup cities:", error);
          set({ error: errorMessage, isLoading: false });
          toast.error("Failed to fetch pickup cities");
        }
      },

      // Fetch active pickup cities only
      fetchActivePickupCities: async () => {
        try {
          const response = await pickupCitiesApiClient.getActivePickupCities();

          if (response.success && response.data) {
            set({ activePickupCities: response.data });
          } else {
            throw new Error(
              response.error?.message || "Failed to fetch active pickup cities"
            );
          }
        } catch (error) {
          console.error("Error fetching active pickup cities:", error);
          toast.error("Failed to fetch active pickup cities");
        }
      },

      // Fetch pickup city by ID
      fetchPickupCityById: async (id: string) => {
        set({ isLoading: true, error: null });

        try {
          const response = await pickupCitiesApiClient.getPickupCityById(id);

          if (response.success && response.data) {
            set({ selectedPickupCity: response.data, isLoading: false });
            return response.data;
          } else {
            throw new Error(response.error?.message || "Pickup city not found");
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error fetching pickup city:", error);
          set({
            error: errorMessage,
            isLoading: false,
            selectedPickupCity: null,
          });
          toast.error("Failed to fetch pickup city");
          return null;
        }
      },

      // Create pickup city
      createPickupCity: async (data: CreatePickupCityRequest) => {
        set({ isCreating: true, error: null });

        try {
          const response = await pickupCitiesApiClient.createPickupCity(data);

          if (response.success && response.data) {
            const newPickupCity = response.data;

            // Add to list if it matches current filters
            const { pickupCities } = get();
            set({
              pickupCities: [newPickupCity, ...pickupCities],
              isCreating: false,
            });

            toast.success("Pickup city created successfully");

            // Refresh the list to get accurate pagination
            get().fetchPickupCities();

            return newPickupCity;
          } else {
            throw new Error(
              response.error?.message || "Failed to create pickup city"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error creating pickup city:", error);
          set({ error: errorMessage, isCreating: false });
          toast.error(`Failed to create pickup city: ${errorMessage}`);
          return null;
        }
      },

      // Update pickup city
      updatePickupCity: async (id: string, data: UpdatePickupCityRequest) => {
        set({ isUpdating: true, error: null });

        try {
          const response = await pickupCitiesApiClient.updatePickupCity(
            id,
            data
          );

          if (response.success && response.data) {
            const updatedPickupCity = response.data;

            // Update in list
            const { pickupCities } = get();
            const updatedList = pickupCities.map((city) =>
              city.id === id ? updatedPickupCity : city
            );

            set({
              pickupCities: updatedList,
              selectedPickupCity: updatedPickupCity,
              isUpdating: false,
            });

            toast.success("Pickup city updated successfully");
            return updatedPickupCity;
          } else {
            throw new Error(
              response.error?.message || "Failed to update pickup city"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error updating pickup city:", error);
          set({ error: errorMessage, isUpdating: false });
          toast.error(`Failed to update pickup city: ${errorMessage}`);
          return null;
        }
      },

      // Delete pickup city
      deletePickupCity: async (id: string) => {
        set({ isDeleting: true, error: null });

        try {
          const response = await pickupCitiesApiClient.deletePickupCity(id);

          if (response.success) {
            // Remove from list
            const { pickupCities } = get();
            const updatedList = pickupCities.filter((city) => city.id !== id);

            set({
              pickupCities: updatedList,
              selectedPickupCity: null,
              isDeleting: false,
            });

            toast.success("Pickup city deleted successfully");

            // Refresh to get accurate pagination
            get().fetchPickupCities();

            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to delete pickup city"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error deleting pickup city:", error);
          set({ error: errorMessage, isDeleting: false });
          toast.error(`Failed to delete pickup city: ${errorMessage}`);
          return false;
        }
      },

      // Toggle pickup city status
      togglePickupCityStatus: async (id: string) => {
        try {
          const response = await pickupCitiesApiClient.togglePickupCityStatus(
            id
          );

          if (response.success && response.data) {
            const updatedPickupCity = response.data;

            // Update in list
            const { pickupCities } = get();
            const updatedList = pickupCities.map((city) =>
              city.id === id ? updatedPickupCity : city
            );

            set({
              pickupCities: updatedList,
              selectedPickupCity: updatedPickupCity,
            });

            const status = updatedPickupCity.status
              ? "activated"
              : "deactivated";
            toast.success(`Pickup city ${status} successfully`);

            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to toggle pickup city status"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error toggling pickup city status:", error);
          toast.error(`Failed to toggle status: ${errorMessage}`);
          return false;
        }
      },

      // Bulk delete pickup cities
      bulkDeletePickupCities: async (ids: string[]) => {
        set({ isDeleting: true, error: null });

        try {
          const response = await pickupCitiesApiClient.bulkDeletePickupCities(
            ids
          );

          if (response.success && response.data) {
            toast.success(
              `${response.data.successful} pickup cities deleted successfully`
            );

            if (response.data.failed.length > 0) {
              toast.warning(
                `${response.data.failed.length} pickup cities could not be deleted`
              );
            }

            // Clear selection and refresh
            set({ selectedIds: [], isDeleting: false });
            get().fetchPickupCities();

            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to delete pickup cities"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error bulk deleting pickup cities:", error);
          set({ error: errorMessage, isDeleting: false });
          toast.error(`Failed to delete pickup cities: ${errorMessage}`);
          return false;
        }
      },

      // Bulk toggle status
      bulkToggleStatus: async (ids: string[], status: boolean) => {
        try {
          const response = await pickupCitiesApiClient.bulkToggleStatus(
            ids,
            status
          );

          if (response.success && response.data) {
            const action = status ? "activated" : "deactivated";
            toast.success(
              `${response.data.successful} pickup cities ${action} successfully`
            );

            if (response.data.failed.length > 0) {
              toast.warning(
                `${response.data.failed.length} pickup cities could not be ${action}`
              );
            }

            // Clear selection and refresh
            set({ selectedIds: [] });
            get().fetchPickupCities();

            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to update pickup city status"
            );
          }
        } catch (error) {
          const errorMessage =
            error instanceof Error
              ? error.message
              : "An unexpected error occurred";
          console.error("Error bulk toggling pickup city status:", error);
          toast.error(`Failed to update status: ${errorMessage}`);
          return false;
        }
      },

      // Fetch statistics
      fetchStatistics: async () => {
        try {
          const response =
            await pickupCitiesApiClient.getPickupCityStatistics();

          if (response.success && response.data) {
            set({ statistics: response.data });
          } else {
            throw new Error(
              response.error?.message || "Failed to fetch statistics"
            );
          }
        } catch (error) {
          console.error("Error fetching pickup city statistics:", error);
        }
      },

      // Utility methods
      getPickupCityById: (id: string) => {
        const { pickupCities } = get();
        return pickupCities.find((city) => city.id === id);
      },

      resetState: () => {
        set({
          pickupCities: [],
          activePickupCities: [],
          selectedPickupCity: null,
          statistics: null,
          error: null,
          pagination: DEFAULT_PAGINATION,
          filters: DEFAULT_FILTERS,
          selectedIds: [],
          isLoading: false,
          isCreating: false,
          isUpdating: false,
          isDeleting: false,
        });
      },

      clearError: () => set({ error: null }),
    }),
    {
      name: "pickup-cities-store",
      partialize: (state) => ({
        activePickupCities: state.activePickupCities,
        statistics: state.statistics,
        // Don't persist loading states or selections
      }),
      version: 1,
    }
  )
);
-----------------------------------------------------------------------
--++--> lib/stores/parcels/tariffs.store.ts =======>
-----------------------------------------------------------------------
import { create } from "zustand";
import { tariffsApiClient } from "@/lib/api/clients/parcels/tariffs.client";
import type {
  Tariff,
  CreateTariffRequest,
  UpdateTariffRequest,
  TariffFilters,
  TariffCalculationRequest,
  TariffCalculationResult,
  BulkTariffImportRequest,
  BulkImportResult,
} from "@/lib/types/parcels/tariffs.types";
import { toast } from "sonner";
interface TariffState {
  // State
  tariffs: Tariff[];
  currentTariff: Tariff | null;
  isLoading: boolean;
  error: string | null;

  // Pagination
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };

  // Filters
  filters: TariffFilters;

  // Stats
  stats: {
    totalTariffs: number;
    averageDeliveryPrice: number;
    averageReturnPrice: number;
    averageRefusalPrice: number;
    averageDeliveryDelay: number;
    priceRanges: { range: string; count: number }[];
    delayDistribution: { delay: number; count: number }[];
    cityPairCoverage: {
      totalPossiblePairs: number;
      configuredPairs: number;
      coveragePercentage: number;
    };
  } | null;

  // Missing tariffs
  missingTariffs: Array<{
    pickupCityId: string;
    destinationCityId: string;
    pickupCity: {
      id: string;
      name: string;
      ref: string;
    };
    destinationCity: {
      id: string;
      name: string;
      ref: string;
    };
    route: string;
  }>;

  // Calculation result
  calculationResult: TariffCalculationResult | null;

  // Actions
  fetchTariffs: () => Promise<void>;
  fetchTariffById: (id: string) => Promise<void>;
  createTariff: (data: CreateTariffRequest) => Promise<boolean>;
  updateTariff: (id: string, data: UpdateTariffRequest) => Promise<boolean>;
  deleteTariff: (id: string) => Promise<boolean>;
  bulkImportTariffs: (
    data: BulkTariffImportRequest
  ) => Promise<BulkImportResult | null>;
  calculateTariff: (data: TariffCalculationRequest) => Promise<boolean>;
  fetchStats: () => Promise<void>;
  fetchMissingTariffs: () => Promise<void>;
  validateRoute: (
    pickupCityId: string,
    destinationCityId: string,
    excludeId?: string
  ) => Promise<boolean>;
  duplicateTariff: (
    id: string,
    pickupCityId: string,
    destinationCityId: string
  ) => Promise<boolean>;

  // Filter actions
  setFilters: (filters: Partial<TariffFilters>) => void;
  resetFilters: () => void;

  // Utility actions
  setCurrentTariff: (tariff: Tariff | null) => void;
  clearError: () => void;
  clearCalculationResult: () => void;
}
const initialFilters: TariffFilters = {
  page: 1,
  limit: 10,
  search: "",
};
export const useTariffsStore = create<TariffState>((set, get) => ({
  // Initial state
  tariffs: [],
  currentTariff: null,
  isLoading: false,
  error: null,
  pagination: {
    page: 1,
    limit: 10,
    total: 0,
    totalPages: 0,
    hasNext: false,
    hasPrev: false,
  },
  filters: initialFilters,
  stats: null,
  missingTariffs: [],
  calculationResult: null,

  // Fetch tariffs with filters
  fetchTariffs: async () => {
    const { filters } = get();
    set({ isLoading: true, error: null });

    try {
      const result = await tariffsApiClient.getTariffs(filters);

      if (result.data) {
        set({
          tariffs: result.data[0].data,
          pagination: result.data[0].meta,
          isLoading: false,
        });
      } else {
        throw new Error("Failed to fetch tariffs");
      }
    } catch (error: any) {
      console.error("Error fetching tariffs:", error);
      set({
        error: error?.message || "Failed to fetch tariffs",
        isLoading: false,
      });
      toast.error("Failed to fetch tariffs");
    }
  },

  // Fetch single tariff
  fetchTariffById: async (id: string) => {
    set({ isLoading: true, error: null });

    try {
      const result = await tariffsApiClient.getTariffById(id);

      if (result.success && result.data) {
        set({
          currentTariff: result.data,
          isLoading: false,
        });
      } else {
        throw new Error(result.error?.message || "Failed to fetch tariff");
      }
    } catch (error: any) {
      console.error("Error fetching tariff:", error);
      set({
        error: error?.message || "Failed to fetch tariff",
        isLoading: false,
      });
      toast.error("Failed to fetch tariff details");
    }
  },

  // Create tariff
  createTariff: async (data: CreateTariffRequest) => {
    set({ isLoading: true, error: null });

    try {
      const result = await tariffsApiClient.createTariff(data);

      if (result.success && result.data) {
        // Refresh the list
        await get().fetchTariffs();
        set({ isLoading: false });
        toast.success("Tariff created successfully");
        return true;
      } else {
        throw new Error(result.error?.message || "Failed to create tariff");
      }
    } catch (error: any) {
      console.error("Error creating tariff:", error);
      const errorMessage = error?.message || "Failed to create tariff";
      set({
        error: errorMessage,
        isLoading: false,
      });
      toast.error(errorMessage);
      return false;
    }
  },

  // Update tariff
  updateTariff: async (id: string, data: UpdateTariffRequest) => {
    set({ isLoading: true, error: null });

    try {
      const result = await tariffsApiClient.updateTariff(id, data);

      if (result.success && result.data) {
        const { tariffs, currentTariff } = get();

        // Update in list
        const updatedTariffs = tariffs.map((tariff) =>
          tariff.id === id ? result.data! : tariff
        );

        set({
          tariffs: updatedTariffs,
          currentTariff:
            currentTariff?.id === id ? result.data! : currentTariff,
          isLoading: false,
        });

        toast.success("Tariff updated successfully");
        return true;
      } else {
        throw new Error(result.error?.message || "Failed to update tariff");
      }
    } catch (error: any) {
      console.error("Error updating tariff:", error);
      const errorMessage = error?.message || "Failed to update tariff";
      set({
        error: errorMessage,
        isLoading: false,
      });
      toast.error(errorMessage);
      return false;
    }
  },

  // Delete tariff
  deleteTariff: async (id: string) => {
    set({ isLoading: true, error: null });

    try {
      const result = await tariffsApiClient.deleteTariff(id);

      if (result.success) {
        const { tariffs, currentTariff } = get();

        // Remove from list
        const updatedTariffs = tariffs.filter((tariff) => tariff.id !== id);

        set({
          tariffs: updatedTariffs,
          currentTariff: currentTariff?.id === id ? null : currentTariff,
          isLoading: false,
        });

        toast.success("Tariff deleted successfully");
        return true;
      } else {
        throw new Error(result.error?.message || "Failed to delete tariff");
      }
    } catch (error: any) {
      console.error("Error deleting tariff:", error);
      const errorMessage = error?.message || "Failed to delete tariff";
      set({
        error: errorMessage,
        isLoading: false,
      });
      toast.error(errorMessage);
      return false;
    }
  },

  // Bulk import tariffs
  bulkImportTariffs: async (data: BulkTariffImportRequest) => {
    set({ isLoading: true, error: null });

    try {
      const result = await tariffsApiClient.bulkImportTariffs(data);

      if (result.success && result.data) {
        // Refresh the list
        await get().fetchTariffs();
        set({ isLoading: false });

        const importResult = result.data;
        if (importResult.failed > 0) {
          toast.warning(
            `Import completed: ${importResult.success} successful, ${importResult.failed} failed`
          );
        } else {
          toast.success(
            `Successfully imported ${importResult.success} tariffs`
          );
        }

        return importResult;
      } else {
        throw new Error(result.error?.message || "Failed to import tariffs");
      }
    } catch (error: any) {
      console.error("Error importing tariffs:", error);
      const errorMessage = error?.message || "Failed to import tariffs";
      set({
        error: errorMessage,
        isLoading: false,
      });
      toast.error(errorMessage);
      return null;
    }
  },

  // Calculate tariff
  calculateTariff: async (data: TariffCalculationRequest) => {
    set({ isLoading: true, error: null });

    try {
      const result = await tariffsApiClient.calculateTariff(data);

      if (result.success && result.data) {
        set({
          calculationResult: result.data,
          isLoading: false,
        });
        return true;
      } else {
        throw new Error(
          result.error?.message || "No tariff found for this route"
        );
      }
    } catch (error: any) {
      console.error("Error calculating tariff:", error);
      const errorMessage = error?.message || "Failed to calculate tariff";
      set({
        error: errorMessage,
        isLoading: false,
        calculationResult: null,
      });
      toast.error(errorMessage);
      return false;
    }
  },

  // Fetch stats
  fetchStats: async () => {
    try {
      const result = await tariffsApiClient.getTariffStats();

      if (result.success && result.data) {
        set({ stats: result.data });
      }
    } catch (error) {
      console.error("Error fetching tariff stats:", error);
    }
  },

  // Fetch missing tariffs
  fetchMissingTariffs: async () => {
    try {
      const result = await tariffsApiClient.getMissingTariffs();

      if (result.success && result.data) {
        set({ missingTariffs: result.data });
      }
    } catch (error) {
      console.error("Error fetching missing tariffs:", error);
    }
  },

  // Validate route
  validateRoute: async (
    pickupCityId: string,
    destinationCityId: string,
    excludeId?: string
  ) => {
    try {
      const result = await tariffsApiClient.validateTariffRoute(
        pickupCityId,
        destinationCityId,
        excludeId
      );

      if (result.success && result.data) {
        if (result.data.exists) {
          toast.error("A tariff already exists for this route");
          return false;
        }
        return true;
      }
      return true;
    } catch (error) {
      console.error("Error validating route:", error);
      return true; // Allow on validation error
    }
  },

  // Duplicate tariff
  duplicateTariff: async (
    id: string,
    pickupCityId: string,
    destinationCityId: string
  ) => {
    set({ isLoading: true, error: null });

    try {
      const result = await tariffsApiClient.duplicateTariff(
        id,
        pickupCityId,
        destinationCityId
      );

      if (result.success && result.data) {
        await get().fetchTariffs();
        set({ isLoading: false });
        toast.success("Tariff duplicated successfully");
        return true;
      } else {
        throw new Error(result.error?.message || "Failed to duplicate tariff");
      }
    } catch (error: any) {
      console.error("Error duplicating tariff:", error);
      const errorMessage = error?.message || "Failed to duplicate tariff";
      set({
        error: errorMessage,
        isLoading: false,
      });
      toast.error(errorMessage);
      return false;
    }
  },

  // Filter actions
  setFilters: (newFilters: Partial<TariffFilters>) => {
    const { filters } = get();
    const updatedFilters = { ...filters, ...newFilters };

    // Reset to page 1 when filters change (except for page changes)
    if (!newFilters.page) {
      updatedFilters.page = 1;
    }

    set({ filters: updatedFilters });

    // Auto-fetch when filters change
    get().fetchTariffs();
  },

  resetFilters: () => {
    set({ filters: initialFilters });
    get().fetchTariffs();
  },

  // Utility actions
  setCurrentTariff: (tariff: Tariff | null) => {
    set({ currentTariff: tariff });
  },

  clearError: () => {
    set({ error: null });
  },

  clearCalculationResult: () => {
    set({ calculationResult: null });
  },
}));
-----------------------------------------------------------------------
--++--> lib/stores/parcels/zones.store.ts =======>
-----------------------------------------------------------------------
import { create } from "zustand";
import { persist } from "zustand/middleware";
import { zonesApiClient } from "@/lib/api/clients/parcels/zones.client";
import { citiesApiClient } from "@/lib/api/clients/parcels/cities.client";
import type {
  Zone,
  CreateZoneRequest,
  UpdateZoneRequest,
  ZoneFilters,
  ZoneStatistics,
  AvailableCity,
} from "@/lib/types/parcels/zones.types";
import { toast } from "sonner";
interface ZonesState {
  // Data state
  zones: Zone[];
  activeZones: Zone[];
  currentZone: Zone | null;
  availableCities: AvailableCity[];
  statistics: ZoneStatistics | null;

  // UI state
  loading: boolean;
  error: string | null;
  filters: ZoneFilters;
  selectedZones: string[];

  // Pagination
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };

  // Actions
  setFilters: (filters: Partial<ZoneFilters>) => void;
  clearFilters: () => void;
  setSelectedZones: (zoneIds: string[]) => void;
  clearSelection: () => void;
  setError: (error: string | null) => void;
  clearError: () => void;

  // API actions
  fetchZones: (filters?: ZoneFilters) => Promise<void>;
  fetchActiveZones: () => Promise<void>;
  fetchZoneById: (id: string) => Promise<Zone | null>;
  fetchAvailableCities: () => Promise<void>;
  fetchStatistics: () => Promise<void>;

  // CRUD operations
  createZone: (data: CreateZoneRequest) => Promise<Zone | null>;
  updateZone: (id: string, data: UpdateZoneRequest) => Promise<Zone | null>;
  deleteZone: (id: string) => Promise<boolean>;
  toggleZoneStatus: (id: string) => Promise<boolean>;

  // Zone cities management
  addCitiesToZone: (zoneId: string, cityIds: string[]) => Promise<boolean>;
  removeCitiesFromZone: (zoneId: string, cityIds: string[]) => Promise<boolean>;

  // Bulk operations
  bulkDeleteZones: (zoneIds: string[]) => Promise<boolean>;
  bulkToggleStatus: (zoneIds: string[]) => Promise<boolean>;

  // Export
  exportZones: (filters?: ZoneFilters) => Promise<string | null>;

  // Utility methods
  getZoneById: (id: string) => Zone | undefined;
  getZonesByStatus: (status: boolean) => Zone[];
  getZonesCount: () => { total: number; active: number; inactive: number };
  refreshData: () => Promise<void>;
}
const DEFAULT_FILTERS: ZoneFilters = {
  page: 1,
  limit: 10,
  search: "",
  status: undefined,
};
const DEFAULT_PAGINATION = {
  page: 1,
  limit: 10,
  total: 0,
  totalPages: 0,
  hasNext: false,
  hasPrev: false,
};
export const useZonesStore = create<ZonesState>()(
  persist(
    (set, get) => ({
      // Initial state
      zones: [],
      activeZones: [],
      currentZone: null,
      availableCities: [],
      statistics: null,
      loading: false,
      error: null,
      filters: DEFAULT_FILTERS,
      selectedZones: [],
      pagination: DEFAULT_PAGINATION,

      // Filter and selection actions
      setFilters: (newFilters) => {
        const currentFilters = get().filters;
        const updatedFilters = { ...currentFilters, ...newFilters };

        // Reset page when filters change (except page itself)
        if (Object.keys(newFilters).some((key) => key !== "page")) {
          updatedFilters.page = 1;
        }

        set({ filters: updatedFilters });
        get().fetchZones(updatedFilters);
      },

      clearFilters: () => {
        set({ filters: DEFAULT_FILTERS });
        get().fetchZones(DEFAULT_FILTERS);
      },

      setSelectedZones: (zoneIds) => set({ selectedZones: zoneIds }),

      clearSelection: () => set({ selectedZones: [] }),

      setError: (error) => set({ error }),

      clearError: () => set({ error: null }),

      // Fetch zones with filters
      fetchZones: async (filters) => {
        set({ loading: true, error: null });

        try {
          const filtersToUse = filters || get().filters;
          const response = await zonesApiClient.getZones(filtersToUse);

          if (response.data) {
            set({
              zones: response.data[0].data,
              pagination: response.data[0].meta,
              loading: false,
            });
          } else {
            throw new Error(response.error?.message || "Failed to fetch zones");
          }
        } catch (error: any) {
          console.error("Error fetching zones:", error);
          set({
            error: error.message || "Failed to fetch zones",
            loading: false,
          });
          toast.error("Failed to fetch zones");
        }
      },

      // Fetch active zones only
      fetchActiveZones: async () => {
        try {
          const response = await zonesApiClient.getActiveZones();

          if (response.success && response.data) {
            set({ activeZones: response.data });
          }
        } catch (error: any) {
          console.error("Error fetching active zones:", error);
          toast.error("Failed to fetch active zones");
        }
      },

      // Fetch single zone
      fetchZoneById: async (id) => {
        set({ loading: true, error: null });

        try {
          const response = await zonesApiClient.getZoneById(id);

          if (response.success && response.data) {
            set({
              currentZone: response.data,
              loading: false,
            });
            return response.data;
          } else {
            throw new Error(response.error?.message || "Zone not found");
          }
        } catch (error: any) {
          console.error("Error fetching zone:", error);
          set({
            error: error.message || "Failed to fetch zone",
            loading: false,
            currentZone: null,
          });
          toast.error("Failed to fetch zone details");
          return null;
        }
      },

      // Fetch available cities for zone assignment
      fetchAvailableCities: async () => {
        try {
          const response = await citiesApiClient.getCities({
            page: 1,
            limit: 100,
            status: true,
          });

          if (response.success && response.data) {
            set({ availableCities: response.data.data });
          }
        } catch (error: any) {
          console.error("Error fetching available cities:", error);
          toast.error("Failed to fetch cities");
        }
      },

      // Fetch statistics
      fetchStatistics: async () => {
        try {
          const response = await zonesApiClient.getZoneStatistics();

          if (response.success && response.data) {
            set({ statistics: response.data });
          }
        } catch (error: any) {
          console.error("Error fetching zone statistics:", error);
        }
      },

      // Create zone
      createZone: async (data) => {
        set({ loading: true, error: null });

        try {
          const response = await zonesApiClient.createZone(data);

          if (response.success && response.data) {
            // Add to zones list
            const currentZones = get().zones;
            set({
              zones: [response.data, ...currentZones],
              loading: false,
            });

            // Update active zones if the new zone is active
            if (response.data.status) {
              get().fetchActiveZones();
            }

            // Update statistics
            get().fetchStatistics();

            toast.success("Zone created successfully");
            return response.data;
          } else {
            throw new Error(response.error?.message || "Failed to create zone");
          }
        } catch (error: any) {
          console.error("Error creating zone:", error);
          set({
            error: error.message || "Failed to create zone",
            loading: false,
          });
          toast.error(error.message || "Failed to create zone");
          return null;
        }
      },

      // Update zone
      updateZone: async (id, data) => {
        set({ loading: true, error: null });

        try {
          const response = await zonesApiClient.updateZone(id, data);

          if (response.success && response.data) {
            // Update in zones list
            const currentZones = get().zones;
            const updatedZones = currentZones.map((zone) =>
              zone.id === id ? response.data : zone
            );

            set({
              zones: updatedZones,
              currentZone: response.data,
              loading: false,
            });

            // Refresh active zones
            get().fetchActiveZones();

            // Update statistics
            get().fetchStatistics();

            toast.success("Zone updated successfully");
            return response.data;
          } else {
            throw new Error(response.error?.message || "Failed to update zone");
          }
        } catch (error: any) {
          console.error("Error updating zone:", error);
          set({
            error: error.message || "Failed to update zone",
            loading: false,
          });
          toast.error(error.message || "Failed to update zone");
          return null;
        }
      },

      // Delete zone
      deleteZone: async (id) => {
        try {
          const response = await zonesApiClient.deleteZone(id);

          if (response.success) {
            // Remove from zones list
            const currentZones = get().zones;
            const updatedZones = currentZones.filter((zone) => zone.id !== id);

            set({
              zones: updatedZones,
              currentZone: null,
            });

            // Update selected zones if needed
            const selectedZones = get().selectedZones;
            if (selectedZones.includes(id)) {
              set({
                selectedZones: selectedZones.filter((zoneId) => zoneId !== id),
              });
            }

            // Refresh active zones and statistics
            get().fetchActiveZones();
            get().fetchStatistics();

            toast.success("Zone deleted successfully");
            return true;
          } else {
            throw new Error(response.error?.message || "Failed to delete zone");
          }
        } catch (error: any) {
          console.error("Error deleting zone:", error);
          toast.error(error.message || "Failed to delete zone");
          return false;
        }
      },

      // Toggle zone status
      toggleZoneStatus: async (id) => {
        try {
          const response = await zonesApiClient.toggleZoneStatus(id);

          if (response.success && response.data) {
            // Update in zones list
            const currentZones = get().zones;
            const updatedZones = currentZones.map((zone) =>
              zone.id === id ? response.data : zone
            );

            set({ zones: updatedZones });

            // Refresh active zones
            get().fetchActiveZones();

            toast.success(
              `Zone ${
                response.data.status ? "activated" : "deactivated"
              } successfully`
            );
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to toggle zone status"
            );
          }
        } catch (error: any) {
          console.error("Error toggling zone status:", error);
          toast.error(error.message || "Failed to toggle zone status");
          return false;
        }
      },

      // Add cities to zone
      addCitiesToZone: async (zoneId, cityIds) => {
        try {
          const response = await zonesApiClient.addCitiesToZone(
            zoneId,
            cityIds
          );

          if (response.success && response.data) {
            // Update current zone if it matches
            const currentZone = get().currentZone;
            if (currentZone?.id === zoneId) {
              set({ currentZone: response.data });
            }

            toast.success("Cities added to zone successfully");
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to add cities to zone"
            );
          }
        } catch (error: any) {
          console.error("Error adding cities to zone:", error);
          toast.error(error.message || "Failed to add cities to zone");
          return false;
        }
      },

      // Remove cities from zone
      removeCitiesFromZone: async (zoneId, cityIds) => {
        try {
          const response = await zonesApiClient.removeCitiesFromZone(
            zoneId,
            cityIds
          );

          if (response.success && response.data) {
            // Update current zone if it matches
            const currentZone = get().currentZone;
            if (currentZone?.id === zoneId) {
              set({ currentZone: response.data });
            }

            toast.success("Cities removed from zone successfully");
            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to remove cities from zone"
            );
          }
        } catch (error: any) {
          console.error("Error removing cities from zone:", error);
          toast.error(error.message || "Failed to remove cities from zone");
          return false;
        }
      },

      // Bulk delete zones
      bulkDeleteZones: async (zoneIds) => {
        try {
          const response = await zonesApiClient.bulkDeleteZones(zoneIds);

          if (response.success) {
            // Remove deleted zones from list
            const currentZones = get().zones;
            const remainingZones = currentZones.filter(
              (zone) => !zoneIds.includes(zone.id)
            );

            set({
              zones: remainingZones,
              selectedZones: [],
            });

            // Refresh data
            get().fetchActiveZones();
            get().fetchStatistics();

            toast.success(
              `Successfully deleted ${
                response.data?.successful || zoneIds.length
              } zone(s)`
            );

            if (response.data?.failed && response.data.failed.length > 0) {
              toast.warning(
                `Failed to delete ${response.data.failed.length} zone(s)`
              );
            }

            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to delete zones"
            );
          }
        } catch (error: any) {
          console.error("Error bulk deleting zones:", error);
          toast.error(error.message || "Failed to delete zones");
          return false;
        }
      },

      // Bulk toggle status
      bulkToggleStatus: async (zoneIds) => {
        try {
          const response = await zonesApiClient.bulkToggleStatus(zoneIds);

          if (response.success) {
            // Refresh zones to get updated statuses
            await get().fetchZones();

            set({ selectedZones: [] });

            toast.success(
              `Successfully updated ${
                response.data?.successful || zoneIds.length
              } zone(s)`
            );

            if (response.data?.failed && response.data.failed.length > 0) {
              toast.warning(
                `Failed to update ${response.data.failed.length} zone(s)`
              );
            }

            return true;
          } else {
            throw new Error(
              response.error?.message || "Failed to update zones"
            );
          }
        } catch (error: any) {
          console.error("Error bulk toggling zone status:", error);
          toast.error(error.message || "Failed to update zones");
          return false;
        }
      },

      // Export zones
      // Export zones - FIXED VERSION
      exportZones: async (filters) => {
        set({ loading: true, error: null });

        try {
          const filtersToUse = filters || get().filters;

          // Send the request with the correct structure
          const result = await zonesApiClient.exportZones({
            page: filtersToUse.page || 1,
            limit: filtersToUse.limit || 1000,
            search: filtersToUse.search || "",
            status: filtersToUse.status,
          });

          if (result.success && result.data) {
            set({ loading: false });
            toast.success(
              `Exported ${result.data.totalRecords} zones successfully`
            );
            return result.data.downloadUrl;
          } else {
            throw new Error(result.error?.message || "Failed to export zones");
          }
        } catch (error: any) {
          console.error("Error exporting zones:", error);
          const errorMessage = error?.message || "Failed to export zones";
          set({
            error: errorMessage,
            loading: false,
          });
          toast.error(errorMessage);
          return null;
        }
      },

      // Utility methods
      getZoneById: (id) => {
        return get().zones.find((zone) => zone.id === id);
      },

      getZonesByStatus: (status) => {
        return get().zones.filter((zone) => zone.status === status);
      },

      getZonesCount: () => {
        const zones = get().zones;
        return {
          total: zones.length,
          active: zones.filter((zone) => zone.status).length,
          inactive: zones.filter((zone) => !zone.status).length,
        };
      },

      // Refresh all data
      refreshData: async () => {
        const promises = [
          get().fetchZones(),
          get().fetchActiveZones(),
          get().fetchStatistics(),
          get().fetchAvailableCities(),
        ];

        await Promise.allSettled(promises);
      },
    }),
    {
      name: "zones-store",
      partialize: (state) => ({
        filters: state.filters,
        selectedZones: state.selectedZones,
      }),
      version: 1,
    }
  )
);
-----------------------------------------------------------------------
Types folders:
-----------------------------------------------------------------------
--++--> lib/types/parcels/delivery-slips.types.ts =======>
-----------------------------------------------------------------------
export enum DeliverySlipStatus {
  PENDING = "PENDING",
  RECEIVED = "RECEIVED",
  CANCELLED = "CANCELLED",
}

export interface DeliverySlip {
  id: string;
  tenantId: string;
  userId: string;
  reference: string;
  cityId?: string;
  status: DeliverySlipStatus;
  receivedAt?: Date;
  receivedBy?: string;
  notes?: string;
  createdAt: Date;
  updatedAt: Date;
  createdBy?: string;
  updatedBy?: string;

  // Relations
  city?: {
    id: string;
    name: string;
    ref: string;
  };
  creator?: {
    id: string;
    name: string;
    email: string;
  };
  items: DeliverySlipItem[];
  summary: {
    totalParcels: number;
    scannedParcels: number;
    unscannedParcels: number;
    totalValue: number;
  };
}

export interface DeliverySlipItem {
  deliverySlipId: string;
  parcelId: string;
  scanned: boolean;
  scannedAt?: Date;
  scannedBy?: string;
  parcel: {
    id: string;
    code: string;
    recipientName: string;
    recipientPhone: string;
    destinationCity: string;
    price: number;
    statusCode: string;
    statusName: string;
  };
}

export interface CreateDeliverySlipRequest {
  cityId?: string;
  parcelIds?: string[];
  notes?: string;
  autoReceive?: boolean;
}

export interface UpdateDeliverySlipRequest {
  cityId?: string;
  notes?: string;
  status?: DeliverySlipStatus;
}

export interface DeliverySlipFilters {
  page?: number;
  limit?: number;
  search?: string;
  status?: DeliverySlipStatus;
  cityId?: string;
  userId?: string;
  startDate?: string;
  endDate?: string;
  sortBy?: string;
  sortParcel?: "asc" | "desc";
}

export interface AddParcelsToSlipRequest {
  parcelIds: string[];
  comment?: string;
  markAsScanned?: boolean;
}

export interface RemoveParcelsFromSlipRequest {
  parcelIds: string[];
  reason?: string;
}

export interface ReceiveSlipRequest {
  notes?: string;
  parcelIds?: string[];
  forceReceive?: boolean;
}

export interface DeliverySlipStats {
  totalSlips: number;
  pendingSlips: number;
  receivedSlips: number;
  cancelledSlips: number;
  totalParcelsInSlips: number;
  totalValueInSlips: number;
  averageParcelsPerSlip: number;
  recentActivity: Array<{
    date: string;
    slipsCreated: number;
    slipsReceived: number;
  }>;
  topCities: Array<{
    cityName: string;
    slipCount: number;
    parcelCount: number;
  }>;
}

export interface BulkSlipActionRequest {
  slipIds: string[];
  action: string;
  comment?: string;
}

export interface AvailableParcel {
  id: string;
  code: string;
  recipientName: string;
  recipientPhone: string;
  price: number;
  createdAt: Date;
  pickupCity: {
    id: string;
    name: string;
    ref: string;
  };
  destinationCity: {
    id: string;
    name: string;
    ref: string;
  };
}

export interface PaginatedDeliverySlips {
  data: DeliverySlip[];
  meta: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrev: boolean;
  };
}

===============================================================================================================
# WORKFLOW DES COMMANDES
===============================================================================================================
## TAPE 1 : CRATION DE COLIS

**Vue Client (Seller)**
Cette tape permet au client (seller) de crer un nouveau colis en renseignant toutes les informations ncessaires  la livraison.

### 1. Accs au formulaire de cration
- Le client navigue vers : Gestion des colis > Nouveau Colis
- Le systme affiche le formulaire de cration de colis

### 2. Saisie des informations obligatoires
Le client renseigne les champs suivants :

**Informations destinataire :**
- Destinataire* (obligatoire) : Nom du destinataire
- Tlphone* (obligatoire) : Numro de tlphone du destinataire
- Ville* (obligatoire) : Ville de livraison (slection via liste droulante)
- Adresse* (obligatoire) : Adresse complte de livraison

**Informations colis :**
- Code suivi (facultatif) : Code de suivi personnalis
- Marchandise (facultatif) : produit (slection via liste droulante)
- Quantit (facultatif) : Nombre d'articles
- Prix* (obligatoire) : Montant de la commande
- Commentaire (facultatif) : Informations complmentaires (autre tlphone, date de livraison souhaite, etc.)

**Options spciales :**
- Interdit d'ouvrir le colis : Case  cocher
- Colis  remplacer : Case  cocher
- Colis de Stock : Case  cocher

**Actions disponibles**
- Enregistrer : Valide et cre le colis
- Reset : Remet  zro tous les champs du formulaire

### 3. Vue client - Suivi des colis crs
**Accs :** Menu Gestion des colis > Colis pour ramassage

Aprs la cration d'un colis, le client peut consulter ses colis en attente de ramassage dans une interface ddie.

**Informations affiches dans le tableau :**
- Code d'envoi : Identifiant unique du colis (ex: BSK0925539432LE)
- Destinataire : Nom du destinataire
- Statut : Badge color indiquant l'tat actuel
  - "Nouveau Colis" : colis cr, en attente de traitement
  - "Attente De Ramassage" : colis prt pour collecte
- Date de cration : Date et heure de cration du colis
- Prix : Montant de la commande (en DH)
- Tlphone : Numro du destinataire
- Ville : Ville de destination
- Bon de livraison : Rfrence du bon associ (ex: BL-280225-0192950-16-161)
- Actions : Boutons d'actions disponibles (icne information, icne update et icne delete)

**NB:** icne update et icne delete si le status de colis est "Nouveau colis"
**Icne information :** Accs aux dtails via le bouton d'actions

### Vue administrateur - Supervision des colis
**Accs :** Menu Colis

**Informations affiches dans le tableau de bord :**
- Code d'envoi : Identifiant unique du colis
- Date d'expdition : Date de cration du colis
- Tlphone : Numro du destinataire
- Nom du magasin : Nom du client (seller)
- tat : Statut actuel du colis (Non paye, paye, facture)
- Statut : Badge color indiquant l'tat
- Ville : Ville de destination
- Prix : Montant de la commande
- Actions : Boutons d'actions disponibles pour chaque colis

**Actions disponibles par colis :**
L'administrateur dispose d'un menu d'actions contextuel pour chaque colis avec les options suivantes :
-  Dtails du suivi : Consultation de l'historique complet du colis
-  Information du colis : Affichage des dtails de la commande
-  Modifier le colis : dition des informations du colis
-  Change Ville : Modification de la ville de destination
-  Change Vendeur : Rassignation du vendeur/client
-  Rinitialiser ce colis : Remise  zro du statut du colis
-  Relance ce colis : Relancement du processus de traitement

## TAPE 2 : CRATION DES BONS DE LIVRAISON

Cette tape correspond  la rception physique des colis  l'agence et  la gnration automatique des bons de livraison. Le systme utilise la technologie de scan de codes-barres pour traiter les colis et mettre  jour automatiquement leur statut selon la zone gographique.

### 1. Accs  l'interface de scan
- L'agent navigue vers : Menu > Bons de livraison
- Clic sur le bouton "Code Bar Scanner" dans la barre d'outils

### 2. Interface de scan
L'interface propose deux mthodes de scan :
- **Scan manuel ou douchette :** Champ de saisie "CLIC ICI AVANT LE SCAN" pour saisie manuelle ou par douchette le code
- **Scan camra :** Bouton " Utiliser Camera" pour scan automatique via webcam/camra mobile (scan qr code or barcode)

### 3. Traitement automatique du scan
Une fois le code-barres scann ou saisi :
- Le systme identifie automatiquement le colis
- Gnre un bon de livraison avec rfrence unique
- Met  jour le statut selon la logique gographique

### 4. Logique de changement de statut

**Cas 1 : Destination dans la mme zone que l'agence**
- Condition : Ville de destination = Zone de l'agence de ramassage
- Nouveau statut : "Reu"
- Action : Le colis reste dans l'agence pour livraison locale

**Cas 2 : Destination dans une zone diffrente**
- Condition : Ville de destination  Zone de l'agence de ramassage
- Nouveau statut : "Ramass"
- Action : Le colis doit tre transfr vers l'agence de destination

### 4. Interface de gestion des bons de livraison
Vue tableau des bons crs :
- Rfrence: Code unique du bon (BL-XXXXXX-XXX)
- Client
- Date de cration: Date et heure de cration du bon
- Date de rception
- Statut
- Colis: Nombre de colis dans le bon
- Total: Montant total en DH
- Actions:
  -  Dtails du bon : Consultation dtaille du bon de livraison
  -  Bon bien reu : Confirmation de rception du bon
  -  Voir en PDF : Gnration et tlchargement du bon au format PDF
  -  Voir les tiquettes : Affichage/impression des tiquettes de colis

## CRATION DE BONS DE LIVRAISON (INTERFACE CLIENT)

Cette fonctionnalit permet au client (seller) de crer ses propres bons de livraison (au cas o il ne va pas se dplacer  l'agence) en slectionnant les colis qu'il souhaite regrouper.

### 1. Accs  l'interface de cration
- Le client navigue vers : Menu > Bons de livraison
- La page affiche la liste des bons existants
- Clic sur le bouton "+ Ajouter Bon de livraison"
- Une deuxime page s'affiche:
  - Indicateur de nombre de colis ligibles pour cration d'un bon
  - Bouton principal : "+ Crer bon de livraison"

### 2. Cration de bons de livraison
- Clic sur ce bouton pour accder  l'interface dtaille de slection des colis
- Une fois le bouton "Crer bon de livraison" cliqu, le systme affiche l'interface complte avec :

**Liste des nouveaux colis disponibles:** Tableau des colis ligibles pour ajout au bon :
- Code d'envoi: Identifiant unique du colis
- Destinataire: Nom du destinataire
- Date de cration: Date de cration du colis
- Prix: Montant en DH
- Ville: Ville de destination
- Actions: Bouton "+" pour ajouter le colis et Case  cocher pour slection multiple et Bouton "Ajouter" (en bas) : Ajouter tous les colis slectionns

**Liste des colis ajouts au bon:** Section qui affiche les colis slectionns pour le bon en cours de cration.
- Vide initialement : "Aucun enregistrement disponible" / "Aucune entres correspondants trouvs"
- Aprs ajout : Liste des colis inclus dans le bon

**Tickets et Bon de livraison - Obtenir en PDF** Trois options de gnration disponibles :
- Gnration du premier type de ticket (Premire image)
- Gnration de deuxime type de ticket (deuxime image)
- Gnration de bon de livraison (troisieme image)

### 3. Vue tableau des bons de livraison
Aprs cration, les bons apparaissent dans le tableau principal :
- Rfrence
- Date de cration
- Statut
- Colis
- Actions

## CRATION DES BONS DE DISTRIBUTION

Cette tape permet  l'administrateur d'affecter les colis aux livreurs en crant des bons de distribution. Le processus implique la slection d'une zone gographique, l'assignation d'un livreur spcifique, puis la slection des colis  distribuer soit manuellement soit par scan.

### 1. Accs  l'interface de distribution
- L'administrateur navigue vers : Menu > Bons de distribution
- Clic sur le bouton "+ Ajouter Bon De Distribution"
- **Slection de la zone:**
  - Liste droulante des zones disponibles
  - Affichage du nombre de colis en attente par zone
- **Slection du livreur:**
  - Liste droulante des livreurs disponibles pour la zone slectionne

### 2. Cration du bon et slection des colis
Une fois le bouton "Crer" cliqu, le systme affiche l'interface de slection des colis :

**Liste des nouveaux colis disponibles:** Tableau des colis ligibles pour distribution dans la zone slectionne
- Code d'envoi
- Client
- Date de rception
- Ville
- Livreur
- Adresse
- Commentaire
- Prix
- Statut
- Actions: (Boutons d'ajout et slection + Case  cocher)

**Liste des colis ajouts au bon :** Affiche les colis slectionns pour le bon de distribution en cours

**Interface de scan pour retrait de colis:**
- Champ de scan : "CLIC ICI AVANT LE SCAN"
- Scan camra : Bouton " Utiliser Camera" (scan qr code or barcode)
- Fonctionnalit : Permet de retirer des colis du bon par scan

### 3. Vue tableau des bons de distribution crs
Une fois crs, les bons apparaissent dans le tableau principal des bons de distribution :
- Rfrence
- Date de cration
- Date d'Enregistrement
- Zone
- Livreur
- Statut
- Colis
- Actions:
  -  Dtails du bon : Consultation dtaille
  -  Supprimer le bon : Suppression du bon
  -  Modifier le bon : dition des paramtres
  -  Voir en PDF : Gnration du document
  -  Export Excel : Export des donnes

### 3. Logique de changement de statut aprs distribution

**Cas 1 : Distribution dans la mme zone (livraison locale)**
- Condition : Ville de destination = Zone de ramassage/agence
- Changement de statut : "Reu"  "En distribution"
- Action : Le colis passe directement en phase de livraison finale
- Workflow : Colis  Bon de livraison Bon de distribution  Livraison directe

**Cas 2 : Distribution vers une zone diffrente (transfert inter-agences)**
- Condition : Ville de destination  Zone de ramassage/agence
- tape intermdiaire : Cration d'un "Bon d'envoi" ( dtailler)
- Action : Le colis doit tre transfr vers l'agence de la zone de destination
- Workflow : Colis  Bon de livraison Bon d'envoi ( Transfert  a l l'agence destination ) Bon de distribution  Livraison

## CRATION DES BONS D'ENVOI

Cette tape gre les colis qui doivent tre transfrs vers d'autres zones gographiques. Lorsqu'un colis  une destination diffrente de la zone de ramassage, il passe par un bon d'envoi avant d'tre achemin vers l'agence de destination approprie.

### 1. Accs  l'interface de cration
- L'administrateur navigue vers : Menu > Bons d'envoi
- Clic sur le bouton "+ Ajouter Bon D'envoi ( Zone )"
- **Slection de la zone de destination**
  - Liste droulante des zones de destination disponibles
  - Slection de la zone vers laquelle transfrer les colis

### 2. Cration du bon et slection des colis
**Liste des nouveaux colis disponibles :** Tableau des colis ligibles pour transfert vers la zone slectionne
- Code d'envoi
- Client
- Date de ramassage
- Prix
- Ville
- Actions: (Boutons d'ajout et Case  cocher)

**Liste des colis ajouts au bon :** Section "LIST DES COLIS AJOUTS" Affiche les colis slectionns pour le bon d'envoi
- Toutes les elements de liste de colis disponible + la colonne scanned (indicateur de scan)

**Interface de scan :**
- Champ de scan : "CLIC ICI AVANT LE SCAN"
- Scan camra : Bouton " Utiliser Camera" (scan qr code or barcode)
- Fonctionnalit : Retrait de colis du bon par scan

### 3. Vue tableau des bons d'envoi crs
Une fois crs, les bons d'envoi apparaissent dans le tableau principal :
- Rfrence
- Date de cration
- Date de rception
- Zone
- Statut
- Colis
- Actions:
  -  Dtails du bon : Consultation dtaille du bon d'envoi
  -  Bon bien reu :
  -  Modifier le bon : dition des paramtres du bon d'envoi
  -  Voir en PDF : Gnration et tlchargement du bon au format PDF
  -  Export Excel : Export des donnes du bon vers Excel

### 4. Changement de statut des colis
**Transition automatique :** Une fois les colis ajouts au bon d'envoi et le bon finalis :
- Statut prcdent : "Ramass"
- Nouveau statut : "Expdi"
- Action : Les colis sont prts pour transfert physique vers l'agence de destination

### 5. Workflow de transfert inter-agences
- **Agence source :** Cration du bon d'envoi (statut "Ramasse")
- **Expdition :** Colis passent au statut "Expdi"
- **Transport :** Acheminement physique vers agence de destination
- **Agence destination :** Rception et scan des colis
- **Suite du processus :** Cration de bons de distribution locaux

## GESTION DES BONS DE PAIEMENT

Le module de bons de paiement gre la comptabilit et les rglements financiers dans le systme. Il se divise en deux catgories principales : les paiements aux livreurs individuels et les paiements aux modrateurs de zone pour les transferts inter-agences.

- **Bons de paiement pour livreur :** Rglement des livreurs individuels
- **Bons de paiement pour zone :** Comptabilit avec les modrateurs de zone

## BONS DE PAIEMENT POUR LIVREUR

Cette fonctionnalit permet de crer et grer les paiements destins aux livreurs individuels pour les livraisons effectues dans leur zone d'intervention.

### 1. Accs  l'interface
- Navigation : Menu > Bons de paiement > Pour livreur
- Clic sur "+ Ajouter Bon Pour Livreur"

### 2. Cration de bon de paiement pour livreur
- **Slectionner la zone:** Liste droulante avec statistiques (Affichage du nombre de livraisons russies et checs)
- **Slection du livreur:** Liste droulante des livreurs avec statistiques individuelles (Affichage du nombre de livraisons russies et checs)
- **Cration et configuration du bon:**

**Liste des nouveaux colis:** Tableau des colis livrs ligibles au paiement :
- Code d'envoi
- Client
- Tlphone
- Date de livraison
- Statut
- Ville
- Prix
- Frais
- Total
- Actions:
  - Dtails du suivi : Historique complet
  - Information du colis : Dtails de la commande
  - Modifier le colis : dition des informations
  - Change Ville : Modification destination
  - Change Vendeur : Rassignation vendeur
  - Colis non livr : Marquage chec livraison
  - Changer le prix : Ajustement montant
  - Remboursement : Gestion des retours

**Section "AUTRES FRAIS"** Interface pour ajouter des frais supplmentaires :
- Dsignation : Description du frais
- Quantit
- Prix unitaire
- Total

### 3. Vue tableau des bons de paiement
Interface principale des bons crs :
- Rfrence
- Date de cration
- Date Changement de statuts
- Zone
- Livreur
- Portefeuille
- Screen
- Statut
- Colis (Nb)
- Total

### 4. Cycle de vie des bons de paiement
Changement de statut se fait en 3 tapes

**1. Attente de paiement**
- Bon cr avec les colis livrs
- En attente de traitement financier

**2. Encore de traitement**
- Paiement en cours de traitement
- Vrifications comptables en cours

**3. Pay**
- Paiement effectu au livreur
- Clture comptable du bon

Lors du passage au statut "Pay", une popup s'affiche avec :
- Champ Virement : Montant du virement
- Champ Cash : Montant en espces
- Bouton "Pay" : Confirmation finale du paiement

## BONS DE PAIEMENT POUR ZONE

Cette fonctionnalit gre la comptabilit avec les modrateurs de zone pour les transferts inter-agences. Elle permet de rgler financirement les zones qui ont reu et trait des colis provenant d'autres agences.

### 1. Accs  l'interface
- Navigation : Menu > Bons de paiement > Pour zone
- Clic sur "+ Ajouter Bon Pour Zone"

### 2. Slection de la zone

### 3. Cration et configuration du bon
**Liste des nouveaux colis:** Tableau des colis livrs dans la zone ligibles au paiement
- Code d'envoi
- Client
- Tlphone
- Date de livraison
- Statut
- Ville
- Prix
- Frais
- Total

**Liste des colis ajouts:**
- Code d'envoi
- Client
- Tlphone
- Date de livraison
- Statut
- Ville
- Prix
- Frais
- Total

### 4. Vue tableau des bons de paiement pour zone
Interface principale des bons crs :
- Rfrence
- Date de cration
- Date Changement de statuts
- Zone
- Statut
- Colis
- Total

### 5. Gestion des statuts de paiement
Cycle de vie des bons de paiement pour zone :

**1. Attente de paiement**
- Bon cr pour la zone
- En attente de traitement comptable

**2. En cours de traitement**
- Paiement en cours de validation
- Vrifications inter-agences

**3. Pay**
- Rglement effectu  la zone
- Clture comptable du transfert

## GESTION DES BONS DE RETOUR

### Bons de retour pour livreur

**Table contents :**
- Rfrence
- Date de cration
- Livreur
- Type
- Statut
- Colis
- Actions

*Exemple :*
BRL-240925-0126910-76-133 | 2025-09-24 13:20 | Youness RBT | Demande | Incomplet | 0 | 22 | 2 | update/delete

**Crer Bons de retour for livreur:**
- Slection le livreur
- Select LISTE DES COLIS DEMANDE DE RETOUR
- Create Bons de retour

### Bons de retour pour zone

**Table contents :**
- Rfrence
- Date de cration
- Date de rception
- Ville
- Statut
- Colis
- Actions

*Exemple :*
BRV-170925-0126750-79-V | 2025-09-17 13:51 | 2025-09-17 16:03 | HUB CASABLANCA | Reu | 3 | details/voir/delete
(youness bousaou ali housni)

**Crer Bons de retour for zone:**
- Slection la zone
- List des colis ajouts
- Create Bons de retour

### Bons de retour pour client (customer)

**Table contents :**
- Rfrence
- Date de cration
- Date de rception
- Nom du magasin
- Statut
- Colis
- Actions

*Exemple :*
BRC-160925-0126540-77-138 | 2025-09-16 17:33 | 2025-09-17 09:36 | Metalivraison - (546) | Reu | 1Nouveau | 6 | details/voir/export
(milad settaoui milad settaoui)

**Crer Bons de retour for customer:**
- Slection le client
- Ajouter liste des colis returne
- create Bons de retour for customer
===============================================================================================================
Nest js backend Parcels-Service:
===============================================================================================================
--++--> prisma/schema.prisma =======>
-----------------------------------------------------------------------
generator client {
  provider = "prisma-client-js"
}
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}
// ========================================
// CORE REFERENCE DATA
// These models define the foundational data for the delivery system
// ========================================
/**
 * City Model
 * Represents cities where packages can be picked up or delivered
 * Supports multi-tenant architecture with soft deletes
 */
model City {
  id         String  @id @default(cuid()) // Unique identifier using CUID
  tenantId   String // Multi-tenant support - isolates data per organization
  ref        String // Business reference code (e.g., "CAS" for Casablanca)
  name       String // Display name of the city
  zone       String? // Optional zone grouping for logistics
  pickupCity Boolean @default(false) // Whether this city accepts package pickups
  status     Boolean @default(true) // Active/inactive flag for business operations

  // Soft delete pattern - allows data recovery and maintains referential integrity
  isDeleted Boolean   @default(false) // Soft delete flag
  deletedAt DateTime? // Timestamp when deleted
  deletedBy String? // User who performed the deletion

  // Audit trail - tracks data changes for compliance and debugging
  createdAt DateTime @default(now()) // Record creation timestamp
  updatedAt DateTime @updatedAt // Auto-updated on record changes
  createdBy String? // User who created the record
  updatedBy String? // User who last updated the record

  // Relations - Define how cities connect to other entities
  pickupTariffs        Tariff[]       @relation("PickupCity") // Tariffs where this city is pickup
  destinationTariffs   Tariff[]       @relation("DestinationCity") // Tariffs where this city is destination
  zones                ZoneCity[] // Many-to-many relationship with zones
  parcelsAsPickup      Parcel[]       @relation("PickupCity") // Parcels picked up from this city
  parcelsAsDestination Parcel[]       @relation("DestinationCity") // Parcels delivered to this city
  deliverySlips        DeliverySlip[] // Delivery slips for this city

  // Optimized indexes for common query patterns
  @@unique([tenantId, ref, isDeleted]) // Ensures unique business codes per tenant
  @@index([tenantId, isDeleted, status]) // Fast tenant + active city queries
  @@index([tenantId, isDeleted, pickupCity]) // Quick pickup city filtering
  @@index([tenantId, zone]) // Zone-based queries within tenant
  @@index([name]) // City name searches
  @@map("cities") // Custom table name
}
/**
 * PickupCity Model
 * Specialized reference for pickup locations/hubs
 * Separate from regular cities for operational flexibility
 */
model PickupCity {
  id       String  @id @default(cuid())
  tenantId String // Multi-tenant isolation
  ref      String // Business reference (e.g., "CAS_HUB")
  name     String // Display name (e.g., "HUB CASABLANCA")
  status   Boolean @default(true) // Active status

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations
  tariffs Tariff[] @relation("PickupCityRef") // Optional tariff reference

  // Indexes and constraints
  @@unique([tenantId, ref, isDeleted]) // Unique pickup city refs per tenant
  @@index([tenantId, isDeleted, status]) // Active pickup cities per tenant
  @@map("pickup_cities")
}
/**
 * Tariff Model
 * Defines pricing and delivery terms between city pairs
 * Core business logic for cost calculation
 */
model Tariff {
  id                String  @id @default(cuid())
  tenantId          String // Multi-tenant support
  pickupCityId      String // Source city for package
  destinationCityId String // Destination city for package
  deliveryPrice     Decimal @db.Decimal(10, 2) // Standard delivery fee (precise decimal for money)
  returnPrice       Decimal @default(0) @db.Decimal(10, 2) // Fee for returning undelivered packages
  refusalPrice      Decimal @default(0) @db.Decimal(10, 2) // Fee for refused packages
  deliveryDelay     Int     @db.SmallInt // Expected delivery time in days

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations
  pickupCity      City        @relation("PickupCity", fields: [pickupCityId], references: [id])
  destinationCity City        @relation("DestinationCity", fields: [destinationCityId], references: [id])
  pickupCityRef   PickupCity? @relation("PickupCityRef", fields: [pickupCityRefId], references: [id])
  pickupCityRefId String? // Optional reference to pickup city hub
  parcels         Parcel[] // Parcels using this tariff

  // Optimized indexes for route-based pricing queries
  @@unique([tenantId, pickupCityId, destinationCityId, isDeleted]) // Unique routes per tenant
  @@index([tenantId, isDeleted]) // Tenant-wide tariff queries
  @@index([pickupCityId, destinationCityId]) // Fast route-based lookups
  @@map("tariffs")
}
/**
 * Zone Model
 * Logical grouping of cities for operational management
 * Used for organizing delivery routes and staff assignments
 */
model Zone {
  id       String  @id @default(cuid())
  tenantId String // Multi-tenant support
  name     String // Zone name (e.g., "HUB CASABLANCA")
  status   Boolean @default(true) // Active status

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations - Zones coordinate multiple operational processes
  cities              ZoneCity[] // Cities within this zone
  distributionSlips   DistributionSlip[] // Distribution assignments for this zone
  shippingSlips       ShippingSlip[] // Inter-zone shipments to this zone
  returnSlipsForZone  ReturnSlip[]       @relation("ReturnSlipZone") // Returns processed by zone
  paymentSlipsForZone PaymentSlip[]      @relation("PaymentSlipZone") // Payments processed by zone

  // Indexes for zone-based operations
  @@unique([tenantId, name, isDeleted]) // Unique zone names per tenant
  @@index([tenantId, isDeleted, status]) // Active zones per tenant
  @@map("zones")
}
/**
 * ZoneCity Junction Table
 * Many-to-many relationship between zones and cities
 * Allows flexible city-to-zone assignments
 */
model ZoneCity {
  zoneId String // Reference to zone
  cityId String // Reference to city

  // Relations with cascade delete - if zone/city deleted, remove assignment
  zone Zone @relation(fields: [zoneId], references: [id], onDelete: Cascade)
  city City @relation(fields: [cityId], references: [id], onDelete: Cascade)

  @@id([zoneId, cityId]) // Composite primary key - more efficient than separate ID
  @@map("zone_cities")
}
/**
 * ParcelStatus Model
 * Defines the workflow states an parcel can be in
 * Core to tracking package lifecycle
 */
model ParcelStatus {
  id       String  @id @default(cuid())
  tenantId String // Multi-tenant support
  code     String  @db.VarChar(50) // Business code (e.g., "NEW_PACKAGE", "DELIVERED")
  name     String  @db.VarChar(100) // Display name (e.g., "Nouveau Colis", "Livr")
  color    String  @db.VarChar(7) // Hex color for UI display (#FF0000)
  isLocked Boolean @default(false) // Whether status can be manually changed
  status   Boolean @default(true) // Active status

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations
  parcels               Parcel[] // Parcels in this status
  parcelStatusHistories ParcelStatusHistory[] // Status change history

  // Constraints and indexes
  @@unique([tenantId, code, isDeleted]) // Unique status codes per tenant
  @@unique([tenantId, color, isDeleted]) // Unique colors per tenant (UI requirement)
  @@index([tenantId, isDeleted, status]) // Active statuses per tenant
  @@map("parcel_statuses")
}
// ========================================
// PARCELS CORE
// The heart of the delivery system - manages package parcels
// ========================================
/**
 * Parcel Model
 * Central entity representing a package delivery request
 * Contains all information needed for pickup, delivery, and payment
 */
model Parcel {
  id       String @id @default(cuid())
  tenantId String // Multi-tenant support
  userId   String // Seller/client who created the parcel
  code     String @unique @db.VarChar(50) // Unique business code (e.g., BSK0925539432LE)

  // Customer information - who receives the package
  recipientName    String  @db.VarChar(200) // Customer name
  recipientPhone   String  @db.VarChar(20) // Primary contact number
  recipientAddress String  @db.Text // Full delivery address
  alternativePhone String? @db.VarChar(20) // Backup contact number

  // Location - pickup and delivery cities
  pickupCityId      String // Where package is collected
  destinationCityId String // Where package is delivered

  // Package details - what's being delivered
  trackingCode String? @db.VarChar(100) // Custom tracking code from seller
  productName  String? @db.VarChar(200) // Product description
  quantity     Int?    @default(1) @db.SmallInt // Number of items
  price        Decimal @db.Decimal(12, 2) // COD amount (Cash on Delivery value)
  comment      String? @db.Text // Special delivery instructions

  // Package handling options - business rules
  cannotOpen Boolean @default(false) // Package cannot be opened for inspection
  canReplace Boolean @default(false) // Can substitute with different item
  isStock    Boolean @default(false) // Is this a stock/inventory item

  // Status and workflow tracking
  parcelStatusId   String // Current status reference
  parcelStatusCode String        @db.VarChar(50) // Current status code (for fast queries)
  paymentStatus    PaymentStatus @default(PENDING) // Payment processing state

  // Pricing - calculated from tariff, stored for historical accuracy
  deliveryPrice Decimal @db.Decimal(10, 2) // Standard delivery fee
  returnPrice   Decimal @default(0) @db.Decimal(10, 2) // Return fee if undelivered
  refusalPrice  Decimal @default(0) @db.Decimal(10, 2) // Refusal fee if rejected
  deliveryDelay Int     @db.SmallInt // Expected delivery days
  tariffId      String? // Reference to tariff used for pricing

  // Delivery tracking - operational data
  deliveryAttempts Int       @default(0) @db.SmallInt // How many delivery attempts made
  lastAttemptDate  DateTime? // When last delivery was attempted
  deliveredAt      DateTime? // When successfully delivered
  deliveredBy      String? // ID of delivery person who completed

  // Return/Refusal tracking - handling failed deliveries
  returnedAt    DateTime? // When package was returned to sender
  returnReason  String?   @db.Text // Why package was returned
  refusedAt     DateTime? // When package was refused by recipient
  refusalReason String?   @db.Text // Why package was refused

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations - how parcels connect to other system components
  pickupCity      City         @relation("PickupCity", fields: [pickupCityId], references: [id])
  destinationCity City         @relation("DestinationCity", fields: [destinationCityId], references: [id])
  parcelStatus    ParcelStatus @relation(fields: [parcelStatusId], references: [id])
  tariff          Tariff?      @relation(fields: [tariffId], references: [id])

  // Status change history for audit trail
  statusHistory ParcelStatusHistory[]

  // Slip associations - tracking through various operational documents
  deliverySlipItems     DeliverySlipItem[] // When parcel is collected from sender
  distributionSlipItems DistributionSlipItem[] // When parcel is assigned for delivery
  shippingSlipItems     ShippingSlipItem[] // When parcel is shipped between zones
  returnSlipItems       ReturnSlipItem[] // When parcel is returned to sender
  paymentSlipItems      PaymentSlipItem[] // When payment is processed

  // Optimized indexes for common query patterns
  @@index([tenantId, isDeleted]) // Basic tenant filtering
  @@index([tenantId, userId, isDeleted]) // Parcels by user
  @@index([tenantId, parcelStatusCode, isDeleted]) // Parcels by status
  @@index([tenantId, paymentStatus, isDeleted]) // Parcels by payment status
  @@index([tenantId, createdAt, isDeleted]) // Time-based queries within tenant
  @@index([recipientPhone, tenantId]) // Customer phone lookup
  @@index([pickupCityId, destinationCityId]) // Route-based queries
  @@index([deliveredAt]) // Delivered parcels analytics
  @@map("parcels")
}
/**
 * ParcelStatusHistory Model
 * Tracks all status changes for an parcel
 * Provides complete audit trail of parcel lifecycle
 */
model ParcelStatusHistory {
  id             String   @id @default(cuid())
  parcelId       String // Reference to the parcel
  parcelStatusId String // Reference to the status
  statusCode     String   @db.VarChar(50) // Status code for fast queries
  comment        String?  @db.Text // Optional comment about the change
  changedBy      String? // User who made the change
  changedAt      DateTime @default(now()) // When the change occurred

  // Relations with cascade delete - if parcel deleted, remove history
  parcel       Parcel       @relation(fields: [parcelId], references: [id], onDelete: Cascade)
  parcelStatus ParcelStatus @relation(fields: [parcelStatusId], references: [id])

  // Optimized indexes for history queries
  @@index([parcelId, changedAt]) // Parcel history timeline
  @@index([statusCode, changedAt]) // Status-based reporting and analytics
  @@map("parcel_status_history")
}
// ========================================
// DELIVERY SLIPS (Bons de livraison)
// Documents for tracking package collection from senders
// ========================================
/**
 * DeliverySlip Model
 * Represents a collection document for packages from senders
 * Groups multiple parcels for efficient pickup operations
 */
model DeliverySlip {
  id        String  @id @default(cuid())
  tenantId  String // Multi-tenant support
  userId    String // Client/seller who created the slip
  reference String  @unique @db.VarChar(50) // Business reference (BL-XXXXXX-XXX)
  cityId    String? // City where packages are collected

  status DeliverySlipStatus @default(PENDING) // Processing status

  // Reception tracking - when packages are actually collected
  receivedAt DateTime? // When collection was completed
  receivedBy String? // Staff member who performed collection

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations
  city  City?              @relation(fields: [cityId], references: [id])
  items DeliverySlipItem[] // Individual parcels on this slip

  // Optimized indexes for operational queries
  @@index([tenantId, userId, isDeleted]) // Slips by client
  @@index([tenantId, status, isDeleted]) // Slips by processing status
  @@index([tenantId, createdAt, isDeleted]) // Time-based slip queries
  @@map("delivery_slips")
}
/**
 * DeliverySlipItem Model
 * Junction table linking parcels to delivery slips
 * Tracks scanning/processing of individual packages
 */
model DeliverySlipItem {
  deliverySlipId String // Reference to delivery slip
  parcelId       String // Reference to parcel
  scanned        Boolean   @default(false) // Whether package was scanned/processed
  scannedAt      DateTime? // When scanning occurred
  scannedBy      String? // Who performed the scan

  // Relations with cascade delete
  deliverySlip DeliverySlip @relation(fields: [deliverySlipId], references: [id], onDelete: Cascade)
  parcel       Parcel       @relation(fields: [parcelId], references: [id])

  @@id([deliverySlipId, parcelId]) // Composite primary key - efficient and prevents duplicates
  @@index([parcelId]) // Reverse lookup - find slips for an parcel
  @@map("delivery_slip_items")
}
// ========================================
// SHIPPING SLIPS (Bons d'envoi)
// Documents for inter-zone package transfers
// ========================================
/**
 * ShippingSlip Model
 * Manages transfer of packages between different zones/hubs
 * Critical for multi-location delivery networks
 */
model ShippingSlip {
  id                String @id @default(cuid())
  tenantId          String // Multi-tenant support
  reference         String @unique @db.VarChar(50) // Business reference (BE-XXXXXX-XXX)
  destinationZoneId String // Zone receiving the packages

  status ShippingSlipStatus @default(PENDING) // Transfer status

  // Shipping process tracking
  shippedAt  DateTime? // When packages left origin
  shippedBy  String? // Who sent the packages
  receivedAt DateTime? // When packages arrived at destination
  receivedBy String? // Who received the packages

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations
  destinationZone Zone               @relation(fields: [destinationZoneId], references: [id])
  items           ShippingSlipItem[] // Individual parcels being shipped

  // Optimized indexes for logistics queries
  @@index([tenantId, status, isDeleted]) // Slips by status
  @@index([tenantId, createdAt, isDeleted]) // Time-based queries
  @@index([destinationZoneId, status]) // Zone-specific shipping status
  @@map("shipping_slips")
}
/**
 * ShippingSlipItem Model
 * Links individual parcels to shipping slips
 * Tracks package movement between zones
 */
model ShippingSlipItem {
  shippingSlipId String // Reference to shipping slip
  parcelId       String // Reference to parcel being shipped
  scanned        Boolean   @default(false) // Whether package was scanned for shipping
  scannedAt      DateTime? // When scan occurred
  scannedBy      String? // Who performed the scan

  // Relations with cascade delete
  shippingSlip ShippingSlip @relation(fields: [shippingSlipId], references: [id], onDelete: Cascade)
  parcel       Parcel       @relation(fields: [parcelId], references: [id])

  @@id([shippingSlipId, parcelId]) // Composite primary key
  @@index([parcelId]) // Reverse lookup capability
  @@map("shipping_slip_items")
}
// ========================================
// DISTRIBUTION SLIPS (Bons de distribution)
// Documents for assigning packages to delivery personnel
// ========================================
/**
 * DistributionSlip Model
 * Assigns packages to delivery personnel for final delivery
 * Core document for last-mile delivery operations
 */
model DistributionSlip {
  id               String  @id @default(cuid())
  tenantId         String // Multi-tenant support
  reference        String  @unique @db.VarChar(50) // Business reference (BD-XXXXXX-XXX)
  zoneId           String // Zone where delivery occurs
  deliveryPersonId String? // Assigned delivery person

  status DistributionSlipStatus @default(PENDING) // Assignment status

  // Assignment tracking
  assignedAt DateTime? // When assigned to delivery person
  assignedBy String? // Who made the assignment

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations
  zone  Zone                   @relation(fields: [zoneId], references: [id])
  items DistributionSlipItem[] // Parcels assigned for delivery

  // Optimized indexes for delivery management
  @@index([tenantId, status, isDeleted]) // Slips by status
  @@index([tenantId, createdAt, isDeleted]) // Time-based queries
  @@index([zoneId, status]) // Zone-specific distribution status
  @@index([deliveryPersonId, status]) // Person-specific assignments
  @@map("distribution_slips")
}
/**
 * DistributionSlipItem Model
 * Links parcels to distribution assignments
 * Tracks individual package assignments to delivery staff
 */
model DistributionSlipItem {
  distributionSlipId String // Reference to distribution slip
  parcelId           String // Reference to parcel for delivery
  scanned            Boolean   @default(false) // Whether assignment was scanned/confirmed
  scannedAt          DateTime? // When scan occurred
  scannedBy          String? // Who performed the scan

  // Relations with cascade delete
  distributionSlip DistributionSlip @relation(fields: [distributionSlipId], references: [id], onDelete: Cascade)
  parcel           Parcel           @relation(fields: [parcelId], references: [id])

  @@id([distributionSlipId, parcelId]) // Composite primary key
  @@index([parcelId]) // Reverse lookup capability
  @@map("distribution_slip_items")
}
// ========================================
// RETURN SLIPS (Bons de retour)
// Documents for handling undelivered packages
// ========================================
/**
 * ReturnSlip Model
 * Manages packages that couldn't be delivered and need to be returned
 * Supports different return types: from drivers, zones, or back to customers
 */
model ReturnSlip {
  id        String         @id @default(cuid())
  tenantId  String // Multi-tenant support
  reference String         @unique @db.VarChar(50) // Business reference (BRL/BRV/BRC-XXXXXX-XXX)
  type      ReturnSlipType // Type of return (DRIVER/ZONE/CUSTOMER)

  // Type-specific associations - polymorphic relationship pattern
  deliveryPersonId String? // For DRIVER type - returns from delivery staff
  zoneId           String? // For ZONE type - returns from operational zones
  customerId       String? // For CUSTOMER type - returns to specific customers
  customerName     String? @db.VarChar(200) // Display name for customer returns

  status ReturnSlipStatus @default(PENDING) // Processing status

  // Processing workflow tracking
  processedAt DateTime? // When return processing started
  processedBy String? // Who initiated processing
  receivedAt  DateTime? // When returned packages were received
  receivedBy  String? // Who received the returned packages

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations
  zone  Zone?            @relation("ReturnSlipZone", fields: [zoneId], references: [id])
  items ReturnSlipItem[] // Individual parcels being returned

  // Optimized indexes for return management
  @@index([tenantId, type, isDeleted]) // Returns by type
  @@index([tenantId, status, isDeleted]) // Returns by processing status
  @@index([tenantId, createdAt, isDeleted]) // Time-based return queries
  @@index([deliveryPersonId, status]) // Driver-specific returns
  @@index([zoneId, status]) // Zone-specific returns
  @@index([customerId]) // Customer-specific returns
  @@map("return_slips")
}
/**
 * ReturnSlipItem Model
 * Links individual parcels to return slips
 * Captures return reasons and processing details
 */
model ReturnSlipItem {
  returnSlipId String // Reference to return slip
  parcelId     String // Reference to parcel being returned
  returnReason String?   @db.Text // Detailed reason for return
  scanned      Boolean   @default(false) // Whether return was scanned/processed
  scannedAt    DateTime? // When scan occurred
  scannedBy    String? // Who performed the scan

  // Relations with cascade delete
  returnSlip ReturnSlip @relation(fields: [returnSlipId], references: [id], onDelete: Cascade)
  parcel     Parcel     @relation(fields: [parcelId], references: [id])

  @@id([returnSlipId, parcelId]) // Composite primary key
  @@index([parcelId]) // Reverse lookup capability
  @@map("return_slip_items")
}
// ========================================
// PAYMENT SLIPS (Bons de paiement)
// Documents for processing delivery payments and fees
// ========================================
/**
 * PaymentSlip Model
 * Manages payment collection and distribution for delivery services
 * Handles payments to delivery personnel and zone operations
 */
model PaymentSlip {
  id        String          @id @default(cuid())
  tenantId  String // Multi-tenant support
  reference String          @unique @db.VarChar(50) // Business reference (BPL/BPV-XXXXXX-XXX)
  type      PaymentSlipType // Payment type (DRIVER/ZONE)

  // Type-specific associations
  deliveryPersonId String? // For DRIVER type - payments to delivery staff
  zoneId           String? // For ZONE type - payments to zone operations

  // Payment amount breakdown - using Decimal for financial precision
  totalAmount    Decimal @default(0) @db.Decimal(12, 2) // Total payment amount
  cashAmount     Decimal @default(0) @db.Decimal(12, 2) // Cash component
  transferAmount Decimal @default(0) @db.Decimal(12, 2) // Bank transfer component
  additionalFees Decimal @default(0) @db.Decimal(12, 2) // Extra fees and charges

  status PaymentSlipStatus @default(PENDING) // Payment processing status

  // Payment workflow tracking
  processedAt DateTime? // When payment processing started
  processedBy String? // Who initiated processing
  paidAt      DateTime? // When payment was completed
  paidBy      String? // Who completed the payment

  // Additional information
  notes String? @db.Text // Payment notes and comments

  // Soft delete support
  isDeleted Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?

  // Audit trail
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String?
  updatedBy String?

  // Relations
  zone            Zone?                      @relation("PaymentSlipZone", fields: [zoneId], references: [id])
  items           PaymentSlipItem[] // Individual parcel payments
  additionalItems PaymentSlipAdditionalFee[] // Extra fees and charges

  // Optimized indexes for financial queries
  @@index([tenantId, type, isDeleted]) // Payments by type
  @@index([tenantId, status, isDeleted]) // Payments by status
  @@index([tenantId, createdAt, isDeleted]) // Time-based payment queries
  @@index([deliveryPersonId, status]) // Driver-specific payments
  @@index([zoneId, status]) // Zone-specific payments
  @@map("payment_slips")
}
/**
 * PaymentSlipItem Model
 * Links individual parcel payments to payment slips
 * Tracks specific fees for each parcel (delivery, return, refusal)
 */
model PaymentSlipItem {
  paymentSlipId String // Reference to payment slip
  parcelId      String // Reference to parcel
  feeType       String  @db.VarChar(20) // Type of fee (DELIVERY, RETURN, REFUSAL)
  amount        Decimal @db.Decimal(10, 2) // Payment amount for this parcel/fee

  // Relations with cascade delete
  paymentSlip PaymentSlip @relation(fields: [paymentSlipId], references: [id], onDelete: Cascade)
  parcel      Parcel      @relation(fields: [parcelId], references: [id])

  @@id([paymentSlipId, parcelId, feeType]) // Composite primary key - prevents duplicate fee types per parcel
  @@index([parcelId]) // Reverse lookup capability
  @@map("payment_slip_items")
}
/**
 * PaymentSlipAdditionalFee Model
 * Handles extra fees and charges not tied to specific parcels
 * Examples: fuel costs, equipment rental, bonus payments
 */
model PaymentSlipAdditionalFee {
  id            String  @id @default(cuid())
  paymentSlipId String // Reference to payment slip
  description   String  @db.VarChar(200) // Fee description
  quantity      Int     @default(1) @db.SmallInt // Quantity for unit-based fees
  unitPrice     Decimal @db.Decimal(10, 2) // Price per unit
  totalPrice    Decimal @db.Decimal(10, 2) // Total fee amount (quantity  unit price)

  // Relations with cascade delete
  paymentSlip PaymentSlip @relation(fields: [paymentSlipId], references: [id], onDelete: Cascade)

  @@index([paymentSlipId]) // Payment slip lookup
  @@map("payment_slip_additional_fees")
}
// ========================================
// ENUMS
// Define the possible values for status and type fields
// ========================================
/**
 * PaymentStatus Enum
 * Tracks the payment lifecycle for parcels
 */
enum PaymentStatus {
  PENDING // Payment not yet received
  PAID // Payment has been received
  INVOICED // Invoice has been generated
}
/**
 * DeliverySlipStatus Enum
 * Tracks the collection process status
 */
enum DeliverySlipStatus {
  PENDING // Created but packages not yet collected
  RECEIVED // Packages have been collected and processed
  CANCELLED // Collection was cancelled
}
/**
 * ShippingSlipStatus Enum
 * Tracks inter-zone transfer status
 */
enum ShippingSlipStatus {
  PENDING // Created but not yet shipped
  SHIPPED // Packages have been sent to destination
  RECEIVED // Packages received at destination zone
  CANCELLED // Shipment was cancelled
}
/**
 * DistributionSlipStatus Enum
 * Tracks delivery assignment status
 */
enum DistributionSlipStatus {
  PENDING // Created but not yet assigned to delivery person
  ASSIGNED // Assigned to delivery person for delivery
  COMPLETED // All packages have been delivered
  CANCELLED // Distribution assignment was cancelled
}
/**
 * ReturnSlipType Enum
 * Defines different types of return processes
 */
enum ReturnSlipType {
  DRIVER // Return from delivery driver to hub (BRL - Bon de Retour Livreur)
  ZONE // Return from zone to central hub (BRV - Bon de Retour Ville)
  CUSTOMER // Return to customer/sender (BRC - Bon de Retour Client)
}
/**
 * ReturnSlipStatus Enum
 * Tracks return processing status
 */
enum ReturnSlipStatus {
  PENDING // Created but processing not started
  INCOMPLETE // Partially processed - some items handled
  RECEIVED // All items have been processed and received
  CANCELLED // Return process was cancelled
}
/**
 * PaymentSlipType Enum
 * Defines different payment slip types
 */
enum PaymentSlipType {
  DRIVER // Payment to delivery driver (BPL - Bon de Paiement Livreur)
  ZONE // Payment to zone operations (BPV - Bon de Paiement Ville)
}
/**
 * PaymentSlipStatus Enum
 * Tracks payment processing workflow
 */
enum PaymentSlipStatus {
  PENDING // Created but processing not started
  IN_PROCESSING // Payment is being processed
  AWAITING_PAYMENT // Waiting for actual payment to be made
  VERIFIED // Payment has been verified
  PAID // Payment completed successfully
  CANCELLED // Payment was cancelled
}
-----------------------------------------------------------------------
--++--> prisma/seed.ts =======>
-----------------------------------------------------------------------
import { PrismaClient } from '@prisma/client';
import { Decimal } from '@prisma/client/runtime/library';
const prisma = new PrismaClient();
/**
 * Reset Database Function
 * Clears all data in reverse dependency parcel to avoid foreign key constraints
 */
async function resetDatabase() {
  console.log(' Resetting parcels database...');

  // Delete in reverse parcel of dependencies to avoid foreign key constraint errors
  await prisma.paymentSlipAdditionalFee.deleteMany({});
  await prisma.paymentSlipItem.deleteMany({});
  await prisma.paymentSlip.deleteMany({});

  await prisma.returnSlipItem.deleteMany({});
  await prisma.returnSlip.deleteMany({});

  await prisma.distributionSlipItem.deleteMany({});
  await prisma.distributionSlip.deleteMany({});

  await prisma.shippingSlipItem.deleteMany({});
  await prisma.shippingSlip.deleteMany({});

  await prisma.deliverySlipItem.deleteMany({});
  await prisma.deliverySlip.deleteMany({});

  await prisma.parcelStatusHistory.deleteMany({});
  await prisma.parcel.deleteMany({});

  await prisma.tariff.deleteMany({});
  await prisma.parcelStatus.deleteMany({});
  await prisma.zoneCity.deleteMany({});
  await prisma.zone.deleteMany({});
  await prisma.pickupCity.deleteMany({});
  await prisma.city.deleteMany({});

  console.log(' Database reset completed');
}
async function main() {
  console.log(' Starting Parcels service seed...');

  // Reset database - comment out if you want to preserve existing data
  await resetDatabase();

  // Multi-tenant configuration
  const tenantId = 'cmfo1utdj00005820owl4mluk';
  const adminUserId = 'cmfo1utlp000g5820u6jov7rw';

  console.log(` Seeding data for tenant: ${tenantId}`);

  // ========================================
  // 1. CREATE CITIES
  // ========================================

  const cities = await Promise.all([
    // Major pickup cities - can accept packages for collection
    prisma.city.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'CAS',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'CAS',
        name: 'Casablanca',
        zone: 'Zone A',
        pickupCity: true, // Can accept pickups
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.city.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'RAB',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'RAB',
        name: 'Rabat',
        zone: 'Zone A',
        pickupCity: true,
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.city.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'MAR',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'MAR',
        name: 'Marrakech',
        zone: 'Zone B',
        pickupCity: true,
        status: true,
        createdBy: adminUserId,
      },
    }),

    // Delivery-only cities - cannot accept pickups
    prisma.city.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'FEZ',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'FEZ',
        name: 'Fez',
        zone: 'Zone B',
        pickupCity: false, // Delivery only
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.city.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'TAN',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'TAN',
        name: 'Tangier',
        zone: 'Zone C',
        pickupCity: false,
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.city.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'AGA',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'AGA',
        name: 'Agadir',
        zone: 'Zone C',
        pickupCity: false,
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.city.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'SALE',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'SALE',
        name: 'Sal',
        zone: 'Zone A',
        pickupCity: false,
        status: true,
        createdBy: adminUserId,
      },
    }),
  ]);

  console.log(` Created ${cities.length} cities`);

  // ========================================
  // 2. CREATE PICKUP CITIES (HUBS)
  // ========================================

  const pickupCities = await Promise.all([
    prisma.pickupCity.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'CAS_HUB',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'CAS_HUB',
        name: 'HUB CASABLANCA',
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.pickupCity.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'RAB_HUB',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'RAB_HUB',
        name: 'HUB RABAT',
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.pickupCity.upsert({
      where: {
        tenantId_ref_isDeleted: {
          tenantId,
          ref: 'MAR_HUB',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        ref: 'MAR_HUB',
        name: 'HUB MARRAKECH',
        status: true,
        createdBy: adminUserId,
      },
    }),
  ]);

  console.log(` Created ${pickupCities.length} pickup cities`);

  // ========================================
  // 3. CREATE ZONES
  // ========================================

  const zones = await Promise.all([
    prisma.zone.upsert({
      where: {
        tenantId_name_isDeleted: {
          tenantId,
          name: 'HUB CASABLANCA',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        name: 'HUB CASABLANCA',
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.zone.upsert({
      where: {
        tenantId_name_isDeleted: {
          tenantId,
          name: 'HUB RABAT',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        name: 'HUB RABAT',
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.zone.upsert({
      where: {
        tenantId_name_isDeleted: {
          tenantId,
          name: 'HUB MARRAKECH',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        name: 'HUB MARRAKECH',
        status: true,
        createdBy: adminUserId,
      },
    }),
  ]);

  console.log(` Created ${zones.length} zones`);

  // ========================================
  // 4. ASSIGN CITIES TO ZONES
  // ========================================

  // Get city and zone references for assignments
  const casablancaCity = cities.find((c) => c.ref === 'CAS');
  const rabatCity = cities.find((c) => c.ref === 'RAB');
  const saleCity = cities.find((c) => c.ref === 'SALE');
  const fezCity = cities.find((c) => c.ref === 'FEZ');
  const marrakechCity = cities.find((c) => c.ref === 'MAR');
  const tangierCity = cities.find((c) => c.ref === 'TAN');
  const agadirCity = cities.find((c) => c.ref === 'AGA');

  const casablancaZone = zones.find((z) => z.name === 'HUB CASABLANCA');
  const rabatZone = zones.find((z) => z.name === 'HUB RABAT');
  const marrakechZone = zones.find((z) => z.name === 'HUB MARRAKECH');

  // Create zone-city assignments
  const zoneAssignments = [];

  // Casablanca Zone
  if (casablancaCity && casablancaZone) {
    zoneAssignments.push(
      prisma.zoneCity.upsert({
        where: {
          zoneId_cityId: {
            zoneId: casablancaZone.id,
            cityId: casablancaCity.id,
          },
        },
        update: {},
        create: {
          zoneId: casablancaZone.id,
          cityId: casablancaCity.id,
        },
      }),
    );
  }

  // Rabat Zone (includes Rabat and Sal)
  if (rabatCity && saleCity && rabatZone) {
    zoneAssignments.push(
      prisma.zoneCity.upsert({
        where: {
          zoneId_cityId: {
            zoneId: rabatZone.id,
            cityId: rabatCity.id,
          },
        },
        update: {},
        create: {
          zoneId: rabatZone.id,
          cityId: rabatCity.id,
        },
      }),
      prisma.zoneCity.upsert({
        where: {
          zoneId_cityId: {
            zoneId: rabatZone.id,
            cityId: saleCity.id,
          },
        },
        update: {},
        create: {
          zoneId: rabatZone.id,
          cityId: saleCity.id,
        },
      }),
    );
  }

  // Marrakech Zone (includes Marrakech, Fez, Tangier, Agadir)
  if (marrakechCity && fezCity && tangierCity && agadirCity && marrakechZone) {
    zoneAssignments.push(
      prisma.zoneCity.upsert({
        where: {
          zoneId_cityId: {
            zoneId: marrakechZone.id,
            cityId: marrakechCity.id,
          },
        },
        update: {},
        create: {
          zoneId: marrakechZone.id,
          cityId: marrakechCity.id,
        },
      }),
      prisma.zoneCity.upsert({
        where: {
          zoneId_cityId: {
            zoneId: marrakechZone.id,
            cityId: fezCity.id,
          },
        },
        update: {},
        create: {
          zoneId: marrakechZone.id,
          cityId: fezCity.id,
        },
      }),
      prisma.zoneCity.upsert({
        where: {
          zoneId_cityId: {
            zoneId: marrakechZone.id,
            cityId: tangierCity.id,
          },
        },
        update: {},
        create: {
          zoneId: marrakechZone.id,
          cityId: tangierCity.id,
        },
      }),
      prisma.zoneCity.upsert({
        where: {
          zoneId_cityId: {
            zoneId: marrakechZone.id,
            cityId: agadirCity.id,
          },
        },
        update: {},
        create: {
          zoneId: marrakechZone.id,
          cityId: agadirCity.id,
        },
      }),
    );
  }

  await Promise.all(zoneAssignments);
  console.log(` Created zone-city assignments`);

  // ========================================
  // 5. CREATE PARCEL STATUSES
  // ========================================

  const parcelStatuses = await Promise.all([
    // Initial parcel status
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'NEW_PACKAGE',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'NEW_PACKAGE',
        name: 'Nouveau Colis',
        color: '#3B82F6', // Blue
        isLocked: true, // System-managed status
        status: true,
        createdBy: adminUserId,
      },
    }),

    // Collection and processing statuses
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'RECEIVED',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'RECEIVED',
        name: 'Reu',
        color: '#10B981', // Emerald
        isLocked: false,
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'COLLECTED',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'COLLECTED',
        name: 'Ramass',
        color: '#8B5CF6', // Purple
        isLocked: false,
        status: true,
        createdBy: adminUserId,
      },
    }),

    // Shipping and transfer statuses
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'DISPATCHED',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'DISPATCHED',
        name: 'Expdi',
        color: '#F59E0B', // Amber
        isLocked: false,
        status: true,
        createdBy: adminUserId,
      },
    }),

    // Distribution and delivery statuses
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'PUT_IN_DISTRIBUTION',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'PUT_IN_DISTRIBUTION',
        name: 'Mis en distribution',
        color: '#06B6D4', // Cyan
        isLocked: false,
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'OUT_FOR_DELIVERY',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'OUT_FOR_DELIVERY',
        name: 'En cours de livraison',
        color: '#F97316', // Orange
        isLocked: false,
        status: true,
        createdBy: adminUserId,
      },
    }),

    // Final delivery statuses
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'DELIVERED',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'DELIVERED',
        name: 'Livr',
        color: '#22C55E', // Green
        isLocked: true, // System-managed status
        status: true,
        createdBy: adminUserId,
      },
    }),

    // Return and refusal statuses
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'RETURNED',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'RETURNED',
        name: 'Retourn',
        color: '#EF4444', // Red
        isLocked: true, // System-managed status
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'REFUSED',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'REFUSED',
        name: 'Refus',
        color: '#DC2626', // Red-600
        isLocked: false,
        status: true,
        createdBy: adminUserId,
      },
    }),
    prisma.parcelStatus.upsert({
      where: {
        tenantId_code_isDeleted: {
          tenantId,
          code: 'CANCELLED',
          isDeleted: false,
        },
      },
      update: {},
      create: {
        tenantId,
        code: 'CANCELLED',
        name: 'Annul',
        color: '#6B7280', // Gray
        isLocked: false,
        status: true,
        createdBy: adminUserId,
      },
    }),
  ]);

  console.log(` Created ${parcelStatuses.length} parcel statuses`);

  // ========================================
  // 6. CREATE TARIFFS (PRICING ROUTES)
  // ========================================

  if (
    casablancaCity &&
    rabatCity &&
    fezCity &&
    marrakechCity &&
    tangierCity &&
    agadirCity
  ) {
    const tariffs = await Promise.all([
      // From Casablanca to other cities
      prisma.tariff.upsert({
        where: {
          tenantId_pickupCityId_destinationCityId_isDeleted: {
            tenantId,
            pickupCityId: casablancaCity.id,
            destinationCityId: rabatCity.id,
            isDeleted: false,
          },
        },
        update: {},
        create: {
          tenantId,
          pickupCityId: casablancaCity.id,
          destinationCityId: rabatCity.id,
          deliveryPrice: new Decimal('25.00'), // Using Decimal for precision
          returnPrice: new Decimal('20.00'),
          refusalPrice: new Decimal('15.00'),
          deliveryDelay: 1,
          createdBy: adminUserId,
        },
      }),
      prisma.tariff.upsert({
        where: {
          tenantId_pickupCityId_destinationCityId_isDeleted: {
            tenantId,
            pickupCityId: casablancaCity.id,
            destinationCityId: fezCity.id,
            isDeleted: false,
          },
        },
        update: {},
        create: {
          tenantId,
          pickupCityId: casablancaCity.id,
          destinationCityId: fezCity.id,
          deliveryPrice: new Decimal('40.00'),
          returnPrice: new Decimal('35.00'),
          refusalPrice: new Decimal('25.00'),
          deliveryDelay: 2,
          createdBy: adminUserId,
        },
      }),
      prisma.tariff.upsert({
        where: {
          tenantId_pickupCityId_destinationCityId_isDeleted: {
            tenantId,
            pickupCityId: casablancaCity.id,
            destinationCityId: marrakechCity.id,
            isDeleted: false,
          },
        },
        update: {},
        create: {
          tenantId,
          pickupCityId: casablancaCity.id,
          destinationCityId: marrakechCity.id,
          deliveryPrice: new Decimal('35.00'),
          returnPrice: new Decimal('30.00'),
          refusalPrice: new Decimal('20.00'),
          deliveryDelay: 2,
          createdBy: adminUserId,
        },
      }),
      prisma.tariff.upsert({
        where: {
          tenantId_pickupCityId_destinationCityId_isDeleted: {
            tenantId,
            pickupCityId: casablancaCity.id,
            destinationCityId: tangierCity.id,
            isDeleted: false,
          },
        },
        update: {},
        create: {
          tenantId,
          pickupCityId: casablancaCity.id,
          destinationCityId: tangierCity.id,
          deliveryPrice: new Decimal('45.00'),
          returnPrice: new Decimal('40.00'),
          refusalPrice: new Decimal('30.00'),
          deliveryDelay: 3,
          createdBy: adminUserId,
        },
      }),
      prisma.tariff.upsert({
        where: {
          tenantId_pickupCityId_destinationCityId_isDeleted: {
            tenantId,
            pickupCityId: casablancaCity.id,
            destinationCityId: agadirCity.id,
            isDeleted: false,
          },
        },
        update: {},
        create: {
          tenantId,
          pickupCityId: casablancaCity.id,
          destinationCityId: agadirCity.id,
          deliveryPrice: new Decimal('50.00'),
          returnPrice: new Decimal('45.00'),
          refusalPrice: new Decimal('35.00'),
          deliveryDelay: 3,
          createdBy: adminUserId,
        },
      }),

      // From Rabat to other cities
      prisma.tariff.upsert({
        where: {
          tenantId_pickupCityId_destinationCityId_isDeleted: {
            tenantId,
            pickupCityId: rabatCity.id,
            destinationCityId: casablancaCity.id,
            isDeleted: false,
          },
        },
        update: {},
        create: {
          tenantId,
          pickupCityId: rabatCity.id,
          destinationCityId: casablancaCity.id,
          deliveryPrice: new Decimal('25.00'),
          returnPrice: new Decimal('20.00'),
          refusalPrice: new Decimal('15.00'),
          deliveryDelay: 1,
          createdBy: adminUserId,
        },
      }),

      // From Marrakech to other cities
      prisma.tariff.upsert({
        where: {
          tenantId_pickupCityId_destinationCityId_isDeleted: {
            tenantId,
            pickupCityId: marrakechCity.id,
            destinationCityId: casablancaCity.id,
            isDeleted: false,
          },
        },
        update: {},
        create: {
          tenantId,
          pickupCityId: marrakechCity.id,
          destinationCityId: casablancaCity.id,
          deliveryPrice: new Decimal('35.00'),
          returnPrice: new Decimal('30.00'),
          refusalPrice: new Decimal('20.00'),
          deliveryDelay: 2,
          createdBy: adminUserId,
        },
      }),
    ]);

    console.log(` Created ${tariffs.length} tariff routes`);
  }

  // ========================================
  // 7. CREATE SAMPLE PARCELS
  // ========================================

  const newPackageStatus = parcelStatuses.find((s) => s.code === 'NEW_PACKAGE');

  if (newPackageStatus && casablancaCity && rabatCity && marrakechCity) {
    // Get tariffs for sample parcels
    const casaToRabatTariff = await prisma.tariff.findFirst({
      where: {
        tenantId,
        pickupCityId: casablancaCity.id,
        destinationCityId: rabatCity.id,
        isDeleted: false,
      },
    });

    const casaToMarrakechTariff = await prisma.tariff.findFirst({
      where: {
        tenantId,
        pickupCityId: casablancaCity.id,
        destinationCityId: marrakechCity.id,
        isDeleted: false,
      },
    });

    const sampleParcels = [];

    if (casaToRabatTariff) {
      sampleParcels.push(
        prisma.parcel.create({
          data: {
            tenantId,
            userId: adminUserId,
            code: 'BSK0925539432LE',
            recipientName: 'Ahmed Benjelloun',
            recipientPhone: '+212661234567',
            recipientAddress: '123 Avenue Mohammed V, Agdal, Rabat',
            alternativePhone: '+212537123456',
            pickupCityId: casablancaCity.id,
            destinationCityId: rabatCity.id,
            productName: 'Smartphone Case Premium',
            quantity: 1,
            price: new Decimal('350.00'),
            comment: 'Appeler avant livraison - Livraison aprs 14h',
            parcelStatusId: newPackageStatus.id,
            parcelStatusCode: newPackageStatus.code,
            deliveryPrice: casaToRabatTariff.deliveryPrice,
            returnPrice: casaToRabatTariff.returnPrice,
            refusalPrice: casaToRabatTariff.refusalPrice,
            deliveryDelay: casaToRabatTariff.deliveryDelay,
            tariffId: casaToRabatTariff.id,
            createdBy: adminUserId,
          },
        }),
        prisma.parcel.create({
          data: {
            tenantId,
            userId: adminUserId,
            code: 'BSK0925539433LE',
            recipientName: 'Fatima El Mansouri',
            recipientPhone: '+212662345678',
            recipientAddress: '456 Rue Hassan II, Centre-ville, Rabat',
            pickupCityId: casablancaCity.id,
            destinationCityId: rabatCity.id,
            productName: 'Laptop Charger Dell',
            quantity: 1,
            price: new Decimal('450.00'),
            parcelStatusId: newPackageStatus.id,
            parcelStatusCode: newPackageStatus.code,
            deliveryPrice: casaToRabatTariff.deliveryPrice,
            returnPrice: casaToRabatTariff.returnPrice,
            refusalPrice: casaToRabatTariff.refusalPrice,
            deliveryDelay: casaToRabatTariff.deliveryDelay,
            tariffId: casaToRabatTariff.id,
            createdBy: adminUserId,
          },
        }),
      );
    }

    if (casaToMarrakechTariff) {
      sampleParcels.push(
        prisma.parcel.create({
          data: {
            tenantId,
            userId: adminUserId,
            code: 'BSK0925539434LE',
            recipientName: 'Youssef Benali',
            recipientPhone: '+212663456789',
            recipientAddress: '789 Avenue Mohammed VI, Gueliz, Marrakech',
            pickupCityId: casablancaCity.id,
            destinationCityId: marrakechCity.id,
            productName: 'Wireless Headphones',
            quantity: 2,
            price: new Decimal('680.00'),
            comment: 'Fragile - Manipuler avec prcaution',
            cannotOpen: true, // Special handling
            parcelStatusId: newPackageStatus.id,
            parcelStatusCode: newPackageStatus.code,
            deliveryPrice: casaToMarrakechTariff.deliveryPrice,
            returnPrice: casaToMarrakechTariff.returnPrice,
            refusalPrice: casaToMarrakechTariff.refusalPrice,
            deliveryDelay: casaToMarrakechTariff.deliveryDelay,
            tariffId: casaToMarrakechTariff.id,
            createdBy: adminUserId,
          },
        }),
      );
    }

    const createdParcels = await Promise.all(sampleParcels);
    console.log(` Created ${createdParcels.length} sample parcels`);

    // Create status history for each parcel
    const statusHistories = createdParcels.map((parcel) =>
      prisma.parcelStatusHistory.create({
        data: {
          parcelId: parcel.id,
          parcelStatusId: newPackageStatus.id,
          statusCode: newPackageStatus.code,
          comment: 'Parcel created successfully',
          changedBy: adminUserId,
        },
      }),
    );

    await Promise.all(statusHistories);
    console.log(
      ` Created status history for ${statusHistories.length} parcels`,
    );
  }

  // ========================================
  // COMPLETION SUMMARY
  // ========================================

  console.log('\n Parcels service seed completed successfully!');
  console.log('\n Created Data Summary:');
  console.log(`Tenant ID: ${tenantId}`);
  console.log(`Cities: ${cities.length}`);
  console.log(`Pickup Cities: ${pickupCities.length}`);
  console.log(`Zones: ${zones.length}`);
  console.log(`Parcel Statuses: ${parcelStatuses.length}`);

  const totalTariffs = await prisma.tariff.count({
    where: { tenantId, isDeleted: false },
  });
  const totalParcels = await prisma.parcel.count({
    where: { tenantId, isDeleted: false },
  });

  console.log(`Tariff Routes: ${totalTariffs}`);
  console.log(`Sample Parcels: ${totalParcels}`);

  console.log('\n Database seeding completed - Ready for testing!');
}
// Execute the seeding process
main()
  .catch((e) => {
    console.error(' Parcels seed failed:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
-----------------------------------------------------------------------
--++--> src/modules/shipping-slips/dto/shipping-slip.dto.ts =======>
-----------------------------------------------------------------------
import {
  IsString,
  IsArray,
  IsOptional,
  IsNotEmpty,
  IsEnum,
  IsDateString,
} from 'class-validator';
import { Transform, Type } from 'class-transformer';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { PaginationDto } from '../../../common/dto/pagination.dto';
// Enums for status management
export enum ShippingSlipStatus {
  PENDING = 'PENDING',
  SHIPPED = 'SHIPPED',
  RECEIVED = 'RECEIVED',
  CANCELLED = 'CANCELLED',
}
export class CreateShippingSlipDto {
  @ApiProperty({
    example: 'cuid123',
    description: 'Destination zone ID where packages will be shipped',
  })
  @IsString()
  @IsNotEmpty()
  destinationZoneId: string;

  @ApiPropertyOptional({
    example: ['parcel1', 'parcel2'],
    description: 'Array of parcel IDs to include in shipping slip',
  })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  parcelIds?: string[];
}
export class UpdateShippingSlipDto {
  @ApiPropertyOptional({
    example: 'cuid456',
    description: 'Update destination zone ID',
  })
  @IsOptional()
  @IsString()
  destinationZoneId?: string;

  @ApiPropertyOptional({
    enum: ShippingSlipStatus,
    example: ShippingSlipStatus.SHIPPED,
    description: 'Update shipping slip status',
  })
  @IsOptional()
  @IsEnum(ShippingSlipStatus)
  status?: ShippingSlipStatus;

  @ApiPropertyOptional({
    example: ['parcel1', 'parcel2', 'parcel3'],
    description: 'Update parcel IDs in shipping slip',
  })
  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  parcelIds?: string[];
}
export class ShippingSlipQueryDto extends PaginationDto {
  @ApiPropertyOptional({
    example: 'BE-123456',
    description: 'Search by reference or zone name',
  })
  @IsOptional()
  @IsString()
  search?: string;

  @ApiPropertyOptional({
    example: 'cuid123',
    description: 'Filter by destination zone ID',
  })
  @IsOptional()
  @IsString()
  destinationZoneId?: string;

  @ApiPropertyOptional({
    enum: ShippingSlipStatus,
    example: ShippingSlipStatus.PENDING,
    description: 'Filter by shipping slip status',
  })
  @IsOptional()
  @IsEnum(ShippingSlipStatus)
  status?: ShippingSlipStatus;

  @ApiPropertyOptional({
    example: '2024-01-01',
    description: 'Filter by creation date from (YYYY-MM-DD)',
  })
  @IsOptional()
  @IsDateString()
  dateFrom?: string;

  @ApiPropertyOptional({
    example: '2024-12-31',
    description: 'Filter by creation date to (YYYY-MM-DD)',
  })
  @IsOptional()
  @IsDateString()
  dateTo?: string;
}
export class ShippingSlipItemDto {
  @ApiProperty()
  parcelId: string;

  @ApiProperty()
  scanned: boolean;

  @ApiPropertyOptional()
  scannedAt?: Date;

  @ApiPropertyOptional()
  scannedBy?: string;

  @ApiPropertyOptional()
  parcel?: {
    id: string;
    code: string;
    recipientName: string;
    recipientPhone: string;
    destinationCity: {
      id: string;
      name: string;
      ref: string;
    };
    price: number;
    parcelStatusCode: string;
  };
}
export class ShippingSlipResponseDto {
  @ApiProperty()
  id: string;

  @ApiProperty()
  tenantId: string;

  @ApiProperty()
  reference: string;

  @ApiProperty()
  destinationZoneId: string;

  @ApiProperty({ enum: ShippingSlipStatus })
  status: ShippingSlipStatus;

  @ApiPropertyOptional()
  shippedAt?: Date;

  @ApiPropertyOptional()
  shippedBy?: string;

  @ApiPropertyOptional()
  receivedAt?: Date;

  @ApiPropertyOptional()
  receivedBy?: string;

  @ApiProperty()
  createdAt: Date;

  @ApiProperty()
  updatedAt: Date;

  @ApiPropertyOptional()
  createdBy?: string;

  @ApiPropertyOptional()
  updatedBy?: string;

  @ApiPropertyOptional()
  destinationZone?: {
    id: string;
    name: string;
  };

  @ApiPropertyOptional({ type: [ShippingSlipItemDto] })
  items?: ShippingSlipItemDto[];

  @ApiPropertyOptional()
  _count?: {
    items: number;
    scannedItems: number;
    totalValue: number;
  };
}
export class ShippingSlipStatsDto {
  @ApiProperty({ description: 'Total shipping slips' })
  total: number;

  @ApiProperty({ description: 'Pending shipping slips' })
  pending: number;

  @ApiProperty({ description: 'Shipped but not received' })
  inTransit: number;

  @ApiProperty({ description: 'Completed shipping slips' })
  completed: number;

  @ApiProperty({ description: 'Cancelled shipping slips' })
  cancelled: number;

  @ApiProperty({ description: 'Total packages shipped this month' })
  packagesShippedThisMonth: number;

  @ApiProperty({ description: 'Average packages per slip' })
  averagePackagesPerSlip: number;

  @ApiProperty({ description: 'Top destination zones' })
  topDestinationZones: Array<{
    zoneId: string;
    zoneName: string;
    count: number;
    percentage: number;
  }>;
}
export class AddParcelsToShippingSlipDto {
  @ApiProperty({
    example: ['parcel1', 'parcel2'],
    description: 'Array of parcel IDs to add to shipping slip',
  })
  @IsArray()
  @IsString({ each: true })
  @IsNotEmpty({ each: true })
  parcelIds: string[];
}
export class RemoveParcelsFromShippingSlipDto {
  @ApiProperty({
    example: ['parcel1', 'parcel2'],
    description: 'Array of parcel IDs to remove from shipping slip',
  })
  @IsArray()
  @IsString({ each: true })
  @IsNotEmpty({ each: true })
  parcelIds: string[];
}
export class ScanParcelDto {
  @ApiProperty({
    example: 'BSK0925539432LE',
    description: 'Parcel code to scan',
  })
  @IsString()
  @IsNotEmpty()
  parcelCode: string;
}
export class BulkScanDto {
  @ApiProperty({
    example: ['BSK0925539432LE', 'BSK0925539433LE'],
    description: 'Array of parcel codes to scan',
  })
  @IsArray()
  @IsString({ each: true })
  @IsNotEmpty({ each: true })
  parcelCodes: string[];
}
export class AvailableParcelsQueryDto extends PaginationDto {
  @ApiProperty({
    example: 'cuid123',
    description: 'Destination zone ID to filter available parcels',
  })
  @IsString()
  @IsNotEmpty()
  destinationZoneId: string;

  @ApiPropertyOptional({
    example: 'BSK092',
    description: 'Search parcels by code or recipient name',
  })
  @IsOptional()
  @IsString()
  search?: string;
}
export class AvailableParcelDto {
  @ApiProperty()
  id: string;

  @ApiProperty()
  code: string;

  @ApiProperty()
  recipientName: string;

  @ApiProperty()
  recipientPhone: string;

  @ApiProperty()
  price: number;

  @ApiProperty()
  parcelStatusCode: string;

  @ApiProperty()
  createdAt: Date;

  @ApiProperty()
  pickupCity: {
    id: string;
    name: string;
    ref: string;
  };

  @ApiProperty()
  destinationCity: {
    id: string;
    name: string;
    ref: string;
  };
}
-----------------------------------------------------------------------
--++--> src/modules/shipping-slips/shipping-slips.controller.ts =======>
-----------------------------------------------------------------------
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  HttpStatus,
  HttpCode,
  BadRequestException,
} from '@nestjs/common';
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiParam,
  ApiBadRequestResponse,
  ApiNotFoundResponse,
  ApiConflictResponse,
} from '@nestjs/swagger';
import { ShippingSlipsService } from './shipping-slips.service';
import {
  CreateShippingSlipDto,
  UpdateShippingSlipDto,
  ShippingSlipQueryDto,
  ShippingSlipResponseDto,
  ShippingSlipStatsDto,
  AddParcelsToShippingSlipDto,
  RemoveParcelsFromShippingSlipDto,
  ScanParcelDto,
  BulkScanDto,
  AvailableParcelsQueryDto,
  AvailableParcelDto,
} from './dto/shipping-slip.dto';
import { PaginatedResult } from '../../common/dto/pagination.dto';
import {
  GlobalAuth,
  CurrentTenant,
  CurrentUser,
  Public,
} from '@network-saas/auth-lib';
import { ParseCuidPipe } from '../../common/pipes/parse-cuid.pipe';
@ApiTags('shipping-slips')
@Controller('shipping-slips')
export class ShippingSlipsController {
  constructor(private readonly shippingSlipsService: ShippingSlipsService) {}

  @Post()
  @GlobalAuth('shipping_slips:create')
  @ApiOperation({
    summary: 'Create a new shipping slip',
    description:
      'Create a shipping slip for transferring packages between zones',
  })
  @ApiResponse({
    status: 201,
    description: 'Shipping slip created successfully',
    type: ShippingSlipResponseDto,
  })
  @ApiBadRequestResponse({ description: 'Invalid zone or parcels' })
  async create(
    @Body() createDto: CreateShippingSlipDto,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<ShippingSlipResponseDto> {
    return this.shippingSlipsService.create(createDto, tenantId, user.id);
  }

  @Get()
  @GlobalAuth('shipping_slips:read')
  @ApiOperation({
    summary: 'Get all shipping slips',
    description: 'Retrieve paginated list of shipping slips with filtering',
  })
  @ApiResponse({
    status: 200,
    description: 'Shipping slips retrieved successfully',
    type: PaginatedResult<ShippingSlipResponseDto>,
  })
  async findAll(
    @CurrentTenant() tenantId: string,
    @Query() query: ShippingSlipQueryDto,
  ): Promise<PaginatedResult<ShippingSlipResponseDto>> {
    return this.shippingSlipsService.findAll(tenantId, query);
  }

  @Get('stats')
  @GlobalAuth('shipping_slips:read')
  @ApiOperation({
    summary: 'Get shipping slip statistics',
    description: 'Get comprehensive statistics about shipping operations',
  })
  @ApiResponse({
    status: 200,
    description: 'Statistics retrieved successfully',
    type: ShippingSlipStatsDto,
  })
  async getStatistics(
    @CurrentTenant() tenantId: string,
  ): Promise<ShippingSlipStatsDto> {
    return this.shippingSlipsService.getStatistics(tenantId);
  }

  @Get('available-parcels')
  @GlobalAuth('shipping_slips:read')
  @ApiOperation({
    summary: 'Get available parcels for shipping',
    description:
      'Get parcels that can be added to a shipping slip for a specific zone',
  })
  @ApiResponse({
    status: 200,
    description: 'Available parcels retrieved successfully',
    type: PaginatedResult<AvailableParcelDto>,
  })
  async getAvailableParcels(
    @CurrentTenant() tenantId: string,
    @Query() query: AvailableParcelsQueryDto,
  ): Promise<PaginatedResult<AvailableParcelDto>> {
    return this.shippingSlipsService.getAvailableParcels(tenantId, query);
  }

  @Get(':id')
  @GlobalAuth('shipping_slips:read')
  @ApiOperation({
    summary: 'Get shipping slip by ID',
    description: 'Retrieve a specific shipping slip with all items',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Shipping slip ID' })
  @ApiResponse({
    status: 200,
    description: 'Shipping slip retrieved successfully',
    type: ShippingSlipResponseDto,
  })
  @ApiNotFoundResponse({ description: 'Shipping slip not found' })
  async findOne(
    @Param('id', ParseCuidPipe) id: string,
    @CurrentTenant() tenantId: string,
  ): Promise<ShippingSlipResponseDto> {
    return this.shippingSlipsService.findOne(id, tenantId);
  }

  @Patch(':id')
  @GlobalAuth('shipping_slips:update')
  @ApiOperation({
    summary: 'Update shipping slip',
    description: 'Update shipping slip details',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Shipping slip ID' })
  @ApiResponse({
    status: 200,
    description: 'Shipping slip updated successfully',
    type: ShippingSlipResponseDto,
  })
  @ApiNotFoundResponse({ description: 'Shipping slip not found' })
  @ApiBadRequestResponse({ description: 'Cannot modify shipped/received slip' })
  async update(
    @Param('id', ParseCuidPipe) id: string,
    @Body() updateDto: UpdateShippingSlipDto,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<ShippingSlipResponseDto> {
    return this.shippingSlipsService.update(id, updateDto, tenantId, user.id);
  }

  @Delete(':id')
  @GlobalAuth('shipping_slips:delete')
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({
    summary: 'Delete shipping slip',
    description: 'Soft delete a shipping slip (only if pending)',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Shipping slip ID' })
  @ApiResponse({
    status: 204,
    description: 'Shipping slip deleted successfully',
  })
  @ApiNotFoundResponse({ description: 'Shipping slip not found' })
  @ApiBadRequestResponse({ description: 'Cannot delete shipped/received slip' })
  async remove(
    @Param('id', ParseCuidPipe) id: string,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<void> {
    await this.shippingSlipsService.remove(id, tenantId, user.id);
  }

  @Post(':id/add-parcels')
  @GlobalAuth('shipping_slips:update')
  @ApiOperation({
    summary: 'Add parcels to shipping slip',
    description: 'Add multiple parcels to an existing shipping slip',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Shipping slip ID' })
  @ApiResponse({
    status: 200,
    description: 'Parcels added successfully',
    type: ShippingSlipResponseDto,
  })
  @ApiBadRequestResponse({
    description: 'Invalid parcels or slip not modifiable',
  })
  async addParcels(
    @Param('id', ParseCuidPipe) id: string,
    @Body() addParcelsDto: AddParcelsToShippingSlipDto,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<ShippingSlipResponseDto> {
    return this.shippingSlipsService.addParcels(
      id,
      addParcelsDto.parcelIds,
      tenantId,
      user.id,
    );
  }

  @Post(':id/remove-parcels')
  @GlobalAuth('shipping_slips:update')
  @ApiOperation({
    summary: 'Remove parcels from shipping slip',
    description: 'Remove multiple parcels from an existing shipping slip',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Shipping slip ID' })
  @ApiResponse({
    status: 200,
    description: 'Parcels removed successfully',
    type: ShippingSlipResponseDto,
  })
  @ApiBadRequestResponse({
    description: 'Parcels not in slip or slip not modifiable',
  })
  async removeParcels(
    @Param('id', ParseCuidPipe) id: string,
    @Body() removeParcelsDto: RemoveParcelsFromShippingSlipDto,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<ShippingSlipResponseDto> {
    return this.shippingSlipsService.removeParcels(
      id,
      removeParcelsDto.parcelIds,
      tenantId,
      user.id,
    );
  }

  @Post(':id/scan-parcel')
  @GlobalAuth('shipping_slips:scan')
  @ApiOperation({
    summary: 'Scan parcel for shipping',
    description: 'Scan an parcel code to mark it as processed for shipping',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Shipping slip ID' })
  @ApiResponse({
    status: 200,
    description: 'Parcel scanned successfully',
    schema: {
      type: 'object',
      properties: {
        success: { type: 'boolean' },
        message: { type: 'string' },
        parcel: { type: 'object' },
        scanInfo: { type: 'object' },
      },
    },
  })
  @ApiBadRequestResponse({
    description: 'Parcel not in slip or already scanned',
  })
  async scanParcel(
    @Param('id', ParseCuidPipe) id: string,
    @Body() scanDto: ScanParcelDto,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ) {
    return this.shippingSlipsService.scanParcel(
      id,
      scanDto.parcelCode,
      tenantId,
      user.id,
    );
  }

  @Post(':id/scan-bulk')
  @GlobalAuth('shipping_slips:scan')
  @ApiOperation({
    summary: 'Bulk scan parcels for shipping',
    description: 'Scan multiple parcel codes at once',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Shipping slip ID' })
  @ApiResponse({
    status: 200,
    description: 'Bulk scan completed',
    schema: {
      type: 'object',
      properties: {
        success: { type: 'boolean' },
        scannedCount: { type: 'number' },
        failedCount: { type: 'number' },
        results: { type: 'array', items: { type: 'object' } },
      },
    },
  })
  async bulkScanParcels(
    @Param('id', ParseCuidPipe) id: string,
    @Body() bulkScanDto: BulkScanDto,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ) {
    return this.shippingSlipsService.bulkScanParcels(
      id,
      bulkScanDto.parcelCodes,
      tenantId,
      user.id,
    );
  }

  @Post(':id/ship')
  @GlobalAuth('shipping_slips:ship')
  @ApiOperation({
    summary: 'Mark shipping slip as shipped',
    description: 'Mark the shipping slip as shipped and update parcel statuses',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Shipping slip ID' })
  @ApiResponse({
    status: 200,
    description: 'Shipping slip marked as shipped',
    type: ShippingSlipResponseDto,
  })
  @ApiBadRequestResponse({
    description: 'Cannot ship - invalid status or no parcels',
  })
  async markAsShipped(
    @Param('id', ParseCuidPipe) id: string,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<ShippingSlipResponseDto> {
    return this.shippingSlipsService.markAsShipped(id, tenantId, user.id);
  }

  @Post(':id/receive')
  @GlobalAuth('shipping_slips:receive')
  @ApiOperation({
    summary: 'Mark shipping slip as received',
    description: 'Mark the shipping slip as received at destination zone',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Shipping slip ID' })
  @ApiResponse({
    status: 200,
    description: 'Shipping slip marked as received',
    type: ShippingSlipResponseDto,
  })
  @ApiBadRequestResponse({
    description: 'Cannot receive - must be shipped first',
  })
  async markAsReceived(
    @Param('id', ParseCuidPipe) id: string,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<ShippingSlipResponseDto> {
    return this.shippingSlipsService.markAsReceived(id, tenantId, user.id);
  }

  @Post(':id/cancel')
  @GlobalAuth('shipping_slips:cancel')
  @ApiOperation({
    summary: 'Cancel shipping slip',
    description: 'Cancel a shipping slip and revert parcel statuses',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Shipping slip ID' })
  @ApiResponse({
    status: 200,
    description: 'Shipping slip cancelled successfully',
    type: ShippingSlipResponseDto,
  })
  @ApiBadRequestResponse({ description: 'Cannot cancel - already received' })
  async cancelShippingSlip(
    @Param('id', ParseCuidPipe) id: string,
    @CurrentTenant() tenantId: string,
    @CurrentUser() user: any,
  ): Promise<ShippingSlipResponseDto> {
    return this.shippingSlipsService.cancelShippingSlip(id, tenantId, user.id);
  }

  @Get(':id/pdf')
  @GlobalAuth('shipping_slips:read')
  @ApiOperation({
    summary: 'Generate shipping slip PDF',
    description: 'Generate and download PDF for the shipping slip',
  })
  @ApiParam({ name: 'id', type: 'string', description: 'Shipping slip ID' })
  @ApiResponse({
    status: 200,
    description: 'PDF generated successfully',
    headers: {
      'Content-Type': { description: 'application/pdf' },
      'Content-Disposition': { description: 'attachment; filename=...' },
    },
  })
  async generatePDF(
    @Param('id', ParseCuidPipe) id: string,
    @CurrentTenant() tenantId: string,
  ) {
    return this.shippingSlipsService.generatePDF(id, tenantId);
  }
}
-----------------------------------------------------------------------
--++--> src/modules/shipping-slips/shipping-slips.module.ts =======>
-----------------------------------------------------------------------
import { Module } from '@nestjs/common';
import { ShippingSlipsService } from './shipping-slips.service';
import { ShippingSlipsController } from './shipping-slips.controller';
import { PrismaModule } from '../../shared/services/prisma/prisma.module';
import { RedisModule } from '../../shared/services/redis/redis.module';
@Module({
  imports: [PrismaModule, RedisModule],
  controllers: [ShippingSlipsController],
  providers: [ShippingSlipsService],
  exports: [ShippingSlipsService],
})
export class ShippingSlipsModule {}
-----------------------------------------------------------------------
--++--> src/modules/shipping-slips/services/shipping-slips.service.ts =======>
-----------------------------------------------------------------------
import {
  Injectable,
  NotFoundException,
  BadRequestException,
  ConflictException,
  Logger,
} from '@nestjs/common';
import { PrismaService } from '../../shared/services/prisma/prisma.service';
import { RedisService } from '../../shared/services/redis/redis.service';
import {
  CreateShippingSlipDto,
  UpdateShippingSlipDto,
  ShippingSlipQueryDto,
  ShippingSlipResponseDto,
  ShippingSlipStatsDto,
  ShippingSlipStatus,
  AvailableParcelsQueryDto,
  AvailableParcelDto,
} from './dto/shipping-slip.dto';
import { PaginatedResult } from '../../common/dto/pagination.dto';
@Injectable()
export class ShippingSlipsService {
  private readonly logger = new Logger(ShippingSlipsService.name);

  constructor(
    private prisma: PrismaService,
    private redis: RedisService,
  ) {}

  async create(
    createDto: CreateShippingSlipDto,
    tenantId: string,
    userId: string,
  ): Promise<ShippingSlipResponseDto> {
    // Validate destination zone exists
    const destinationZone = await this.prisma.zone.findFirst({
      where: {
        id: createDto.destinationZoneId,
        tenantId,
        isDeleted: false,
        status: true,
      },
    });

    if (!destinationZone) {
      throw new BadRequestException('Invalid destination zone');
    }

    // Generate reference
    const reference = await this.generateReference(tenantId);

    // Validate parcels if provided
    let validatedParcels: string[] = [];
    if (createDto.parcelIds && createDto.parcelIds.length > 0) {
      validatedParcels = await this.validateParcelsForShipping(
        createDto.parcelIds,
        createDto.destinationZoneId,
        tenantId,
      );
    }

    // Create shipping slip in transaction
    const result = await this.prisma.$transaction(async (tx) => {
      // Create the shipping slip
      const shippingSlip = await tx.shippingSlip.create({
        data: {
          reference,
          destinationZoneId: createDto.destinationZoneId,
          status: ShippingSlipStatus.PENDING,
          tenantId,
          createdBy: userId,
        },
      });

      // Add parcels if provided
      if (validatedParcels.length > 0) {
        await tx.shippingSlipItem.createMany({
          data: validatedParcels.map((parcelId) => ({
            shippingSlipId: shippingSlip.id,
            parcelId,
          })),
        });

        // Update parcel status to DISPATCHED
        await tx.parcel.updateMany({
          where: {
            id: { in: validatedParcels },
            tenantId,
          },
          data: {
            parcelStatusCode: 'DISPATCHED',
            updatedBy: userId,
          },
        });

        // Add status history for parcels
        const dispatchedStatus = await tx.parcelStatus.findFirst({
          where: { tenantId, code: 'DISPATCHED', isDeleted: false },
        });

        if (dispatchedStatus) {
          await tx.parcelStatusHistory.createMany({
            data: validatedParcels.map((parcelId) => ({
              parcelId,
              parcelStatusId: dispatchedStatus.id,
              statusCode: 'DISPATCHED',
              comment: `Added to shipping slip ${reference}`,
              changedBy: userId,
            })),
          });
        }
      }

      return shippingSlip;
    });

    await this.clearCache(tenantId);

    this.logger.log(
      `Created shipping slip ${reference} for zone ${destinationZone.name} with ${validatedParcels.length} parcels`,
    );

    return this.findOne(result.id, tenantId);
  }

  async findAll(
    tenantId: string,
    query: ShippingSlipQueryDto,
  ): Promise<PaginatedResult<ShippingSlipResponseDto>> {
    const {
      page = 1,
      limit = 10,
      search,
      destinationZoneId,
      status,
      dateFrom,
      dateTo,
    } = query;
    const skip = (page - 1) * limit;

    // Build where clause
    const where: any = {
      tenantId,
      isDeleted: false,
    };

    if (search) {
      where.OR = [
        { reference: { contains: search, mode: 'insensitive' } },
        {
          destinationZone: {
            name: { contains: search, mode: 'insensitive' },
          },
        },
      ];
    }

    if (destinationZoneId) {
      where.destinationZoneId = destinationZoneId;
    }

    if (status) {
      where.status = status;
    }

    // Date filtering
    if (dateFrom || dateTo) {
      where.createdAt = {};
      if (dateFrom) {
        where.createdAt.gte = new Date(dateFrom);
      }
      if (dateTo) {
        const endDate = new Date(dateTo);
        endDate.setHours(23, 59, 59, 999);
        where.createdAt.lte = endDate;
      }
    }

    const [total, shippingSlips] = await Promise.all([
      this.prisma.shippingSlip.count({ where }),
      this.prisma.shippingSlip.findMany({
        where,
        skip,
        take: limit,
        orderBy: [{ createdAt: 'desc' }],
        include: {
          destinationZone: {
            select: { id: true, name: true },
          },
          _count: {
            select: { items: true },
          },
          items: {
            take: 5, // Limit for performance
            include: {
              parcel: {
                select: {
                  code: true,
                  recipientName: true,
                  price: true,
                },
              },
            },
          },
        },
      }),
    ]);

    const data = shippingSlips.map((slip) => this.mapToResponseDto(slip));
    return new PaginatedResult(data, page, limit, total);
  }

  async findOne(
    id: string,
    tenantId: string,
  ): Promise<ShippingSlipResponseDto> {
    const shippingSlip = await this.prisma.shippingSlip.findFirst({
      where: {
        id,
        tenantId,
        isDeleted: false,
      },
      include: {
        destinationZone: {
          select: { id: true, name: true },
        },
        _count: {
          select: { items: true },
        },
        items: {
          include: {
            parcel: {
              select: {
                id: true,
                code: true,
                recipientName: true,
                recipientPhone: true,
                price: true,
                parcelStatusCode: true,
                destinationCity: {
                  select: {
                    id: true,
                    name: true,
                    ref: true,
                  },
                },
              },
            },
          },
          orderBy: { parcel: { code: 'asc' } },
        },
      },
    });

    if (!shippingSlip) {
      throw new NotFoundException('Shipping slip not found');
    }

    return this.mapToResponseDto(shippingSlip);
  }

  async update(
    id: string,
    updateDto: UpdateShippingSlipDto,
    tenantId: string,
    userId: string,
  ): Promise<ShippingSlipResponseDto> {
    const existing = await this.prisma.shippingSlip.findFirst({
      where: { id, tenantId, isDeleted: false },
      include: { _count: { select: { items: true } } },
    });

    if (!existing) {
      throw new NotFoundException('Shipping slip not found');
    }

    // Check if modifiable
    if (existing.status !== ShippingSlipStatus.PENDING) {
      throw new BadRequestException(
        `Cannot modify shipping slip with status: ${existing.status}`,
      );
    }

    // Validate destination zone if updating
    if (updateDto.destinationZoneId) {
      const zone = await this.prisma.zone.findFirst({
        where: {
          id: updateDto.destinationZoneId,
          tenantId,
          isDeleted: false,
          status: true,
        },
      });

      if (!zone) {
        throw new BadRequestException('Invalid destination zone');
      }
    }

    // Handle parcel updates in transaction
    const result = await this.prisma.$transaction(async (tx) => {
      // Update shipping slip
      const updatedSlip = await tx.shippingSlip.update({
        where: { id },
        data: {
          destinationZoneId: updateDto.destinationZoneId,
          status: updateDto.status,
          updatedBy: userId,
        },
      });

      // Handle parcel replacements
      if (updateDto.parcelIds !== undefined) {
        // Get current parcels
        const currentItems = await tx.shippingSlipItem.findMany({
          where: { shippingSlipId: id },
        });
        const currentParcelIds = currentItems.map((item) => item.parcelId);

        // Remove all current parcels
        if (currentItems.length > 0) {
          await tx.shippingSlipItem.deleteMany({
            where: { shippingSlipId: id },
          });

          // Revert parcel statuses
          await tx.parcel.updateMany({
            where: { id: { in: currentParcelIds }, tenantId },
            data: { parcelStatusCode: 'COLLECTED', updatedBy: userId },
          });
        }

        // Add new parcels if provided
        if (updateDto.parcelIds.length > 0) {
          const validatedParcels = await this.validateParcelsForShipping(
            updateDto.parcelIds,
            updateDto.destinationZoneId || existing.destinationZoneId,
            tenantId,
          );

          await tx.shippingSlipItem.createMany({
            data: validatedParcels.map((parcelId) => ({
              shippingSlipId: id,
              parcelId,
            })),
          });

          // Update new parcel statuses
          await tx.parcel.updateMany({
            where: { id: { in: validatedParcels }, tenantId },
            data: { parcelStatusCode: 'DISPATCHED', updatedBy: userId },
          });
        }
      }

      return updatedSlip;
    });

    await this.clearCache(tenantId);

    this.logger.log(`Updated shipping slip ${id} for tenant ${tenantId}`);
    return this.findOne(id, tenantId);
  }

  async remove(id: string, tenantId: string, userId: string): Promise<void> {
    const existing = await this.prisma.shippingSlip.findFirst({
      where: { id, tenantId, isDeleted: false },
      include: {
        items: true,
      },
    });

    if (!existing) {
      throw new NotFoundException('Shipping slip not found');
    }

    if (existing.status !== ShippingSlipStatus.PENDING) {
      throw new BadRequestException(
        'Cannot delete shipping slip that has been shipped or received',
      );
    }

    await this.prisma.$transaction(async (tx) => {
      // Revert parcel statuses
      if (existing.items.length > 0) {
        const parcelIds = existing.items.map((item) => item.parcelId);

        await tx.parcel.updateMany({
          where: { id: { in: parcelIds }, tenantId },
          data: { parcelStatusCode: 'COLLECTED', updatedBy: userId },
        });

        // Remove shipping slip items
        await tx.shippingSlipItem.deleteMany({
          where: { shippingSlipId: id },
        });
      }

      // Soft delete shipping slip
      await tx.shippingSlip.update({
        where: { id },
        data: {
          isDeleted: true,
          deletedAt: new Date(),
          deletedBy: userId,
        },
      });
    });

    await this.clearCache(tenantId);
    this.logger.log(`Deleted shipping slip ${id} for tenant ${tenantId}`);
  }

  async getAvailableParcels(
    tenantId: string,
    query: AvailableParcelsQueryDto,
  ): Promise<PaginatedResult<AvailableParcelDto>> {
    const { page = 1, limit = 10, destinationZoneId, search } = query;
    const skip = (page - 1) * limit;

    // Validate destination zone
    const zone = await this.prisma.zone.findFirst({
      where: {
        id: destinationZoneId,
        tenantId,
        isDeleted: false,
      },
      include: {
        cities: {
          include: {
            city: { select: { id: true } },
          },
        },
      },
    });

    if (!zone) {
      throw new BadRequestException('Invalid destination zone');
    }

    const zoneCityIds = zone.cities.map((zc) => zc.city.id);

    // Build where clause for available parcels
    const where: any = {
      tenantId,
      isDeleted: false,
      parcelStatusCode: 'COLLECTED', // Only collected parcels can be shipped
      destinationCityId: { in: zoneCityIds }, // Parcels going to cities in this zone
      shippingSlipItems: { none: {} }, // Not already in a shipping slip
    };

    if (search) {
      where.OR = [
        { code: { contains: search, mode: 'insensitive' } },
        { recipientName: { contains: search, mode: 'insensitive' } },
      ];
    }

    const [total, parcels] = await Promise.all([
      this.prisma.parcel.count({ where }),
      this.prisma.parcel.findMany({
        where,
        skip,
        take: limit,
        orderBy: [{ createdAt: 'desc' }],
        select: {
          id: true,
          code: true,
          recipientName: true,
          recipientPhone: true,
          price: true,
          parcelStatusCode: true,
          createdAt: true,
          pickupCity: {
            select: { id: true, name: true, ref: true },
          },
          destinationCity: {
            select: { id: true, name: true, ref: true },
          },
        },
      }),
    ]);

    const data = parcels.map((parcel) => ({
      ...parcel,
      price: Number(parcel.price),
    }));

    return new PaginatedResult(data, page, limit, total);
  }

  async addParcels(
    id: string,
    parcelIds: string[],
    tenantId: string,
    userId: string,
  ): Promise<ShippingSlipResponseDto> {
    const shippingSlip = await this.prisma.shippingSlip.findFirst({
      where: { id, tenantId, isDeleted: false },
      include: { items: true },
    });

    if (!shippingSlip) {
      throw new NotFoundException('Shipping slip not found');
    }

    if (shippingSlip.status !== ShippingSlipStatus.PENDING) {
      throw new BadRequestException('Cannot modify shipped or received slip');
    }

    // Validate parcels
    const validatedParcels = await this.validateParcelsForShipping(
      parcelIds,
      shippingSlip.destinationZoneId,
      tenantId,
    );

    // Check if any parcels are already in this slip
    const existingParcelIds = shippingSlip.items.map((item) => item.parcelId);
    const newParcels = validatedParcels.filter(
      (parcelId) => !existingParcelIds.includes(parcelId),
    );

    if (newParcels.length === 0) {
      throw new BadRequestException(
        'All parcels are already in this shipping slip',
      );
    }

    await this.prisma.$transaction(async (tx) => {
      // Add new parcels
      await tx.shippingSlipItem.createMany({
        data: newParcels.map((parcelId) => ({
          shippingSlipId: id,
          parcelId,
        })),
      });

      // Update parcel statuses
      await tx.parcel.updateMany({
        where: { id: { in: newParcels }, tenantId },
        data: { parcelStatusCode: 'DISPATCHED', updatedBy: userId },
      });

      // Add status history
      const dispatchedStatus = await tx.parcelStatus.findFirst({
        where: { tenantId, code: 'DISPATCHED', isDeleted: false },
      });

      if (dispatchedStatus) {
        await tx.parcelStatusHistory.createMany({
          data: newParcels.map((parcelId) => ({
            parcelId,
            parcelStatusId: dispatchedStatus.id,
            statusCode: 'DISPATCHED',
            comment: `Added to shipping slip ${shippingSlip.reference}`,
            changedBy: userId,
          })),
        });
      }

      // Update shipping slip
      await tx.shippingSlip.update({
        where: { id },
        data: { updatedBy: userId },
      });
    });

    await this.clearCache(tenantId);

    this.logger.log(
      `Added ${newParcels.length} parcels to shipping slip ${shippingSlip.reference}`,
    );

    return this.findOne(id, tenantId);
  }

  async removeParcels(
    id: string,
    parcelIds: string[],
    tenantId: string,
    userId: string,
  ): Promise<ShippingSlipResponseDto> {
    const shippingSlip = await this.prisma.shippingSlip.findFirst({
      where: { id, tenantId, isDeleted: false },
      include: { items: true },
    });

    if (!shippingSlip) {
      throw new NotFoundException('Shipping slip not found');
    }

    if (shippingSlip.status !== ShippingSlipStatus.PENDING) {
      throw new BadRequestException('Cannot modify shipped or received slip');
    }

    // Check which parcels are actually in the slip
    const existingParcelIds = shippingSlip.items.map((item) => item.parcelId);
    const parcelsToRemove = parcelIds.filter((parcelId) =>
      existingParcelIds.includes(parcelId),
    );

    if (parcelsToRemove.length === 0) {
      throw new BadRequestException(
        'None of the specified parcels are in this shipping slip',
      );
    }

    await this.prisma.$transaction(async (tx) => {
      // Remove parcels from slip
      await tx.shippingSlipItem.deleteMany({
        where: {
          shippingSlipId: id,
          parcelId: { in: parcelsToRemove },
        },
      });

      // Revert parcel statuses
      await tx.parcel.updateMany({
        where: { id: { in: parcelsToRemove }, tenantId },
        data: { parcelStatusCode: 'COLLECTED', updatedBy: userId },
      });

      // Update shipping slip
      await tx.shippingSlip.update({
        where: { id },
        data: { updatedBy: userId },
      });
    });

    await this.clearCache(tenantId);

    this.logger.log(
      `Removed ${parcelsToRemove.length} parcels from shipping slip ${shippingSlip.reference}`,
    );

    return this.findOne(id, tenantId);
  }

  async scanParcel(
    id: string,
    parcelCode: string,
    tenantId: string,
    userId: string,
  ) {
    const shippingSlip = await this.prisma.shippingSlip.findFirst({
      where: { id, tenantId, isDeleted: false },
      include: {
        items: {
          include: {
            parcel: { select: { id: true, code: true, recipientName: true } },
          },
        },
      },
    });

    if (!shippingSlip) {
      throw new NotFoundException('Shipping slip not found');
    }

    // Find the parcel in the slip
    const slipItem = shippingSlip.items.find(
      (item) => item.parcel.code === parcelCode,
    );

    if (!slipItem) {
      throw new BadRequestException('Parcel not found in this shipping slip');
    }

    if (slipItem.scanned) {
      throw new BadRequestException('Parcel has already been scanned');
    }

    // Update scan status
    const updatedItem = await this.prisma.shippingSlipItem.update({
      where: {
        shippingSlipId_parcelId: {
          shippingSlipId: id,
          parcelId: slipItem.parcelId,
        },
      },
      data: {
        scanned: true,
        scannedAt: new Date(),
        scannedBy: userId,
      },
      include: {
        parcel: {
          select: {
            code: true,
            recipientName: true,
            recipientPhone: true,
            destinationCity: { select: { name: true } },
          },
        },
      },
    });

    this.logger.log(
      `Scanned parcel ${parcelCode} in shipping slip ${shippingSlip.reference}`,
    );

    return {
      success: true,
      message: `Parcel ${parcelCode} scanned successfully`,
      parcel: updatedItem.parcel,
      scanInfo: {
        scannedAt: updatedItem.scannedAt,
        scannedBy: userId,
      },
    };
  }

  async bulkScanParcels(
    id: string,
    parcelCodes: string[],
    tenantId: string,
    userId: string,
  ) {
    const results = [];
    let scannedCount = 0;
    let failedCount = 0;

    for (const parcelCode of parcelCodes) {
      try {
        const result = await this.scanParcel(id, parcelCode, tenantId, userId);
        results.push({ parcelCode, success: true, ...result });
        scannedCount++;
      } catch (error) {
        results.push({
          parcelCode,
          success: false,
          error: error.message,
        });
        failedCount++;
      }
    }

    this.logger.log(
      `Bulk scan completed: ${scannedCount} successful, ${failedCount} failed`,
    );

    return {
      success: true,
      scannedCount,
      failedCount,
      results,
    };
  }

  async markAsShipped(
    id: string,
    tenantId: string,
    userId: string,
  ): Promise<ShippingSlipResponseDto> {
    const shippingSlip = await this.prisma.shippingSlip.findFirst({
      where: { id, tenantId, isDeleted: false },
      include: { items: true, _count: { select: { items: true } } },
    });

    if (!shippingSlip) {
      throw new NotFoundException('Shipping slip not found');
    }

    if (shippingSlip.status !== ShippingSlipStatus.PENDING) {
      throw new BadRequestException('Only pending slips can be shipped');
    }

    if (shippingSlip._count.items === 0) {
      throw new BadRequestException('Cannot ship empty shipping slip');
    }

    const updatedSlip = await this.prisma.shippingSlip.update({
      where: { id },
      data: {
        status: ShippingSlipStatus.SHIPPED,
        shippedAt: new Date(),
        shippedBy: userId,
        updatedBy: userId,
      },
    });

    await this.clearCache(tenantId);

    this.logger.log(
      `Marked shipping slip ${shippingSlip.reference} as shipped`,
    );

    return this.findOne(id, tenantId);
  }

  async markAsReceived(
    id: string,
    tenantId: string,
    userId: string,
  ): Promise<ShippingSlipResponseDto> {
    const shippingSlip = await this.prisma.shippingSlip.findFirst({
      where: { id, tenantId, isDeleted: false },
      include: { items: true },
    });

    if (!shippingSlip) {
      throw new NotFoundException('Shipping slip not found');
    }

    if (shippingSlip.status !== ShippingSlipStatus.SHIPPED) {
      throw new BadRequestException('Only shipped slips can be received');
    }

    await this.prisma.$transaction(async (tx) => {
      // Update shipping slip status
      await tx.shippingSlip.update({
        where: { id },
        data: {
          status: ShippingSlipStatus.RECEIVED,
          receivedAt: new Date(),
          receivedBy: userId,
          updatedBy: userId,
        },
      });

      // Update parcel statuses to PUT_IN_DISTRIBUTION (ready for local delivery)
      const parcelIds = shippingSlip.items.map((item) => item.parcelId);
      if (parcelIds.length > 0) {
        await tx.parcel.updateMany({
          where: { id: { in: parcelIds }, tenantId },
          data: { parcelStatusCode: 'PUT_IN_DISTRIBUTION', updatedBy: userId },
        });

        // Add status history
        const distributionStatus = await tx.parcelStatus.findFirst({
          where: { tenantId, code: 'PUT_IN_DISTRIBUTION', isDeleted: false },
        });

        if (distributionStatus) {
          await tx.parcelStatusHistory.createMany({
            data: parcelIds.map((parcelId) => ({
              parcelId,
              parcelStatusId: distributionStatus.id,
              statusCode: 'PUT_IN_DISTRIBUTION',
              comment: `Received at destination zone via ${shippingSlip.reference}`,
              changedBy: userId,
            })),
          });
        }
      }
    });

    await this.clearCache(tenantId);

    this.logger.log(
      `Marked shipping slip ${shippingSlip.reference} as received`,
    );

    return this.findOne(id, tenantId);
  }

  async cancelShippingSlip(
    id: string,
    tenantId: string,
    userId: string,
  ): Promise<ShippingSlipResponseDto> {
    const shippingSlip = await this.prisma.shippingSlip.findFirst({
      where: { id, tenantId, isDeleted: false },
      include: { items: true },
    });

    if (!shippingSlip) {
      throw new NotFoundException('Shipping slip not found');
    }

    if (shippingSlip.status === ShippingSlipStatus.RECEIVED) {
      throw new BadRequestException(
        'Cannot cancel already received shipping slip',
      );
    }

    await this.prisma.$transaction(async (tx) => {
      // Cancel shipping slip
      await tx.shippingSlip.update({
        where: { id },
        data: {
          status: ShippingSlipStatus.CANCELLED,
          updatedBy: userId,
        },
      });

      // Revert parcel statuses back to COLLECTED
      const parcelIds = shippingSlip.items.map((item) => item.parcelId);
      if (parcelIds.length > 0) {
        await tx.parcel.updateMany({
          where: { id: { in: parcelIds }, tenantId },
          data: { parcelStatusCode: 'COLLECTED', updatedBy: userId },
        });
      }
    });

    await this.clearCache(tenantId);

    this.logger.log(`Cancelled shipping slip ${shippingSlip.reference}`);

    return this.findOne(id, tenantId);
  }

  async getStatistics(tenantId: string): Promise<ShippingSlipStatsDto> {
    // Try cache first
    const cached = await this.redis.getTenantCache(
      tenantId,
      'shipping-slip-stats',
    );
    if (cached) {
      return JSON.parse(cached);
    }

    const [statusCounts, thisMonthStats, allShippingSlips] = await Promise.all([
      // Status distribution
      this.prisma.shippingSlip.groupBy({
        by: ['status'],
        where: { tenantId, isDeleted: false },
        _count: true,
      }),

      // This month's packages
      this.prisma.shippingSlipItem.count({
        where: {
          shippingSlip: {
            tenantId,
            isDeleted: false,
            createdAt: {
              gte: new Date(new Date().getFullYear(), new Date().getMonth(), 1),
            },
          },
        },
      }),

      // Get all shipping slips to group manually
      this.prisma.shippingSlip.findMany({
        where: { tenantId, isDeleted: false },
        select: { destinationZoneId: true },
      }),
    ]);

    // Calculate stats
    const total = statusCounts.reduce((sum, stat) => sum + stat._count, 0);
    const pending =
      statusCounts.find((s) => s.status === 'PENDING')?._count || 0;
    const shipped =
      statusCounts.find((s) => s.status === 'SHIPPED')?._count || 0;
    const completed =
      statusCounts.find((s) => s.status === 'RECEIVED')?._count || 0;
    const cancelled =
      statusCounts.find((s) => s.status === 'CANCELLED')?._count || 0;

    // Get total packages across all slips
    const totalPackages = await this.prisma.shippingSlipItem.count({
      where: { shippingSlip: { tenantId, isDeleted: false } },
    });

    const averagePackagesPerSlip = total > 0 ? totalPackages / total : 0;

    // Group destinations manually to avoid circular reference
    const destinationCounts: Record<string, number> = {};
    allShippingSlips.forEach((slip) => {
      const zoneId = slip.destinationZoneId;
      destinationCounts[zoneId] = (destinationCounts[zoneId] || 0) + 1;
    });

    // Get top 5 destinations
    const topDestinationIds = Object.entries(destinationCounts)
      .sort(([, a], [, b]) => b - a)
      .slice(0, 5);

    // Get zone names for top destinations
    const zoneIds = topDestinationIds.map(([zoneId]) => zoneId);
    const zones = await this.prisma.zone.findMany({
      where: { id: { in: zoneIds }, tenantId },
      select: { id: true, name: true },
    });

    const topDestinationZones = topDestinationIds.map(([zoneId, count]) => {
      const zone = zones.find((z) => z.id === zoneId);
      return {
        zoneId,
        zoneName: zone?.name || 'Unknown Zone',
        count,
        percentage: total > 0 ? (count / total) * 100 : 0,
      };
    });

    const stats: ShippingSlipStatsDto = {
      total,
      pending,
      inTransit: shipped,
      completed,
      cancelled,
      packagesShippedThisMonth: thisMonthStats,
      averagePackagesPerSlip: Number(averagePackagesPerSlip.toFixed(1)),
      topDestinationZones,
    };

    // Cache for 30 minutes
    await this.redis.setTenantCache(
      tenantId,
      'shipping-slip-stats',
      JSON.stringify(stats),
      1800,
    );

    return stats;
  }

  async generatePDF(id: string, tenantId: string) {
    const shippingSlip = await this.findOne(id, tenantId);

    // This would integrate with your PDF generation service
    // For now, return a placeholder response
    return {
      success: true,
      message: 'PDF generation not implemented yet',
      shippingSlip,
    };
  }

  // Helper methods
  private async generateReference(tenantId: string): Promise<string> {
    const date = new Date();
    const dateStr = date.toISOString().slice(2, 10).replace(/-/g, '');

    // Get today's count for this tenant
    const todayStart = new Date(
      date.getFullYear(),
      date.getMonth(),
      date.getDate(),
    );
    const todayEnd = new Date(todayStart);
    todayEnd.setDate(todayEnd.getDate() + 1);

    const count = await this.prisma.shippingSlip.count({
      where: {
        tenantId,
        createdAt: {
          gte: todayStart,
          lt: todayEnd,
        },
      },
    });

    const sequence = String(count + 1).padStart(7, '0');
    const random = Math.floor(Math.random() * 100)
      .toString()
      .padStart(2, '0');

    return `BE-${dateStr}-${sequence}-${random}`;
  }

  private async validateParcelsForShipping(
    parcelIds: string[],
    destinationZoneId: string,
    tenantId: string,
  ): Promise<string[]> {
    // Get destination zone cities
    const zone = await this.prisma.zone.findFirst({
      where: { id: destinationZoneId, tenantId, isDeleted: false },
      include: {
        cities: { include: { city: { select: { id: true } } } },
      },
    });

    if (!zone) {
      throw new BadRequestException('Invalid destination zone');
    }

    const zoneCityIds = zone.cities.map((zc) => zc.city.id);

    // Validate parcels
    const parcels = await this.prisma.parcel.findMany({
      where: {
        id: { in: parcelIds },
        tenantId,
        isDeleted: false,
        parcelStatusCode: 'COLLECTED', // Must be collected
        destinationCityId: { in: zoneCityIds }, // Must be going to zone cities
        shippingSlipItems: { none: {} }, // Not already in another slip
      },
    });

    if (parcels.length !== parcelIds.length) {
      throw new BadRequestException(
        'Some parcels are invalid, not collected, or already in another shipping slip',
      );
    }

    return parcels.map((parcel) => parcel.id);
  }

  private async clearCache(tenantId: string): Promise<void> {
    await Promise.all([
      this.redis.delTenantCache(tenantId, 'shipping-slips'),
      this.redis.delTenantCache(tenantId, 'shipping-slip-stats'),
    ]);
  }

  private mapToResponseDto(shippingSlip: any): ShippingSlipResponseDto {
    const scannedItems =
      shippingSlip.items?.filter((item: any) => item.scanned).length || 0;
    const totalValue =
      shippingSlip.items?.reduce(
        (sum: number, item: any) => sum + Number(item.parcel?.price || 0),
        0,
      ) || 0;

    return {
      id: shippingSlip.id,
      tenantId: shippingSlip.tenantId,
      reference: shippingSlip.reference,
      destinationZoneId: shippingSlip.destinationZoneId,
      status: shippingSlip.status,
      shippedAt: shippingSlip.shippedAt,
      shippedBy: shippingSlip.shippedBy,
      receivedAt: shippingSlip.receivedAt,
      receivedBy: shippingSlip.receivedBy,
      createdAt: shippingSlip.createdAt,
      updatedAt: shippingSlip.updatedAt,
      createdBy: shippingSlip.createdBy,
      updatedBy: shippingSlip.updatedBy,
      destinationZone: shippingSlip.destinationZone,
      items: shippingSlip.items?.map((item: any) => ({
        parcelId: item.parcelId,
        scanned: item.scanned,
        scannedAt: item.scannedAt,
        scannedBy: item.scannedBy,
        parcel: item.parcel
          ? {
              id: item.parcel.id,
              code: item.parcel.code,
              recipientName: item.parcel.recipientName,
              recipientPhone: item.parcel.recipientPhone,
              destinationCity: item.parcel.destinationCity,
              price: Number(item.parcel.price),
              parcelStatusCode: item.parcel.parcelStatusCode,
            }
          : undefined,
      })),
      _count: {
        items: shippingSlip._count?.items || shippingSlip.items?.length || 0,
        scannedItems,
        totalValue: Number(totalValue.toFixed(2)),
      },
    };
  }
}
===============================================================================================================
===============================================================================================================
The Subject is :
- READ ALL THIS PROMPT I GIVE YOU.
- I Create A new parcels-service in my nest js project.
- You Alrady Give module delivery-slips and module parcels.
- So Now i want you help me and give me shipping-slips module in front with all pages and crud pages,
And all component and lib and store we will need to create this module in front.
_ Give me each file with page location.
===============================================================================================================
===============================================================================================================