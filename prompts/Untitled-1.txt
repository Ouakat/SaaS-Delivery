ok please righ now i want logic if not login in , force for user to login. he can't see dashboard.

and if login he can acces all project with ou any problem  but he can access login , because already login in.

and i want login page display in  http://localhost:3000/en no need to type  or redirect to http://localhost:3000/en/auth/login =>

=================  app/[locale]/(protected)/layout.tsx =>
import LayoutProvider from "@/providers/layout.provider";
import LayoutContentProvider from "@/providers/content.provider";
import NetworkSidebar from "@/components/partials/sidebar";
import NetworkFooter from "@/components/partials/footer";
import ThemeCustomize from "@/components/partials/customizer";
import NetworkHeader from "@/components/partials/header";
import { ProtectedRoute } from "@/components/auth/protected-route";

interface LayoutProps {
  children: React.ReactNode;
  params: { locale: string };
}

const ProtectedLayout = ({ children, params }: LayoutProps) => {
  return (
    <ProtectedRoute
      requireAuth={true}
      requireTenant={true}
      // Optional: Add role or user type restrictions
      // allowedRoles={["admin", "manager", "support"]}
      // allowedUserTypes={["ADMIN", "MANAGER", "SUPPORT", "SELLER", "LIVREUR"]}
    >
      <LayoutProvider>
        <ThemeCustomize />
        <NetworkHeader />
        <NetworkSidebar />
        <LayoutContentProvider>{children}</LayoutContentProvider>
        <NetworkFooter />
      </LayoutProvider>
    </ProtectedRoute>
  );
};

export default ProtectedLayout;


================= app/[locale]/auth/login/page.tsx =>
"use client";
import { useEffect } from "react";
import { Link } from "@/i18n/routing";
import LoginForm from "@/components/auth/login-form";
import Image from "next/image";
import Social from "@/components/auth/social";
import Copyright from "@/components/auth/copyright";
import Logo from "@/components/auth/logo";
import { useAuthStore } from "@/lib/stores/auth.store";
import { useRouter } from "next/navigation";
interface LoginPageProps {
  params: { locale: string };
}
const LoginPage = ({ params: { locale } }: LoginPageProps) => {
  const { isAuthenticated, isLoading } = useAuthStore();
  const router = useRouter();

  // Redirect to dashboard if already authenticated
  useEffect(() => {
    if (isAuthenticated && !isLoading) {
      const urlParams = new URLSearchParams(window.location.search);
      const redirectTo = urlParams.get("redirect") || "/dashboard";
      router.push(redirectTo);
    }
  }, [isAuthenticated, isLoading, router]);

  // Show loading while checking auth status
  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto mb-4"></div>
          <p className="text-muted-foreground">Loading...</p>
        </div>
      </div>
    );
  }

  // Don't render login form if already authenticated (prevents flash)
  if (isAuthenticated) {
    return null;
  }

  return (
    <div className="flex w-full items-center overflow-hidden min-h-dvh h-dvh basis-full">
      <div className="overflow-y-auto flex flex-wrap w-full h-dvh">
        {/* Left Side - Branding */}
        <div className="lg:block hidden flex-1 overflow-hidden text-[40px] leading-[48px] text-default-600 relative z-1 bg-default-50">
          <div className="max-w-[520px] pt-20 ps-20">
            <Link href="/" className="mb-6 inline-block">
              <Logo />
            </Link>
            <h4>
              Unlock your Project
              <span className="text-default-800 font-bold ms-2">
                performance
              </span>
            </h4>
          </div>
          <div className="absolute left-0 2xl:bottom-[-160px] bottom-[-130px] h-full w-full z-[-1]">
            <Image
              src="/images/auth/ils1.svg"
              alt="Network Illustration"
              priority
              width={300}
              height={300}
              className="mb-10 w-full h-full"
            />
          </div>
        </div>

        {/* Right Side - Login Form */}
        <div className="flex-1 relative">
          <div className="h-full flex flex-col dark:bg-default-100 bg-white">
            <div className="max-w-[524px] md:px-[42px] md:py-[44px] p-7 mx-auto w-full text-2xl text-default-900 mb-3 h-full flex flex-col justify-center">
              {/* Mobile Logo */}
              <div className="flex justify-center items-center text-center mb-6 lg:hidden">
                <Link href="/">
                  <Logo />
                </Link>
              </div>

              {/* Header */}
              <div className="text-center 2xl:mb-10 mb-4">
                <h4 className="font-medium">Sign in</h4>
                <div className="text-default-500 text-base">
                  Sign in to your account to start using Network
                </div>
              </div>

              {/* Login Form */}
              <LoginForm />

              {/* Social Login Divider */}
              <div className="relative border-b-[#9AA2AF] border-opacity-[16%] border-b pt-6">
                <div className="absolute inline-block bg-default-50 dark:bg-default-100 left-1/2 top-1/2 transform -translate-x-1/2 px-4 min-w-max text-sm text-default-500 font-normal">
                  Or continue with
                </div>
              </div>

              {/* Social Login */}
              <div className="max-w-[242px] mx-auto mt-8 w-full">
                <Social locale={locale} />
              </div>

              {/* Sign Up Link */}
              <div className="md:max-w-[345px] mx-auto font-normal text-default-500 mt-12 uppercase text-sm">
                Don't have an account?{" "}
                <Link
                  href="/auth/register"
                  className="text-default-900 font-medium hover:underline"
                >
                  Sign up
                </Link>
              </div>
            </div>

            {/* Footer */}
            <div className="text-xs font-normal text-default-500 z-999 pb-10 text-center">
              <Copyright />
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};
export default LoginPage;

================= components/auth/login-form.tsx =>
"use client";
import React from "react";
import { Button } from "@/components/ui/button";
import { Checkbox } from "@/components/ui/checkbox";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Link } from "@/i18n/routing";
import { Icon } from "@/components/ui/icon";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { cn } from "@/lib/utils/ui.utils";
import { Loader2 } from "lucide-react";
import { toast } from "sonner";
import { useRouter } from "@/components/navigation";
import { useAuthStore } from "@/lib/stores/auth.store";
import { getTenantFromUrl } from "@/lib/utils/tenant.utils";
import { useEffect } from "react";

const schema = z.object({
  email: z.string().email({ message: "Your email is invalid." }),
  password: z
    .string()
    .min(4, { message: "Password must be at least 4 characters." }),
});

type LoginFormData = z.infer<typeof schema>;

const LoginForm = () => {
  const [isPending, startTransition] = React.useTransition();
  const router = useRouter();
  const [passwordType, setPasswordType] = React.useState("password");
  const [rememberMe, setRememberMe] = React.useState(false);

  // Auth store
  const {
    login,
    isAuthenticated,
    error: authError,
    clearError,
  } = useAuthStore();

  // Get current tenant
  const tenantId = getTenantFromUrl();

  const togglePasswordType = () => {
    setPasswordType((prev) => (prev === "password" ? "text" : "password"));
  };

  const {
    register,
    handleSubmit,
    formState: { errors },
    setError,
  } = useForm<LoginFormData>({
    resolver: zodResolver(schema),
    mode: "all",
    defaultValues: {
      email: "admin@acme.com",
      password: "password123",
    },
  });

  // Clear errors when component mounts
  useEffect(() => {
    clearError();
  }, [clearError]);

  // Redirect if already authenticated
  useEffect(() => {
    if (isAuthenticated) {
      // Get redirect URL from query params or default to dashboard
      const urlParams = new URLSearchParams(window.location.search);
      const redirectTo = urlParams.get("redirect") || "/dashboard";
      router.push(redirectTo);
    }
  }, [isAuthenticated, router]);

  // Handle auth errors
  useEffect(() => {
    if (authError) {
      toast.error(authError);

      // Set form-level errors based on auth error type
      if (authError.includes("email") || authError.includes("user not found")) {
        setError("email", { message: "Invalid email address" });
      } else if (
        authError.includes("password") ||
        authError.includes("credentials")
      ) {
        setError("password", { message: "Invalid password" });
      }
    }
  }, [authError, setError]);

  const onSubmit = (data: LoginFormData) => {
    startTransition(async () => {
      try {
        clearError();

        // Validate tenant for multi-tenant setup
        if (!tenantId) {
          toast.error("Tenant not found. Please check your URL.");
          return;
        }

        const result = await login({
          email: data.email,
          password: data.password,
        });

        if (result.success) {
          toast.success("Successfully logged in");

          // Handle remember me functionality
          if (rememberMe) {
            localStorage.setItem("remember_email", data.email);
          } else {
            localStorage.removeItem("remember_email");
          }

          // Get redirect URL from query params or default to dashboard
          const urlParams = new URLSearchParams(window.location.search);
          const redirectTo = urlParams.get("redirect") || "/dashboard";

          // Add a small delay to ensure state is updated
          setTimeout(() => {
            router.push(redirectTo);
          }, 100);
        } else {
          // Error handling is done in useEffect above
          console.error("Login failed:", result.error);
        }
      } catch (err: any) {
        console.error("Login error:", err);
        toast.error(err.message || "An unexpected error occurred");
      }
    });
  };

  // Load remembered email on component mount
  useEffect(() => {
    const rememberedEmail = localStorage.getItem("remember_email");
    if (rememberedEmail) {
      setRememberMe(true);
      // You could also set the email field here if needed
    }
  }, []);

  return (
    <form onSubmit={handleSubmit(onSubmit)} className="mt-5 2xl:mt-7 space-y-4">
      {/* Email Field */}
      <div className="space-y-2">
        <Label htmlFor="email" className="font-medium text-default-600">
          Email
        </Label>
        <Input
          size="lg"
          disabled={isPending}
          {...register("email")}
          type="email"
          id="email"
          placeholder="Enter your email"
          className={cn("", {
            "border-destructive": errors.email,
          })}
        />
        {errors.email && (
          <div className="text-destructive mt-2 text-sm">
            {errors.email.message}
          </div>
        )}
      </div>

      {/* Password Field */}
      <div className="mt-3.5 space-y-2">
        <Label htmlFor="password" className="mb-2 font-medium text-default-600">
          Password
        </Label>
        <div className="relative">
          <Input
            size="lg"
            disabled={isPending}
            {...register("password")}
            type={passwordType}
            id="password"
            className={cn("peer", {
              "border-destructive": errors.password,
            })}
            placeholder="Enter your password"
          />
          <div
            className="absolute top-1/2 -translate-y-1/2 ltr:right-4 rtl:left-4 cursor-pointer"
            onClick={togglePasswordType}
          >
            {passwordType === "password" ? (
              <Icon icon="heroicons:eye" className="w-5 h-5 text-default-400" />
            ) : (
              <Icon
                icon="heroicons:eye-slash"
                className="w-5 h-5 text-default-400"
              />
            )}
          </div>
        </div>
        {errors.password && (
          <div className="text-destructive mt-2 text-sm">
            {errors.password.message}
          </div>
        )}
      </div>

      {/* Remember Me & Forgot Password */}
      <div className="flex justify-between">
        <div className="flex gap-2 items-center">
          <Checkbox
            id="remember"
            checked={rememberMe}
            onCheckedChange={(checked) => setRememberMe(checked as boolean)}
          />
          <Label htmlFor="remember">Keep Me Signed In</Label>
        </div>
        <Link
          href="/auth/forgot-password"
          className="text-sm text-default-800 dark:text-default-400 leading-6 font-medium hover:underline"
        >
          Forgot Password?
        </Link>
      </div>

      {/* Submit Button */}
      <Button fullWidth disabled={isPending} type="submit">
        {isPending && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
        {isPending ? "Signing In..." : "Sign In"}
      </Button>

      {/* Development Helper */}
      {process.env.NODE_ENV === "development" && (
        <div className="mt-4 p-3 bg-muted rounded-lg text-xs text-muted-foreground">
          <strong>Dev Info:</strong> Tenant: {tenantId || "Not detected"}
        </div>
      )}
    </form>
  );
};

export default LoginForm;

================= components/auth/protected-route.tsx =>
"use client";

import { useEffect, useState } from "react";
import { useRouter } from "next/navigation";
import { useAuthStore } from "@/lib/stores/auth.store";
import { useTenantStore } from "@/lib/stores/tenant.store";
import { LoadingSpinner } from "@/components/ui/loading-spinner";

interface ProtectedRouteProps {
  children: React.ReactNode;
  requireAuth?: boolean;
  requireTenant?: boolean;
  allowedRoles?: string[];
  allowedUserTypes?: string[];
  fallback?: React.ReactNode;
}

export function ProtectedRoute({
  children,
  requireAuth = true,
  requireTenant = true,
  allowedRoles = [],
  allowedUserTypes = [],
  fallback,
}: ProtectedRouteProps) {
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(true);
  const [isInitialized, setIsInitialized] = useState(false);

  const { user, isAuthenticated, checkAuth, hasRole, hasUserType } =
    useAuthStore();

  const { currentTenant, fetchTenants } = useTenantStore();

  // Initialize auth and tenant data
  useEffect(() => {
    const initialize = async () => {
      try {
        await checkAuth();

        // If user is authenticated and tenant is required, fetch tenants
        const authState = useAuthStore.getState();
        if (authState.isAuthenticated && requireTenant) {
          await fetchTenants();
        }
      } catch (error) {
        console.error("Auth initialization failed:", error);
      } finally {
        setIsInitialized(true);
        setIsLoading(false);
      }
    };

    if (!isInitialized) {
      initialize();
    }
  }, [checkAuth, fetchTenants, requireTenant, isInitialized]);

  // Handle redirects after initialization
  useEffect(() => {
    if (!isInitialized || isLoading) return;

    // Redirect to login if auth is required but user is not authenticated
    if (requireAuth && !isAuthenticated) {
      router.push(
        `/auth/login?redirect=${encodeURIComponent(window.location.pathname)}`
      );
      return;
    }

    // Redirect to tenant selection if tenant is required but not selected
    if (requireTenant && isAuthenticated && !currentTenant) {
      router.push("/tenant-select");
      return;
    }
  }, [
    isInitialized,
    isLoading,
    requireAuth,
    requireTenant,
    isAuthenticated,
    currentTenant,
    router,
  ]);

  // Show loading state during initialization
  if (isLoading || !isInitialized) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center space-y-4">
          <LoadingSpinner size="lg" />
          <p className="text-muted-foreground">Loading...</p>
        </div>
      </div>
    );
  }

  // Check if user meets authentication requirements
  if (requireAuth && !isAuthenticated) {
    return null; // Will redirect via useEffect
  }

  // Check if user meets tenant requirements
  if (requireTenant && !currentTenant) {
    return null; // Will redirect via useEffect
  }

  // Check role-based access
  if (allowedRoles.length > 0 && user) {
    const hasValidRole = allowedRoles.some((role) => hasRole(role));
    if (!hasValidRole) {
      return (
        fallback || (
          <div className="flex items-center justify-center min-h-screen">
            <div className="text-center space-y-4">
              <h2 className="text-lg font-semibold">Access Denied</h2>
              <p className="text-muted-foreground">
                You don't have the required permissions to access this page.
              </p>
              <button
                onClick={() => router.push("/dashboard")}
                className="px-4 py-2 bg-primary text-primary-foreground rounded-md hover:bg-primary/90"
              >
                Go to Dashboard
              </button>
            </div>
          </div>
        )
      );
    }
  }

  // Check user type-based access
  if (allowedUserTypes.length > 0 && user) {
    const hasValidUserType = allowedUserTypes.some((type) =>
      hasUserType(type as any)
    );
    if (!hasValidUserType) {
      return (
        fallback || (
          <div className="flex items-center justify-center min-h-screen">
            <div className="text-center space-y-4">
              <h2 className="text-lg font-semibold">Access Denied</h2>
              <p className="text-muted-foreground">
                Your account type doesn't have access to this page.
              </p>
              <button
                onClick={() => router.push("/dashboard")}
                className="px-4 py-2 bg-primary text-primary-foreground rounded-md hover:bg-primary/90"
              >
                Go to Dashboard
              </button>
            </div>
          </div>
        )
      );
    }
  }

  // Render protected content
  return <>{children}</>;
}

// Convenience components for common use cases
export function AdminRoute({
  children,
  ...props
}: Omit<ProtectedRouteProps, "allowedRoles">) {
  return (
    <ProtectedRoute {...props} allowedRoles={["admin"]}>
      {children}
    </ProtectedRoute>
  );
}

export function ManagerRoute({
  children,
  ...props
}: Omit<ProtectedRouteProps, "allowedRoles">) {
  return (
    <ProtectedRoute {...props} allowedRoles={["admin", "manager"]}>
      {children}
    </ProtectedRoute>
  );
}

export function TenantRoute({ children, ...props }: ProtectedRouteProps) {
  return (
    <ProtectedRoute {...props} requireTenant={true}>
      {children}
    </ProtectedRoute>
  );
}

================= hooks/auth/use-auth.ts =>
import { useEffect, useCallback, useState, useRef } from "react";
import { useRouter } from "next/navigation";
import { useAuthStore } from "@/lib/stores/auth.store";
import { useTenantStore } from "@/lib/stores/tenant.store";
import type { UserType, User } from "@/lib/types/database/schema.types";
import type { ExtendedTenant } from "@/lib/stores/tenant.store";

export interface UseAuthOptions {
  requireAuth?: boolean;
  requireTenant?: boolean;
  allowedUserTypes?: UserType[];
  allowedRoles?: string[];
  requiredPermissions?: string[];
  redirectToLogin?: string;
  redirectToTenantSelect?: string;
  redirectUnauthorized?: string;
  redirectOnSuccess?: string;
}

export interface AuthError {
  type: "auth" | "tenant" | "userType" | "role" | "permission" | "network";
  message: string;
  code?: string;
  details?: any;
}

export interface AuthStatus {
  isLoading: boolean;
  isAuthenticated: boolean;
  isAuthorized: boolean;
  hasValidTenant: boolean;
  error: AuthError | null;
  user: User | null;
  currentTenant: ExtendedTenant | null;
}

export function useAuth(options: UseAuthOptions = {}) {
  const {
    requireAuth = true,
    requireTenant = true,
    allowedUserTypes = [],
    allowedRoles = [],
    requiredPermissions = [],
    redirectToLogin = "/auth/login",
    redirectToTenantSelect = "/tenant-select",
    redirectUnauthorized = "/unauthorized",
    redirectOnSuccess,
  } = options;

  const router = useRouter();
  const [authError, setAuthError] = useState<AuthError | null>(null);
  const [isInitializing, setIsInitializing] = useState(true);

  // Use refs to track if redirects have already happened to prevent loops
  const redirectedToLogin = useRef(false);
  const redirectedToTenant = useRef(false);
  const redirectedToUnauthorized = useRef(false);
  const hasInitialized = useRef(false);
  const initPromise = useRef<Promise<void> | null>(null);

  // Auth store
  const {
    user,
    isAuthenticated,
    isLoading: authLoading,
    error: authStoreError,
    login,
    logout,
    checkAuth,
    hasPermission,
    hasAnyPermission,
    hasRole,
    hasUserType,
    clearError,
  } = useAuthStore();

  // Tenant store
  const {
    currentTenant,
    isLoading: tenantLoading,
    fetchTenants,
    clearCurrentTenant,
  } = useTenantStore();

  // Memoized permission checking functions to prevent dependency changes
  const checkPermission = useCallback(
    (permission: string) => {
      return hasPermission(permission);
    },
    [hasPermission]
  );

  const checkAnyPermission = useCallback(
    (permissions: string[]) => {
      return hasAnyPermission(permissions);
    },
    [hasAnyPermission]
  );

  const checkRole = useCallback(
    (roleName: string) => {
      return hasRole(roleName);
    },
    [hasRole]
  );

  const checkUserType = useCallback(
    (userType: UserType) => {
      return hasUserType(userType);
    },
    [hasUserType]
  );

  // Memoized authorization check
  const isAuthorized = useCallback(() => {
    if (!isAuthenticated || !user) return false;
    if (requireTenant && !currentTenant) return false;

    // Check user type
    if (allowedUserTypes.length > 0) {
      const hasValidUserType = allowedUserTypes.some((userType) =>
        checkUserType(userType)
      );
      if (!hasValidUserType) return false;
    }

    // Check role
    if (allowedRoles.length > 0) {
      const hasValidRole = allowedRoles.some((role) => checkRole(role));
      if (!hasValidRole) return false;
    }

    // Check permissions
    if (requiredPermissions.length > 0) {
      if (!checkAnyPermission(requiredPermissions)) return false;
    }

    return true;
  }, [
    isAuthenticated,
    user,
    requireTenant,
    currentTenant,
    allowedUserTypes,
    allowedRoles,
    requiredPermissions,
    checkUserType,
    checkRole,
    checkAnyPermission,
  ]);

  // Initialize authentication - only run once
  useEffect(() => {
    if (hasInitialized.current || initPromise.current) return;

    const initializeAuth = async () => {
      try {
        // First check auth
        await checkAuth();

        // If authenticated and requires tenant, fetch tenants
        // We need to check the current auth state after checkAuth completes
        const authStore = useAuthStore.getState();
        if (authStore.isAuthenticated && requireTenant && !currentTenant) {
          await fetchTenants();
        }
      } catch (error) {
        console.error("Auth initialization failed:", error);
        setAuthError({
          type: "network",
          message: "Failed to initialize authentication",
          details: error,
        });
      } finally {
        setIsInitializing(false);
        hasInitialized.current = true;
        initPromise.current = null;
      }
    };

    // Store the promise to prevent multiple concurrent initializations
    initPromise.current = initializeAuth();

    return () => {
      // Cleanup function - cancel any pending operations if needed
    };
  }, []); // Empty dependency array - only run once

  // Handle authentication requirement
  useEffect(() => {
    if (isInitializing || authLoading) return;
    if (redirectedToLogin.current) return;

    if (requireAuth && !isAuthenticated) {
      redirectedToLogin.current = true;

      setAuthError({
        type: "auth",
        message: "Authentication required",
      });

      const currentPath = window.location.pathname;
      const loginUrl = `${redirectToLogin}?redirect=${encodeURIComponent(
        currentPath
      )}`;
      router.push(loginUrl);
      return;
    }

    // Reset redirect flag if user is now authenticated
    if (isAuthenticated && authError?.type === "auth") {
      redirectedToLogin.current = false;
      setAuthError(null);
    }
  }, [
    isAuthenticated,
    requireAuth,
    authLoading,
    isInitializing,
    router,
    redirectToLogin,
    authError,
  ]);

  // Handle tenant requirement
  useEffect(() => {
    if (isInitializing || authLoading || tenantLoading) return;
    if (redirectedToTenant.current) return;

    if (isAuthenticated && requireTenant && !currentTenant) {
      redirectedToTenant.current = true;

      setAuthError({
        type: "tenant",
        message: "Tenant selection required",
      });
      router.push(redirectToTenantSelect);
      return;
    }

    // Reset redirect flag if tenant is now selected
    if (currentTenant && authError?.type === "tenant") {
      redirectedToTenant.current = false;
      setAuthError(null);
    }
  }, [
    isAuthenticated,
    currentTenant,
    requireTenant,
    authLoading,
    tenantLoading,
    isInitializing,
    router,
    redirectToTenantSelect,
    authError,
  ]);

  // Handle authorization checks
  useEffect(() => {
    if (isInitializing || authLoading || !isAuthenticated || !user) return;
    if (redirectedToUnauthorized.current) return;

    const authorized = isAuthorized();

    if (!authorized) {
      redirectedToUnauthorized.current = true;

      // Determine error type
      let errorType: AuthError["type"] = "permission";
      let errorMessage = "Access denied";

      if (
        allowedUserTypes.length > 0 &&
        !allowedUserTypes.some((ut) => checkUserType(ut))
      ) {
        errorType = "userType";
        errorMessage = `Access denied. Required user types: ${allowedUserTypes.join(
          ", "
        )}`;
      } else if (
        allowedRoles.length > 0 &&
        !allowedRoles.some((role) => checkRole(role))
      ) {
        errorType = "role";
        errorMessage = `Access denied. Required roles: ${allowedRoles.join(
          ", "
        )}`;
      } else if (
        requiredPermissions.length > 0 &&
        !checkAnyPermission(requiredPermissions)
      ) {
        errorType = "permission";
        errorMessage = `Access denied. Required permissions: ${requiredPermissions.join(
          ", "
        )}`;
      }

      setAuthError({
        type: errorType,
        message: errorMessage,
        details: {
          allowedUserTypes,
          allowedRoles,
          requiredPermissions,
          userUserType: user.userType,
          userRole: user.role?.name,
          userPermissions: user.role?.permissions,
        },
      });

      router.push(redirectUnauthorized);
      return;
    }

    // Reset redirect flag if user is now authorized
    if (
      authorized &&
      (authError?.type === "userType" ||
        authError?.type === "role" ||
        authError?.type === "permission")
    ) {
      redirectedToUnauthorized.current = false;
      setAuthError(null);
    }
  }, [
    isAuthenticated,
    user,
    isAuthorized,
    authLoading,
    isInitializing,
    router,
    redirectUnauthorized,
    authError,
    allowedUserTypes,
    allowedRoles,
    requiredPermissions,
    checkUserType,
    checkRole,
    checkAnyPermission,
  ]);

  // Handle redirect on success
  useEffect(() => {
    if (
      redirectOnSuccess &&
      isAuthenticated &&
      (!requireTenant || currentTenant) &&
      !authError &&
      !isInitializing &&
      !authLoading &&
      !tenantLoading &&
      isAuthorized()
    ) {
      router.push(redirectOnSuccess);
    }
  }, [
    redirectOnSuccess,
    isAuthenticated,
    currentTenant,
    requireTenant,
    authError,
    isInitializing,
    authLoading,
    tenantLoading,
    router,
    isAuthorized,
  ]);

  // Handle auth store errors
  useEffect(() => {
    if (authStoreError && !authError) {
      setAuthError({
        type: "auth",
        message: authStoreError,
      });
    }
  }, [authStoreError, authError]);

  // Enhanced logout that clears everything
  const enhancedLogout = useCallback(async () => {
    try {
      // Reset redirect flags
      redirectedToLogin.current = false;
      redirectedToTenant.current = false;
      redirectedToUnauthorized.current = false;
      hasInitialized.current = false;

      clearCurrentTenant();
      await logout();
      setAuthError(null);
      clearError();
      router.push(redirectToLogin);
    } catch (error) {
      console.error("Logout failed:", error);
      // Force cleanup even if logout fails
      clearCurrentTenant();
      setAuthError(null);
      router.push(redirectToLogin);
    }
  }, [clearCurrentTenant, logout, clearError, router, redirectToLogin]);

  // Enhanced login with error handling
  const enhancedLogin = useCallback(
    async (credentials: Parameters<typeof login>[0]) => {
      setAuthError(null);
      // Reset redirect flags on new login attempt
      redirectedToLogin.current = false;
      redirectedToTenant.current = false;
      redirectedToUnauthorized.current = false;

      const result = await login(credentials);

      if (!result.success && result.error) {
        setAuthError({
          type: "auth",
          message: result.error,
        });
      }

      return result;
    },
    [login]
  );

  // Get current auth status
  const getAuthStatus = useCallback((): AuthStatus => {
    return {
      isLoading: isInitializing || authLoading || tenantLoading,
      isAuthenticated,
      isAuthorized: isAuthorized(),
      hasValidTenant: Boolean(currentTenant),
      error: authError,
      user,
      currentTenant,
    };
  }, [
    isInitializing,
    authLoading,
    tenantLoading,
    isAuthenticated,
    isAuthorized,
    currentTenant,
    authError,
    user,
  ]);

  // Clear error manually
  const clearAuthError = useCallback(() => {
    setAuthError(null);
    clearError();
    // Reset redirect flags when clearing errors
    redirectedToLogin.current = false;
    redirectedToTenant.current = false;
    redirectedToUnauthorized.current = false;
  }, [clearError]);

  // Refresh auth state
  const refreshAuth = useCallback(async () => {
    try {
      setAuthError(null);
      await checkAuth();
      const authStore = useAuthStore.getState();
      if (authStore.isAuthenticated && requireTenant) {
        await fetchTenants();
      }
      return true;
    } catch (error) {
      console.error("Auth refresh failed:", error);
      setAuthError({
        type: "network",
        message: "Failed to refresh authentication",
        details: error,
      });
      return false;
    }
  }, [checkAuth, requireTenant, fetchTenants]);

  // Get loading state
  const isLoading = isInitializing || authLoading || tenantLoading;

  // Check if there are blocking errors
  const hasBlockingError = Boolean(
    authError &&
      ["auth", "tenant", "userType", "role", "permission"].includes(
        authError.type
      )
  );

  const authorizedValue = isAuthorized();

  return {
    // Core auth state
    user,
    isAuthenticated,
    isAuthorized: authorizedValue,
    isLoading,
    currentTenant,

    // Error state
    error: authError,
    hasBlockingError,
    isInitializing,

    // Actions
    login: enhancedLogin,
    logout: enhancedLogout,
    refreshAuth,

    // Permission utilities
    hasPermission: checkPermission,
    hasAnyPermission: checkAnyPermission,
    hasRole: checkRole,
    hasUserType: checkUserType,

    // Status utilities
    getAuthStatus,

    // Error handling
    clearError: clearAuthError,

    // Computed states
    canAccess: authorizedValue && !hasBlockingError,
    needsAuth: requireAuth && !isAuthenticated,
    needsTenant: requireTenant && isAuthenticated && !currentTenant,
  };
}

================= lib/stores/auth.store.ts =>
import { create } from "zustand";
import { persist } from "zustand/middleware";
import { authApiClient } from "@/lib/api/clients/auth.client";
import { usersApiClient } from "@/lib/api/clients/users.client";
import type { User, UserType } from "@/lib/types/database/schema.types";
import type {
  LoginRequest,
  RegisterRequest,
} from "@/lib/api/clients/auth.client";

interface AuthState {
  // Core state
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  error: string | null;

  // Token management
  accessToken: string | null;
  refreshToken: string | null;
  tokenExpiresAt: number | null;

  // Session management
  lastActivity: number;
  sessionTimeoutWarning: boolean;

  // Actions
  login: (
    credentials: LoginRequest
  ) => Promise<{ success: boolean; error?: string }>;
  register: (
    userData: RegisterRequest
  ) => Promise<{ success: boolean; error?: string }>;
  logout: () => Promise<void>;
  refreshSession: () => Promise<boolean>;
  checkAuth: () => Promise<void>;

  // User management
  updateUser: (userData: Partial<User>) => void;
  updateProfile: (profileData: any) => Promise<boolean>;

  // Permission methods
  hasPermission: (permission: string) => boolean;
  hasAnyPermission: (permissions: string[]) => boolean;
  hasAllPermissions: (permissions: string[]) => boolean;
  hasRole: (roleName: string) => boolean;
  hasUserType: (userType: UserType) => boolean;

  // Session utilities
  updateLastActivity: () => void;
  isSessionExpired: () => boolean;
  getTimeUntilExpiry: () => number;
  setSessionTimeoutWarning: (show: boolean) => void;

  // State management
  clearError: () => void;
  setLoading: (loading: boolean) => void;
}

const TOKEN_STORAGE_KEY = "auth_token";
const REFRESH_TOKEN_STORAGE_KEY = "refresh_token";
const SESSION_TIMEOUT = 30 * 60 * 1000; // 30 minutes
const WARNING_THRESHOLD = 5 * 60 * 1000; // 5 minutes before timeout

export const useAuthStore = create<AuthState>()(
  persist(
    (set, get) => ({
      // Initial state
      user: null,
      isAuthenticated: false,
      isLoading: false,
      error: null,
      accessToken: null,
      refreshToken: null,
      tokenExpiresAt: null,
      lastActivity: Date.now(),
      sessionTimeoutWarning: false,

      // Login method
      login: async (credentials: LoginRequest) => {
        set({ isLoading: true, error: null });

        try {
          const response = await authApiClient.login(credentials);

          if (response.success && response.data) {
            const { user, accessToken, refreshToken, expiresIn } =
              response.data;
            const tokenExpiresAt = Date.now() + expiresIn * 1000;

            // Store tokens in localStorage
            if (typeof window !== "undefined") {
              localStorage.setItem(TOKEN_STORAGE_KEY, accessToken);
              localStorage.setItem(REFRESH_TOKEN_STORAGE_KEY, refreshToken);
            }

            set({
              user,
              isAuthenticated: true,
              isLoading: false,
              error: null,
              accessToken,
              refreshToken,
              tokenExpiresAt,
              lastActivity: Date.now(),
            });

            return { success: true };
          } else {
            const error = response.error?.message || "Login failed";
            set({ isLoading: false, error });
            return { success: false, error };
          }
        } catch (error: any) {
          const errorMessage = error?.message || "Network error during login";
          set({ isLoading: false, error: errorMessage });
          return { success: false, error: errorMessage };
        }
      },

      // Register method
      register: async (userData: RegisterRequest) => {
        set({ isLoading: true, error: null });

        try {
          const response = await authApiClient.register(userData);

          if (response.success && response.data) {
            const { user, accessToken, refreshToken, expiresIn } =
              response.data;
            const tokenExpiresAt = Date.now() + expiresIn * 1000;

            // Store tokens
            if (typeof window !== "undefined") {
              localStorage.setItem(TOKEN_STORAGE_KEY, accessToken);
              localStorage.setItem(REFRESH_TOKEN_STORAGE_KEY, refreshToken);
            }

            set({
              user,
              isAuthenticated: true,
              isLoading: false,
              error: null,
              accessToken,
              refreshToken,
              tokenExpiresAt,
              lastActivity: Date.now(),
            });

            return { success: true };
          } else {
            const error = response.error?.message || "Registration failed";
            set({ isLoading: false, error });
            return { success: false, error };
          }
        } catch (error: any) {
          const errorMessage =
            error?.message || "Network error during registration";
          set({ isLoading: false, error: errorMessage });
          return { success: false, error: errorMessage };
        }
      },

      // Logout method
      logout: async () => {
        const { refreshToken } = get();

        try {
          if (refreshToken) {
            await authApiClient.logout({ refreshToken });
          }
        } catch (error) {
          console.error("Logout API call failed:", error);
          // Continue with local cleanup even if API call fails
        }

        // Clear local storage
        if (typeof window !== "undefined") {
          localStorage.removeItem(TOKEN_STORAGE_KEY);
          localStorage.removeItem(REFRESH_TOKEN_STORAGE_KEY);
        }

        // Reset state
        set({
          user: null,
          isAuthenticated: false,
          accessToken: null,
          refreshToken: null,
          tokenExpiresAt: null,
          error: null,
          sessionTimeoutWarning: false,
        });
      },

      // Refresh session method
      refreshSession: async () => {
        const { refreshToken } = get();

        if (!refreshToken) {
          get().logout();
          return false;
        }

        try {
          const response = await authApiClient.refreshToken({ refreshToken });

          if (response.success && response.data) {
            const {
              user,
              accessToken,
              refreshToken: newRefreshToken,
              expiresIn,
            } = response.data;
            const tokenExpiresAt = Date.now() + expiresIn * 1000;

            // Update stored tokens
            if (typeof window !== "undefined") {
              localStorage.setItem(TOKEN_STORAGE_KEY, accessToken);
              localStorage.setItem(REFRESH_TOKEN_STORAGE_KEY, newRefreshToken);
            }

            set({
              user,
              accessToken,
              refreshToken: newRefreshToken,
              tokenExpiresAt,
              lastActivity: Date.now(),
              sessionTimeoutWarning: false,
            });

            return true;
          } else {
            get().logout();
            return false;
          }
        } catch (error) {
          console.error("Token refresh failed:", error);
          get().logout();
          return false;
        }
      },

      // Check authentication status
      checkAuth: async () => {
        set({ isLoading: true });

        try {
          // Check if tokens exist in localStorage
          const storedToken =
            typeof window !== "undefined"
              ? localStorage.getItem(TOKEN_STORAGE_KEY)
              : null;
          const storedRefreshToken =
            typeof window !== "undefined"
              ? localStorage.getItem(REFRESH_TOKEN_STORAGE_KEY)
              : null;

          if (!storedToken || !storedRefreshToken) {
            set({ isLoading: false });
            return;
          }

          // Verify token with server
          const response = await authApiClient.getProfile();

          if (response.success && response.data) {
            set({
              user: response.data,
              isAuthenticated: true,
              isLoading: false,
              accessToken: storedToken,
              refreshToken: storedRefreshToken,
              lastActivity: Date.now(),
            });
          } else {
            // Token is invalid, try to refresh
            const refreshed = await get().refreshSession();
            if (!refreshed) {
              get().logout();
            }
            set({ isLoading: false });
          }
        } catch (error) {
          console.error("Auth check failed:", error);
          // Try to refresh token
          const refreshed = await get().refreshSession();
          if (!refreshed) {
            get().logout();
          }
          set({ isLoading: false });
        }
      },

      // Update user data (local state only)
      updateUser: (userData: Partial<User>) => {
        const { user } = get();
        if (user) {
          set({ user: { ...user, ...userData } });
        }
      },

      // Update user profile (API call)
      updateProfile: async (profileData: any) => {
        const { user } = get();
        if (!user) return false;

        try {
          // Use the users client instead of auth client
          const response = await usersApiClient.updateUser(
            user.id,
            profileData
          );

          if (response.success && response.data) {
            set({ user: response.data });
            return true;
          }
        } catch (error) {
          console.error("Profile update failed:", error);
        }

        return false;
      },

      // Permission checking methods
      hasPermission: (permission: string) => {
        const { user } = get();
        if (!user?.role?.permissions) return false;

        const permissions = user.role.permissions;
        return permissions.includes(permission) || permissions.includes("*");
      },

      hasAnyPermission: (permissions: string[]) => {
        return permissions.some((permission) =>
          get().hasPermission(permission)
        );
      },

      hasAllPermissions: (permissions: string[]) => {
        return permissions.every((permission) =>
          get().hasPermission(permission)
        );
      },

      hasRole: (roleName: string) => {
        const { user } = get();
        return user?.role?.name === roleName;
      },

      hasUserType: (userType: UserType) => {
        const { user } = get();
        return user?.userType === userType;
      },

      // Session management
      updateLastActivity: () => {
        set({ lastActivity: Date.now() });
      },

      isSessionExpired: () => {
        const { lastActivity } = get();
        return Date.now() - lastActivity > SESSION_TIMEOUT;
      },

      getTimeUntilExpiry: () => {
        const { tokenExpiresAt } = get();
        if (!tokenExpiresAt) return 0;
        return Math.max(0, tokenExpiresAt - Date.now());
      },

      setSessionTimeoutWarning: (show: boolean) => {
        set({ sessionTimeoutWarning: show });
      },

      // Utility methods
      clearError: () => {
        set({ error: null });
      },

      setLoading: (loading: boolean) => {
        set({ isLoading: loading });
      },
    }),
    {
      name: "auth-store",
      partialize: (state) => ({
        user: state.user,
        isAuthenticated: state.isAuthenticated,
        lastActivity: state.lastActivity,
        // Don't persist tokens - they're in localStorage
      }),
      version: 1,
    }
  )
);

// Session timeout monitoring (client-side only)
if (typeof window !== "undefined") {
  let timeoutWarningTimer: NodeJS.Timeout;
  let timeoutTimer: NodeJS.Timeout;

  const setupSessionMonitoring = () => {
    const checkSession = () => {
      const state = useAuthStore.getState();

      if (!state.isAuthenticated) return;

      const timeUntilExpiry = state.getTimeUntilExpiry();
      const timeSinceActivity = Date.now() - state.lastActivity;

      // Show warning if close to expiry
      if (
        timeUntilExpiry <= WARNING_THRESHOLD &&
        !state.sessionTimeoutWarning
      ) {
        state.setSessionTimeoutWarning(true);
      }

      // Auto-refresh if token is expiring soon
      if (timeUntilExpiry <= 2 * 60 * 1000 && timeUntilExpiry > 0) {
        state.refreshSession();
      }

      // Logout if session expired due to inactivity
      if (timeSinceActivity > SESSION_TIMEOUT) {
        state.logout();
      }
    };

    // Check every minute
    setInterval(checkSession, 60 * 1000);

    // Initial check
    checkSession();
  };

  // Start monitoring when store is loaded
  setupSessionMonitoring();
}


================= lib/stores/tenant.store.ts =>
import { create } from "zustand";
import { persist } from "zustand/middleware";
import { tenantsApiClient } from "@/lib/api/clients/tenants.client"; // Changed import
import type { Tenant } from "@/lib/types/database/schema.types";

// Extended tenant interface for UI needs
export interface ExtendedTenant extends Tenant {
  // Additional UI-specific properties
  features?: string[];
  permissions?: string[];
  stats?: {
    totalUsers?: number;
    activeUsers?: number;
    totalParcels?: number;
    totalInvoices?: number;
    totalClaims?: number;
  };
}

interface TenantState {
  // Core state
  currentTenant: ExtendedTenant | null;
  tenants: ExtendedTenant[];
  isLoading: boolean;
  error: string | null;

  // Actions
  setTenant: (tenant: ExtendedTenant) => void;
  setTenants: (tenants: ExtendedTenant[]) => void;
  addTenant: (tenant: ExtendedTenant) => void;
  updateTenant: (tenantId: string, updates: Partial<ExtendedTenant>) => void;
  removeTenant: (tenantId: string) => void;
  clearCurrentTenant: () => void;

  // API Actions
  fetchTenants: () => Promise<void>;
  fetchCurrentTenant: () => Promise<void>;
  fetchTenantById: (tenantId: string) => Promise<ExtendedTenant | null>;
  switchTenant: (tenantId: string) => Promise<boolean>;
  updateTenantSettings: (settings: any) => Promise<boolean>;

  // Utility methods
  getTenantSettings: () => any;
  getCurrentTenantId: () => string | null;
  isTenantActive: (tenantId: string) => boolean;

  // Feature/Permission checking
  hasFeature: (feature: string) => boolean;
  getTenantPermissions: () => string[];
  canAccessResource: (resource: string) => boolean;

  // Error handling
  clearError: () => void;
  setError: (error: string) => void;
}

export const useTenantStore = create<TenantState>()(
  persist(
    (set, get) => ({
      // Initial state
      currentTenant: null,
      tenants: [],
      isLoading: false,
      error: null,

      // Basic setters
      setTenant: (tenant: ExtendedTenant) => {
        set({ currentTenant: tenant, error: null });

        // Update API client tenant context
        if (typeof window !== "undefined") {
          localStorage.setItem("current_tenant_id", tenant.id);
        }
      },

      setTenants: (tenants: ExtendedTenant[]) => {
        set({ tenants, error: null });
      },

      addTenant: (tenant: ExtendedTenant) => {
        const { tenants } = get();
        set({ tenants: [...tenants, tenant] });
      },

      updateTenant: (tenantId: string, updates: Partial<ExtendedTenant>) => {
        const { tenants, currentTenant } = get();

        // Update in tenants list
        const updatedTenants = tenants.map((tenant) =>
          tenant.id === tenantId ? { ...tenant, ...updates } : tenant
        );
        set({ tenants: updatedTenants });

        // Update current tenant if it's the one being updated
        if (currentTenant?.id === tenantId) {
          set({ currentTenant: { ...currentTenant, ...updates } });
        }
      },

      removeTenant: (tenantId: string) => {
        const { tenants, currentTenant } = get();

        const updatedTenants = tenants.filter(
          (tenant) => tenant.id !== tenantId
        );
        set({ tenants: updatedTenants });

        // Clear current tenant if it's the one being removed
        if (currentTenant?.id === tenantId) {
          get().clearCurrentTenant();
        }
      },

      clearCurrentTenant: () => {
        set({ currentTenant: null });

        if (typeof window !== "undefined") {
          localStorage.removeItem("current_tenant_id");
        }
      },

      // API Actions

      fetchTenants: async () => {
        set({ isLoading: true, error: null });

        try {
          // Try the paginated endpoint first
          const response = await tenantsApiClient.getTenants();

          set({
            tenants: response.data,
            isLoading: false,
            error: null,
          });
        } catch (paginatedError: any) {
          console.warn(
            "Paginated getTenants failed, trying alternative approach:",
            paginatedError.message
          );

          try {
            // If paginated fails, try to use the regular get method as fallback
            // This assumes you have a direct API endpoint that returns tenant array
            const fallbackResponse = await tenantsApiClient.getCurrentTenant();

            if (fallbackResponse.success && fallbackResponse.data) {
              // If we only got current tenant, wrap it in array
              set({
                tenants: [fallbackResponse.data],
                isLoading: false,
                error: null,
              });
            } else {
              throw new Error(
                fallbackResponse.error?.message || "Failed to fetch tenant data"
              );
            }
          } catch (fallbackError: any) {
            console.error("All tenant fetch methods failed:", fallbackError);
            set({
              isLoading: false,
              error:
                fallbackError?.message ||
                "Network error while fetching tenants",
            });
          }
        }
      },

      fetchCurrentTenant: async () => {
        set({ isLoading: true, error: null });

        try {
          const response = await tenantsApiClient.getCurrentTenant(); // Updated client

          if (response.success && response.data) {
            const tenantData = response.data;
            set({
              currentTenant: tenantData,
              isLoading: false,
              error: null,
            });

            // Update localStorage
            if (typeof window !== "undefined") {
              localStorage.setItem("current_tenant_id", tenantData.id);
            }
          } else {
            set({
              isLoading: false,
              error:
                response.error?.message || "Failed to fetch current tenant",
            });
          }
        } catch (error: any) {
          console.error("Fetch current tenant failed:", error);
          set({
            isLoading: false,
            error: error?.message || "Network error while fetching tenant",
          });
        }
      },

      fetchTenantById: async (tenantId: string) => {
        set({ isLoading: true, error: null });

        try {
          // For now, we'll use the current tenant endpoint
          // You might want to add a specific endpoint for fetching by ID
          const response = await tenantsApiClient.getCurrentTenant(); // Updated client

          if (response.success && response.data) {
            set({ isLoading: false, error: null });
            return response.data;
          } else {
            set({
              isLoading: false,
              error: response.error?.message || "Failed to fetch tenant",
            });
            return null;
          }
        } catch (error: any) {
          console.error("Fetch tenant by ID failed:", error);
          set({
            isLoading: false,
            error: error?.message || "Network error while fetching tenant",
          });
          return null;
        }
      },

      switchTenant: async (tenantId: string) => {
        const { tenants } = get();

        // Check if tenant exists in local list
        const tenant = tenants.find((t) => t.id === tenantId);

        if (tenant) {
          get().setTenant(tenant);
          return true;
        } else {
          // Try to fetch the tenant
          const fetchedTenant = await get().fetchTenantById(tenantId);
          if (fetchedTenant) {
            get().setTenant(fetchedTenant);
            return true;
          }
        }

        set({ error: "Failed to switch to tenant" });
        return false;
      },

      updateTenantSettings: async (settings: any) => {
        try {
          const response = await tenantsApiClient.updateTenantSettings(
            settings
          ); // Updated client

          if (response.success && response.data) {
            const { currentTenant } = get();
            if (currentTenant) {
              get().updateTenant(currentTenant.id, {
                settings: response.data.settings,
              });
            }
            return true;
          } else {
            set({
              error: response.error?.message || "Failed to update settings",
            });
            return false;
          }
        } catch (error: any) {
          console.error("Update tenant settings failed:", error);
          set({
            error: error?.message || "Network error while updating settings",
          });
          return false;
        }
      },

      // Utility methods
      getTenantSettings: () => {
        const { currentTenant } = get();
        return currentTenant?.settings || {};
      },

      getCurrentTenantId: () => {
        const { currentTenant } = get();
        return currentTenant?.id || null;
      },

      isTenantActive: (tenantId: string) => {
        const { currentTenant } = get();
        return currentTenant?.id === tenantId && currentTenant?.isActive;
      },

      // Feature checking
      hasFeature: (feature: string) => {
        const { currentTenant } = get();
        if (!currentTenant?.features) return false;
        return currentTenant.features.includes(feature);
      },

      getTenantPermissions: () => {
        const { currentTenant } = get();
        return currentTenant?.permissions || [];
      },

      canAccessResource: (resource: string) => {
        const permissions = get().getTenantPermissions();
        return permissions.includes(resource) || permissions.includes("*");
      },

      // Error handling
      clearError: () => {
        set({ error: null });
      },

      setError: (error: string) => {
        set({ error });
      },
    }),
    {
      name: "tenant-store",
      partialize: (state) => ({
        currentTenant: state.currentTenant,
        tenants: state.tenants,
        // Don't persist loading states or errors
      }),
      version: 1,
    }
  )
);

// Helper function to initialize tenant from URL/localStorage
export const initializeTenantFromContext = () => {
  if (typeof window === "undefined") return;

  const store = useTenantStore.getState();

  // Try to get tenant from localStorage first
  const storedTenantId = localStorage.getItem("current_tenant_id");

  if (storedTenantId && !store.currentTenant) {
    // Try to find tenant in local list or fetch it
    const existingTenant = store.tenants.find((t) => t.id === storedTenantId);

    if (existingTenant) {
      store.setTenant(existingTenant);
    } else {
      // Fetch tenant data
      store.fetchTenantById(storedTenantId);
    }
  }
};

// Auto-initialize on client side
if (typeof window !== "undefined") {
  // Initialize tenant context when store is first accessed
  setTimeout(() => {
    initializeTenantFromContext();
  }, 0);
}

================= types/database/schema.types.ts =>
// ========================================
// ENUMS (matching your Prisma schema)
// ========================================

export enum UserType {
  ADMIN = "ADMIN",
  MANAGER = "MANAGER",
  SUPPORT = "SUPPORT",
  SELLER = "SELLER",
  LIVREUR = "LIVREUR",
  CUSTOMER = "CUSTOMER",
  BUYER = "BUYER",
  VENDOR = "VENDOR",
  WAREHOUSE = "WAREHOUSE",
  DISPATCHER = "DISPATCHER",
}

export enum ParcelStatus {
  NEW = "NEW",
  ASSIGNED = "ASSIGNED",
  PICKUP_SCHEDULED = "PICKUP_SCHEDULED",
  PICKED_UP = "PICKED_UP",
  IN_TRANSIT = "IN_TRANSIT",
  OUT_FOR_DELIVERY = "OUT_FOR_DELIVERY",
  DELIVERED = "DELIVERED",
  FAILED_DELIVERY = "FAILED_DELIVERY",
  RETURNED = "RETURNED",
  CANCELLED = "CANCELLED",
}

export enum InvoiceStatus {
  DRAFT = "DRAFT",
  PENDING = "PENDING",
  SENT = "SENT",
  PAID = "PAID",
  OVERDUE = "OVERDUE",
  CANCELLED = "CANCELLED",
}

export enum ClaimType {
  DAMAGED = "DAMAGED",
  LOST = "LOST",
  DELAYED = "DELAYED",
  WRONG_ADDRESS = "WRONG_ADDRESS",
  CUSTOMER_COMPLAINT = "CUSTOMER_COMPLAINT",
  OTHER = "OTHER",
}

export enum ClaimStatus {
  OPEN = "OPEN",
  IN_PROGRESS = "IN_PROGRESS",
  RESOLVED = "RESOLVED",
  REJECTED = "REJECTED",
  ESCALATED = "ESCALATED",
}

export enum ClaimPriority {
  LOW = "LOW",
  NORMAL = "NORMAL",
  HIGH = "HIGH",
  URGENT = "URGENT",
}

export enum NotificationType {
  PARCEL_STATUS = "PARCEL_STATUS",
  INVOICE_DUE = "INVOICE_DUE",
  CLAIM_CREATED = "CLAIM_CREATED",
  SYSTEM_ALERT = "SYSTEM_ALERT",
  ASSIGNMENT = "ASSIGNMENT",
  PAYMENT_RECEIVED = "PAYMENT_RECEIVED",
  USER_ACTION = "USER_ACTION",
}

// ========================================
// CORE ENTITIES
// ========================================

export interface Tenant {
  id: string;
  name: string;
  slug: string;
  domain?: string;
  logo?: string;
  settings: Json;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
}

export interface User {
  id: string;
  email: string;
  password: string;
  name?: string;
  roleId: string;
  userType: UserType;
  avatar?: string;
  isActive: boolean;
  tenantId: string;
  profile: Json;
  lastLogin?: Date;
  createdAt: Date;
  updatedAt: Date;

  // Relations
  tenant: Tenant;
  role: Role;
  sentParcels?: Parcel[];
  assignedParcels?: Parcel[];
  notifications?: Notification[];
  auditLogs?: AuditLog[];
}

export interface Role {
  id: string;
  name: string;
  description?: string;
  permissions: string[];
  userTypes: UserType[];
  tenantId: string;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;

  // Relations
  tenant: Tenant;
  users?: User[];
}

export interface Parcel {
  id: string;
  trackingNumber: string;
  status: ParcelStatus;
  senderInfo: Json;
  recipientInfo: Json;
  dimensions: Json;
  weight: number;
  value: number;
  description?: string;
  pickupAddress: Json;
  deliveryAddress: Json;
  notes?: string;
  senderId?: string;
  agentId?: string;
  tenantId: string;
  createdAt: Date;
  updatedAt: Date;
  deliveredAt?: Date;
  estimatedCost?: number;
  actualCost?: number;

  // Relations
  tenant: Tenant;
  senderUser?: User;
  agent?: User;
  claims?: Claim[];
  trackingEvents?: TrackingEvent[];
}

export interface TrackingEvent {
  id: string;
  parcelId: string;
  status: ParcelStatus;
  location?: string;
  description?: string;
  timestamp: Date;
  createdBy?: string;
  metadata?: Json;

  // Relations
  parcel: Parcel;
}

export interface Rate {
  id: string;
  name: string;
  description?: string;
  basePrice: number;
  weightRate: number;
  distanceRate: number;
  zoneFrom: string;
  zoneTo: string;
  userTypes: UserType[];
  tenantId: string;
  isActive: boolean;
  validFrom?: Date;
  validTo?: Date;
  createdAt: Date;
  updatedAt: Date;

  // Relations
  tenant: Tenant;
}

export interface Invoice {
  id: string;
  invoiceNumber: string;
  parcels: string[];
  amount: number;
  currency: string;
  status: InvoiceStatus;
  dueDate: Date;
  payerId?: string;
  tenantId: string;
  paidAmount?: number;
  paymentMethod?: string;
  createdAt: Date;
  updatedAt: Date;
  paidAt?: Date;

  // Relations
  tenant: Tenant;
}

export interface Claim {
  id: string;
  type: ClaimType;
  description: string;
  status: ClaimStatus;
  priority: ClaimPriority;
  resolution?: string;
  parcelId: string;
  filedBy?: string;
  assignedTo?: string;
  tenantId: string;
  createdAt: Date;
  updatedAt: Date;
  resolvedAt?: Date;

  // Relations
  tenant: Tenant;
  parcel: Parcel;
}

export interface Notification {
  id: string;
  title: string;
  message: string;
  type: NotificationType;
  userId?: string;
  userTypes: UserType[];
  tenantId: string;
  isRead: boolean;
  data?: Json;
  expiresAt?: Date;
  createdAt: Date;

  // Relations
  tenant: Tenant;
  user?: User;
}

export interface AuditLog {
  id: string;
  action: string;
  entityType: string;
  entityId: string;
  oldValues?: Json;
  newValues?: Json;
  userId?: string;
  userType?: UserType;
  tenantId: string;
  ipAddress?: string;
  userAgent?: string;
  sessionId?: string;
  timestamp: Date;

  // Relations
  tenant: Tenant;
  user?: User;
}

// ========================================
// UTILITY TYPES
// ========================================

export type Json =
  | string
  | number
  | boolean
  | Json[]
  | { [key: string]: Json }
  | null;

// API Request/Response types
export interface CreateUserRequest {
  email: string;
  password: string;
  name?: string;
  userType: UserType;
  roleId: string;
  profile?: Json;
}

export interface UpdateUserRequest {
  name?: string;
  roleId?: string;
  profile?: Json;
  isActive?: boolean;
}

export interface CreateParcelRequest {
  senderInfo: Json;
  recipientInfo: Json;
  dimensions: Json;
  weight: number;
  value: number;
  description?: string;
  pickupAddress: Json;
  deliveryAddress: Json;
  notes?: string;
}

export interface UpdateParcelStatusRequest {
  status: ParcelStatus;
  location?: string;
  description?: string;
}

export interface CreateClaimRequest {
  type: ClaimType;
  description: string;
  priority: ClaimPriority;
  parcelId: string;
}

// Pagination types
export interface PaginationParams {
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: "asc" | "desc";
}

export interface PaginationMeta {
  page: number;
  limit: number;
  total: number;
  totalPages: number;
  hasNext: boolean;
  hasPrev: boolean;
}

// Filter types
export interface ParcelFilters extends PaginationParams {
  status?: ParcelStatus;
  senderId?: string;
  agentId?: string;
  dateFrom?: string;
  dateTo?: string;
  search?: string;
}

export interface InvoiceFilters extends PaginationParams {
  status?: InvoiceStatus;
  payerId?: string;
  dueFrom?: string;
  dueTo?: string;
}

export interface ClaimFilters extends PaginationParams {
  status?: ClaimStatus;
  type?: ClaimType;
  priority?: ClaimPriority;
  assignedTo?: string;
}

export interface UserFilters extends PaginationParams {
  userType?: UserType;
  roleId?: string;
  isActive?: boolean;
  search?: string;
}

================= utils/tenant.utils.ts =>
export function getTenantFromUrl(): string | null {
  if (typeof window === "undefined") return null;

  const hostname = window.location.hostname;

  // Handle localhost development
  if (hostname === "localhost" || hostname === "127.0.0.1") {
    // Check for query parameter fallback
    const urlParams = new URLSearchParams(window.location.search);
    const tenantParam = urlParams.get("tenant");
    if (tenantParam) return tenantParam;

    // Check for environment variable fallback
    const devTenant = process.env.NEXT_PUBLIC_DEV_TENANT_ID;
    if (devTenant) return devTenant;

    return null;
  }

  // Production: Extract from subdomain
  const parts = hostname.split(".");

  // Must have at least 3 parts for subdomain
  if (parts.length >= 3) {
    const subdomain = parts[0];

    // Exclude common subdomains that aren't tenants
    const excludedSubdomains = [
      "www",
      "api",
      "admin",
      "app",
      "mail",
      "ftp",
      "cdn",
      "static",
    ];

    if (!excludedSubdomains.includes(subdomain.toLowerCase())) {
      return subdomain;
    }
  }

  // Fallback: Check for path-based routing
  // e.g., myapp.com/tenant/dashboard
  const pathParts = window.location.pathname.split("/").filter(Boolean);
  if (pathParts.length > 0 && pathParts[0] !== "auth") {
    // Validate that it looks like a tenant slug
    const potentialTenant = pathParts[0];
    if (/^[a-z0-9-]+$/.test(potentialTenant) && potentialTenant.length >= 2) {
      return potentialTenant;
    }
  }

  return null;
}

export function getTenantDomain(tenantSlug: string): string {
  const isProduction = process.env.NODE_ENV === "production";
  const baseDomain = process.env.NEXT_PUBLIC_BASE_DOMAIN || "localhost:3000";

  if (isProduction) {
    return `${tenantSlug}.${baseDomain}`;
  } else {
    return `${baseDomain}?tenant=${tenantSlug}`;
  }
}

export function buildTenantUrl(tenantSlug: string, path: string = "/"): string {
  const domain = getTenantDomain(tenantSlug);
  const protocol = process.env.NODE_ENV === "production" ? "https" : "http";

  return `${protocol}://${domain}${path}`;
}

export function validateTenantSlug(slug: string): boolean {
  // Tenant slug validation rules
  const rules = [
    slug.length >= 2 && slug.length <= 63, // Length constraints
    /^[a-z0-9-]+$/.test(slug), // Only lowercase, numbers, hyphens
    !slug.startsWith("-") && !slug.endsWith("-"), // No leading/trailing hyphens
    !slug.includes("--"), // No consecutive hyphens
    !/^\d+$/.test(slug), // Not purely numeric
  ];

  return rules.every(Boolean);
}

export function normalizeTenantSlug(input: string): string {
  return input
    .toLowerCase()
    .replace(/[^a-z0-9-]/g, "-") // Replace invalid chars with hyphens
    .replace(/-+/g, "-") // Replace multiple hyphens with single
    .replace(/^-|-$/g, ""); // Remove leading/trailing hyphens
}

export function isValidTenantDomain(domain: string): boolean {
  const domainRegex =
    /^(?:[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?$/i;
  return domainRegex.test(domain);
}

================= providers/auth.provider.tsx =>
"use client";

import React, { useEffect, useState } from "react";
import { useAuthStore } from "@/lib/stores/auth.store";
import { useTenantStore } from "@/lib/stores/tenant.store";
import { getTenantFromUrl } from "@/lib/utils/tenant.utils";
import { toast } from "sonner";

interface AuthProviderProps {
  children: React.ReactNode;
}

export default function AuthProvider({ children }: AuthProviderProps) {
  const [isInitialized, setIsInitialized] = useState(false);
  const { checkAuth, isAuthenticated } = useAuthStore();
  const { setTenant, fetchTenants } = useTenantStore();

  useEffect(() => {
    let mounted = true;

    const initializeAuth = async () => {
      try {
        // Get tenant from URL
        const tenantId = getTenantFromUrl();
        if (tenantId) {
          // Set tenant context (this will be used by API clients)
          setTenant({ id: tenantId } as any); // You'll need to fetch full tenant data later
        }

        // Check authentication status
        await checkAuth();

        // If authenticated and tenant is available, fetch tenant data
        if (mounted && isAuthenticated && tenantId) {
          try {
            await fetchTenants();
          } catch (error) {
            console.error("Failed to fetch tenant data:", error);
            // Don't block app initialization for tenant fetch failures
          }
        }
      } catch (error) {
        console.error("Auth initialization failed:", error);
        // Don't show error toast on initialization failures
        // The login form will handle auth errors
      } finally {
        if (mounted) {
          setIsInitialized(true);
        }
      }
    };

    initializeAuth();

    return () => {
      mounted = false;
    };
  }, [checkAuth, isAuthenticated, setTenant, fetchTenants]);

  // Handle browser tab focus to refresh auth
  useEffect(() => {
    const handleFocus = () => {
      if (isInitialized && isAuthenticated) {
        // Silently check auth status when user returns to tab
        checkAuth().catch(() => {
          // If auth check fails, the auth store will handle logout
        });
      }
    };

    const handleOnline = () => {
      if (isInitialized && isAuthenticated) {
        // When coming back online, refresh auth state
        checkAuth().catch(() => {
          toast.error("Unable to verify session. Please sign in again.");
        });
      }
    };

    // Only add listeners after initialization
    if (isInitialized) {
      window.addEventListener("focus", handleFocus);
      window.addEventListener("online", handleOnline);

      return () => {
        window.removeEventListener("focus", handleFocus);
        window.removeEventListener("online", handleOnline);
      };
    }
  }, [isInitialized, isAuthenticated, checkAuth]);

  return <>{children}</>;
}


=================== middleware.ts =>

import createMiddleware from "next-intl/middleware";
import { NextRequest, NextResponse } from "next/server";
import { locales } from "@/config";

// Define protected routes that require authentication
const protectedRoutes = [
  "/dashboard",
  "/parcels",
  "/invoices",
  "/claims",
  "/users",
  "/roles",
  "/settings",
  "/analytics",
];

// Define public routes that don't require authentication
const publicRoutes = [
  "/",
  "/login",
  "/auth/login",
  "/auth/register",
  "/auth/forgot-password",
  "/auth/reset-password",
];

// Define auth routes (redirect to dashboard if already authenticated)
const authRoutes = ["/login", "/auth/login", "/auth/register"];

function isProtectedRoute(pathname: string): boolean {
  // Remove locale prefix for route checking
  const routeWithoutLocale = pathname.replace(/^\/[a-z]{2}(?=\/|$)/, "") || "/";

  return protectedRoutes.some((route) => routeWithoutLocale.startsWith(route));
}

function isPublicRoute(pathname: string): boolean {
  // Remove locale prefix for route checking
  const routeWithoutLocale = pathname.replace(/^\/[a-z]{2}(?=\/|$)/, "") || "/";

  return publicRoutes.some(
    (route) =>
      routeWithoutLocale === route || routeWithoutLocale.startsWith(route)
  );
}

function isAuthRoute(pathname: string): boolean {
  // Remove locale prefix for route checking
  const routeWithoutLocale = pathname.replace(/^\/[a-z]{2}(?=\/|$)/, "") || "/";

  return authRoutes.some(
    (route) =>
      routeWithoutLocale === route || routeWithoutLocale.startsWith(route)
  );
}

function getAuthToken(request: NextRequest): string | null {
  // Try to get token from Authorization header
  const authHeader = request.headers.get("authorization");
  if (authHeader?.startsWith("Bearer ")) {
    return authHeader.substring(7);
  }

  // Try to get token from cookie
  const tokenCookie = request.cookies.get("auth_token");
  if (tokenCookie) {
    return tokenCookie.value;
  }

  return null;
}

function isTokenExpired(token: string): boolean {
  try {
    // Simple JWT expiration check (you might want to use a proper JWT library)
    const payload = JSON.parse(atob(token.split(".")[1]));
    const currentTime = Math.floor(Date.now() / 1000);
    return payload.exp < currentTime;
  } catch {
    return true; // If we can't parse the token, consider it expired
  }
}

function getTenantFromRequest(request: NextRequest): string | null {
  const hostname = request.nextUrl.hostname;

  // Handle localhost development
  if (hostname === "localhost" || hostname === "127.0.0.1") {
    // Check for query parameter
    const tenantParam = request.nextUrl.searchParams.get("tenant");
    if (tenantParam) return tenantParam;

    // Check for path-based routing
    const pathParts = request.nextUrl.pathname.split("/").filter(Boolean);
    if (pathParts.length > 1 && pathParts[0] === "platform") {
      return pathParts[1];
    }

    return process.env.NEXT_PUBLIC_DEV_TENANT_ID || null;
  }

  // Production: Extract from subdomain
  const parts = hostname.split(".");
  if (parts.length >= 3) {
    const subdomain = parts[0];
    const excludedSubdomains = ["www", "api", "admin", "app"];

    if (!excludedSubdomains.includes(subdomain.toLowerCase())) {
      return subdomain;
    }
  }

  return null;
}

export default async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;

  // Get tenant information
  const tenantId = getTenantFromRequest(request);

  // Step 1: Handle internationalization
  const defaultLocale = request.headers.get("network-locale") || "en";
  const handleI18nRouting = createMiddleware({
    locales,
    defaultLocale,
  });

  let response = handleI18nRouting(request);

  // Step 2: Handle authentication logic
  const token = getAuthToken(request);
  const isAuthenticated = token && !isTokenExpired(token);

  // Handle protected routes
  if (isProtectedRoute(pathname)) {
    if (!isAuthenticated) {
      // Redirect to login with return URL
      const loginUrl = new URL("/", request.url);
      loginUrl.searchParams.set("redirect", pathname);

      response = NextResponse.redirect(loginUrl);
    }
  }

  // Handle auth routes (redirect authenticated users to dashboard)
  else if (isAuthRoute(pathname) && isAuthenticated) {
    // Check if there's a redirect parameter
    const redirectTo = request.nextUrl.searchParams.get("redirect");
    const dashboardUrl = new URL(redirectTo || "/dashboard", request.url);

    response = NextResponse.redirect(dashboardUrl);
  }

  // Handle root route
  else if (pathname === "/" || pathname.match(/^\/[a-z]{2}$/)) {
    if (isAuthenticated) {
      // Redirect authenticated users to dashboard
      const dashboardUrl = new URL("/dashboard", request.url);
      response = NextResponse.redirect(dashboardUrl);
    }
    // If not authenticated, root route will show login (handled in page.tsx)
  }

  // Step 3: Add custom headers
  response.headers.set("network-locale", defaultLocale);

  // Add tenant information to headers for use in components
  if (tenantId) {
    response.headers.set("x-tenant-id", tenantId);
  }

  // Add security headers
  response.headers.set("x-frame-options", "DENY");
  response.headers.set("x-content-type-options", "nosniff");
  response.headers.set("referrer-policy", "origin-when-cross-origin");

  // For development: Add CORS headers
  if (process.env.NODE_ENV === "development") {
    response.headers.set("Access-Control-Allow-Origin", "*");
    response.headers.set(
      "Access-Control-Allow-Methods",
      "GET, POST, PUT, DELETE, OPTIONS"
    );
    response.headers.set(
      "Access-Control-Allow-Headers",
      "Content-Type, Authorization, X-Tenant-ID"
    );
  }

  return response;
}

export const config = {
  // Match all routes except static files and API routes
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - api (API routes)
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - public folder files
     */
    "/((?!api|_next/static|_next/image|favicon.ico|images|icons).*)",
  ],
};

you can do any logic you want just apply, best practices because project is new.